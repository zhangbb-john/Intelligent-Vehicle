/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KV5XP144M240RM Rev. 3, 02/2016
**     Version:             rev. 0.3, 2016-02-29
**     Build:               b160229
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2016 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 0.1 (2015-02-24)
**         Initial version.
**     - rev. 0.2 (2015-10-21)
**         UART0 - removed LON functionality.
**         FMC - corrected base address.
**     - rev. 0.3 (2016-02-29)
**         PORT - removed registers GICLR, GICHR.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKV58F24_EXTENSION_H__
#define __MKV58F24_EXTENSION_H__

#include "MKV58F24.h"
#include "fsl_bitaccess.h"

#if defined(__IAR_SYSTEMS_ICC__)
  /*
   * Suppress "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)"
   * as some register descriptions contain code examples
   */
  #pragma diag_suppress=pm008
#endif

/*
 * MKV58F24 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_MG - ADC Minus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s (module disabled). Writing any of the SC1n registers while
 * that specific SC1n register is actively controlling a conversion aborts the
 * current conversion. None of the SC1B-SC1n registers are used for software
 * trigger operation and therefore writes to the SC1B-SC1n registers do not initiate a
 * new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (BME_OR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
#define ADC_CLR_SC1(base, index, value) (BME_AND32(&ADC_SC1_REG(base, index), (uint32_t)(~(value))))
#define ADC_TOG_SC1(base, index, value) (BME_XOR32(&ADC_SC1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 0b00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 0b00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 0b00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 0b00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 0b00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is
 *     reserved.
 * - 0b11000 - Reserved.
 * - 0b11001 - Reserved.
 * - 0b11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input;
 *     when DIFF=1, Temp Sensor (differential) is selected as input.
 * - 0b11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 0b11100 - Reserved.
 * - 0b11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 0b11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 0b11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_ADCH_SHIFT), ADC_SC1_ADCH_SHIFT, ADC_SC1_ADCH_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0b0 - Single-ended conversions and input channels are selected.
 * - 0b1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_DIFF_SHIFT), ADC_SC1_DIFF_SHIFT, ADC_SC1_DIFF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0b0 - Conversion complete interrupt is disabled.
 * - 0b1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BME_BFI32(&ADC_SC1_REG(base, index), ((uint32_t)(value) << ADC_SC1_AIEN_SHIFT), ADC_SC1_AIEN_SHIFT, ADC_SC1_AIEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0b0 - Conversion is not completed.
 * - 0b1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BME_UBFX32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT, ADC_SC1_COCO_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (BME_OR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG1(base, value) (BME_AND32(&ADC_CFG1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG1(base, value) (BME_XOR32(&ADC_CFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 0b00 - Bus clock
 * - 0b01 - Alternate clock 2 (ALTCLK2)
 * - 0b10 - Alternate clock (ALTCLK)
 * - 0b11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADICLK_SHIFT), ADC_CFG1_ADICLK_SHIFT, ADC_CFG1_ADICLK_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 0b00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 0b01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it
 *     is differential 13-bit conversion with 2's complement output.
 * - 0b10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it
 *     is differential 11-bit conversion with 2's complement output
 * - 0b11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it
 *     is differential 16-bit conversion with 2's complement output
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_MODE_SHIFT), ADC_CFG1_MODE_SHIFT, ADC_CFG1_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0b0 - Short sample time.
 * - 0b1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLSMP_SHIFT), ADC_CFG1_ADLSMP_SHIFT, ADC_CFG1_ADLSMP_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 0b00 - The divide ratio is 1 and the clock rate is input clock.
 * - 0b01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 0b10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 0b11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADIV_SHIFT), ADC_CFG1_ADIV_SHIFT, ADC_CFG1_ADIV_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0b0 - Normal power configuration.
 * - 0b1 - Low-power configuration. The power is reduced at the expense of
 *     maximum clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BME_UBFX32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BME_BFI32(&ADC_CFG1_REG(base), ((uint32_t)(value) << ADC_CFG1_ADLPC_SHIFT), ADC_CFG1_ADLPC_SHIFT, ADC_CFG1_ADLPC_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (BME_OR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CFG2(base, value) (BME_AND32(&ADC_CFG2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CFG2(base, value) (BME_XOR32(&ADC_CFG2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 0b00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 0b01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 0b10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 0b11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADLSTS_SHIFT), ADC_CFG2_ADLSTS_SHIFT, ADC_CFG2_ADLSTS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0b0 - Normal conversion sequence selected.
 * - 0b1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADHSC_SHIFT), ADC_CFG2_ADHSC_SHIFT, ADC_CFG2_ADHSC_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0b0 - Asynchronous clock output disabled; Asynchronous clock is enabled
 *     only if selected by ADICLK and a conversion is active.
 * - 0b1 - Asynchronous clock and clock output is enabled regardless of the
 *     state of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_ADACKEN_SHIFT), ADC_CFG2_ADACKEN_SHIFT, ADC_CFG2_ADACKEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0b0 - ADxxa channels are selected.
 * - 0b1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BME_UBFX32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BME_BFI32(&ADC_CFG2_REG(base), ((uint32_t)(value) << ADC_CFG2_MUXSEL_SHIFT), ADC_CFG2_MUXSEL_SHIFT, ADC_CFG2_MUXSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (ADC_RD_R_D(base, index))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (BME_OR32(&ADC_CV1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV1(base, value) (BME_AND32(&ADC_CV1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV1(base, value) (BME_XOR32(&ADC_CV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (ADC_RD_CV1_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (ADC_WR_CV1_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (BME_OR32(&ADC_CV2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CV2(base, value) (BME_AND32(&ADC_CV2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CV2(base, value) (BME_XOR32(&ADC_CV2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (ADC_RD_CV2_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (ADC_WR_CV2_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (BME_OR32(&ADC_SC2_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC2(base, value) (BME_AND32(&ADC_SC2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC2(base, value) (BME_XOR32(&ADC_SC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 0b00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 0b01 - Alternate reference pair, that is, VALTH and VALTL . This pair may
 *     be additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to
 *     this MCU
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_REFSEL_SHIFT), ADC_SC2_REFSEL_SHIFT, ADC_SC2_REFSEL_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_DMAEN_SHIFT), ADC_SC2_DMAEN_SHIFT, ADC_SC2_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0b0 - Range function disabled. Only CV1 is compared.
 * - 0b1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACREN_SHIFT), ADC_SC2_ACREN_SHIFT, ADC_SC2_ACREN_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0b0 - Configures less than threshold, outside range not inclusive and
 *     inside range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 0b1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFGT_SHIFT), ADC_SC2_ACFGT_SHIFT, ADC_SC2_ACFGT_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0b0 - Compare function disabled.
 * - 0b1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ACFE_SHIFT), ADC_SC2_ACFE_SHIFT, ADC_SC2_ACFE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0b0 - Software trigger selected.
 * - 0b1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BME_BFI32(&ADC_SC2_REG(base), ((uint32_t)(value) << ADC_SC2_ADTRG_SHIFT), ADC_SC2_ADTRG_SHIFT, ADC_SC2_ADTRG_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0b0 - Conversion not in progress.
 * - 0b1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BME_UBFX32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT, ADC_SC2_ADACT_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (BME_OR32(&ADC_SC3_REG(base), (uint32_t)(value)))
#define ADC_CLR_SC3(base, value) (BME_AND32(&ADC_SC3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_SC3(base, value) (BME_XOR32(&ADC_SC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 0b00 - 4 samples averaged.
 * - 0b01 - 8 samples averaged.
 * - 0b10 - 16 samples averaged.
 * - 0b11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGS_SHIFT), ADC_SC3_AVGS_SHIFT, ADC_SC3_AVGS_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0b0 - Hardware average function disabled.
 * - 0b1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_AVGE_SHIFT), ADC_SC3_AVGE_SHIFT, ADC_SC3_AVGE_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0b0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 0b1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_ADCO_SHIFT), ADC_SC3_ADCO_SHIFT, ADC_SC3_ADCO_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0b0 - Calibration completed normally.
 * - 0b1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CALF_SHIFT), ADC_SC3_CALF_SHIFT, ADC_SC3_CALF_WIDTH))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BME_UBFX32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BME_BFI32(&ADC_SC3_REG(base), ((uint32_t)(value) << ADC_SC3_CAL_SHIFT), ADC_SC3_CAL_SHIFT, ADC_SC3_CAL_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation. For more
 * information regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (BME_OR32(&ADC_OFS_REG(base), (uint32_t)(value)))
#define ADC_CLR_OFS(base, value) (BME_AND32(&ADC_OFS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_OFS(base, value) (BME_XOR32(&ADC_OFS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (ADC_RD_OFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (ADC_WR_OFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between PG[15] and PG[14]. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration functionThe
 * ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (BME_OR32(&ADC_PG_REG(base), (uint32_t)(value)))
#define ADC_CLR_PG(base, value)  (BME_AND32(&ADC_PG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_PG(base, value)  (BME_XOR32(&ADC_PG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (ADC_RD_PG_PG(base))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (ADC_WR_PG_PG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between MG[15] and MG[14]. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (BME_OR32(&ADC_MG_REG(base), (uint32_t)(value)))
#define ADC_CLR_MG(base, value)  (BME_AND32(&ADC_MG_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_MG(base, value)  (BME_XOR32(&ADC_MG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (ADC_RD_MG_MG(base))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (ADC_WR_MG_MG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (BME_OR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPD(base, value) (BME_AND32(&ADC_CLPD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPD(base, value) (BME_XOR32(&ADC_CLPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (BME_UBFX32(&ADC_CLPD_REG(base), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (BME_BFI32(&ADC_CLPD_REG(base), ((uint32_t)(value) << ADC_CLPD_CLPD_SHIFT), ADC_CLPD_CLPD_SHIFT, ADC_CLPD_CLPD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (BME_OR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLPS(base, value) (BME_AND32(&ADC_CLPS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLPS(base, value) (BME_XOR32(&ADC_CLPS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (BME_UBFX32(&ADC_CLPS_REG(base), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (BME_BFI32(&ADC_CLPS_REG(base), ((uint32_t)(value) << ADC_CLPS_CLPS_SHIFT), ADC_CLPS_CLPS_SHIFT, ADC_CLPS_CLPS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (BME_OR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP4(base, value) (BME_AND32(&ADC_CLP4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP4(base, value) (BME_XOR32(&ADC_CLP4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (ADC_RD_CLP4_CLP4(base))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (ADC_WR_CLP4_CLP4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (BME_OR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP3(base, value) (BME_AND32(&ADC_CLP3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP3(base, value) (BME_XOR32(&ADC_CLP3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (ADC_RD_CLP3_CLP3(base))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (ADC_WR_CLP3_CLP3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (BME_OR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP2(base, value) (BME_AND32(&ADC_CLP2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP2(base, value) (BME_XOR32(&ADC_CLP2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (BME_UBFX32(&ADC_CLP2_REG(base), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (BME_BFI32(&ADC_CLP2_REG(base), ((uint32_t)(value) << ADC_CLP2_CLP2_SHIFT), ADC_CLP2_CLP2_SHIFT, ADC_CLP2_CLP2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (BME_OR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP1(base, value) (BME_AND32(&ADC_CLP1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP1(base, value) (BME_XOR32(&ADC_CLP1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (BME_UBFX32(&ADC_CLP1_REG(base), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (BME_BFI32(&ADC_CLP1_REG(base), ((uint32_t)(value) << ADC_CLP1_CLP1_SHIFT), ADC_CLP1_CLP1_SHIFT, ADC_CLP1_CLP1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (BME_OR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLP0(base, value) (BME_AND32(&ADC_CLP0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLP0(base, value) (BME_XOR32(&ADC_CLP0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (BME_UBFX32(&ADC_CLP0_REG(base), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (BME_BFI32(&ADC_CLP0_REG(base), ((uint32_t)(value) << ADC_CLP0_CLP0_SHIFT), ADC_CLP0_CLP0_SHIFT, ADC_CLP0_CLP0_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (BME_OR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMD(base, value) (BME_AND32(&ADC_CLMD_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMD(base, value) (BME_XOR32(&ADC_CLMD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (BME_UBFX32(&ADC_CLMD_REG(base), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (BME_BFI32(&ADC_CLMD_REG(base), ((uint32_t)(value) << ADC_CLMD_CLMD_SHIFT), ADC_CLMD_CLMD_SHIFT, ADC_CLMD_CLMD_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (BME_OR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLMS(base, value) (BME_AND32(&ADC_CLMS_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLMS(base, value) (BME_XOR32(&ADC_CLMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (BME_UBFX32(&ADC_CLMS_REG(base), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (BME_BFI32(&ADC_CLMS_REG(base), ((uint32_t)(value) << ADC_CLMS_CLMS_SHIFT), ADC_CLMS_CLMS_SHIFT, ADC_CLMS_CLMS_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (BME_OR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM4(base, value) (BME_AND32(&ADC_CLM4_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM4(base, value) (BME_XOR32(&ADC_CLM4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (ADC_RD_CLM4_CLM4(base))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (ADC_WR_CLM4_CLM4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (BME_OR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM3(base, value) (BME_AND32(&ADC_CLM3_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM3(base, value) (BME_XOR32(&ADC_CLM3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (ADC_RD_CLM3_CLM3(base))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (ADC_WR_CLM3_CLM3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (BME_OR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM2(base, value) (BME_AND32(&ADC_CLM2_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM2(base, value) (BME_XOR32(&ADC_CLM2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (BME_UBFX32(&ADC_CLM2_REG(base), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (BME_BFI32(&ADC_CLM2_REG(base), ((uint32_t)(value) << ADC_CLM2_CLM2_SHIFT), ADC_CLM2_CLM2_SHIFT, ADC_CLM2_CLM2_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (BME_OR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM1(base, value) (BME_AND32(&ADC_CLM1_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM1(base, value) (BME_XOR32(&ADC_CLM1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (BME_UBFX32(&ADC_CLM1_REG(base), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (BME_BFI32(&ADC_CLM1_REG(base), ((uint32_t)(value) << ADC_CLM1_CLM1_SHIFT), ADC_CLM1_CLM1_SHIFT, ADC_CLM1_CLM1_WIDTH))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (BME_OR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
#define ADC_CLR_CLM0(base, value) (BME_AND32(&ADC_CLM0_REG(base), (uint32_t)(~(value))))
#define ADC_TOG_CLM0(base, value) (BME_XOR32(&ADC_CLM0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (BME_UBFX32(&ADC_CLM0_REG(base), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (BME_BFI32(&ADC_CLM0_REG(base), ((uint32_t)(value) << ADC_CLM0_CLM0_SHIFT), ADC_CLM0_CLM0_SHIFT, ADC_CLM0_CLM0_WIDTH))
/*@}*/

/*
 * MKV58F24 AIPS
 *
 * AIPS-Lite Bridge
 *
 * Registers defined in this header file:
 * - AIPS_MPRA - Master Privilege Register A
 * - AIPS_PACRA - Peripheral Access Control Register
 * - AIPS_PACRB - Peripheral Access Control Register
 * - AIPS_PACRC - Peripheral Access Control Register
 * - AIPS_PACRD - Peripheral Access Control Register
 * - AIPS_PACRE - Peripheral Access Control Register
 * - AIPS_PACRF - Peripheral Access Control Register
 * - AIPS_PACRG - Peripheral Access Control Register
 * - AIPS_PACRH - Peripheral Access Control Register
 * - AIPS_PACRI - Peripheral Access Control Register
 * - AIPS_PACRJ - Peripheral Access Control Register
 * - AIPS_PACRK - Peripheral Access Control Register
 * - AIPS_PACRL - Peripheral Access Control Register
 * - AIPS_PACRM - Peripheral Access Control Register
 * - AIPS_PACRN - Peripheral Access Control Register
 * - AIPS_PACRO - Peripheral Access Control Register
 * - AIPS_PACRP - Peripheral Access Control Register
 */

#define AIPS_INSTANCE_COUNT (2U) /*!< Number of instances of the AIPS module. */
#define AIPS0_IDX (0U) /*!< Instance number for AIPS0. */
#define AIPS1_IDX (1U) /*!< Instance number for AIPS1. */

/*******************************************************************************
 * AIPS_MPRA - Master Privilege Register A
 ******************************************************************************/

/*!
 * @brief AIPS_MPRA - Master Privilege Register A (RW)
 *
 * Reset value: 0x77700000U
 *
 * The MPRA specifies identical 4-bit fields defining the access-privilege level
 * associated with a bus master to various peripherals on the chip. The register
 * provides one field per bus master. At reset, the default value loaded into
 * the MPRA fields is chip-specific. See the chip configuration details for the
 * value of a particular device. A register field that maps to an unimplemented
 * master or peripheral behaves as read-only-zero. Each master is assigned a logical
 * ID from 0 to 15. See the master logical ID assignment table in the
 * chip-specific AIPS information.
 */
/*!
 * @name Constants and macros for entire AIPS_MPRA register
 */
/*@{*/
#define AIPS_RD_MPRA(base)       (AIPS_MPRA_REG(base))
#define AIPS_WR_MPRA(base, value) (AIPS_MPRA_REG(base) = (value))
#define AIPS_RMW_MPRA(base, mask, value) (AIPS_WR_MPRA(base, (AIPS_RD_MPRA(base) & ~(mask)) | (value)))
#define AIPS_SET_MPRA(base, value) (BME_OR32(&AIPS_MPRA_REG(base), (uint32_t)(value)))
#define AIPS_CLR_MPRA(base, value) (BME_AND32(&AIPS_MPRA_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_MPRA(base, value) (BME_XOR32(&AIPS_MPRA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_MPRA bitfields
 */

/*!
 * @name Register AIPS_MPRA, field MPL3[16] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0b0 - Accesses from this master are forced to user-mode.
 * - 0b1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MPL3 field. */
#define AIPS_RD_MPRA_MPL3(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MPL3_MASK) >> AIPS_MPRA_MPL3_SHIFT)
#define AIPS_BRD_MPRA_MPL3(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MPL3_SHIFT, AIPS_MPRA_MPL3_WIDTH))

/*! @brief Set the MPL3 field to a new value. */
#define AIPS_WR_MPRA_MPL3(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MPL3_MASK, AIPS_MPRA_MPL3(value)))
#define AIPS_BWR_MPRA_MPL3(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MPL3_SHIFT), AIPS_MPRA_MPL3_SHIFT, AIPS_MPRA_MPL3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW3[17] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for write accesses.
 * - 0b1 - This master is trusted for write accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTW3 field. */
#define AIPS_RD_MPRA_MTW3(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTW3_MASK) >> AIPS_MPRA_MTW3_SHIFT)
#define AIPS_BRD_MPRA_MTW3(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTW3_SHIFT, AIPS_MPRA_MTW3_WIDTH))

/*! @brief Set the MTW3 field to a new value. */
#define AIPS_WR_MPRA_MTW3(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTW3_MASK, AIPS_MPRA_MTW3(value)))
#define AIPS_BWR_MPRA_MTW3(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTW3_SHIFT), AIPS_MPRA_MTW3_SHIFT, AIPS_MPRA_MTW3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR3[18] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for read accesses.
 * - 0b1 - This master is trusted for read accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTR3 field. */
#define AIPS_RD_MPRA_MTR3(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTR3_MASK) >> AIPS_MPRA_MTR3_SHIFT)
#define AIPS_BRD_MPRA_MTR3(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTR3_SHIFT, AIPS_MPRA_MTR3_WIDTH))

/*! @brief Set the MTR3 field to a new value. */
#define AIPS_WR_MPRA_MTR3(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTR3_MASK, AIPS_MPRA_MTR3(value)))
#define AIPS_BWR_MPRA_MTR3(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTR3_SHIFT), AIPS_MPRA_MTR3_SHIFT, AIPS_MPRA_MTR3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL2[20] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0b0 - Accesses from this master are forced to user-mode.
 * - 0b1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MPL2 field. */
#define AIPS_RD_MPRA_MPL2(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MPL2_MASK) >> AIPS_MPRA_MPL2_SHIFT)
#define AIPS_BRD_MPRA_MPL2(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MPL2_SHIFT, AIPS_MPRA_MPL2_WIDTH))

/*! @brief Set the MPL2 field to a new value. */
#define AIPS_WR_MPRA_MPL2(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MPL2_MASK, AIPS_MPRA_MPL2(value)))
#define AIPS_BWR_MPRA_MPL2(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MPL2_SHIFT), AIPS_MPRA_MPL2_SHIFT, AIPS_MPRA_MPL2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW2[21] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for write accesses.
 * - 0b1 - This master is trusted for write accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTW2 field. */
#define AIPS_RD_MPRA_MTW2(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTW2_MASK) >> AIPS_MPRA_MTW2_SHIFT)
#define AIPS_BRD_MPRA_MTW2(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTW2_SHIFT, AIPS_MPRA_MTW2_WIDTH))

/*! @brief Set the MTW2 field to a new value. */
#define AIPS_WR_MPRA_MTW2(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTW2_MASK, AIPS_MPRA_MTW2(value)))
#define AIPS_BWR_MPRA_MTW2(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTW2_SHIFT), AIPS_MPRA_MTW2_SHIFT, AIPS_MPRA_MTW2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR2[22] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for read accesses.
 * - 0b1 - This master is trusted for read accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTR2 field. */
#define AIPS_RD_MPRA_MTR2(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTR2_MASK) >> AIPS_MPRA_MTR2_SHIFT)
#define AIPS_BRD_MPRA_MTR2(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTR2_SHIFT, AIPS_MPRA_MTR2_WIDTH))

/*! @brief Set the MTR2 field to a new value. */
#define AIPS_WR_MPRA_MTR2(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTR2_MASK, AIPS_MPRA_MTR2(value)))
#define AIPS_BWR_MPRA_MTR2(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTR2_SHIFT), AIPS_MPRA_MTR2_SHIFT, AIPS_MPRA_MTR2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL1[24] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0b0 - Accesses from this master are forced to user-mode.
 * - 0b1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MPL1 field. */
#define AIPS_RD_MPRA_MPL1(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MPL1_MASK) >> AIPS_MPRA_MPL1_SHIFT)
#define AIPS_BRD_MPRA_MPL1(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MPL1_SHIFT, AIPS_MPRA_MPL1_WIDTH))

/*! @brief Set the MPL1 field to a new value. */
#define AIPS_WR_MPRA_MPL1(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MPL1_MASK, AIPS_MPRA_MPL1(value)))
#define AIPS_BWR_MPRA_MPL1(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MPL1_SHIFT), AIPS_MPRA_MPL1_SHIFT, AIPS_MPRA_MPL1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW1[25] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for write accesses.
 * - 0b1 - This master is trusted for write accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTW1 field. */
#define AIPS_RD_MPRA_MTW1(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTW1_MASK) >> AIPS_MPRA_MTW1_SHIFT)
#define AIPS_BRD_MPRA_MTW1(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTW1_SHIFT, AIPS_MPRA_MTW1_WIDTH))

/*! @brief Set the MTW1 field to a new value. */
#define AIPS_WR_MPRA_MTW1(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTW1_MASK, AIPS_MPRA_MTW1(value)))
#define AIPS_BWR_MPRA_MTW1(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTW1_SHIFT), AIPS_MPRA_MTW1_SHIFT, AIPS_MPRA_MTW1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR1[26] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for read accesses.
 * - 0b1 - This master is trusted for read accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTR1 field. */
#define AIPS_RD_MPRA_MTR1(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTR1_MASK) >> AIPS_MPRA_MTR1_SHIFT)
#define AIPS_BRD_MPRA_MTR1(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTR1_SHIFT, AIPS_MPRA_MTR1_WIDTH))

/*! @brief Set the MTR1 field to a new value. */
#define AIPS_WR_MPRA_MTR1(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTR1_MASK, AIPS_MPRA_MTR1(value)))
#define AIPS_BWR_MPRA_MTR1(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTR1_SHIFT), AIPS_MPRA_MTR1_SHIFT, AIPS_MPRA_MTR1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MPL0[28] (RW)
 *
 * Specifies how the privilege level of the master is determined.
 *
 * Values:
 * - 0b0 - Accesses from this master are forced to user-mode.
 * - 0b1 - Accesses from this master are not forced to user-mode.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MPL0 field. */
#define AIPS_RD_MPRA_MPL0(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MPL0_MASK) >> AIPS_MPRA_MPL0_SHIFT)
#define AIPS_BRD_MPRA_MPL0(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MPL0_SHIFT, AIPS_MPRA_MPL0_WIDTH))

/*! @brief Set the MPL0 field to a new value. */
#define AIPS_WR_MPRA_MPL0(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MPL0_MASK, AIPS_MPRA_MPL0(value)))
#define AIPS_BWR_MPRA_MPL0(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MPL0_SHIFT), AIPS_MPRA_MPL0_SHIFT, AIPS_MPRA_MPL0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTW0[29] (RW)
 *
 * Determines whether the master is trusted for write accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for write accesses.
 * - 0b1 - This master is trusted for write accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTW0 field. */
#define AIPS_RD_MPRA_MTW0(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTW0_MASK) >> AIPS_MPRA_MTW0_SHIFT)
#define AIPS_BRD_MPRA_MTW0(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTW0_SHIFT, AIPS_MPRA_MTW0_WIDTH))

/*! @brief Set the MTW0 field to a new value. */
#define AIPS_WR_MPRA_MTW0(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTW0_MASK, AIPS_MPRA_MTW0(value)))
#define AIPS_BWR_MPRA_MTW0(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTW0_SHIFT), AIPS_MPRA_MTW0_SHIFT, AIPS_MPRA_MTW0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_MPRA, field MTR0[30] (RW)
 *
 * Determines whether the master is trusted for read accesses.
 *
 * Values:
 * - 0b0 - This master is not trusted for read accesses.
 * - 0b1 - This master is trusted for read accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_MPRA_MTR0 field. */
#define AIPS_RD_MPRA_MTR0(base) ((AIPS_MPRA_REG(base) & AIPS_MPRA_MTR0_MASK) >> AIPS_MPRA_MTR0_SHIFT)
#define AIPS_BRD_MPRA_MTR0(base) (BME_UBFX32(&AIPS_MPRA_REG(base), AIPS_MPRA_MTR0_SHIFT, AIPS_MPRA_MTR0_WIDTH))

/*! @brief Set the MTR0 field to a new value. */
#define AIPS_WR_MPRA_MTR0(base, value) (AIPS_RMW_MPRA(base, AIPS_MPRA_MTR0_MASK, AIPS_MPRA_MTR0(value)))
#define AIPS_BWR_MPRA_MTR0(base, value) (BME_BFI32(&AIPS_MPRA_REG(base), ((uint32_t)(value) << AIPS_MPRA_MTR0_SHIFT), AIPS_MPRA_MTR0_SHIFT, AIPS_MPRA_MTR0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRA - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRA - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 The
 * register field descriptions for PACR A-D, which control peripheral slots 0-31,
 * are shown below. The following section, PACRPeripheral Access Control
 * Register , shows the register field descriptions for PACR E-P. All PACR registers are
 * identical. They are divided into two sections because they occupy two
 * non-contiguous address spaces.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRA register
 */
/*@{*/
#define AIPS_RD_PACRA(base)      (AIPS_PACRA_REG(base))
#define AIPS_WR_PACRA(base, value) (AIPS_PACRA_REG(base) = (value))
#define AIPS_RMW_PACRA(base, mask, value) (AIPS_WR_PACRA(base, (AIPS_RD_PACRA(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRA(base, value) (BME_OR32(&AIPS_PACRA_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRA(base, value) (BME_AND32(&AIPS_PACRA_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRA(base, value) (BME_XOR32(&AIPS_PACRA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRA bitfields
 */

/*!
 * @name Register AIPS_PACRA, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP7 field. */
#define AIPS_RD_PACRA_TP7(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP7_MASK) >> AIPS_PACRA_TP7_SHIFT)
#define AIPS_BRD_PACRA_TP7(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP7_SHIFT, AIPS_PACRA_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRA_TP7(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP7_MASK, AIPS_PACRA_TP7(value)))
#define AIPS_BWR_PACRA_TP7(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP7_SHIFT), AIPS_PACRA_TP7_SHIFT, AIPS_PACRA_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP7 field. */
#define AIPS_RD_PACRA_WP7(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP7_MASK) >> AIPS_PACRA_WP7_SHIFT)
#define AIPS_BRD_PACRA_WP7(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP7_SHIFT, AIPS_PACRA_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRA_WP7(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP7_MASK, AIPS_PACRA_WP7(value)))
#define AIPS_BWR_PACRA_WP7(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP7_SHIFT), AIPS_PACRA_WP7_SHIFT, AIPS_PACRA_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP7 field. */
#define AIPS_RD_PACRA_SP7(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP7_MASK) >> AIPS_PACRA_SP7_SHIFT)
#define AIPS_BRD_PACRA_SP7(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP7_SHIFT, AIPS_PACRA_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRA_SP7(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP7_MASK, AIPS_PACRA_SP7(value)))
#define AIPS_BWR_PACRA_SP7(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP7_SHIFT), AIPS_PACRA_SP7_SHIFT, AIPS_PACRA_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP6 field. */
#define AIPS_RD_PACRA_TP6(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP6_MASK) >> AIPS_PACRA_TP6_SHIFT)
#define AIPS_BRD_PACRA_TP6(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP6_SHIFT, AIPS_PACRA_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRA_TP6(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP6_MASK, AIPS_PACRA_TP6(value)))
#define AIPS_BWR_PACRA_TP6(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP6_SHIFT), AIPS_PACRA_TP6_SHIFT, AIPS_PACRA_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP6 field. */
#define AIPS_RD_PACRA_WP6(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP6_MASK) >> AIPS_PACRA_WP6_SHIFT)
#define AIPS_BRD_PACRA_WP6(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP6_SHIFT, AIPS_PACRA_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRA_WP6(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP6_MASK, AIPS_PACRA_WP6(value)))
#define AIPS_BWR_PACRA_WP6(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP6_SHIFT), AIPS_PACRA_WP6_SHIFT, AIPS_PACRA_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP6 field. */
#define AIPS_RD_PACRA_SP6(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP6_MASK) >> AIPS_PACRA_SP6_SHIFT)
#define AIPS_BRD_PACRA_SP6(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP6_SHIFT, AIPS_PACRA_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRA_SP6(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP6_MASK, AIPS_PACRA_SP6(value)))
#define AIPS_BWR_PACRA_SP6(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP6_SHIFT), AIPS_PACRA_SP6_SHIFT, AIPS_PACRA_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP5 field. */
#define AIPS_RD_PACRA_TP5(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP5_MASK) >> AIPS_PACRA_TP5_SHIFT)
#define AIPS_BRD_PACRA_TP5(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP5_SHIFT, AIPS_PACRA_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRA_TP5(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP5_MASK, AIPS_PACRA_TP5(value)))
#define AIPS_BWR_PACRA_TP5(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP5_SHIFT), AIPS_PACRA_TP5_SHIFT, AIPS_PACRA_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP5 field. */
#define AIPS_RD_PACRA_WP5(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP5_MASK) >> AIPS_PACRA_WP5_SHIFT)
#define AIPS_BRD_PACRA_WP5(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP5_SHIFT, AIPS_PACRA_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRA_WP5(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP5_MASK, AIPS_PACRA_WP5(value)))
#define AIPS_BWR_PACRA_WP5(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP5_SHIFT), AIPS_PACRA_WP5_SHIFT, AIPS_PACRA_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP5 field. */
#define AIPS_RD_PACRA_SP5(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP5_MASK) >> AIPS_PACRA_SP5_SHIFT)
#define AIPS_BRD_PACRA_SP5(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP5_SHIFT, AIPS_PACRA_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRA_SP5(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP5_MASK, AIPS_PACRA_SP5(value)))
#define AIPS_BWR_PACRA_SP5(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP5_SHIFT), AIPS_PACRA_SP5_SHIFT, AIPS_PACRA_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP4 field. */
#define AIPS_RD_PACRA_TP4(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP4_MASK) >> AIPS_PACRA_TP4_SHIFT)
#define AIPS_BRD_PACRA_TP4(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP4_SHIFT, AIPS_PACRA_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRA_TP4(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP4_MASK, AIPS_PACRA_TP4(value)))
#define AIPS_BWR_PACRA_TP4(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP4_SHIFT), AIPS_PACRA_TP4_SHIFT, AIPS_PACRA_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP4 field. */
#define AIPS_RD_PACRA_WP4(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP4_MASK) >> AIPS_PACRA_WP4_SHIFT)
#define AIPS_BRD_PACRA_WP4(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP4_SHIFT, AIPS_PACRA_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRA_WP4(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP4_MASK, AIPS_PACRA_WP4(value)))
#define AIPS_BWR_PACRA_WP4(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP4_SHIFT), AIPS_PACRA_WP4_SHIFT, AIPS_PACRA_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP4 field. */
#define AIPS_RD_PACRA_SP4(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP4_MASK) >> AIPS_PACRA_SP4_SHIFT)
#define AIPS_BRD_PACRA_SP4(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP4_SHIFT, AIPS_PACRA_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRA_SP4(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP4_MASK, AIPS_PACRA_SP4(value)))
#define AIPS_BWR_PACRA_SP4(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP4_SHIFT), AIPS_PACRA_SP4_SHIFT, AIPS_PACRA_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP3 field. */
#define AIPS_RD_PACRA_TP3(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP3_MASK) >> AIPS_PACRA_TP3_SHIFT)
#define AIPS_BRD_PACRA_TP3(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP3_SHIFT, AIPS_PACRA_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRA_TP3(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP3_MASK, AIPS_PACRA_TP3(value)))
#define AIPS_BWR_PACRA_TP3(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP3_SHIFT), AIPS_PACRA_TP3_SHIFT, AIPS_PACRA_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP3 field. */
#define AIPS_RD_PACRA_WP3(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP3_MASK) >> AIPS_PACRA_WP3_SHIFT)
#define AIPS_BRD_PACRA_WP3(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP3_SHIFT, AIPS_PACRA_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRA_WP3(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP3_MASK, AIPS_PACRA_WP3(value)))
#define AIPS_BWR_PACRA_WP3(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP3_SHIFT), AIPS_PACRA_WP3_SHIFT, AIPS_PACRA_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP3 field. */
#define AIPS_RD_PACRA_SP3(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP3_MASK) >> AIPS_PACRA_SP3_SHIFT)
#define AIPS_BRD_PACRA_SP3(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP3_SHIFT, AIPS_PACRA_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRA_SP3(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP3_MASK, AIPS_PACRA_SP3(value)))
#define AIPS_BWR_PACRA_SP3(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP3_SHIFT), AIPS_PACRA_SP3_SHIFT, AIPS_PACRA_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP2 field. */
#define AIPS_RD_PACRA_TP2(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP2_MASK) >> AIPS_PACRA_TP2_SHIFT)
#define AIPS_BRD_PACRA_TP2(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP2_SHIFT, AIPS_PACRA_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRA_TP2(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP2_MASK, AIPS_PACRA_TP2(value)))
#define AIPS_BWR_PACRA_TP2(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP2_SHIFT), AIPS_PACRA_TP2_SHIFT, AIPS_PACRA_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP2 field. */
#define AIPS_RD_PACRA_WP2(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP2_MASK) >> AIPS_PACRA_WP2_SHIFT)
#define AIPS_BRD_PACRA_WP2(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP2_SHIFT, AIPS_PACRA_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRA_WP2(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP2_MASK, AIPS_PACRA_WP2(value)))
#define AIPS_BWR_PACRA_WP2(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP2_SHIFT), AIPS_PACRA_WP2_SHIFT, AIPS_PACRA_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP2 field. */
#define AIPS_RD_PACRA_SP2(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP2_MASK) >> AIPS_PACRA_SP2_SHIFT)
#define AIPS_BRD_PACRA_SP2(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP2_SHIFT, AIPS_PACRA_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRA_SP2(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP2_MASK, AIPS_PACRA_SP2(value)))
#define AIPS_BWR_PACRA_SP2(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP2_SHIFT), AIPS_PACRA_SP2_SHIFT, AIPS_PACRA_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP1 field. */
#define AIPS_RD_PACRA_TP1(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP1_MASK) >> AIPS_PACRA_TP1_SHIFT)
#define AIPS_BRD_PACRA_TP1(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP1_SHIFT, AIPS_PACRA_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRA_TP1(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP1_MASK, AIPS_PACRA_TP1(value)))
#define AIPS_BWR_PACRA_TP1(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP1_SHIFT), AIPS_PACRA_TP1_SHIFT, AIPS_PACRA_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP1 field. */
#define AIPS_RD_PACRA_WP1(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP1_MASK) >> AIPS_PACRA_WP1_SHIFT)
#define AIPS_BRD_PACRA_WP1(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP1_SHIFT, AIPS_PACRA_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRA_WP1(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP1_MASK, AIPS_PACRA_WP1(value)))
#define AIPS_BWR_PACRA_WP1(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP1_SHIFT), AIPS_PACRA_WP1_SHIFT, AIPS_PACRA_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP1 field. */
#define AIPS_RD_PACRA_SP1(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP1_MASK) >> AIPS_PACRA_SP1_SHIFT)
#define AIPS_BRD_PACRA_SP1(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP1_SHIFT, AIPS_PACRA_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRA_SP1(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP1_MASK, AIPS_PACRA_SP1(value)))
#define AIPS_BWR_PACRA_SP1(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP1_SHIFT), AIPS_PACRA_SP1_SHIFT, AIPS_PACRA_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_TP0 field. */
#define AIPS_RD_PACRA_TP0(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_TP0_MASK) >> AIPS_PACRA_TP0_SHIFT)
#define AIPS_BRD_PACRA_TP0(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_TP0_SHIFT, AIPS_PACRA_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRA_TP0(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_TP0_MASK, AIPS_PACRA_TP0(value)))
#define AIPS_BWR_PACRA_TP0(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_TP0_SHIFT), AIPS_PACRA_TP0_SHIFT, AIPS_PACRA_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_WP0 field. */
#define AIPS_RD_PACRA_WP0(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_WP0_MASK) >> AIPS_PACRA_WP0_SHIFT)
#define AIPS_BRD_PACRA_WP0(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_WP0_SHIFT, AIPS_PACRA_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRA_WP0(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_WP0_MASK, AIPS_PACRA_WP0(value)))
#define AIPS_BWR_PACRA_WP0(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_WP0_SHIFT), AIPS_PACRA_WP0_SHIFT, AIPS_PACRA_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRA, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRA_SP0 field. */
#define AIPS_RD_PACRA_SP0(base) ((AIPS_PACRA_REG(base) & AIPS_PACRA_SP0_MASK) >> AIPS_PACRA_SP0_SHIFT)
#define AIPS_BRD_PACRA_SP0(base) (BME_UBFX32(&AIPS_PACRA_REG(base), AIPS_PACRA_SP0_SHIFT, AIPS_PACRA_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRA_SP0(base, value) (AIPS_RMW_PACRA(base, AIPS_PACRA_SP0_MASK, AIPS_PACRA_SP0(value)))
#define AIPS_BWR_PACRA_SP0(base, value) (BME_BFI32(&AIPS_PACRA_REG(base), ((uint32_t)(value) << AIPS_PACRA_SP0_SHIFT), AIPS_PACRA_SP0_SHIFT, AIPS_PACRA_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRB - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRB - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 The
 * register field descriptions for PACR A-D, which control peripheral slots 0-31,
 * are shown below. The following section, PACRPeripheral Access Control
 * Register , shows the register field descriptions for PACR E-P. All PACR registers are
 * identical. They are divided into two sections because they occupy two
 * non-contiguous address spaces.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRB register
 */
/*@{*/
#define AIPS_RD_PACRB(base)      (AIPS_PACRB_REG(base))
#define AIPS_WR_PACRB(base, value) (AIPS_PACRB_REG(base) = (value))
#define AIPS_RMW_PACRB(base, mask, value) (AIPS_WR_PACRB(base, (AIPS_RD_PACRB(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRB(base, value) (BME_OR32(&AIPS_PACRB_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRB(base, value) (BME_AND32(&AIPS_PACRB_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRB(base, value) (BME_XOR32(&AIPS_PACRB_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRB bitfields
 */

/*!
 * @name Register AIPS_PACRB, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP7 field. */
#define AIPS_RD_PACRB_TP7(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP7_MASK) >> AIPS_PACRB_TP7_SHIFT)
#define AIPS_BRD_PACRB_TP7(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP7_SHIFT, AIPS_PACRB_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRB_TP7(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP7_MASK, AIPS_PACRB_TP7(value)))
#define AIPS_BWR_PACRB_TP7(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP7_SHIFT), AIPS_PACRB_TP7_SHIFT, AIPS_PACRB_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP7 field. */
#define AIPS_RD_PACRB_WP7(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP7_MASK) >> AIPS_PACRB_WP7_SHIFT)
#define AIPS_BRD_PACRB_WP7(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP7_SHIFT, AIPS_PACRB_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRB_WP7(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP7_MASK, AIPS_PACRB_WP7(value)))
#define AIPS_BWR_PACRB_WP7(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP7_SHIFT), AIPS_PACRB_WP7_SHIFT, AIPS_PACRB_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP7 field. */
#define AIPS_RD_PACRB_SP7(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP7_MASK) >> AIPS_PACRB_SP7_SHIFT)
#define AIPS_BRD_PACRB_SP7(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP7_SHIFT, AIPS_PACRB_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRB_SP7(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP7_MASK, AIPS_PACRB_SP7(value)))
#define AIPS_BWR_PACRB_SP7(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP7_SHIFT), AIPS_PACRB_SP7_SHIFT, AIPS_PACRB_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP6 field. */
#define AIPS_RD_PACRB_TP6(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP6_MASK) >> AIPS_PACRB_TP6_SHIFT)
#define AIPS_BRD_PACRB_TP6(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP6_SHIFT, AIPS_PACRB_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRB_TP6(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP6_MASK, AIPS_PACRB_TP6(value)))
#define AIPS_BWR_PACRB_TP6(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP6_SHIFT), AIPS_PACRB_TP6_SHIFT, AIPS_PACRB_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP6 field. */
#define AIPS_RD_PACRB_WP6(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP6_MASK) >> AIPS_PACRB_WP6_SHIFT)
#define AIPS_BRD_PACRB_WP6(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP6_SHIFT, AIPS_PACRB_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRB_WP6(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP6_MASK, AIPS_PACRB_WP6(value)))
#define AIPS_BWR_PACRB_WP6(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP6_SHIFT), AIPS_PACRB_WP6_SHIFT, AIPS_PACRB_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP6 field. */
#define AIPS_RD_PACRB_SP6(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP6_MASK) >> AIPS_PACRB_SP6_SHIFT)
#define AIPS_BRD_PACRB_SP6(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP6_SHIFT, AIPS_PACRB_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRB_SP6(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP6_MASK, AIPS_PACRB_SP6(value)))
#define AIPS_BWR_PACRB_SP6(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP6_SHIFT), AIPS_PACRB_SP6_SHIFT, AIPS_PACRB_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP5 field. */
#define AIPS_RD_PACRB_TP5(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP5_MASK) >> AIPS_PACRB_TP5_SHIFT)
#define AIPS_BRD_PACRB_TP5(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP5_SHIFT, AIPS_PACRB_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRB_TP5(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP5_MASK, AIPS_PACRB_TP5(value)))
#define AIPS_BWR_PACRB_TP5(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP5_SHIFT), AIPS_PACRB_TP5_SHIFT, AIPS_PACRB_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP5 field. */
#define AIPS_RD_PACRB_WP5(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP5_MASK) >> AIPS_PACRB_WP5_SHIFT)
#define AIPS_BRD_PACRB_WP5(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP5_SHIFT, AIPS_PACRB_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRB_WP5(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP5_MASK, AIPS_PACRB_WP5(value)))
#define AIPS_BWR_PACRB_WP5(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP5_SHIFT), AIPS_PACRB_WP5_SHIFT, AIPS_PACRB_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP5 field. */
#define AIPS_RD_PACRB_SP5(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP5_MASK) >> AIPS_PACRB_SP5_SHIFT)
#define AIPS_BRD_PACRB_SP5(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP5_SHIFT, AIPS_PACRB_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRB_SP5(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP5_MASK, AIPS_PACRB_SP5(value)))
#define AIPS_BWR_PACRB_SP5(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP5_SHIFT), AIPS_PACRB_SP5_SHIFT, AIPS_PACRB_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP4 field. */
#define AIPS_RD_PACRB_TP4(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP4_MASK) >> AIPS_PACRB_TP4_SHIFT)
#define AIPS_BRD_PACRB_TP4(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP4_SHIFT, AIPS_PACRB_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRB_TP4(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP4_MASK, AIPS_PACRB_TP4(value)))
#define AIPS_BWR_PACRB_TP4(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP4_SHIFT), AIPS_PACRB_TP4_SHIFT, AIPS_PACRB_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP4 field. */
#define AIPS_RD_PACRB_WP4(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP4_MASK) >> AIPS_PACRB_WP4_SHIFT)
#define AIPS_BRD_PACRB_WP4(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP4_SHIFT, AIPS_PACRB_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRB_WP4(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP4_MASK, AIPS_PACRB_WP4(value)))
#define AIPS_BWR_PACRB_WP4(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP4_SHIFT), AIPS_PACRB_WP4_SHIFT, AIPS_PACRB_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP4 field. */
#define AIPS_RD_PACRB_SP4(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP4_MASK) >> AIPS_PACRB_SP4_SHIFT)
#define AIPS_BRD_PACRB_SP4(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP4_SHIFT, AIPS_PACRB_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRB_SP4(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP4_MASK, AIPS_PACRB_SP4(value)))
#define AIPS_BWR_PACRB_SP4(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP4_SHIFT), AIPS_PACRB_SP4_SHIFT, AIPS_PACRB_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP3 field. */
#define AIPS_RD_PACRB_TP3(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP3_MASK) >> AIPS_PACRB_TP3_SHIFT)
#define AIPS_BRD_PACRB_TP3(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP3_SHIFT, AIPS_PACRB_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRB_TP3(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP3_MASK, AIPS_PACRB_TP3(value)))
#define AIPS_BWR_PACRB_TP3(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP3_SHIFT), AIPS_PACRB_TP3_SHIFT, AIPS_PACRB_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP3 field. */
#define AIPS_RD_PACRB_WP3(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP3_MASK) >> AIPS_PACRB_WP3_SHIFT)
#define AIPS_BRD_PACRB_WP3(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP3_SHIFT, AIPS_PACRB_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRB_WP3(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP3_MASK, AIPS_PACRB_WP3(value)))
#define AIPS_BWR_PACRB_WP3(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP3_SHIFT), AIPS_PACRB_WP3_SHIFT, AIPS_PACRB_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP3 field. */
#define AIPS_RD_PACRB_SP3(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP3_MASK) >> AIPS_PACRB_SP3_SHIFT)
#define AIPS_BRD_PACRB_SP3(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP3_SHIFT, AIPS_PACRB_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRB_SP3(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP3_MASK, AIPS_PACRB_SP3(value)))
#define AIPS_BWR_PACRB_SP3(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP3_SHIFT), AIPS_PACRB_SP3_SHIFT, AIPS_PACRB_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP2 field. */
#define AIPS_RD_PACRB_TP2(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP2_MASK) >> AIPS_PACRB_TP2_SHIFT)
#define AIPS_BRD_PACRB_TP2(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP2_SHIFT, AIPS_PACRB_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRB_TP2(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP2_MASK, AIPS_PACRB_TP2(value)))
#define AIPS_BWR_PACRB_TP2(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP2_SHIFT), AIPS_PACRB_TP2_SHIFT, AIPS_PACRB_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP2 field. */
#define AIPS_RD_PACRB_WP2(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP2_MASK) >> AIPS_PACRB_WP2_SHIFT)
#define AIPS_BRD_PACRB_WP2(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP2_SHIFT, AIPS_PACRB_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRB_WP2(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP2_MASK, AIPS_PACRB_WP2(value)))
#define AIPS_BWR_PACRB_WP2(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP2_SHIFT), AIPS_PACRB_WP2_SHIFT, AIPS_PACRB_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP2 field. */
#define AIPS_RD_PACRB_SP2(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP2_MASK) >> AIPS_PACRB_SP2_SHIFT)
#define AIPS_BRD_PACRB_SP2(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP2_SHIFT, AIPS_PACRB_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRB_SP2(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP2_MASK, AIPS_PACRB_SP2(value)))
#define AIPS_BWR_PACRB_SP2(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP2_SHIFT), AIPS_PACRB_SP2_SHIFT, AIPS_PACRB_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP1 field. */
#define AIPS_RD_PACRB_TP1(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP1_MASK) >> AIPS_PACRB_TP1_SHIFT)
#define AIPS_BRD_PACRB_TP1(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP1_SHIFT, AIPS_PACRB_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRB_TP1(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP1_MASK, AIPS_PACRB_TP1(value)))
#define AIPS_BWR_PACRB_TP1(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP1_SHIFT), AIPS_PACRB_TP1_SHIFT, AIPS_PACRB_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP1 field. */
#define AIPS_RD_PACRB_WP1(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP1_MASK) >> AIPS_PACRB_WP1_SHIFT)
#define AIPS_BRD_PACRB_WP1(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP1_SHIFT, AIPS_PACRB_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRB_WP1(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP1_MASK, AIPS_PACRB_WP1(value)))
#define AIPS_BWR_PACRB_WP1(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP1_SHIFT), AIPS_PACRB_WP1_SHIFT, AIPS_PACRB_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP1 field. */
#define AIPS_RD_PACRB_SP1(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP1_MASK) >> AIPS_PACRB_SP1_SHIFT)
#define AIPS_BRD_PACRB_SP1(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP1_SHIFT, AIPS_PACRB_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRB_SP1(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP1_MASK, AIPS_PACRB_SP1(value)))
#define AIPS_BWR_PACRB_SP1(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP1_SHIFT), AIPS_PACRB_SP1_SHIFT, AIPS_PACRB_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_TP0 field. */
#define AIPS_RD_PACRB_TP0(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_TP0_MASK) >> AIPS_PACRB_TP0_SHIFT)
#define AIPS_BRD_PACRB_TP0(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_TP0_SHIFT, AIPS_PACRB_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRB_TP0(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_TP0_MASK, AIPS_PACRB_TP0(value)))
#define AIPS_BWR_PACRB_TP0(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_TP0_SHIFT), AIPS_PACRB_TP0_SHIFT, AIPS_PACRB_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_WP0 field. */
#define AIPS_RD_PACRB_WP0(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_WP0_MASK) >> AIPS_PACRB_WP0_SHIFT)
#define AIPS_BRD_PACRB_WP0(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_WP0_SHIFT, AIPS_PACRB_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRB_WP0(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_WP0_MASK, AIPS_PACRB_WP0(value)))
#define AIPS_BWR_PACRB_WP0(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_WP0_SHIFT), AIPS_PACRB_WP0_SHIFT, AIPS_PACRB_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRB, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRB_SP0 field. */
#define AIPS_RD_PACRB_SP0(base) ((AIPS_PACRB_REG(base) & AIPS_PACRB_SP0_MASK) >> AIPS_PACRB_SP0_SHIFT)
#define AIPS_BRD_PACRB_SP0(base) (BME_UBFX32(&AIPS_PACRB_REG(base), AIPS_PACRB_SP0_SHIFT, AIPS_PACRB_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRB_SP0(base, value) (AIPS_RMW_PACRB(base, AIPS_PACRB_SP0_MASK, AIPS_PACRB_SP0(value)))
#define AIPS_BWR_PACRB_SP0(base, value) (BME_BFI32(&AIPS_PACRB_REG(base), ((uint32_t)(value) << AIPS_PACRB_SP0_SHIFT), AIPS_PACRB_SP0_SHIFT, AIPS_PACRB_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRC - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRC - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 The
 * register field descriptions for PACR A-D, which control peripheral slots 0-31,
 * are shown below. The following section, PACRPeripheral Access Control
 * Register , shows the register field descriptions for PACR E-P. All PACR registers are
 * identical. They are divided into two sections because they occupy two
 * non-contiguous address spaces.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRC register
 */
/*@{*/
#define AIPS_RD_PACRC(base)      (AIPS_PACRC_REG(base))
#define AIPS_WR_PACRC(base, value) (AIPS_PACRC_REG(base) = (value))
#define AIPS_RMW_PACRC(base, mask, value) (AIPS_WR_PACRC(base, (AIPS_RD_PACRC(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRC(base, value) (BME_OR32(&AIPS_PACRC_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRC(base, value) (BME_AND32(&AIPS_PACRC_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRC(base, value) (BME_XOR32(&AIPS_PACRC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRC bitfields
 */

/*!
 * @name Register AIPS_PACRC, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP7 field. */
#define AIPS_RD_PACRC_TP7(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP7_MASK) >> AIPS_PACRC_TP7_SHIFT)
#define AIPS_BRD_PACRC_TP7(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP7_SHIFT, AIPS_PACRC_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRC_TP7(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP7_MASK, AIPS_PACRC_TP7(value)))
#define AIPS_BWR_PACRC_TP7(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP7_SHIFT), AIPS_PACRC_TP7_SHIFT, AIPS_PACRC_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP7 field. */
#define AIPS_RD_PACRC_WP7(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP7_MASK) >> AIPS_PACRC_WP7_SHIFT)
#define AIPS_BRD_PACRC_WP7(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP7_SHIFT, AIPS_PACRC_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRC_WP7(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP7_MASK, AIPS_PACRC_WP7(value)))
#define AIPS_BWR_PACRC_WP7(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP7_SHIFT), AIPS_PACRC_WP7_SHIFT, AIPS_PACRC_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP7 field. */
#define AIPS_RD_PACRC_SP7(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP7_MASK) >> AIPS_PACRC_SP7_SHIFT)
#define AIPS_BRD_PACRC_SP7(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP7_SHIFT, AIPS_PACRC_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRC_SP7(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP7_MASK, AIPS_PACRC_SP7(value)))
#define AIPS_BWR_PACRC_SP7(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP7_SHIFT), AIPS_PACRC_SP7_SHIFT, AIPS_PACRC_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP6 field. */
#define AIPS_RD_PACRC_TP6(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP6_MASK) >> AIPS_PACRC_TP6_SHIFT)
#define AIPS_BRD_PACRC_TP6(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP6_SHIFT, AIPS_PACRC_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRC_TP6(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP6_MASK, AIPS_PACRC_TP6(value)))
#define AIPS_BWR_PACRC_TP6(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP6_SHIFT), AIPS_PACRC_TP6_SHIFT, AIPS_PACRC_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP6 field. */
#define AIPS_RD_PACRC_WP6(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP6_MASK) >> AIPS_PACRC_WP6_SHIFT)
#define AIPS_BRD_PACRC_WP6(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP6_SHIFT, AIPS_PACRC_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRC_WP6(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP6_MASK, AIPS_PACRC_WP6(value)))
#define AIPS_BWR_PACRC_WP6(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP6_SHIFT), AIPS_PACRC_WP6_SHIFT, AIPS_PACRC_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP6 field. */
#define AIPS_RD_PACRC_SP6(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP6_MASK) >> AIPS_PACRC_SP6_SHIFT)
#define AIPS_BRD_PACRC_SP6(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP6_SHIFT, AIPS_PACRC_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRC_SP6(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP6_MASK, AIPS_PACRC_SP6(value)))
#define AIPS_BWR_PACRC_SP6(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP6_SHIFT), AIPS_PACRC_SP6_SHIFT, AIPS_PACRC_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP5 field. */
#define AIPS_RD_PACRC_TP5(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP5_MASK) >> AIPS_PACRC_TP5_SHIFT)
#define AIPS_BRD_PACRC_TP5(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP5_SHIFT, AIPS_PACRC_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRC_TP5(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP5_MASK, AIPS_PACRC_TP5(value)))
#define AIPS_BWR_PACRC_TP5(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP5_SHIFT), AIPS_PACRC_TP5_SHIFT, AIPS_PACRC_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP5 field. */
#define AIPS_RD_PACRC_WP5(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP5_MASK) >> AIPS_PACRC_WP5_SHIFT)
#define AIPS_BRD_PACRC_WP5(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP5_SHIFT, AIPS_PACRC_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRC_WP5(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP5_MASK, AIPS_PACRC_WP5(value)))
#define AIPS_BWR_PACRC_WP5(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP5_SHIFT), AIPS_PACRC_WP5_SHIFT, AIPS_PACRC_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP5 field. */
#define AIPS_RD_PACRC_SP5(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP5_MASK) >> AIPS_PACRC_SP5_SHIFT)
#define AIPS_BRD_PACRC_SP5(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP5_SHIFT, AIPS_PACRC_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRC_SP5(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP5_MASK, AIPS_PACRC_SP5(value)))
#define AIPS_BWR_PACRC_SP5(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP5_SHIFT), AIPS_PACRC_SP5_SHIFT, AIPS_PACRC_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP4 field. */
#define AIPS_RD_PACRC_TP4(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP4_MASK) >> AIPS_PACRC_TP4_SHIFT)
#define AIPS_BRD_PACRC_TP4(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP4_SHIFT, AIPS_PACRC_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRC_TP4(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP4_MASK, AIPS_PACRC_TP4(value)))
#define AIPS_BWR_PACRC_TP4(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP4_SHIFT), AIPS_PACRC_TP4_SHIFT, AIPS_PACRC_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP4 field. */
#define AIPS_RD_PACRC_WP4(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP4_MASK) >> AIPS_PACRC_WP4_SHIFT)
#define AIPS_BRD_PACRC_WP4(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP4_SHIFT, AIPS_PACRC_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRC_WP4(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP4_MASK, AIPS_PACRC_WP4(value)))
#define AIPS_BWR_PACRC_WP4(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP4_SHIFT), AIPS_PACRC_WP4_SHIFT, AIPS_PACRC_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP4 field. */
#define AIPS_RD_PACRC_SP4(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP4_MASK) >> AIPS_PACRC_SP4_SHIFT)
#define AIPS_BRD_PACRC_SP4(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP4_SHIFT, AIPS_PACRC_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRC_SP4(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP4_MASK, AIPS_PACRC_SP4(value)))
#define AIPS_BWR_PACRC_SP4(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP4_SHIFT), AIPS_PACRC_SP4_SHIFT, AIPS_PACRC_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP3 field. */
#define AIPS_RD_PACRC_TP3(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP3_MASK) >> AIPS_PACRC_TP3_SHIFT)
#define AIPS_BRD_PACRC_TP3(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP3_SHIFT, AIPS_PACRC_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRC_TP3(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP3_MASK, AIPS_PACRC_TP3(value)))
#define AIPS_BWR_PACRC_TP3(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP3_SHIFT), AIPS_PACRC_TP3_SHIFT, AIPS_PACRC_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP3 field. */
#define AIPS_RD_PACRC_WP3(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP3_MASK) >> AIPS_PACRC_WP3_SHIFT)
#define AIPS_BRD_PACRC_WP3(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP3_SHIFT, AIPS_PACRC_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRC_WP3(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP3_MASK, AIPS_PACRC_WP3(value)))
#define AIPS_BWR_PACRC_WP3(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP3_SHIFT), AIPS_PACRC_WP3_SHIFT, AIPS_PACRC_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP3 field. */
#define AIPS_RD_PACRC_SP3(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP3_MASK) >> AIPS_PACRC_SP3_SHIFT)
#define AIPS_BRD_PACRC_SP3(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP3_SHIFT, AIPS_PACRC_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRC_SP3(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP3_MASK, AIPS_PACRC_SP3(value)))
#define AIPS_BWR_PACRC_SP3(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP3_SHIFT), AIPS_PACRC_SP3_SHIFT, AIPS_PACRC_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP2 field. */
#define AIPS_RD_PACRC_TP2(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP2_MASK) >> AIPS_PACRC_TP2_SHIFT)
#define AIPS_BRD_PACRC_TP2(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP2_SHIFT, AIPS_PACRC_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRC_TP2(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP2_MASK, AIPS_PACRC_TP2(value)))
#define AIPS_BWR_PACRC_TP2(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP2_SHIFT), AIPS_PACRC_TP2_SHIFT, AIPS_PACRC_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP2 field. */
#define AIPS_RD_PACRC_WP2(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP2_MASK) >> AIPS_PACRC_WP2_SHIFT)
#define AIPS_BRD_PACRC_WP2(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP2_SHIFT, AIPS_PACRC_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRC_WP2(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP2_MASK, AIPS_PACRC_WP2(value)))
#define AIPS_BWR_PACRC_WP2(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP2_SHIFT), AIPS_PACRC_WP2_SHIFT, AIPS_PACRC_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP2 field. */
#define AIPS_RD_PACRC_SP2(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP2_MASK) >> AIPS_PACRC_SP2_SHIFT)
#define AIPS_BRD_PACRC_SP2(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP2_SHIFT, AIPS_PACRC_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRC_SP2(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP2_MASK, AIPS_PACRC_SP2(value)))
#define AIPS_BWR_PACRC_SP2(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP2_SHIFT), AIPS_PACRC_SP2_SHIFT, AIPS_PACRC_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP1 field. */
#define AIPS_RD_PACRC_TP1(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP1_MASK) >> AIPS_PACRC_TP1_SHIFT)
#define AIPS_BRD_PACRC_TP1(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP1_SHIFT, AIPS_PACRC_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRC_TP1(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP1_MASK, AIPS_PACRC_TP1(value)))
#define AIPS_BWR_PACRC_TP1(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP1_SHIFT), AIPS_PACRC_TP1_SHIFT, AIPS_PACRC_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP1 field. */
#define AIPS_RD_PACRC_WP1(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP1_MASK) >> AIPS_PACRC_WP1_SHIFT)
#define AIPS_BRD_PACRC_WP1(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP1_SHIFT, AIPS_PACRC_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRC_WP1(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP1_MASK, AIPS_PACRC_WP1(value)))
#define AIPS_BWR_PACRC_WP1(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP1_SHIFT), AIPS_PACRC_WP1_SHIFT, AIPS_PACRC_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP1 field. */
#define AIPS_RD_PACRC_SP1(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP1_MASK) >> AIPS_PACRC_SP1_SHIFT)
#define AIPS_BRD_PACRC_SP1(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP1_SHIFT, AIPS_PACRC_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRC_SP1(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP1_MASK, AIPS_PACRC_SP1(value)))
#define AIPS_BWR_PACRC_SP1(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP1_SHIFT), AIPS_PACRC_SP1_SHIFT, AIPS_PACRC_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_TP0 field. */
#define AIPS_RD_PACRC_TP0(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_TP0_MASK) >> AIPS_PACRC_TP0_SHIFT)
#define AIPS_BRD_PACRC_TP0(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_TP0_SHIFT, AIPS_PACRC_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRC_TP0(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_TP0_MASK, AIPS_PACRC_TP0(value)))
#define AIPS_BWR_PACRC_TP0(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_TP0_SHIFT), AIPS_PACRC_TP0_SHIFT, AIPS_PACRC_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_WP0 field. */
#define AIPS_RD_PACRC_WP0(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_WP0_MASK) >> AIPS_PACRC_WP0_SHIFT)
#define AIPS_BRD_PACRC_WP0(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_WP0_SHIFT, AIPS_PACRC_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRC_WP0(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_WP0_MASK, AIPS_PACRC_WP0(value)))
#define AIPS_BWR_PACRC_WP0(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_WP0_SHIFT), AIPS_PACRC_WP0_SHIFT, AIPS_PACRC_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRC, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRC_SP0 field. */
#define AIPS_RD_PACRC_SP0(base) ((AIPS_PACRC_REG(base) & AIPS_PACRC_SP0_MASK) >> AIPS_PACRC_SP0_SHIFT)
#define AIPS_BRD_PACRC_SP0(base) (BME_UBFX32(&AIPS_PACRC_REG(base), AIPS_PACRC_SP0_SHIFT, AIPS_PACRC_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRC_SP0(base, value) (AIPS_RMW_PACRC(base, AIPS_PACRC_SP0_MASK, AIPS_PACRC_SP0(value)))
#define AIPS_BWR_PACRC_SP0(base, value) (BME_BFI32(&AIPS_PACRC_REG(base), ((uint32_t)(value) << AIPS_PACRC_SP0_SHIFT), AIPS_PACRC_SP0_SHIFT, AIPS_PACRC_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRD - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRD - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PACR register consists of eight 4-bit PACR fields. Each PACR field
 * defines the access levels for a particular peripheral. The mapping between a
 * peripheral and its PACR field is shown in the table below. The peripheral assignment
 * to each PACR is defined by the memory map slot that the peripheral is
 * assigned to. See this chip's memory map for the assignment of a particular
 * peripheral. The following table shows the location of each peripheral slot's PACR field
 * in the PACR registers. Offset Register [31:28] [27:24] [23:20] [19:16] [15:12]
 * [11:8] [7:4] [3:0] 0x20 PACRA PACR0 PACR1 PACR2 PACR3 PACR4 PACR5 PACR6 PACR7
 * 0x24 PACRB PACR8 PACR9 PACR10 PACR11 PACR12 PACR13 PACR14 PACR15 0x28 PACRC
 * PACR16 PACR17 PACR18 PACR19 PACR20 PACR21 PACR22 PACR23 0x2C PACRD PACR24
 * PACR25 PACR26 PACR27 PACR28 PACR29 PACR30 PACR31 0x30 Reserved 0x34 Reserved 0x38
 * Reserved 0x3C Reserved 0x40 PACRE PACR32 PACR33 PACR34 PACR35 PACR36 PACR37
 * PACR38 PACR39 0x44 PACRF PACR40 PACR41 PACR42 PACR43 PACR44 PACR45 PACR46 PACR47
 * 0x48 PACRG PACR48 PACR49 PACR50 PACR51 PACR52 PACR53 PACR54 PACR55 0x4C PACRH
 * PACR56 PACR57 PACR58 PACR59 PACR60 PACR61 PACR62 PACR63 0x50 PACRI PACR64
 * PACR65 PACR66 PACR67 PACR68 PACR69 PACR70 PACR71 0x54 PACRJ PACR72 PACR73 PACR74
 * PACR75 PACR76 PACR77 PACR78 PACR79 0x58 PACRK PACR80 PACR81 PACR82 PACR83
 * PACR84 PACR85 PACR86 PACR87 0x5C PACRL PACR88 PACR89 PACR90 PACR91 PACR92 PACR93
 * PACR94 PACR95 0x60 PACRM PACR96 PACR97 PACR98 PACR99 PACR100 PACR101 PACR102
 * PACR103 0x64 PACRN PACR104 PACR105 PACR106 PACR107 PACR108 PACR109 PACR110
 * PACR111 0x68 PACRO PACR112 PACR113 PACR114 PACR115 PACR116 PACR117 PACR118 PACR119
 * 0x6C PACRP PACR120 PACR121 PACR122 PACR123 PACR124 PACR125 PACR126 PACR127 The
 * register field descriptions for PACR A-D, which control peripheral slots 0-31,
 * are shown below. The following section, PACRPeripheral Access Control
 * Register , shows the register field descriptions for PACR E-P. All PACR registers are
 * identical. They are divided into two sections because they occupy two
 * non-contiguous address spaces.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRD register
 */
/*@{*/
#define AIPS_RD_PACRD(base)      (AIPS_PACRD_REG(base))
#define AIPS_WR_PACRD(base, value) (AIPS_PACRD_REG(base) = (value))
#define AIPS_RMW_PACRD(base, mask, value) (AIPS_WR_PACRD(base, (AIPS_RD_PACRD(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRD(base, value) (BME_OR32(&AIPS_PACRD_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRD(base, value) (BME_AND32(&AIPS_PACRD_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRD(base, value) (BME_XOR32(&AIPS_PACRD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRD bitfields
 */

/*!
 * @name Register AIPS_PACRD, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP7 field. */
#define AIPS_RD_PACRD_TP7(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP7_MASK) >> AIPS_PACRD_TP7_SHIFT)
#define AIPS_BRD_PACRD_TP7(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP7_SHIFT, AIPS_PACRD_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRD_TP7(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP7_MASK, AIPS_PACRD_TP7(value)))
#define AIPS_BWR_PACRD_TP7(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP7_SHIFT), AIPS_PACRD_TP7_SHIFT, AIPS_PACRD_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP7 field. */
#define AIPS_RD_PACRD_WP7(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP7_MASK) >> AIPS_PACRD_WP7_SHIFT)
#define AIPS_BRD_PACRD_WP7(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP7_SHIFT, AIPS_PACRD_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRD_WP7(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP7_MASK, AIPS_PACRD_WP7(value)))
#define AIPS_BWR_PACRD_WP7(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP7_SHIFT), AIPS_PACRD_WP7_SHIFT, AIPS_PACRD_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP7 field. */
#define AIPS_RD_PACRD_SP7(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP7_MASK) >> AIPS_PACRD_SP7_SHIFT)
#define AIPS_BRD_PACRD_SP7(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP7_SHIFT, AIPS_PACRD_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRD_SP7(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP7_MASK, AIPS_PACRD_SP7(value)))
#define AIPS_BWR_PACRD_SP7(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP7_SHIFT), AIPS_PACRD_SP7_SHIFT, AIPS_PACRD_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP6 field. */
#define AIPS_RD_PACRD_TP6(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP6_MASK) >> AIPS_PACRD_TP6_SHIFT)
#define AIPS_BRD_PACRD_TP6(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP6_SHIFT, AIPS_PACRD_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRD_TP6(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP6_MASK, AIPS_PACRD_TP6(value)))
#define AIPS_BWR_PACRD_TP6(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP6_SHIFT), AIPS_PACRD_TP6_SHIFT, AIPS_PACRD_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP6 field. */
#define AIPS_RD_PACRD_WP6(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP6_MASK) >> AIPS_PACRD_WP6_SHIFT)
#define AIPS_BRD_PACRD_WP6(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP6_SHIFT, AIPS_PACRD_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRD_WP6(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP6_MASK, AIPS_PACRD_WP6(value)))
#define AIPS_BWR_PACRD_WP6(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP6_SHIFT), AIPS_PACRD_WP6_SHIFT, AIPS_PACRD_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP6 field. */
#define AIPS_RD_PACRD_SP6(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP6_MASK) >> AIPS_PACRD_SP6_SHIFT)
#define AIPS_BRD_PACRD_SP6(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP6_SHIFT, AIPS_PACRD_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRD_SP6(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP6_MASK, AIPS_PACRD_SP6(value)))
#define AIPS_BWR_PACRD_SP6(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP6_SHIFT), AIPS_PACRD_SP6_SHIFT, AIPS_PACRD_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP5 field. */
#define AIPS_RD_PACRD_TP5(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP5_MASK) >> AIPS_PACRD_TP5_SHIFT)
#define AIPS_BRD_PACRD_TP5(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP5_SHIFT, AIPS_PACRD_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRD_TP5(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP5_MASK, AIPS_PACRD_TP5(value)))
#define AIPS_BWR_PACRD_TP5(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP5_SHIFT), AIPS_PACRD_TP5_SHIFT, AIPS_PACRD_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP5 field. */
#define AIPS_RD_PACRD_WP5(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP5_MASK) >> AIPS_PACRD_WP5_SHIFT)
#define AIPS_BRD_PACRD_WP5(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP5_SHIFT, AIPS_PACRD_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRD_WP5(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP5_MASK, AIPS_PACRD_WP5(value)))
#define AIPS_BWR_PACRD_WP5(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP5_SHIFT), AIPS_PACRD_WP5_SHIFT, AIPS_PACRD_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP5 field. */
#define AIPS_RD_PACRD_SP5(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP5_MASK) >> AIPS_PACRD_SP5_SHIFT)
#define AIPS_BRD_PACRD_SP5(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP5_SHIFT, AIPS_PACRD_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRD_SP5(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP5_MASK, AIPS_PACRD_SP5(value)))
#define AIPS_BWR_PACRD_SP5(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP5_SHIFT), AIPS_PACRD_SP5_SHIFT, AIPS_PACRD_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP4 field. */
#define AIPS_RD_PACRD_TP4(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP4_MASK) >> AIPS_PACRD_TP4_SHIFT)
#define AIPS_BRD_PACRD_TP4(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP4_SHIFT, AIPS_PACRD_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRD_TP4(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP4_MASK, AIPS_PACRD_TP4(value)))
#define AIPS_BWR_PACRD_TP4(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP4_SHIFT), AIPS_PACRD_TP4_SHIFT, AIPS_PACRD_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP4 field. */
#define AIPS_RD_PACRD_WP4(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP4_MASK) >> AIPS_PACRD_WP4_SHIFT)
#define AIPS_BRD_PACRD_WP4(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP4_SHIFT, AIPS_PACRD_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRD_WP4(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP4_MASK, AIPS_PACRD_WP4(value)))
#define AIPS_BWR_PACRD_WP4(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP4_SHIFT), AIPS_PACRD_WP4_SHIFT, AIPS_PACRD_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP4 field. */
#define AIPS_RD_PACRD_SP4(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP4_MASK) >> AIPS_PACRD_SP4_SHIFT)
#define AIPS_BRD_PACRD_SP4(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP4_SHIFT, AIPS_PACRD_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRD_SP4(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP4_MASK, AIPS_PACRD_SP4(value)))
#define AIPS_BWR_PACRD_SP4(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP4_SHIFT), AIPS_PACRD_SP4_SHIFT, AIPS_PACRD_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP3 field. */
#define AIPS_RD_PACRD_TP3(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP3_MASK) >> AIPS_PACRD_TP3_SHIFT)
#define AIPS_BRD_PACRD_TP3(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP3_SHIFT, AIPS_PACRD_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRD_TP3(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP3_MASK, AIPS_PACRD_TP3(value)))
#define AIPS_BWR_PACRD_TP3(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP3_SHIFT), AIPS_PACRD_TP3_SHIFT, AIPS_PACRD_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP3 field. */
#define AIPS_RD_PACRD_WP3(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP3_MASK) >> AIPS_PACRD_WP3_SHIFT)
#define AIPS_BRD_PACRD_WP3(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP3_SHIFT, AIPS_PACRD_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRD_WP3(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP3_MASK, AIPS_PACRD_WP3(value)))
#define AIPS_BWR_PACRD_WP3(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP3_SHIFT), AIPS_PACRD_WP3_SHIFT, AIPS_PACRD_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP3 field. */
#define AIPS_RD_PACRD_SP3(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP3_MASK) >> AIPS_PACRD_SP3_SHIFT)
#define AIPS_BRD_PACRD_SP3(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP3_SHIFT, AIPS_PACRD_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRD_SP3(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP3_MASK, AIPS_PACRD_SP3(value)))
#define AIPS_BWR_PACRD_SP3(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP3_SHIFT), AIPS_PACRD_SP3_SHIFT, AIPS_PACRD_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP2 field. */
#define AIPS_RD_PACRD_TP2(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP2_MASK) >> AIPS_PACRD_TP2_SHIFT)
#define AIPS_BRD_PACRD_TP2(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP2_SHIFT, AIPS_PACRD_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRD_TP2(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP2_MASK, AIPS_PACRD_TP2(value)))
#define AIPS_BWR_PACRD_TP2(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP2_SHIFT), AIPS_PACRD_TP2_SHIFT, AIPS_PACRD_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP2 field. */
#define AIPS_RD_PACRD_WP2(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP2_MASK) >> AIPS_PACRD_WP2_SHIFT)
#define AIPS_BRD_PACRD_WP2(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP2_SHIFT, AIPS_PACRD_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRD_WP2(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP2_MASK, AIPS_PACRD_WP2(value)))
#define AIPS_BWR_PACRD_WP2(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP2_SHIFT), AIPS_PACRD_WP2_SHIFT, AIPS_PACRD_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP2 field. */
#define AIPS_RD_PACRD_SP2(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP2_MASK) >> AIPS_PACRD_SP2_SHIFT)
#define AIPS_BRD_PACRD_SP2(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP2_SHIFT, AIPS_PACRD_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRD_SP2(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP2_MASK, AIPS_PACRD_SP2(value)))
#define AIPS_BWR_PACRD_SP2(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP2_SHIFT), AIPS_PACRD_SP2_SHIFT, AIPS_PACRD_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP1 field. */
#define AIPS_RD_PACRD_TP1(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP1_MASK) >> AIPS_PACRD_TP1_SHIFT)
#define AIPS_BRD_PACRD_TP1(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP1_SHIFT, AIPS_PACRD_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRD_TP1(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP1_MASK, AIPS_PACRD_TP1(value)))
#define AIPS_BWR_PACRD_TP1(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP1_SHIFT), AIPS_PACRD_TP1_SHIFT, AIPS_PACRD_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP1 field. */
#define AIPS_RD_PACRD_WP1(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP1_MASK) >> AIPS_PACRD_WP1_SHIFT)
#define AIPS_BRD_PACRD_WP1(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP1_SHIFT, AIPS_PACRD_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRD_WP1(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP1_MASK, AIPS_PACRD_WP1(value)))
#define AIPS_BWR_PACRD_WP1(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP1_SHIFT), AIPS_PACRD_WP1_SHIFT, AIPS_PACRD_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP1 field. */
#define AIPS_RD_PACRD_SP1(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP1_MASK) >> AIPS_PACRD_SP1_SHIFT)
#define AIPS_BRD_PACRD_SP1(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP1_SHIFT, AIPS_PACRD_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRD_SP1(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP1_MASK, AIPS_PACRD_SP1(value)))
#define AIPS_BWR_PACRD_SP1(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP1_SHIFT), AIPS_PACRD_SP1_SHIFT, AIPS_PACRD_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_TP0 field. */
#define AIPS_RD_PACRD_TP0(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_TP0_MASK) >> AIPS_PACRD_TP0_SHIFT)
#define AIPS_BRD_PACRD_TP0(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_TP0_SHIFT, AIPS_PACRD_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRD_TP0(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_TP0_MASK, AIPS_PACRD_TP0(value)))
#define AIPS_BWR_PACRD_TP0(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_TP0_SHIFT), AIPS_PACRD_TP0_SHIFT, AIPS_PACRD_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_WP0 field. */
#define AIPS_RD_PACRD_WP0(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_WP0_MASK) >> AIPS_PACRD_WP0_SHIFT)
#define AIPS_BRD_PACRD_WP0(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_WP0_SHIFT, AIPS_PACRD_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRD_WP0(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_WP0_MASK, AIPS_PACRD_WP0(value)))
#define AIPS_BWR_PACRD_WP0(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_WP0_SHIFT), AIPS_PACRD_WP0_SHIFT, AIPS_PACRD_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRD, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRD_SP0 field. */
#define AIPS_RD_PACRD_SP0(base) ((AIPS_PACRD_REG(base) & AIPS_PACRD_SP0_MASK) >> AIPS_PACRD_SP0_SHIFT)
#define AIPS_BRD_PACRD_SP0(base) (BME_UBFX32(&AIPS_PACRD_REG(base), AIPS_PACRD_SP0_SHIFT, AIPS_PACRD_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRD_SP0(base, value) (AIPS_RMW_PACRD(base, AIPS_PACRD_SP0_MASK, AIPS_PACRD_SP0(value)))
#define AIPS_BWR_PACRD_SP0(base, value) (BME_BFI32(&AIPS_PACRD_REG(base), ((uint32_t)(value) << AIPS_PACRD_SP0_SHIFT), AIPS_PACRD_SP0_SHIFT, AIPS_PACRD_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRE - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRE - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRE register
 */
/*@{*/
#define AIPS_RD_PACRE(base)      (AIPS_PACRE_REG(base))
#define AIPS_WR_PACRE(base, value) (AIPS_PACRE_REG(base) = (value))
#define AIPS_RMW_PACRE(base, mask, value) (AIPS_WR_PACRE(base, (AIPS_RD_PACRE(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRE(base, value) (BME_OR32(&AIPS_PACRE_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRE(base, value) (BME_AND32(&AIPS_PACRE_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRE(base, value) (BME_XOR32(&AIPS_PACRE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRE bitfields
 */

/*!
 * @name Register AIPS_PACRE, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP7 field. */
#define AIPS_RD_PACRE_TP7(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP7_MASK) >> AIPS_PACRE_TP7_SHIFT)
#define AIPS_BRD_PACRE_TP7(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP7_SHIFT, AIPS_PACRE_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRE_TP7(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP7_MASK, AIPS_PACRE_TP7(value)))
#define AIPS_BWR_PACRE_TP7(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP7_SHIFT), AIPS_PACRE_TP7_SHIFT, AIPS_PACRE_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP7 field. */
#define AIPS_RD_PACRE_WP7(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP7_MASK) >> AIPS_PACRE_WP7_SHIFT)
#define AIPS_BRD_PACRE_WP7(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP7_SHIFT, AIPS_PACRE_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRE_WP7(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP7_MASK, AIPS_PACRE_WP7(value)))
#define AIPS_BWR_PACRE_WP7(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP7_SHIFT), AIPS_PACRE_WP7_SHIFT, AIPS_PACRE_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP7 field. */
#define AIPS_RD_PACRE_SP7(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP7_MASK) >> AIPS_PACRE_SP7_SHIFT)
#define AIPS_BRD_PACRE_SP7(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP7_SHIFT, AIPS_PACRE_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRE_SP7(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP7_MASK, AIPS_PACRE_SP7(value)))
#define AIPS_BWR_PACRE_SP7(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP7_SHIFT), AIPS_PACRE_SP7_SHIFT, AIPS_PACRE_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP6 field. */
#define AIPS_RD_PACRE_TP6(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP6_MASK) >> AIPS_PACRE_TP6_SHIFT)
#define AIPS_BRD_PACRE_TP6(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP6_SHIFT, AIPS_PACRE_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRE_TP6(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP6_MASK, AIPS_PACRE_TP6(value)))
#define AIPS_BWR_PACRE_TP6(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP6_SHIFT), AIPS_PACRE_TP6_SHIFT, AIPS_PACRE_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP6 field. */
#define AIPS_RD_PACRE_WP6(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP6_MASK) >> AIPS_PACRE_WP6_SHIFT)
#define AIPS_BRD_PACRE_WP6(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP6_SHIFT, AIPS_PACRE_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRE_WP6(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP6_MASK, AIPS_PACRE_WP6(value)))
#define AIPS_BWR_PACRE_WP6(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP6_SHIFT), AIPS_PACRE_WP6_SHIFT, AIPS_PACRE_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP6 field. */
#define AIPS_RD_PACRE_SP6(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP6_MASK) >> AIPS_PACRE_SP6_SHIFT)
#define AIPS_BRD_PACRE_SP6(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP6_SHIFT, AIPS_PACRE_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRE_SP6(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP6_MASK, AIPS_PACRE_SP6(value)))
#define AIPS_BWR_PACRE_SP6(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP6_SHIFT), AIPS_PACRE_SP6_SHIFT, AIPS_PACRE_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP5 field. */
#define AIPS_RD_PACRE_TP5(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP5_MASK) >> AIPS_PACRE_TP5_SHIFT)
#define AIPS_BRD_PACRE_TP5(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP5_SHIFT, AIPS_PACRE_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRE_TP5(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP5_MASK, AIPS_PACRE_TP5(value)))
#define AIPS_BWR_PACRE_TP5(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP5_SHIFT), AIPS_PACRE_TP5_SHIFT, AIPS_PACRE_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP5 field. */
#define AIPS_RD_PACRE_WP5(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP5_MASK) >> AIPS_PACRE_WP5_SHIFT)
#define AIPS_BRD_PACRE_WP5(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP5_SHIFT, AIPS_PACRE_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRE_WP5(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP5_MASK, AIPS_PACRE_WP5(value)))
#define AIPS_BWR_PACRE_WP5(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP5_SHIFT), AIPS_PACRE_WP5_SHIFT, AIPS_PACRE_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP5 field. */
#define AIPS_RD_PACRE_SP5(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP5_MASK) >> AIPS_PACRE_SP5_SHIFT)
#define AIPS_BRD_PACRE_SP5(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP5_SHIFT, AIPS_PACRE_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRE_SP5(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP5_MASK, AIPS_PACRE_SP5(value)))
#define AIPS_BWR_PACRE_SP5(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP5_SHIFT), AIPS_PACRE_SP5_SHIFT, AIPS_PACRE_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP4 field. */
#define AIPS_RD_PACRE_TP4(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP4_MASK) >> AIPS_PACRE_TP4_SHIFT)
#define AIPS_BRD_PACRE_TP4(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP4_SHIFT, AIPS_PACRE_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRE_TP4(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP4_MASK, AIPS_PACRE_TP4(value)))
#define AIPS_BWR_PACRE_TP4(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP4_SHIFT), AIPS_PACRE_TP4_SHIFT, AIPS_PACRE_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP4 field. */
#define AIPS_RD_PACRE_WP4(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP4_MASK) >> AIPS_PACRE_WP4_SHIFT)
#define AIPS_BRD_PACRE_WP4(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP4_SHIFT, AIPS_PACRE_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRE_WP4(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP4_MASK, AIPS_PACRE_WP4(value)))
#define AIPS_BWR_PACRE_WP4(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP4_SHIFT), AIPS_PACRE_WP4_SHIFT, AIPS_PACRE_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP4 field. */
#define AIPS_RD_PACRE_SP4(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP4_MASK) >> AIPS_PACRE_SP4_SHIFT)
#define AIPS_BRD_PACRE_SP4(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP4_SHIFT, AIPS_PACRE_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRE_SP4(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP4_MASK, AIPS_PACRE_SP4(value)))
#define AIPS_BWR_PACRE_SP4(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP4_SHIFT), AIPS_PACRE_SP4_SHIFT, AIPS_PACRE_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP3 field. */
#define AIPS_RD_PACRE_TP3(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP3_MASK) >> AIPS_PACRE_TP3_SHIFT)
#define AIPS_BRD_PACRE_TP3(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP3_SHIFT, AIPS_PACRE_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRE_TP3(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP3_MASK, AIPS_PACRE_TP3(value)))
#define AIPS_BWR_PACRE_TP3(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP3_SHIFT), AIPS_PACRE_TP3_SHIFT, AIPS_PACRE_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP3 field. */
#define AIPS_RD_PACRE_WP3(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP3_MASK) >> AIPS_PACRE_WP3_SHIFT)
#define AIPS_BRD_PACRE_WP3(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP3_SHIFT, AIPS_PACRE_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRE_WP3(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP3_MASK, AIPS_PACRE_WP3(value)))
#define AIPS_BWR_PACRE_WP3(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP3_SHIFT), AIPS_PACRE_WP3_SHIFT, AIPS_PACRE_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP3 field. */
#define AIPS_RD_PACRE_SP3(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP3_MASK) >> AIPS_PACRE_SP3_SHIFT)
#define AIPS_BRD_PACRE_SP3(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP3_SHIFT, AIPS_PACRE_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRE_SP3(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP3_MASK, AIPS_PACRE_SP3(value)))
#define AIPS_BWR_PACRE_SP3(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP3_SHIFT), AIPS_PACRE_SP3_SHIFT, AIPS_PACRE_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP2 field. */
#define AIPS_RD_PACRE_TP2(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP2_MASK) >> AIPS_PACRE_TP2_SHIFT)
#define AIPS_BRD_PACRE_TP2(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP2_SHIFT, AIPS_PACRE_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRE_TP2(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP2_MASK, AIPS_PACRE_TP2(value)))
#define AIPS_BWR_PACRE_TP2(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP2_SHIFT), AIPS_PACRE_TP2_SHIFT, AIPS_PACRE_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP2 field. */
#define AIPS_RD_PACRE_WP2(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP2_MASK) >> AIPS_PACRE_WP2_SHIFT)
#define AIPS_BRD_PACRE_WP2(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP2_SHIFT, AIPS_PACRE_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRE_WP2(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP2_MASK, AIPS_PACRE_WP2(value)))
#define AIPS_BWR_PACRE_WP2(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP2_SHIFT), AIPS_PACRE_WP2_SHIFT, AIPS_PACRE_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP2 field. */
#define AIPS_RD_PACRE_SP2(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP2_MASK) >> AIPS_PACRE_SP2_SHIFT)
#define AIPS_BRD_PACRE_SP2(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP2_SHIFT, AIPS_PACRE_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRE_SP2(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP2_MASK, AIPS_PACRE_SP2(value)))
#define AIPS_BWR_PACRE_SP2(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP2_SHIFT), AIPS_PACRE_SP2_SHIFT, AIPS_PACRE_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP1 field. */
#define AIPS_RD_PACRE_TP1(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP1_MASK) >> AIPS_PACRE_TP1_SHIFT)
#define AIPS_BRD_PACRE_TP1(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP1_SHIFT, AIPS_PACRE_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRE_TP1(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP1_MASK, AIPS_PACRE_TP1(value)))
#define AIPS_BWR_PACRE_TP1(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP1_SHIFT), AIPS_PACRE_TP1_SHIFT, AIPS_PACRE_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP1 field. */
#define AIPS_RD_PACRE_WP1(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP1_MASK) >> AIPS_PACRE_WP1_SHIFT)
#define AIPS_BRD_PACRE_WP1(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP1_SHIFT, AIPS_PACRE_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRE_WP1(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP1_MASK, AIPS_PACRE_WP1(value)))
#define AIPS_BWR_PACRE_WP1(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP1_SHIFT), AIPS_PACRE_WP1_SHIFT, AIPS_PACRE_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP1 field. */
#define AIPS_RD_PACRE_SP1(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP1_MASK) >> AIPS_PACRE_SP1_SHIFT)
#define AIPS_BRD_PACRE_SP1(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP1_SHIFT, AIPS_PACRE_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRE_SP1(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP1_MASK, AIPS_PACRE_SP1(value)))
#define AIPS_BWR_PACRE_SP1(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP1_SHIFT), AIPS_PACRE_SP1_SHIFT, AIPS_PACRE_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_TP0 field. */
#define AIPS_RD_PACRE_TP0(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_TP0_MASK) >> AIPS_PACRE_TP0_SHIFT)
#define AIPS_BRD_PACRE_TP0(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_TP0_SHIFT, AIPS_PACRE_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRE_TP0(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_TP0_MASK, AIPS_PACRE_TP0(value)))
#define AIPS_BWR_PACRE_TP0(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_TP0_SHIFT), AIPS_PACRE_TP0_SHIFT, AIPS_PACRE_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_WP0 field. */
#define AIPS_RD_PACRE_WP0(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_WP0_MASK) >> AIPS_PACRE_WP0_SHIFT)
#define AIPS_BRD_PACRE_WP0(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_WP0_SHIFT, AIPS_PACRE_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRE_WP0(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_WP0_MASK, AIPS_PACRE_WP0(value)))
#define AIPS_BWR_PACRE_WP0(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_WP0_SHIFT), AIPS_PACRE_WP0_SHIFT, AIPS_PACRE_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRE, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRE_SP0 field. */
#define AIPS_RD_PACRE_SP0(base) ((AIPS_PACRE_REG(base) & AIPS_PACRE_SP0_MASK) >> AIPS_PACRE_SP0_SHIFT)
#define AIPS_BRD_PACRE_SP0(base) (BME_UBFX32(&AIPS_PACRE_REG(base), AIPS_PACRE_SP0_SHIFT, AIPS_PACRE_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRE_SP0(base, value) (AIPS_RMW_PACRE(base, AIPS_PACRE_SP0_MASK, AIPS_PACRE_SP0(value)))
#define AIPS_BWR_PACRE_SP0(base, value) (BME_BFI32(&AIPS_PACRE_REG(base), ((uint32_t)(value) << AIPS_PACRE_SP0_SHIFT), AIPS_PACRE_SP0_SHIFT, AIPS_PACRE_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRF - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRF - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRF register
 */
/*@{*/
#define AIPS_RD_PACRF(base)      (AIPS_PACRF_REG(base))
#define AIPS_WR_PACRF(base, value) (AIPS_PACRF_REG(base) = (value))
#define AIPS_RMW_PACRF(base, mask, value) (AIPS_WR_PACRF(base, (AIPS_RD_PACRF(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRF(base, value) (BME_OR32(&AIPS_PACRF_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRF(base, value) (BME_AND32(&AIPS_PACRF_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRF(base, value) (BME_XOR32(&AIPS_PACRF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRF bitfields
 */

/*!
 * @name Register AIPS_PACRF, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP7 field. */
#define AIPS_RD_PACRF_TP7(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP7_MASK) >> AIPS_PACRF_TP7_SHIFT)
#define AIPS_BRD_PACRF_TP7(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP7_SHIFT, AIPS_PACRF_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRF_TP7(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP7_MASK, AIPS_PACRF_TP7(value)))
#define AIPS_BWR_PACRF_TP7(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP7_SHIFT), AIPS_PACRF_TP7_SHIFT, AIPS_PACRF_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP7 field. */
#define AIPS_RD_PACRF_WP7(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP7_MASK) >> AIPS_PACRF_WP7_SHIFT)
#define AIPS_BRD_PACRF_WP7(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP7_SHIFT, AIPS_PACRF_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRF_WP7(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP7_MASK, AIPS_PACRF_WP7(value)))
#define AIPS_BWR_PACRF_WP7(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP7_SHIFT), AIPS_PACRF_WP7_SHIFT, AIPS_PACRF_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP7 field. */
#define AIPS_RD_PACRF_SP7(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP7_MASK) >> AIPS_PACRF_SP7_SHIFT)
#define AIPS_BRD_PACRF_SP7(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP7_SHIFT, AIPS_PACRF_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRF_SP7(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP7_MASK, AIPS_PACRF_SP7(value)))
#define AIPS_BWR_PACRF_SP7(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP7_SHIFT), AIPS_PACRF_SP7_SHIFT, AIPS_PACRF_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP6 field. */
#define AIPS_RD_PACRF_TP6(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP6_MASK) >> AIPS_PACRF_TP6_SHIFT)
#define AIPS_BRD_PACRF_TP6(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP6_SHIFT, AIPS_PACRF_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRF_TP6(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP6_MASK, AIPS_PACRF_TP6(value)))
#define AIPS_BWR_PACRF_TP6(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP6_SHIFT), AIPS_PACRF_TP6_SHIFT, AIPS_PACRF_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP6 field. */
#define AIPS_RD_PACRF_WP6(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP6_MASK) >> AIPS_PACRF_WP6_SHIFT)
#define AIPS_BRD_PACRF_WP6(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP6_SHIFT, AIPS_PACRF_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRF_WP6(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP6_MASK, AIPS_PACRF_WP6(value)))
#define AIPS_BWR_PACRF_WP6(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP6_SHIFT), AIPS_PACRF_WP6_SHIFT, AIPS_PACRF_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP6 field. */
#define AIPS_RD_PACRF_SP6(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP6_MASK) >> AIPS_PACRF_SP6_SHIFT)
#define AIPS_BRD_PACRF_SP6(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP6_SHIFT, AIPS_PACRF_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRF_SP6(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP6_MASK, AIPS_PACRF_SP6(value)))
#define AIPS_BWR_PACRF_SP6(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP6_SHIFT), AIPS_PACRF_SP6_SHIFT, AIPS_PACRF_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP5 field. */
#define AIPS_RD_PACRF_TP5(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP5_MASK) >> AIPS_PACRF_TP5_SHIFT)
#define AIPS_BRD_PACRF_TP5(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP5_SHIFT, AIPS_PACRF_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRF_TP5(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP5_MASK, AIPS_PACRF_TP5(value)))
#define AIPS_BWR_PACRF_TP5(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP5_SHIFT), AIPS_PACRF_TP5_SHIFT, AIPS_PACRF_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP5 field. */
#define AIPS_RD_PACRF_WP5(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP5_MASK) >> AIPS_PACRF_WP5_SHIFT)
#define AIPS_BRD_PACRF_WP5(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP5_SHIFT, AIPS_PACRF_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRF_WP5(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP5_MASK, AIPS_PACRF_WP5(value)))
#define AIPS_BWR_PACRF_WP5(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP5_SHIFT), AIPS_PACRF_WP5_SHIFT, AIPS_PACRF_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP5 field. */
#define AIPS_RD_PACRF_SP5(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP5_MASK) >> AIPS_PACRF_SP5_SHIFT)
#define AIPS_BRD_PACRF_SP5(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP5_SHIFT, AIPS_PACRF_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRF_SP5(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP5_MASK, AIPS_PACRF_SP5(value)))
#define AIPS_BWR_PACRF_SP5(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP5_SHIFT), AIPS_PACRF_SP5_SHIFT, AIPS_PACRF_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP4 field. */
#define AIPS_RD_PACRF_TP4(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP4_MASK) >> AIPS_PACRF_TP4_SHIFT)
#define AIPS_BRD_PACRF_TP4(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP4_SHIFT, AIPS_PACRF_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRF_TP4(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP4_MASK, AIPS_PACRF_TP4(value)))
#define AIPS_BWR_PACRF_TP4(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP4_SHIFT), AIPS_PACRF_TP4_SHIFT, AIPS_PACRF_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP4 field. */
#define AIPS_RD_PACRF_WP4(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP4_MASK) >> AIPS_PACRF_WP4_SHIFT)
#define AIPS_BRD_PACRF_WP4(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP4_SHIFT, AIPS_PACRF_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRF_WP4(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP4_MASK, AIPS_PACRF_WP4(value)))
#define AIPS_BWR_PACRF_WP4(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP4_SHIFT), AIPS_PACRF_WP4_SHIFT, AIPS_PACRF_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP4 field. */
#define AIPS_RD_PACRF_SP4(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP4_MASK) >> AIPS_PACRF_SP4_SHIFT)
#define AIPS_BRD_PACRF_SP4(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP4_SHIFT, AIPS_PACRF_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRF_SP4(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP4_MASK, AIPS_PACRF_SP4(value)))
#define AIPS_BWR_PACRF_SP4(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP4_SHIFT), AIPS_PACRF_SP4_SHIFT, AIPS_PACRF_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP3 field. */
#define AIPS_RD_PACRF_TP3(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP3_MASK) >> AIPS_PACRF_TP3_SHIFT)
#define AIPS_BRD_PACRF_TP3(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP3_SHIFT, AIPS_PACRF_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRF_TP3(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP3_MASK, AIPS_PACRF_TP3(value)))
#define AIPS_BWR_PACRF_TP3(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP3_SHIFT), AIPS_PACRF_TP3_SHIFT, AIPS_PACRF_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP3 field. */
#define AIPS_RD_PACRF_WP3(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP3_MASK) >> AIPS_PACRF_WP3_SHIFT)
#define AIPS_BRD_PACRF_WP3(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP3_SHIFT, AIPS_PACRF_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRF_WP3(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP3_MASK, AIPS_PACRF_WP3(value)))
#define AIPS_BWR_PACRF_WP3(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP3_SHIFT), AIPS_PACRF_WP3_SHIFT, AIPS_PACRF_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP3 field. */
#define AIPS_RD_PACRF_SP3(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP3_MASK) >> AIPS_PACRF_SP3_SHIFT)
#define AIPS_BRD_PACRF_SP3(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP3_SHIFT, AIPS_PACRF_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRF_SP3(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP3_MASK, AIPS_PACRF_SP3(value)))
#define AIPS_BWR_PACRF_SP3(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP3_SHIFT), AIPS_PACRF_SP3_SHIFT, AIPS_PACRF_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP2 field. */
#define AIPS_RD_PACRF_TP2(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP2_MASK) >> AIPS_PACRF_TP2_SHIFT)
#define AIPS_BRD_PACRF_TP2(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP2_SHIFT, AIPS_PACRF_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRF_TP2(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP2_MASK, AIPS_PACRF_TP2(value)))
#define AIPS_BWR_PACRF_TP2(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP2_SHIFT), AIPS_PACRF_TP2_SHIFT, AIPS_PACRF_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP2 field. */
#define AIPS_RD_PACRF_WP2(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP2_MASK) >> AIPS_PACRF_WP2_SHIFT)
#define AIPS_BRD_PACRF_WP2(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP2_SHIFT, AIPS_PACRF_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRF_WP2(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP2_MASK, AIPS_PACRF_WP2(value)))
#define AIPS_BWR_PACRF_WP2(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP2_SHIFT), AIPS_PACRF_WP2_SHIFT, AIPS_PACRF_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP2 field. */
#define AIPS_RD_PACRF_SP2(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP2_MASK) >> AIPS_PACRF_SP2_SHIFT)
#define AIPS_BRD_PACRF_SP2(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP2_SHIFT, AIPS_PACRF_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRF_SP2(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP2_MASK, AIPS_PACRF_SP2(value)))
#define AIPS_BWR_PACRF_SP2(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP2_SHIFT), AIPS_PACRF_SP2_SHIFT, AIPS_PACRF_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP1 field. */
#define AIPS_RD_PACRF_TP1(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP1_MASK) >> AIPS_PACRF_TP1_SHIFT)
#define AIPS_BRD_PACRF_TP1(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP1_SHIFT, AIPS_PACRF_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRF_TP1(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP1_MASK, AIPS_PACRF_TP1(value)))
#define AIPS_BWR_PACRF_TP1(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP1_SHIFT), AIPS_PACRF_TP1_SHIFT, AIPS_PACRF_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP1 field. */
#define AIPS_RD_PACRF_WP1(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP1_MASK) >> AIPS_PACRF_WP1_SHIFT)
#define AIPS_BRD_PACRF_WP1(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP1_SHIFT, AIPS_PACRF_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRF_WP1(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP1_MASK, AIPS_PACRF_WP1(value)))
#define AIPS_BWR_PACRF_WP1(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP1_SHIFT), AIPS_PACRF_WP1_SHIFT, AIPS_PACRF_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP1 field. */
#define AIPS_RD_PACRF_SP1(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP1_MASK) >> AIPS_PACRF_SP1_SHIFT)
#define AIPS_BRD_PACRF_SP1(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP1_SHIFT, AIPS_PACRF_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRF_SP1(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP1_MASK, AIPS_PACRF_SP1(value)))
#define AIPS_BWR_PACRF_SP1(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP1_SHIFT), AIPS_PACRF_SP1_SHIFT, AIPS_PACRF_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_TP0 field. */
#define AIPS_RD_PACRF_TP0(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_TP0_MASK) >> AIPS_PACRF_TP0_SHIFT)
#define AIPS_BRD_PACRF_TP0(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_TP0_SHIFT, AIPS_PACRF_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRF_TP0(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_TP0_MASK, AIPS_PACRF_TP0(value)))
#define AIPS_BWR_PACRF_TP0(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_TP0_SHIFT), AIPS_PACRF_TP0_SHIFT, AIPS_PACRF_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_WP0 field. */
#define AIPS_RD_PACRF_WP0(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_WP0_MASK) >> AIPS_PACRF_WP0_SHIFT)
#define AIPS_BRD_PACRF_WP0(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_WP0_SHIFT, AIPS_PACRF_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRF_WP0(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_WP0_MASK, AIPS_PACRF_WP0(value)))
#define AIPS_BWR_PACRF_WP0(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_WP0_SHIFT), AIPS_PACRF_WP0_SHIFT, AIPS_PACRF_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRF, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRF_SP0 field. */
#define AIPS_RD_PACRF_SP0(base) ((AIPS_PACRF_REG(base) & AIPS_PACRF_SP0_MASK) >> AIPS_PACRF_SP0_SHIFT)
#define AIPS_BRD_PACRF_SP0(base) (BME_UBFX32(&AIPS_PACRF_REG(base), AIPS_PACRF_SP0_SHIFT, AIPS_PACRF_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRF_SP0(base, value) (AIPS_RMW_PACRF(base, AIPS_PACRF_SP0_MASK, AIPS_PACRF_SP0(value)))
#define AIPS_BWR_PACRF_SP0(base, value) (BME_BFI32(&AIPS_PACRF_REG(base), ((uint32_t)(value) << AIPS_PACRF_SP0_SHIFT), AIPS_PACRF_SP0_SHIFT, AIPS_PACRF_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRG - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRG - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRG register
 */
/*@{*/
#define AIPS_RD_PACRG(base)      (AIPS_PACRG_REG(base))
#define AIPS_WR_PACRG(base, value) (AIPS_PACRG_REG(base) = (value))
#define AIPS_RMW_PACRG(base, mask, value) (AIPS_WR_PACRG(base, (AIPS_RD_PACRG(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRG(base, value) (BME_OR32(&AIPS_PACRG_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRG(base, value) (BME_AND32(&AIPS_PACRG_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRG(base, value) (BME_XOR32(&AIPS_PACRG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRG bitfields
 */

/*!
 * @name Register AIPS_PACRG, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP7 field. */
#define AIPS_RD_PACRG_TP7(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP7_MASK) >> AIPS_PACRG_TP7_SHIFT)
#define AIPS_BRD_PACRG_TP7(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP7_SHIFT, AIPS_PACRG_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRG_TP7(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP7_MASK, AIPS_PACRG_TP7(value)))
#define AIPS_BWR_PACRG_TP7(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP7_SHIFT), AIPS_PACRG_TP7_SHIFT, AIPS_PACRG_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP7 field. */
#define AIPS_RD_PACRG_WP7(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP7_MASK) >> AIPS_PACRG_WP7_SHIFT)
#define AIPS_BRD_PACRG_WP7(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP7_SHIFT, AIPS_PACRG_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRG_WP7(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP7_MASK, AIPS_PACRG_WP7(value)))
#define AIPS_BWR_PACRG_WP7(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP7_SHIFT), AIPS_PACRG_WP7_SHIFT, AIPS_PACRG_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP7 field. */
#define AIPS_RD_PACRG_SP7(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP7_MASK) >> AIPS_PACRG_SP7_SHIFT)
#define AIPS_BRD_PACRG_SP7(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP7_SHIFT, AIPS_PACRG_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRG_SP7(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP7_MASK, AIPS_PACRG_SP7(value)))
#define AIPS_BWR_PACRG_SP7(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP7_SHIFT), AIPS_PACRG_SP7_SHIFT, AIPS_PACRG_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP6 field. */
#define AIPS_RD_PACRG_TP6(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP6_MASK) >> AIPS_PACRG_TP6_SHIFT)
#define AIPS_BRD_PACRG_TP6(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP6_SHIFT, AIPS_PACRG_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRG_TP6(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP6_MASK, AIPS_PACRG_TP6(value)))
#define AIPS_BWR_PACRG_TP6(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP6_SHIFT), AIPS_PACRG_TP6_SHIFT, AIPS_PACRG_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP6 field. */
#define AIPS_RD_PACRG_WP6(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP6_MASK) >> AIPS_PACRG_WP6_SHIFT)
#define AIPS_BRD_PACRG_WP6(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP6_SHIFT, AIPS_PACRG_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRG_WP6(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP6_MASK, AIPS_PACRG_WP6(value)))
#define AIPS_BWR_PACRG_WP6(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP6_SHIFT), AIPS_PACRG_WP6_SHIFT, AIPS_PACRG_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP6 field. */
#define AIPS_RD_PACRG_SP6(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP6_MASK) >> AIPS_PACRG_SP6_SHIFT)
#define AIPS_BRD_PACRG_SP6(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP6_SHIFT, AIPS_PACRG_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRG_SP6(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP6_MASK, AIPS_PACRG_SP6(value)))
#define AIPS_BWR_PACRG_SP6(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP6_SHIFT), AIPS_PACRG_SP6_SHIFT, AIPS_PACRG_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP5 field. */
#define AIPS_RD_PACRG_TP5(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP5_MASK) >> AIPS_PACRG_TP5_SHIFT)
#define AIPS_BRD_PACRG_TP5(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP5_SHIFT, AIPS_PACRG_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRG_TP5(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP5_MASK, AIPS_PACRG_TP5(value)))
#define AIPS_BWR_PACRG_TP5(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP5_SHIFT), AIPS_PACRG_TP5_SHIFT, AIPS_PACRG_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP5 field. */
#define AIPS_RD_PACRG_WP5(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP5_MASK) >> AIPS_PACRG_WP5_SHIFT)
#define AIPS_BRD_PACRG_WP5(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP5_SHIFT, AIPS_PACRG_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRG_WP5(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP5_MASK, AIPS_PACRG_WP5(value)))
#define AIPS_BWR_PACRG_WP5(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP5_SHIFT), AIPS_PACRG_WP5_SHIFT, AIPS_PACRG_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP5 field. */
#define AIPS_RD_PACRG_SP5(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP5_MASK) >> AIPS_PACRG_SP5_SHIFT)
#define AIPS_BRD_PACRG_SP5(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP5_SHIFT, AIPS_PACRG_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRG_SP5(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP5_MASK, AIPS_PACRG_SP5(value)))
#define AIPS_BWR_PACRG_SP5(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP5_SHIFT), AIPS_PACRG_SP5_SHIFT, AIPS_PACRG_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP4 field. */
#define AIPS_RD_PACRG_TP4(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP4_MASK) >> AIPS_PACRG_TP4_SHIFT)
#define AIPS_BRD_PACRG_TP4(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP4_SHIFT, AIPS_PACRG_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRG_TP4(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP4_MASK, AIPS_PACRG_TP4(value)))
#define AIPS_BWR_PACRG_TP4(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP4_SHIFT), AIPS_PACRG_TP4_SHIFT, AIPS_PACRG_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP4 field. */
#define AIPS_RD_PACRG_WP4(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP4_MASK) >> AIPS_PACRG_WP4_SHIFT)
#define AIPS_BRD_PACRG_WP4(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP4_SHIFT, AIPS_PACRG_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRG_WP4(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP4_MASK, AIPS_PACRG_WP4(value)))
#define AIPS_BWR_PACRG_WP4(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP4_SHIFT), AIPS_PACRG_WP4_SHIFT, AIPS_PACRG_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP4 field. */
#define AIPS_RD_PACRG_SP4(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP4_MASK) >> AIPS_PACRG_SP4_SHIFT)
#define AIPS_BRD_PACRG_SP4(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP4_SHIFT, AIPS_PACRG_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRG_SP4(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP4_MASK, AIPS_PACRG_SP4(value)))
#define AIPS_BWR_PACRG_SP4(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP4_SHIFT), AIPS_PACRG_SP4_SHIFT, AIPS_PACRG_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP3 field. */
#define AIPS_RD_PACRG_TP3(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP3_MASK) >> AIPS_PACRG_TP3_SHIFT)
#define AIPS_BRD_PACRG_TP3(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP3_SHIFT, AIPS_PACRG_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRG_TP3(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP3_MASK, AIPS_PACRG_TP3(value)))
#define AIPS_BWR_PACRG_TP3(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP3_SHIFT), AIPS_PACRG_TP3_SHIFT, AIPS_PACRG_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP3 field. */
#define AIPS_RD_PACRG_WP3(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP3_MASK) >> AIPS_PACRG_WP3_SHIFT)
#define AIPS_BRD_PACRG_WP3(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP3_SHIFT, AIPS_PACRG_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRG_WP3(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP3_MASK, AIPS_PACRG_WP3(value)))
#define AIPS_BWR_PACRG_WP3(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP3_SHIFT), AIPS_PACRG_WP3_SHIFT, AIPS_PACRG_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP3 field. */
#define AIPS_RD_PACRG_SP3(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP3_MASK) >> AIPS_PACRG_SP3_SHIFT)
#define AIPS_BRD_PACRG_SP3(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP3_SHIFT, AIPS_PACRG_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRG_SP3(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP3_MASK, AIPS_PACRG_SP3(value)))
#define AIPS_BWR_PACRG_SP3(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP3_SHIFT), AIPS_PACRG_SP3_SHIFT, AIPS_PACRG_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP2 field. */
#define AIPS_RD_PACRG_TP2(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP2_MASK) >> AIPS_PACRG_TP2_SHIFT)
#define AIPS_BRD_PACRG_TP2(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP2_SHIFT, AIPS_PACRG_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRG_TP2(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP2_MASK, AIPS_PACRG_TP2(value)))
#define AIPS_BWR_PACRG_TP2(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP2_SHIFT), AIPS_PACRG_TP2_SHIFT, AIPS_PACRG_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP2 field. */
#define AIPS_RD_PACRG_WP2(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP2_MASK) >> AIPS_PACRG_WP2_SHIFT)
#define AIPS_BRD_PACRG_WP2(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP2_SHIFT, AIPS_PACRG_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRG_WP2(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP2_MASK, AIPS_PACRG_WP2(value)))
#define AIPS_BWR_PACRG_WP2(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP2_SHIFT), AIPS_PACRG_WP2_SHIFT, AIPS_PACRG_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP2 field. */
#define AIPS_RD_PACRG_SP2(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP2_MASK) >> AIPS_PACRG_SP2_SHIFT)
#define AIPS_BRD_PACRG_SP2(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP2_SHIFT, AIPS_PACRG_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRG_SP2(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP2_MASK, AIPS_PACRG_SP2(value)))
#define AIPS_BWR_PACRG_SP2(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP2_SHIFT), AIPS_PACRG_SP2_SHIFT, AIPS_PACRG_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP1 field. */
#define AIPS_RD_PACRG_TP1(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP1_MASK) >> AIPS_PACRG_TP1_SHIFT)
#define AIPS_BRD_PACRG_TP1(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP1_SHIFT, AIPS_PACRG_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRG_TP1(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP1_MASK, AIPS_PACRG_TP1(value)))
#define AIPS_BWR_PACRG_TP1(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP1_SHIFT), AIPS_PACRG_TP1_SHIFT, AIPS_PACRG_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP1 field. */
#define AIPS_RD_PACRG_WP1(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP1_MASK) >> AIPS_PACRG_WP1_SHIFT)
#define AIPS_BRD_PACRG_WP1(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP1_SHIFT, AIPS_PACRG_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRG_WP1(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP1_MASK, AIPS_PACRG_WP1(value)))
#define AIPS_BWR_PACRG_WP1(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP1_SHIFT), AIPS_PACRG_WP1_SHIFT, AIPS_PACRG_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP1 field. */
#define AIPS_RD_PACRG_SP1(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP1_MASK) >> AIPS_PACRG_SP1_SHIFT)
#define AIPS_BRD_PACRG_SP1(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP1_SHIFT, AIPS_PACRG_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRG_SP1(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP1_MASK, AIPS_PACRG_SP1(value)))
#define AIPS_BWR_PACRG_SP1(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP1_SHIFT), AIPS_PACRG_SP1_SHIFT, AIPS_PACRG_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_TP0 field. */
#define AIPS_RD_PACRG_TP0(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_TP0_MASK) >> AIPS_PACRG_TP0_SHIFT)
#define AIPS_BRD_PACRG_TP0(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_TP0_SHIFT, AIPS_PACRG_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRG_TP0(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_TP0_MASK, AIPS_PACRG_TP0(value)))
#define AIPS_BWR_PACRG_TP0(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_TP0_SHIFT), AIPS_PACRG_TP0_SHIFT, AIPS_PACRG_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_WP0 field. */
#define AIPS_RD_PACRG_WP0(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_WP0_MASK) >> AIPS_PACRG_WP0_SHIFT)
#define AIPS_BRD_PACRG_WP0(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_WP0_SHIFT, AIPS_PACRG_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRG_WP0(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_WP0_MASK, AIPS_PACRG_WP0(value)))
#define AIPS_BWR_PACRG_WP0(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_WP0_SHIFT), AIPS_PACRG_WP0_SHIFT, AIPS_PACRG_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRG, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRG_SP0 field. */
#define AIPS_RD_PACRG_SP0(base) ((AIPS_PACRG_REG(base) & AIPS_PACRG_SP0_MASK) >> AIPS_PACRG_SP0_SHIFT)
#define AIPS_BRD_PACRG_SP0(base) (BME_UBFX32(&AIPS_PACRG_REG(base), AIPS_PACRG_SP0_SHIFT, AIPS_PACRG_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRG_SP0(base, value) (AIPS_RMW_PACRG(base, AIPS_PACRG_SP0_MASK, AIPS_PACRG_SP0(value)))
#define AIPS_BWR_PACRG_SP0(base, value) (BME_BFI32(&AIPS_PACRG_REG(base), ((uint32_t)(value) << AIPS_PACRG_SP0_SHIFT), AIPS_PACRG_SP0_SHIFT, AIPS_PACRG_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRH - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRH - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRH register
 */
/*@{*/
#define AIPS_RD_PACRH(base)      (AIPS_PACRH_REG(base))
#define AIPS_WR_PACRH(base, value) (AIPS_PACRH_REG(base) = (value))
#define AIPS_RMW_PACRH(base, mask, value) (AIPS_WR_PACRH(base, (AIPS_RD_PACRH(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRH(base, value) (BME_OR32(&AIPS_PACRH_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRH(base, value) (BME_AND32(&AIPS_PACRH_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRH(base, value) (BME_XOR32(&AIPS_PACRH_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRH bitfields
 */

/*!
 * @name Register AIPS_PACRH, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP7 field. */
#define AIPS_RD_PACRH_TP7(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP7_MASK) >> AIPS_PACRH_TP7_SHIFT)
#define AIPS_BRD_PACRH_TP7(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP7_SHIFT, AIPS_PACRH_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRH_TP7(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP7_MASK, AIPS_PACRH_TP7(value)))
#define AIPS_BWR_PACRH_TP7(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP7_SHIFT), AIPS_PACRH_TP7_SHIFT, AIPS_PACRH_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP7 field. */
#define AIPS_RD_PACRH_WP7(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP7_MASK) >> AIPS_PACRH_WP7_SHIFT)
#define AIPS_BRD_PACRH_WP7(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP7_SHIFT, AIPS_PACRH_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRH_WP7(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP7_MASK, AIPS_PACRH_WP7(value)))
#define AIPS_BWR_PACRH_WP7(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP7_SHIFT), AIPS_PACRH_WP7_SHIFT, AIPS_PACRH_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP7 field. */
#define AIPS_RD_PACRH_SP7(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP7_MASK) >> AIPS_PACRH_SP7_SHIFT)
#define AIPS_BRD_PACRH_SP7(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP7_SHIFT, AIPS_PACRH_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRH_SP7(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP7_MASK, AIPS_PACRH_SP7(value)))
#define AIPS_BWR_PACRH_SP7(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP7_SHIFT), AIPS_PACRH_SP7_SHIFT, AIPS_PACRH_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP6 field. */
#define AIPS_RD_PACRH_TP6(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP6_MASK) >> AIPS_PACRH_TP6_SHIFT)
#define AIPS_BRD_PACRH_TP6(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP6_SHIFT, AIPS_PACRH_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRH_TP6(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP6_MASK, AIPS_PACRH_TP6(value)))
#define AIPS_BWR_PACRH_TP6(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP6_SHIFT), AIPS_PACRH_TP6_SHIFT, AIPS_PACRH_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP6 field. */
#define AIPS_RD_PACRH_WP6(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP6_MASK) >> AIPS_PACRH_WP6_SHIFT)
#define AIPS_BRD_PACRH_WP6(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP6_SHIFT, AIPS_PACRH_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRH_WP6(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP6_MASK, AIPS_PACRH_WP6(value)))
#define AIPS_BWR_PACRH_WP6(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP6_SHIFT), AIPS_PACRH_WP6_SHIFT, AIPS_PACRH_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP6 field. */
#define AIPS_RD_PACRH_SP6(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP6_MASK) >> AIPS_PACRH_SP6_SHIFT)
#define AIPS_BRD_PACRH_SP6(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP6_SHIFT, AIPS_PACRH_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRH_SP6(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP6_MASK, AIPS_PACRH_SP6(value)))
#define AIPS_BWR_PACRH_SP6(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP6_SHIFT), AIPS_PACRH_SP6_SHIFT, AIPS_PACRH_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP5 field. */
#define AIPS_RD_PACRH_TP5(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP5_MASK) >> AIPS_PACRH_TP5_SHIFT)
#define AIPS_BRD_PACRH_TP5(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP5_SHIFT, AIPS_PACRH_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRH_TP5(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP5_MASK, AIPS_PACRH_TP5(value)))
#define AIPS_BWR_PACRH_TP5(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP5_SHIFT), AIPS_PACRH_TP5_SHIFT, AIPS_PACRH_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP5 field. */
#define AIPS_RD_PACRH_WP5(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP5_MASK) >> AIPS_PACRH_WP5_SHIFT)
#define AIPS_BRD_PACRH_WP5(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP5_SHIFT, AIPS_PACRH_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRH_WP5(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP5_MASK, AIPS_PACRH_WP5(value)))
#define AIPS_BWR_PACRH_WP5(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP5_SHIFT), AIPS_PACRH_WP5_SHIFT, AIPS_PACRH_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP5 field. */
#define AIPS_RD_PACRH_SP5(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP5_MASK) >> AIPS_PACRH_SP5_SHIFT)
#define AIPS_BRD_PACRH_SP5(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP5_SHIFT, AIPS_PACRH_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRH_SP5(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP5_MASK, AIPS_PACRH_SP5(value)))
#define AIPS_BWR_PACRH_SP5(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP5_SHIFT), AIPS_PACRH_SP5_SHIFT, AIPS_PACRH_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP4 field. */
#define AIPS_RD_PACRH_TP4(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP4_MASK) >> AIPS_PACRH_TP4_SHIFT)
#define AIPS_BRD_PACRH_TP4(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP4_SHIFT, AIPS_PACRH_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRH_TP4(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP4_MASK, AIPS_PACRH_TP4(value)))
#define AIPS_BWR_PACRH_TP4(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP4_SHIFT), AIPS_PACRH_TP4_SHIFT, AIPS_PACRH_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP4 field. */
#define AIPS_RD_PACRH_WP4(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP4_MASK) >> AIPS_PACRH_WP4_SHIFT)
#define AIPS_BRD_PACRH_WP4(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP4_SHIFT, AIPS_PACRH_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRH_WP4(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP4_MASK, AIPS_PACRH_WP4(value)))
#define AIPS_BWR_PACRH_WP4(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP4_SHIFT), AIPS_PACRH_WP4_SHIFT, AIPS_PACRH_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP4 field. */
#define AIPS_RD_PACRH_SP4(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP4_MASK) >> AIPS_PACRH_SP4_SHIFT)
#define AIPS_BRD_PACRH_SP4(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP4_SHIFT, AIPS_PACRH_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRH_SP4(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP4_MASK, AIPS_PACRH_SP4(value)))
#define AIPS_BWR_PACRH_SP4(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP4_SHIFT), AIPS_PACRH_SP4_SHIFT, AIPS_PACRH_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP3 field. */
#define AIPS_RD_PACRH_TP3(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP3_MASK) >> AIPS_PACRH_TP3_SHIFT)
#define AIPS_BRD_PACRH_TP3(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP3_SHIFT, AIPS_PACRH_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRH_TP3(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP3_MASK, AIPS_PACRH_TP3(value)))
#define AIPS_BWR_PACRH_TP3(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP3_SHIFT), AIPS_PACRH_TP3_SHIFT, AIPS_PACRH_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP3 field. */
#define AIPS_RD_PACRH_WP3(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP3_MASK) >> AIPS_PACRH_WP3_SHIFT)
#define AIPS_BRD_PACRH_WP3(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP3_SHIFT, AIPS_PACRH_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRH_WP3(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP3_MASK, AIPS_PACRH_WP3(value)))
#define AIPS_BWR_PACRH_WP3(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP3_SHIFT), AIPS_PACRH_WP3_SHIFT, AIPS_PACRH_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP3 field. */
#define AIPS_RD_PACRH_SP3(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP3_MASK) >> AIPS_PACRH_SP3_SHIFT)
#define AIPS_BRD_PACRH_SP3(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP3_SHIFT, AIPS_PACRH_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRH_SP3(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP3_MASK, AIPS_PACRH_SP3(value)))
#define AIPS_BWR_PACRH_SP3(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP3_SHIFT), AIPS_PACRH_SP3_SHIFT, AIPS_PACRH_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP2 field. */
#define AIPS_RD_PACRH_TP2(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP2_MASK) >> AIPS_PACRH_TP2_SHIFT)
#define AIPS_BRD_PACRH_TP2(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP2_SHIFT, AIPS_PACRH_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRH_TP2(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP2_MASK, AIPS_PACRH_TP2(value)))
#define AIPS_BWR_PACRH_TP2(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP2_SHIFT), AIPS_PACRH_TP2_SHIFT, AIPS_PACRH_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP2 field. */
#define AIPS_RD_PACRH_WP2(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP2_MASK) >> AIPS_PACRH_WP2_SHIFT)
#define AIPS_BRD_PACRH_WP2(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP2_SHIFT, AIPS_PACRH_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRH_WP2(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP2_MASK, AIPS_PACRH_WP2(value)))
#define AIPS_BWR_PACRH_WP2(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP2_SHIFT), AIPS_PACRH_WP2_SHIFT, AIPS_PACRH_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP2 field. */
#define AIPS_RD_PACRH_SP2(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP2_MASK) >> AIPS_PACRH_SP2_SHIFT)
#define AIPS_BRD_PACRH_SP2(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP2_SHIFT, AIPS_PACRH_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRH_SP2(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP2_MASK, AIPS_PACRH_SP2(value)))
#define AIPS_BWR_PACRH_SP2(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP2_SHIFT), AIPS_PACRH_SP2_SHIFT, AIPS_PACRH_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP1 field. */
#define AIPS_RD_PACRH_TP1(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP1_MASK) >> AIPS_PACRH_TP1_SHIFT)
#define AIPS_BRD_PACRH_TP1(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP1_SHIFT, AIPS_PACRH_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRH_TP1(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP1_MASK, AIPS_PACRH_TP1(value)))
#define AIPS_BWR_PACRH_TP1(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP1_SHIFT), AIPS_PACRH_TP1_SHIFT, AIPS_PACRH_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP1 field. */
#define AIPS_RD_PACRH_WP1(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP1_MASK) >> AIPS_PACRH_WP1_SHIFT)
#define AIPS_BRD_PACRH_WP1(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP1_SHIFT, AIPS_PACRH_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRH_WP1(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP1_MASK, AIPS_PACRH_WP1(value)))
#define AIPS_BWR_PACRH_WP1(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP1_SHIFT), AIPS_PACRH_WP1_SHIFT, AIPS_PACRH_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP1 field. */
#define AIPS_RD_PACRH_SP1(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP1_MASK) >> AIPS_PACRH_SP1_SHIFT)
#define AIPS_BRD_PACRH_SP1(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP1_SHIFT, AIPS_PACRH_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRH_SP1(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP1_MASK, AIPS_PACRH_SP1(value)))
#define AIPS_BWR_PACRH_SP1(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP1_SHIFT), AIPS_PACRH_SP1_SHIFT, AIPS_PACRH_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_TP0 field. */
#define AIPS_RD_PACRH_TP0(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_TP0_MASK) >> AIPS_PACRH_TP0_SHIFT)
#define AIPS_BRD_PACRH_TP0(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_TP0_SHIFT, AIPS_PACRH_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRH_TP0(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_TP0_MASK, AIPS_PACRH_TP0(value)))
#define AIPS_BWR_PACRH_TP0(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_TP0_SHIFT), AIPS_PACRH_TP0_SHIFT, AIPS_PACRH_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_WP0 field. */
#define AIPS_RD_PACRH_WP0(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_WP0_MASK) >> AIPS_PACRH_WP0_SHIFT)
#define AIPS_BRD_PACRH_WP0(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_WP0_SHIFT, AIPS_PACRH_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRH_WP0(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_WP0_MASK, AIPS_PACRH_WP0(value)))
#define AIPS_BWR_PACRH_WP0(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_WP0_SHIFT), AIPS_PACRH_WP0_SHIFT, AIPS_PACRH_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRH, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRH_SP0 field. */
#define AIPS_RD_PACRH_SP0(base) ((AIPS_PACRH_REG(base) & AIPS_PACRH_SP0_MASK) >> AIPS_PACRH_SP0_SHIFT)
#define AIPS_BRD_PACRH_SP0(base) (BME_UBFX32(&AIPS_PACRH_REG(base), AIPS_PACRH_SP0_SHIFT, AIPS_PACRH_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRH_SP0(base, value) (AIPS_RMW_PACRH(base, AIPS_PACRH_SP0_MASK, AIPS_PACRH_SP0(value)))
#define AIPS_BWR_PACRH_SP0(base, value) (BME_BFI32(&AIPS_PACRH_REG(base), ((uint32_t)(value) << AIPS_PACRH_SP0_SHIFT), AIPS_PACRH_SP0_SHIFT, AIPS_PACRH_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRI - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRI - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRI register
 */
/*@{*/
#define AIPS_RD_PACRI(base)      (AIPS_PACRI_REG(base))
#define AIPS_WR_PACRI(base, value) (AIPS_PACRI_REG(base) = (value))
#define AIPS_RMW_PACRI(base, mask, value) (AIPS_WR_PACRI(base, (AIPS_RD_PACRI(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRI(base, value) (BME_OR32(&AIPS_PACRI_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRI(base, value) (BME_AND32(&AIPS_PACRI_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRI(base, value) (BME_XOR32(&AIPS_PACRI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRI bitfields
 */

/*!
 * @name Register AIPS_PACRI, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP7 field. */
#define AIPS_RD_PACRI_TP7(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP7_MASK) >> AIPS_PACRI_TP7_SHIFT)
#define AIPS_BRD_PACRI_TP7(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP7_SHIFT, AIPS_PACRI_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRI_TP7(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP7_MASK, AIPS_PACRI_TP7(value)))
#define AIPS_BWR_PACRI_TP7(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP7_SHIFT), AIPS_PACRI_TP7_SHIFT, AIPS_PACRI_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP7 field. */
#define AIPS_RD_PACRI_WP7(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP7_MASK) >> AIPS_PACRI_WP7_SHIFT)
#define AIPS_BRD_PACRI_WP7(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP7_SHIFT, AIPS_PACRI_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRI_WP7(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP7_MASK, AIPS_PACRI_WP7(value)))
#define AIPS_BWR_PACRI_WP7(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP7_SHIFT), AIPS_PACRI_WP7_SHIFT, AIPS_PACRI_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP7 field. */
#define AIPS_RD_PACRI_SP7(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP7_MASK) >> AIPS_PACRI_SP7_SHIFT)
#define AIPS_BRD_PACRI_SP7(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP7_SHIFT, AIPS_PACRI_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRI_SP7(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP7_MASK, AIPS_PACRI_SP7(value)))
#define AIPS_BWR_PACRI_SP7(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP7_SHIFT), AIPS_PACRI_SP7_SHIFT, AIPS_PACRI_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP6 field. */
#define AIPS_RD_PACRI_TP6(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP6_MASK) >> AIPS_PACRI_TP6_SHIFT)
#define AIPS_BRD_PACRI_TP6(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP6_SHIFT, AIPS_PACRI_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRI_TP6(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP6_MASK, AIPS_PACRI_TP6(value)))
#define AIPS_BWR_PACRI_TP6(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP6_SHIFT), AIPS_PACRI_TP6_SHIFT, AIPS_PACRI_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP6 field. */
#define AIPS_RD_PACRI_WP6(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP6_MASK) >> AIPS_PACRI_WP6_SHIFT)
#define AIPS_BRD_PACRI_WP6(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP6_SHIFT, AIPS_PACRI_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRI_WP6(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP6_MASK, AIPS_PACRI_WP6(value)))
#define AIPS_BWR_PACRI_WP6(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP6_SHIFT), AIPS_PACRI_WP6_SHIFT, AIPS_PACRI_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP6 field. */
#define AIPS_RD_PACRI_SP6(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP6_MASK) >> AIPS_PACRI_SP6_SHIFT)
#define AIPS_BRD_PACRI_SP6(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP6_SHIFT, AIPS_PACRI_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRI_SP6(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP6_MASK, AIPS_PACRI_SP6(value)))
#define AIPS_BWR_PACRI_SP6(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP6_SHIFT), AIPS_PACRI_SP6_SHIFT, AIPS_PACRI_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP5 field. */
#define AIPS_RD_PACRI_TP5(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP5_MASK) >> AIPS_PACRI_TP5_SHIFT)
#define AIPS_BRD_PACRI_TP5(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP5_SHIFT, AIPS_PACRI_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRI_TP5(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP5_MASK, AIPS_PACRI_TP5(value)))
#define AIPS_BWR_PACRI_TP5(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP5_SHIFT), AIPS_PACRI_TP5_SHIFT, AIPS_PACRI_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP5 field. */
#define AIPS_RD_PACRI_WP5(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP5_MASK) >> AIPS_PACRI_WP5_SHIFT)
#define AIPS_BRD_PACRI_WP5(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP5_SHIFT, AIPS_PACRI_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRI_WP5(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP5_MASK, AIPS_PACRI_WP5(value)))
#define AIPS_BWR_PACRI_WP5(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP5_SHIFT), AIPS_PACRI_WP5_SHIFT, AIPS_PACRI_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP5 field. */
#define AIPS_RD_PACRI_SP5(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP5_MASK) >> AIPS_PACRI_SP5_SHIFT)
#define AIPS_BRD_PACRI_SP5(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP5_SHIFT, AIPS_PACRI_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRI_SP5(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP5_MASK, AIPS_PACRI_SP5(value)))
#define AIPS_BWR_PACRI_SP5(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP5_SHIFT), AIPS_PACRI_SP5_SHIFT, AIPS_PACRI_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP4 field. */
#define AIPS_RD_PACRI_TP4(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP4_MASK) >> AIPS_PACRI_TP4_SHIFT)
#define AIPS_BRD_PACRI_TP4(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP4_SHIFT, AIPS_PACRI_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRI_TP4(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP4_MASK, AIPS_PACRI_TP4(value)))
#define AIPS_BWR_PACRI_TP4(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP4_SHIFT), AIPS_PACRI_TP4_SHIFT, AIPS_PACRI_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP4 field. */
#define AIPS_RD_PACRI_WP4(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP4_MASK) >> AIPS_PACRI_WP4_SHIFT)
#define AIPS_BRD_PACRI_WP4(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP4_SHIFT, AIPS_PACRI_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRI_WP4(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP4_MASK, AIPS_PACRI_WP4(value)))
#define AIPS_BWR_PACRI_WP4(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP4_SHIFT), AIPS_PACRI_WP4_SHIFT, AIPS_PACRI_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP4 field. */
#define AIPS_RD_PACRI_SP4(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP4_MASK) >> AIPS_PACRI_SP4_SHIFT)
#define AIPS_BRD_PACRI_SP4(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP4_SHIFT, AIPS_PACRI_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRI_SP4(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP4_MASK, AIPS_PACRI_SP4(value)))
#define AIPS_BWR_PACRI_SP4(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP4_SHIFT), AIPS_PACRI_SP4_SHIFT, AIPS_PACRI_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP3 field. */
#define AIPS_RD_PACRI_TP3(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP3_MASK) >> AIPS_PACRI_TP3_SHIFT)
#define AIPS_BRD_PACRI_TP3(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP3_SHIFT, AIPS_PACRI_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRI_TP3(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP3_MASK, AIPS_PACRI_TP3(value)))
#define AIPS_BWR_PACRI_TP3(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP3_SHIFT), AIPS_PACRI_TP3_SHIFT, AIPS_PACRI_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP3 field. */
#define AIPS_RD_PACRI_WP3(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP3_MASK) >> AIPS_PACRI_WP3_SHIFT)
#define AIPS_BRD_PACRI_WP3(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP3_SHIFT, AIPS_PACRI_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRI_WP3(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP3_MASK, AIPS_PACRI_WP3(value)))
#define AIPS_BWR_PACRI_WP3(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP3_SHIFT), AIPS_PACRI_WP3_SHIFT, AIPS_PACRI_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP3 field. */
#define AIPS_RD_PACRI_SP3(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP3_MASK) >> AIPS_PACRI_SP3_SHIFT)
#define AIPS_BRD_PACRI_SP3(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP3_SHIFT, AIPS_PACRI_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRI_SP3(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP3_MASK, AIPS_PACRI_SP3(value)))
#define AIPS_BWR_PACRI_SP3(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP3_SHIFT), AIPS_PACRI_SP3_SHIFT, AIPS_PACRI_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP2 field. */
#define AIPS_RD_PACRI_TP2(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP2_MASK) >> AIPS_PACRI_TP2_SHIFT)
#define AIPS_BRD_PACRI_TP2(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP2_SHIFT, AIPS_PACRI_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRI_TP2(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP2_MASK, AIPS_PACRI_TP2(value)))
#define AIPS_BWR_PACRI_TP2(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP2_SHIFT), AIPS_PACRI_TP2_SHIFT, AIPS_PACRI_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP2 field. */
#define AIPS_RD_PACRI_WP2(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP2_MASK) >> AIPS_PACRI_WP2_SHIFT)
#define AIPS_BRD_PACRI_WP2(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP2_SHIFT, AIPS_PACRI_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRI_WP2(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP2_MASK, AIPS_PACRI_WP2(value)))
#define AIPS_BWR_PACRI_WP2(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP2_SHIFT), AIPS_PACRI_WP2_SHIFT, AIPS_PACRI_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP2 field. */
#define AIPS_RD_PACRI_SP2(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP2_MASK) >> AIPS_PACRI_SP2_SHIFT)
#define AIPS_BRD_PACRI_SP2(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP2_SHIFT, AIPS_PACRI_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRI_SP2(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP2_MASK, AIPS_PACRI_SP2(value)))
#define AIPS_BWR_PACRI_SP2(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP2_SHIFT), AIPS_PACRI_SP2_SHIFT, AIPS_PACRI_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP1 field. */
#define AIPS_RD_PACRI_TP1(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP1_MASK) >> AIPS_PACRI_TP1_SHIFT)
#define AIPS_BRD_PACRI_TP1(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP1_SHIFT, AIPS_PACRI_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRI_TP1(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP1_MASK, AIPS_PACRI_TP1(value)))
#define AIPS_BWR_PACRI_TP1(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP1_SHIFT), AIPS_PACRI_TP1_SHIFT, AIPS_PACRI_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP1 field. */
#define AIPS_RD_PACRI_WP1(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP1_MASK) >> AIPS_PACRI_WP1_SHIFT)
#define AIPS_BRD_PACRI_WP1(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP1_SHIFT, AIPS_PACRI_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRI_WP1(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP1_MASK, AIPS_PACRI_WP1(value)))
#define AIPS_BWR_PACRI_WP1(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP1_SHIFT), AIPS_PACRI_WP1_SHIFT, AIPS_PACRI_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP1 field. */
#define AIPS_RD_PACRI_SP1(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP1_MASK) >> AIPS_PACRI_SP1_SHIFT)
#define AIPS_BRD_PACRI_SP1(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP1_SHIFT, AIPS_PACRI_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRI_SP1(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP1_MASK, AIPS_PACRI_SP1(value)))
#define AIPS_BWR_PACRI_SP1(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP1_SHIFT), AIPS_PACRI_SP1_SHIFT, AIPS_PACRI_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_TP0 field. */
#define AIPS_RD_PACRI_TP0(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_TP0_MASK) >> AIPS_PACRI_TP0_SHIFT)
#define AIPS_BRD_PACRI_TP0(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_TP0_SHIFT, AIPS_PACRI_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRI_TP0(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_TP0_MASK, AIPS_PACRI_TP0(value)))
#define AIPS_BWR_PACRI_TP0(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_TP0_SHIFT), AIPS_PACRI_TP0_SHIFT, AIPS_PACRI_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_WP0 field. */
#define AIPS_RD_PACRI_WP0(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_WP0_MASK) >> AIPS_PACRI_WP0_SHIFT)
#define AIPS_BRD_PACRI_WP0(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_WP0_SHIFT, AIPS_PACRI_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRI_WP0(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_WP0_MASK, AIPS_PACRI_WP0(value)))
#define AIPS_BWR_PACRI_WP0(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_WP0_SHIFT), AIPS_PACRI_WP0_SHIFT, AIPS_PACRI_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRI, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRI_SP0 field. */
#define AIPS_RD_PACRI_SP0(base) ((AIPS_PACRI_REG(base) & AIPS_PACRI_SP0_MASK) >> AIPS_PACRI_SP0_SHIFT)
#define AIPS_BRD_PACRI_SP0(base) (BME_UBFX32(&AIPS_PACRI_REG(base), AIPS_PACRI_SP0_SHIFT, AIPS_PACRI_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRI_SP0(base, value) (AIPS_RMW_PACRI(base, AIPS_PACRI_SP0_MASK, AIPS_PACRI_SP0(value)))
#define AIPS_BWR_PACRI_SP0(base, value) (BME_BFI32(&AIPS_PACRI_REG(base), ((uint32_t)(value) << AIPS_PACRI_SP0_SHIFT), AIPS_PACRI_SP0_SHIFT, AIPS_PACRI_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRJ - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRJ - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRJ register
 */
/*@{*/
#define AIPS_RD_PACRJ(base)      (AIPS_PACRJ_REG(base))
#define AIPS_WR_PACRJ(base, value) (AIPS_PACRJ_REG(base) = (value))
#define AIPS_RMW_PACRJ(base, mask, value) (AIPS_WR_PACRJ(base, (AIPS_RD_PACRJ(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRJ(base, value) (BME_OR32(&AIPS_PACRJ_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRJ(base, value) (BME_AND32(&AIPS_PACRJ_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRJ(base, value) (BME_XOR32(&AIPS_PACRJ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRJ bitfields
 */

/*!
 * @name Register AIPS_PACRJ, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP7 field. */
#define AIPS_RD_PACRJ_TP7(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP7_MASK) >> AIPS_PACRJ_TP7_SHIFT)
#define AIPS_BRD_PACRJ_TP7(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP7_SHIFT, AIPS_PACRJ_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRJ_TP7(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP7_MASK, AIPS_PACRJ_TP7(value)))
#define AIPS_BWR_PACRJ_TP7(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP7_SHIFT), AIPS_PACRJ_TP7_SHIFT, AIPS_PACRJ_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP7 field. */
#define AIPS_RD_PACRJ_WP7(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP7_MASK) >> AIPS_PACRJ_WP7_SHIFT)
#define AIPS_BRD_PACRJ_WP7(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP7_SHIFT, AIPS_PACRJ_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRJ_WP7(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP7_MASK, AIPS_PACRJ_WP7(value)))
#define AIPS_BWR_PACRJ_WP7(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP7_SHIFT), AIPS_PACRJ_WP7_SHIFT, AIPS_PACRJ_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP7 field. */
#define AIPS_RD_PACRJ_SP7(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP7_MASK) >> AIPS_PACRJ_SP7_SHIFT)
#define AIPS_BRD_PACRJ_SP7(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP7_SHIFT, AIPS_PACRJ_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRJ_SP7(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP7_MASK, AIPS_PACRJ_SP7(value)))
#define AIPS_BWR_PACRJ_SP7(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP7_SHIFT), AIPS_PACRJ_SP7_SHIFT, AIPS_PACRJ_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP6 field. */
#define AIPS_RD_PACRJ_TP6(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP6_MASK) >> AIPS_PACRJ_TP6_SHIFT)
#define AIPS_BRD_PACRJ_TP6(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP6_SHIFT, AIPS_PACRJ_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRJ_TP6(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP6_MASK, AIPS_PACRJ_TP6(value)))
#define AIPS_BWR_PACRJ_TP6(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP6_SHIFT), AIPS_PACRJ_TP6_SHIFT, AIPS_PACRJ_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP6 field. */
#define AIPS_RD_PACRJ_WP6(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP6_MASK) >> AIPS_PACRJ_WP6_SHIFT)
#define AIPS_BRD_PACRJ_WP6(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP6_SHIFT, AIPS_PACRJ_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRJ_WP6(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP6_MASK, AIPS_PACRJ_WP6(value)))
#define AIPS_BWR_PACRJ_WP6(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP6_SHIFT), AIPS_PACRJ_WP6_SHIFT, AIPS_PACRJ_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP6 field. */
#define AIPS_RD_PACRJ_SP6(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP6_MASK) >> AIPS_PACRJ_SP6_SHIFT)
#define AIPS_BRD_PACRJ_SP6(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP6_SHIFT, AIPS_PACRJ_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRJ_SP6(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP6_MASK, AIPS_PACRJ_SP6(value)))
#define AIPS_BWR_PACRJ_SP6(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP6_SHIFT), AIPS_PACRJ_SP6_SHIFT, AIPS_PACRJ_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP5 field. */
#define AIPS_RD_PACRJ_TP5(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP5_MASK) >> AIPS_PACRJ_TP5_SHIFT)
#define AIPS_BRD_PACRJ_TP5(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP5_SHIFT, AIPS_PACRJ_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRJ_TP5(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP5_MASK, AIPS_PACRJ_TP5(value)))
#define AIPS_BWR_PACRJ_TP5(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP5_SHIFT), AIPS_PACRJ_TP5_SHIFT, AIPS_PACRJ_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP5 field. */
#define AIPS_RD_PACRJ_WP5(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP5_MASK) >> AIPS_PACRJ_WP5_SHIFT)
#define AIPS_BRD_PACRJ_WP5(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP5_SHIFT, AIPS_PACRJ_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRJ_WP5(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP5_MASK, AIPS_PACRJ_WP5(value)))
#define AIPS_BWR_PACRJ_WP5(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP5_SHIFT), AIPS_PACRJ_WP5_SHIFT, AIPS_PACRJ_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP5 field. */
#define AIPS_RD_PACRJ_SP5(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP5_MASK) >> AIPS_PACRJ_SP5_SHIFT)
#define AIPS_BRD_PACRJ_SP5(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP5_SHIFT, AIPS_PACRJ_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRJ_SP5(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP5_MASK, AIPS_PACRJ_SP5(value)))
#define AIPS_BWR_PACRJ_SP5(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP5_SHIFT), AIPS_PACRJ_SP5_SHIFT, AIPS_PACRJ_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP4 field. */
#define AIPS_RD_PACRJ_TP4(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP4_MASK) >> AIPS_PACRJ_TP4_SHIFT)
#define AIPS_BRD_PACRJ_TP4(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP4_SHIFT, AIPS_PACRJ_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRJ_TP4(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP4_MASK, AIPS_PACRJ_TP4(value)))
#define AIPS_BWR_PACRJ_TP4(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP4_SHIFT), AIPS_PACRJ_TP4_SHIFT, AIPS_PACRJ_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP4 field. */
#define AIPS_RD_PACRJ_WP4(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP4_MASK) >> AIPS_PACRJ_WP4_SHIFT)
#define AIPS_BRD_PACRJ_WP4(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP4_SHIFT, AIPS_PACRJ_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRJ_WP4(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP4_MASK, AIPS_PACRJ_WP4(value)))
#define AIPS_BWR_PACRJ_WP4(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP4_SHIFT), AIPS_PACRJ_WP4_SHIFT, AIPS_PACRJ_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP4 field. */
#define AIPS_RD_PACRJ_SP4(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP4_MASK) >> AIPS_PACRJ_SP4_SHIFT)
#define AIPS_BRD_PACRJ_SP4(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP4_SHIFT, AIPS_PACRJ_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRJ_SP4(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP4_MASK, AIPS_PACRJ_SP4(value)))
#define AIPS_BWR_PACRJ_SP4(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP4_SHIFT), AIPS_PACRJ_SP4_SHIFT, AIPS_PACRJ_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP3 field. */
#define AIPS_RD_PACRJ_TP3(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP3_MASK) >> AIPS_PACRJ_TP3_SHIFT)
#define AIPS_BRD_PACRJ_TP3(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP3_SHIFT, AIPS_PACRJ_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRJ_TP3(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP3_MASK, AIPS_PACRJ_TP3(value)))
#define AIPS_BWR_PACRJ_TP3(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP3_SHIFT), AIPS_PACRJ_TP3_SHIFT, AIPS_PACRJ_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP3 field. */
#define AIPS_RD_PACRJ_WP3(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP3_MASK) >> AIPS_PACRJ_WP3_SHIFT)
#define AIPS_BRD_PACRJ_WP3(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP3_SHIFT, AIPS_PACRJ_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRJ_WP3(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP3_MASK, AIPS_PACRJ_WP3(value)))
#define AIPS_BWR_PACRJ_WP3(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP3_SHIFT), AIPS_PACRJ_WP3_SHIFT, AIPS_PACRJ_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP3 field. */
#define AIPS_RD_PACRJ_SP3(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP3_MASK) >> AIPS_PACRJ_SP3_SHIFT)
#define AIPS_BRD_PACRJ_SP3(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP3_SHIFT, AIPS_PACRJ_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRJ_SP3(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP3_MASK, AIPS_PACRJ_SP3(value)))
#define AIPS_BWR_PACRJ_SP3(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP3_SHIFT), AIPS_PACRJ_SP3_SHIFT, AIPS_PACRJ_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP2 field. */
#define AIPS_RD_PACRJ_TP2(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP2_MASK) >> AIPS_PACRJ_TP2_SHIFT)
#define AIPS_BRD_PACRJ_TP2(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP2_SHIFT, AIPS_PACRJ_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRJ_TP2(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP2_MASK, AIPS_PACRJ_TP2(value)))
#define AIPS_BWR_PACRJ_TP2(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP2_SHIFT), AIPS_PACRJ_TP2_SHIFT, AIPS_PACRJ_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP2 field. */
#define AIPS_RD_PACRJ_WP2(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP2_MASK) >> AIPS_PACRJ_WP2_SHIFT)
#define AIPS_BRD_PACRJ_WP2(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP2_SHIFT, AIPS_PACRJ_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRJ_WP2(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP2_MASK, AIPS_PACRJ_WP2(value)))
#define AIPS_BWR_PACRJ_WP2(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP2_SHIFT), AIPS_PACRJ_WP2_SHIFT, AIPS_PACRJ_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP2 field. */
#define AIPS_RD_PACRJ_SP2(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP2_MASK) >> AIPS_PACRJ_SP2_SHIFT)
#define AIPS_BRD_PACRJ_SP2(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP2_SHIFT, AIPS_PACRJ_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRJ_SP2(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP2_MASK, AIPS_PACRJ_SP2(value)))
#define AIPS_BWR_PACRJ_SP2(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP2_SHIFT), AIPS_PACRJ_SP2_SHIFT, AIPS_PACRJ_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP1 field. */
#define AIPS_RD_PACRJ_TP1(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP1_MASK) >> AIPS_PACRJ_TP1_SHIFT)
#define AIPS_BRD_PACRJ_TP1(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP1_SHIFT, AIPS_PACRJ_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRJ_TP1(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP1_MASK, AIPS_PACRJ_TP1(value)))
#define AIPS_BWR_PACRJ_TP1(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP1_SHIFT), AIPS_PACRJ_TP1_SHIFT, AIPS_PACRJ_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP1 field. */
#define AIPS_RD_PACRJ_WP1(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP1_MASK) >> AIPS_PACRJ_WP1_SHIFT)
#define AIPS_BRD_PACRJ_WP1(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP1_SHIFT, AIPS_PACRJ_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRJ_WP1(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP1_MASK, AIPS_PACRJ_WP1(value)))
#define AIPS_BWR_PACRJ_WP1(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP1_SHIFT), AIPS_PACRJ_WP1_SHIFT, AIPS_PACRJ_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP1 field. */
#define AIPS_RD_PACRJ_SP1(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP1_MASK) >> AIPS_PACRJ_SP1_SHIFT)
#define AIPS_BRD_PACRJ_SP1(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP1_SHIFT, AIPS_PACRJ_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRJ_SP1(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP1_MASK, AIPS_PACRJ_SP1(value)))
#define AIPS_BWR_PACRJ_SP1(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP1_SHIFT), AIPS_PACRJ_SP1_SHIFT, AIPS_PACRJ_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_TP0 field. */
#define AIPS_RD_PACRJ_TP0(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_TP0_MASK) >> AIPS_PACRJ_TP0_SHIFT)
#define AIPS_BRD_PACRJ_TP0(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_TP0_SHIFT, AIPS_PACRJ_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRJ_TP0(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_TP0_MASK, AIPS_PACRJ_TP0(value)))
#define AIPS_BWR_PACRJ_TP0(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_TP0_SHIFT), AIPS_PACRJ_TP0_SHIFT, AIPS_PACRJ_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_WP0 field. */
#define AIPS_RD_PACRJ_WP0(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_WP0_MASK) >> AIPS_PACRJ_WP0_SHIFT)
#define AIPS_BRD_PACRJ_WP0(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_WP0_SHIFT, AIPS_PACRJ_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRJ_WP0(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_WP0_MASK, AIPS_PACRJ_WP0(value)))
#define AIPS_BWR_PACRJ_WP0(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_WP0_SHIFT), AIPS_PACRJ_WP0_SHIFT, AIPS_PACRJ_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRJ, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRJ_SP0 field. */
#define AIPS_RD_PACRJ_SP0(base) ((AIPS_PACRJ_REG(base) & AIPS_PACRJ_SP0_MASK) >> AIPS_PACRJ_SP0_SHIFT)
#define AIPS_BRD_PACRJ_SP0(base) (BME_UBFX32(&AIPS_PACRJ_REG(base), AIPS_PACRJ_SP0_SHIFT, AIPS_PACRJ_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRJ_SP0(base, value) (AIPS_RMW_PACRJ(base, AIPS_PACRJ_SP0_MASK, AIPS_PACRJ_SP0(value)))
#define AIPS_BWR_PACRJ_SP0(base, value) (BME_BFI32(&AIPS_PACRJ_REG(base), ((uint32_t)(value) << AIPS_PACRJ_SP0_SHIFT), AIPS_PACRJ_SP0_SHIFT, AIPS_PACRJ_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRK - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRK - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRK register
 */
/*@{*/
#define AIPS_RD_PACRK(base)      (AIPS_PACRK_REG(base))
#define AIPS_WR_PACRK(base, value) (AIPS_PACRK_REG(base) = (value))
#define AIPS_RMW_PACRK(base, mask, value) (AIPS_WR_PACRK(base, (AIPS_RD_PACRK(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRK(base, value) (BME_OR32(&AIPS_PACRK_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRK(base, value) (BME_AND32(&AIPS_PACRK_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRK(base, value) (BME_XOR32(&AIPS_PACRK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRK bitfields
 */

/*!
 * @name Register AIPS_PACRK, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP7 field. */
#define AIPS_RD_PACRK_TP7(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP7_MASK) >> AIPS_PACRK_TP7_SHIFT)
#define AIPS_BRD_PACRK_TP7(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP7_SHIFT, AIPS_PACRK_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRK_TP7(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP7_MASK, AIPS_PACRK_TP7(value)))
#define AIPS_BWR_PACRK_TP7(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP7_SHIFT), AIPS_PACRK_TP7_SHIFT, AIPS_PACRK_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP7 field. */
#define AIPS_RD_PACRK_WP7(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP7_MASK) >> AIPS_PACRK_WP7_SHIFT)
#define AIPS_BRD_PACRK_WP7(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP7_SHIFT, AIPS_PACRK_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRK_WP7(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP7_MASK, AIPS_PACRK_WP7(value)))
#define AIPS_BWR_PACRK_WP7(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP7_SHIFT), AIPS_PACRK_WP7_SHIFT, AIPS_PACRK_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP7 field. */
#define AIPS_RD_PACRK_SP7(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP7_MASK) >> AIPS_PACRK_SP7_SHIFT)
#define AIPS_BRD_PACRK_SP7(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP7_SHIFT, AIPS_PACRK_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRK_SP7(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP7_MASK, AIPS_PACRK_SP7(value)))
#define AIPS_BWR_PACRK_SP7(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP7_SHIFT), AIPS_PACRK_SP7_SHIFT, AIPS_PACRK_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP6 field. */
#define AIPS_RD_PACRK_TP6(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP6_MASK) >> AIPS_PACRK_TP6_SHIFT)
#define AIPS_BRD_PACRK_TP6(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP6_SHIFT, AIPS_PACRK_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRK_TP6(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP6_MASK, AIPS_PACRK_TP6(value)))
#define AIPS_BWR_PACRK_TP6(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP6_SHIFT), AIPS_PACRK_TP6_SHIFT, AIPS_PACRK_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP6 field. */
#define AIPS_RD_PACRK_WP6(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP6_MASK) >> AIPS_PACRK_WP6_SHIFT)
#define AIPS_BRD_PACRK_WP6(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP6_SHIFT, AIPS_PACRK_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRK_WP6(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP6_MASK, AIPS_PACRK_WP6(value)))
#define AIPS_BWR_PACRK_WP6(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP6_SHIFT), AIPS_PACRK_WP6_SHIFT, AIPS_PACRK_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP6 field. */
#define AIPS_RD_PACRK_SP6(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP6_MASK) >> AIPS_PACRK_SP6_SHIFT)
#define AIPS_BRD_PACRK_SP6(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP6_SHIFT, AIPS_PACRK_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRK_SP6(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP6_MASK, AIPS_PACRK_SP6(value)))
#define AIPS_BWR_PACRK_SP6(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP6_SHIFT), AIPS_PACRK_SP6_SHIFT, AIPS_PACRK_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP5 field. */
#define AIPS_RD_PACRK_TP5(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP5_MASK) >> AIPS_PACRK_TP5_SHIFT)
#define AIPS_BRD_PACRK_TP5(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP5_SHIFT, AIPS_PACRK_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRK_TP5(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP5_MASK, AIPS_PACRK_TP5(value)))
#define AIPS_BWR_PACRK_TP5(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP5_SHIFT), AIPS_PACRK_TP5_SHIFT, AIPS_PACRK_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP5 field. */
#define AIPS_RD_PACRK_WP5(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP5_MASK) >> AIPS_PACRK_WP5_SHIFT)
#define AIPS_BRD_PACRK_WP5(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP5_SHIFT, AIPS_PACRK_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRK_WP5(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP5_MASK, AIPS_PACRK_WP5(value)))
#define AIPS_BWR_PACRK_WP5(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP5_SHIFT), AIPS_PACRK_WP5_SHIFT, AIPS_PACRK_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP5 field. */
#define AIPS_RD_PACRK_SP5(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP5_MASK) >> AIPS_PACRK_SP5_SHIFT)
#define AIPS_BRD_PACRK_SP5(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP5_SHIFT, AIPS_PACRK_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRK_SP5(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP5_MASK, AIPS_PACRK_SP5(value)))
#define AIPS_BWR_PACRK_SP5(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP5_SHIFT), AIPS_PACRK_SP5_SHIFT, AIPS_PACRK_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP4 field. */
#define AIPS_RD_PACRK_TP4(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP4_MASK) >> AIPS_PACRK_TP4_SHIFT)
#define AIPS_BRD_PACRK_TP4(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP4_SHIFT, AIPS_PACRK_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRK_TP4(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP4_MASK, AIPS_PACRK_TP4(value)))
#define AIPS_BWR_PACRK_TP4(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP4_SHIFT), AIPS_PACRK_TP4_SHIFT, AIPS_PACRK_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP4 field. */
#define AIPS_RD_PACRK_WP4(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP4_MASK) >> AIPS_PACRK_WP4_SHIFT)
#define AIPS_BRD_PACRK_WP4(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP4_SHIFT, AIPS_PACRK_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRK_WP4(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP4_MASK, AIPS_PACRK_WP4(value)))
#define AIPS_BWR_PACRK_WP4(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP4_SHIFT), AIPS_PACRK_WP4_SHIFT, AIPS_PACRK_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP4 field. */
#define AIPS_RD_PACRK_SP4(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP4_MASK) >> AIPS_PACRK_SP4_SHIFT)
#define AIPS_BRD_PACRK_SP4(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP4_SHIFT, AIPS_PACRK_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRK_SP4(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP4_MASK, AIPS_PACRK_SP4(value)))
#define AIPS_BWR_PACRK_SP4(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP4_SHIFT), AIPS_PACRK_SP4_SHIFT, AIPS_PACRK_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP3 field. */
#define AIPS_RD_PACRK_TP3(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP3_MASK) >> AIPS_PACRK_TP3_SHIFT)
#define AIPS_BRD_PACRK_TP3(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP3_SHIFT, AIPS_PACRK_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRK_TP3(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP3_MASK, AIPS_PACRK_TP3(value)))
#define AIPS_BWR_PACRK_TP3(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP3_SHIFT), AIPS_PACRK_TP3_SHIFT, AIPS_PACRK_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP3 field. */
#define AIPS_RD_PACRK_WP3(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP3_MASK) >> AIPS_PACRK_WP3_SHIFT)
#define AIPS_BRD_PACRK_WP3(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP3_SHIFT, AIPS_PACRK_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRK_WP3(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP3_MASK, AIPS_PACRK_WP3(value)))
#define AIPS_BWR_PACRK_WP3(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP3_SHIFT), AIPS_PACRK_WP3_SHIFT, AIPS_PACRK_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP3 field. */
#define AIPS_RD_PACRK_SP3(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP3_MASK) >> AIPS_PACRK_SP3_SHIFT)
#define AIPS_BRD_PACRK_SP3(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP3_SHIFT, AIPS_PACRK_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRK_SP3(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP3_MASK, AIPS_PACRK_SP3(value)))
#define AIPS_BWR_PACRK_SP3(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP3_SHIFT), AIPS_PACRK_SP3_SHIFT, AIPS_PACRK_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP2 field. */
#define AIPS_RD_PACRK_TP2(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP2_MASK) >> AIPS_PACRK_TP2_SHIFT)
#define AIPS_BRD_PACRK_TP2(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP2_SHIFT, AIPS_PACRK_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRK_TP2(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP2_MASK, AIPS_PACRK_TP2(value)))
#define AIPS_BWR_PACRK_TP2(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP2_SHIFT), AIPS_PACRK_TP2_SHIFT, AIPS_PACRK_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP2 field. */
#define AIPS_RD_PACRK_WP2(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP2_MASK) >> AIPS_PACRK_WP2_SHIFT)
#define AIPS_BRD_PACRK_WP2(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP2_SHIFT, AIPS_PACRK_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRK_WP2(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP2_MASK, AIPS_PACRK_WP2(value)))
#define AIPS_BWR_PACRK_WP2(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP2_SHIFT), AIPS_PACRK_WP2_SHIFT, AIPS_PACRK_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP2 field. */
#define AIPS_RD_PACRK_SP2(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP2_MASK) >> AIPS_PACRK_SP2_SHIFT)
#define AIPS_BRD_PACRK_SP2(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP2_SHIFT, AIPS_PACRK_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRK_SP2(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP2_MASK, AIPS_PACRK_SP2(value)))
#define AIPS_BWR_PACRK_SP2(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP2_SHIFT), AIPS_PACRK_SP2_SHIFT, AIPS_PACRK_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP1 field. */
#define AIPS_RD_PACRK_TP1(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP1_MASK) >> AIPS_PACRK_TP1_SHIFT)
#define AIPS_BRD_PACRK_TP1(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP1_SHIFT, AIPS_PACRK_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRK_TP1(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP1_MASK, AIPS_PACRK_TP1(value)))
#define AIPS_BWR_PACRK_TP1(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP1_SHIFT), AIPS_PACRK_TP1_SHIFT, AIPS_PACRK_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP1 field. */
#define AIPS_RD_PACRK_WP1(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP1_MASK) >> AIPS_PACRK_WP1_SHIFT)
#define AIPS_BRD_PACRK_WP1(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP1_SHIFT, AIPS_PACRK_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRK_WP1(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP1_MASK, AIPS_PACRK_WP1(value)))
#define AIPS_BWR_PACRK_WP1(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP1_SHIFT), AIPS_PACRK_WP1_SHIFT, AIPS_PACRK_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP1 field. */
#define AIPS_RD_PACRK_SP1(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP1_MASK) >> AIPS_PACRK_SP1_SHIFT)
#define AIPS_BRD_PACRK_SP1(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP1_SHIFT, AIPS_PACRK_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRK_SP1(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP1_MASK, AIPS_PACRK_SP1(value)))
#define AIPS_BWR_PACRK_SP1(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP1_SHIFT), AIPS_PACRK_SP1_SHIFT, AIPS_PACRK_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_TP0 field. */
#define AIPS_RD_PACRK_TP0(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_TP0_MASK) >> AIPS_PACRK_TP0_SHIFT)
#define AIPS_BRD_PACRK_TP0(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_TP0_SHIFT, AIPS_PACRK_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRK_TP0(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_TP0_MASK, AIPS_PACRK_TP0(value)))
#define AIPS_BWR_PACRK_TP0(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_TP0_SHIFT), AIPS_PACRK_TP0_SHIFT, AIPS_PACRK_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_WP0 field. */
#define AIPS_RD_PACRK_WP0(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_WP0_MASK) >> AIPS_PACRK_WP0_SHIFT)
#define AIPS_BRD_PACRK_WP0(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_WP0_SHIFT, AIPS_PACRK_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRK_WP0(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_WP0_MASK, AIPS_PACRK_WP0(value)))
#define AIPS_BWR_PACRK_WP0(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_WP0_SHIFT), AIPS_PACRK_WP0_SHIFT, AIPS_PACRK_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRK, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRK_SP0 field. */
#define AIPS_RD_PACRK_SP0(base) ((AIPS_PACRK_REG(base) & AIPS_PACRK_SP0_MASK) >> AIPS_PACRK_SP0_SHIFT)
#define AIPS_BRD_PACRK_SP0(base) (BME_UBFX32(&AIPS_PACRK_REG(base), AIPS_PACRK_SP0_SHIFT, AIPS_PACRK_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRK_SP0(base, value) (AIPS_RMW_PACRK(base, AIPS_PACRK_SP0_MASK, AIPS_PACRK_SP0(value)))
#define AIPS_BWR_PACRK_SP0(base, value) (BME_BFI32(&AIPS_PACRK_REG(base), ((uint32_t)(value) << AIPS_PACRK_SP0_SHIFT), AIPS_PACRK_SP0_SHIFT, AIPS_PACRK_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRL - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRL - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRL register
 */
/*@{*/
#define AIPS_RD_PACRL(base)      (AIPS_PACRL_REG(base))
#define AIPS_WR_PACRL(base, value) (AIPS_PACRL_REG(base) = (value))
#define AIPS_RMW_PACRL(base, mask, value) (AIPS_WR_PACRL(base, (AIPS_RD_PACRL(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRL(base, value) (BME_OR32(&AIPS_PACRL_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRL(base, value) (BME_AND32(&AIPS_PACRL_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRL(base, value) (BME_XOR32(&AIPS_PACRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRL bitfields
 */

/*!
 * @name Register AIPS_PACRL, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP7 field. */
#define AIPS_RD_PACRL_TP7(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP7_MASK) >> AIPS_PACRL_TP7_SHIFT)
#define AIPS_BRD_PACRL_TP7(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP7_SHIFT, AIPS_PACRL_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRL_TP7(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP7_MASK, AIPS_PACRL_TP7(value)))
#define AIPS_BWR_PACRL_TP7(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP7_SHIFT), AIPS_PACRL_TP7_SHIFT, AIPS_PACRL_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP7 field. */
#define AIPS_RD_PACRL_WP7(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP7_MASK) >> AIPS_PACRL_WP7_SHIFT)
#define AIPS_BRD_PACRL_WP7(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP7_SHIFT, AIPS_PACRL_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRL_WP7(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP7_MASK, AIPS_PACRL_WP7(value)))
#define AIPS_BWR_PACRL_WP7(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP7_SHIFT), AIPS_PACRL_WP7_SHIFT, AIPS_PACRL_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP7 field. */
#define AIPS_RD_PACRL_SP7(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP7_MASK) >> AIPS_PACRL_SP7_SHIFT)
#define AIPS_BRD_PACRL_SP7(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP7_SHIFT, AIPS_PACRL_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRL_SP7(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP7_MASK, AIPS_PACRL_SP7(value)))
#define AIPS_BWR_PACRL_SP7(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP7_SHIFT), AIPS_PACRL_SP7_SHIFT, AIPS_PACRL_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP6 field. */
#define AIPS_RD_PACRL_TP6(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP6_MASK) >> AIPS_PACRL_TP6_SHIFT)
#define AIPS_BRD_PACRL_TP6(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP6_SHIFT, AIPS_PACRL_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRL_TP6(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP6_MASK, AIPS_PACRL_TP6(value)))
#define AIPS_BWR_PACRL_TP6(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP6_SHIFT), AIPS_PACRL_TP6_SHIFT, AIPS_PACRL_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP6 field. */
#define AIPS_RD_PACRL_WP6(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP6_MASK) >> AIPS_PACRL_WP6_SHIFT)
#define AIPS_BRD_PACRL_WP6(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP6_SHIFT, AIPS_PACRL_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRL_WP6(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP6_MASK, AIPS_PACRL_WP6(value)))
#define AIPS_BWR_PACRL_WP6(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP6_SHIFT), AIPS_PACRL_WP6_SHIFT, AIPS_PACRL_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP6 field. */
#define AIPS_RD_PACRL_SP6(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP6_MASK) >> AIPS_PACRL_SP6_SHIFT)
#define AIPS_BRD_PACRL_SP6(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP6_SHIFT, AIPS_PACRL_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRL_SP6(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP6_MASK, AIPS_PACRL_SP6(value)))
#define AIPS_BWR_PACRL_SP6(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP6_SHIFT), AIPS_PACRL_SP6_SHIFT, AIPS_PACRL_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP5 field. */
#define AIPS_RD_PACRL_TP5(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP5_MASK) >> AIPS_PACRL_TP5_SHIFT)
#define AIPS_BRD_PACRL_TP5(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP5_SHIFT, AIPS_PACRL_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRL_TP5(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP5_MASK, AIPS_PACRL_TP5(value)))
#define AIPS_BWR_PACRL_TP5(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP5_SHIFT), AIPS_PACRL_TP5_SHIFT, AIPS_PACRL_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP5 field. */
#define AIPS_RD_PACRL_WP5(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP5_MASK) >> AIPS_PACRL_WP5_SHIFT)
#define AIPS_BRD_PACRL_WP5(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP5_SHIFT, AIPS_PACRL_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRL_WP5(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP5_MASK, AIPS_PACRL_WP5(value)))
#define AIPS_BWR_PACRL_WP5(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP5_SHIFT), AIPS_PACRL_WP5_SHIFT, AIPS_PACRL_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP5 field. */
#define AIPS_RD_PACRL_SP5(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP5_MASK) >> AIPS_PACRL_SP5_SHIFT)
#define AIPS_BRD_PACRL_SP5(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP5_SHIFT, AIPS_PACRL_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRL_SP5(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP5_MASK, AIPS_PACRL_SP5(value)))
#define AIPS_BWR_PACRL_SP5(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP5_SHIFT), AIPS_PACRL_SP5_SHIFT, AIPS_PACRL_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP4 field. */
#define AIPS_RD_PACRL_TP4(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP4_MASK) >> AIPS_PACRL_TP4_SHIFT)
#define AIPS_BRD_PACRL_TP4(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP4_SHIFT, AIPS_PACRL_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRL_TP4(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP4_MASK, AIPS_PACRL_TP4(value)))
#define AIPS_BWR_PACRL_TP4(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP4_SHIFT), AIPS_PACRL_TP4_SHIFT, AIPS_PACRL_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP4 field. */
#define AIPS_RD_PACRL_WP4(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP4_MASK) >> AIPS_PACRL_WP4_SHIFT)
#define AIPS_BRD_PACRL_WP4(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP4_SHIFT, AIPS_PACRL_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRL_WP4(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP4_MASK, AIPS_PACRL_WP4(value)))
#define AIPS_BWR_PACRL_WP4(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP4_SHIFT), AIPS_PACRL_WP4_SHIFT, AIPS_PACRL_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP4 field. */
#define AIPS_RD_PACRL_SP4(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP4_MASK) >> AIPS_PACRL_SP4_SHIFT)
#define AIPS_BRD_PACRL_SP4(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP4_SHIFT, AIPS_PACRL_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRL_SP4(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP4_MASK, AIPS_PACRL_SP4(value)))
#define AIPS_BWR_PACRL_SP4(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP4_SHIFT), AIPS_PACRL_SP4_SHIFT, AIPS_PACRL_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP3 field. */
#define AIPS_RD_PACRL_TP3(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP3_MASK) >> AIPS_PACRL_TP3_SHIFT)
#define AIPS_BRD_PACRL_TP3(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP3_SHIFT, AIPS_PACRL_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRL_TP3(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP3_MASK, AIPS_PACRL_TP3(value)))
#define AIPS_BWR_PACRL_TP3(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP3_SHIFT), AIPS_PACRL_TP3_SHIFT, AIPS_PACRL_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP3 field. */
#define AIPS_RD_PACRL_WP3(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP3_MASK) >> AIPS_PACRL_WP3_SHIFT)
#define AIPS_BRD_PACRL_WP3(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP3_SHIFT, AIPS_PACRL_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRL_WP3(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP3_MASK, AIPS_PACRL_WP3(value)))
#define AIPS_BWR_PACRL_WP3(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP3_SHIFT), AIPS_PACRL_WP3_SHIFT, AIPS_PACRL_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP3 field. */
#define AIPS_RD_PACRL_SP3(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP3_MASK) >> AIPS_PACRL_SP3_SHIFT)
#define AIPS_BRD_PACRL_SP3(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP3_SHIFT, AIPS_PACRL_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRL_SP3(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP3_MASK, AIPS_PACRL_SP3(value)))
#define AIPS_BWR_PACRL_SP3(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP3_SHIFT), AIPS_PACRL_SP3_SHIFT, AIPS_PACRL_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP2 field. */
#define AIPS_RD_PACRL_TP2(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP2_MASK) >> AIPS_PACRL_TP2_SHIFT)
#define AIPS_BRD_PACRL_TP2(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP2_SHIFT, AIPS_PACRL_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRL_TP2(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP2_MASK, AIPS_PACRL_TP2(value)))
#define AIPS_BWR_PACRL_TP2(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP2_SHIFT), AIPS_PACRL_TP2_SHIFT, AIPS_PACRL_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP2 field. */
#define AIPS_RD_PACRL_WP2(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP2_MASK) >> AIPS_PACRL_WP2_SHIFT)
#define AIPS_BRD_PACRL_WP2(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP2_SHIFT, AIPS_PACRL_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRL_WP2(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP2_MASK, AIPS_PACRL_WP2(value)))
#define AIPS_BWR_PACRL_WP2(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP2_SHIFT), AIPS_PACRL_WP2_SHIFT, AIPS_PACRL_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP2 field. */
#define AIPS_RD_PACRL_SP2(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP2_MASK) >> AIPS_PACRL_SP2_SHIFT)
#define AIPS_BRD_PACRL_SP2(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP2_SHIFT, AIPS_PACRL_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRL_SP2(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP2_MASK, AIPS_PACRL_SP2(value)))
#define AIPS_BWR_PACRL_SP2(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP2_SHIFT), AIPS_PACRL_SP2_SHIFT, AIPS_PACRL_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP1 field. */
#define AIPS_RD_PACRL_TP1(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP1_MASK) >> AIPS_PACRL_TP1_SHIFT)
#define AIPS_BRD_PACRL_TP1(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP1_SHIFT, AIPS_PACRL_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRL_TP1(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP1_MASK, AIPS_PACRL_TP1(value)))
#define AIPS_BWR_PACRL_TP1(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP1_SHIFT), AIPS_PACRL_TP1_SHIFT, AIPS_PACRL_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP1 field. */
#define AIPS_RD_PACRL_WP1(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP1_MASK) >> AIPS_PACRL_WP1_SHIFT)
#define AIPS_BRD_PACRL_WP1(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP1_SHIFT, AIPS_PACRL_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRL_WP1(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP1_MASK, AIPS_PACRL_WP1(value)))
#define AIPS_BWR_PACRL_WP1(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP1_SHIFT), AIPS_PACRL_WP1_SHIFT, AIPS_PACRL_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP1 field. */
#define AIPS_RD_PACRL_SP1(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP1_MASK) >> AIPS_PACRL_SP1_SHIFT)
#define AIPS_BRD_PACRL_SP1(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP1_SHIFT, AIPS_PACRL_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRL_SP1(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP1_MASK, AIPS_PACRL_SP1(value)))
#define AIPS_BWR_PACRL_SP1(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP1_SHIFT), AIPS_PACRL_SP1_SHIFT, AIPS_PACRL_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_TP0 field. */
#define AIPS_RD_PACRL_TP0(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_TP0_MASK) >> AIPS_PACRL_TP0_SHIFT)
#define AIPS_BRD_PACRL_TP0(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_TP0_SHIFT, AIPS_PACRL_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRL_TP0(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_TP0_MASK, AIPS_PACRL_TP0(value)))
#define AIPS_BWR_PACRL_TP0(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_TP0_SHIFT), AIPS_PACRL_TP0_SHIFT, AIPS_PACRL_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_WP0 field. */
#define AIPS_RD_PACRL_WP0(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_WP0_MASK) >> AIPS_PACRL_WP0_SHIFT)
#define AIPS_BRD_PACRL_WP0(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_WP0_SHIFT, AIPS_PACRL_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRL_WP0(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_WP0_MASK, AIPS_PACRL_WP0(value)))
#define AIPS_BWR_PACRL_WP0(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_WP0_SHIFT), AIPS_PACRL_WP0_SHIFT, AIPS_PACRL_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRL, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRL_SP0 field. */
#define AIPS_RD_PACRL_SP0(base) ((AIPS_PACRL_REG(base) & AIPS_PACRL_SP0_MASK) >> AIPS_PACRL_SP0_SHIFT)
#define AIPS_BRD_PACRL_SP0(base) (BME_UBFX32(&AIPS_PACRL_REG(base), AIPS_PACRL_SP0_SHIFT, AIPS_PACRL_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRL_SP0(base, value) (AIPS_RMW_PACRL(base, AIPS_PACRL_SP0_MASK, AIPS_PACRL_SP0(value)))
#define AIPS_BWR_PACRL_SP0(base, value) (BME_BFI32(&AIPS_PACRL_REG(base), ((uint32_t)(value) << AIPS_PACRL_SP0_SHIFT), AIPS_PACRL_SP0_SHIFT, AIPS_PACRL_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRM - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRM - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRM register
 */
/*@{*/
#define AIPS_RD_PACRM(base)      (AIPS_PACRM_REG(base))
#define AIPS_WR_PACRM(base, value) (AIPS_PACRM_REG(base) = (value))
#define AIPS_RMW_PACRM(base, mask, value) (AIPS_WR_PACRM(base, (AIPS_RD_PACRM(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRM(base, value) (BME_OR32(&AIPS_PACRM_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRM(base, value) (BME_AND32(&AIPS_PACRM_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRM(base, value) (BME_XOR32(&AIPS_PACRM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRM bitfields
 */

/*!
 * @name Register AIPS_PACRM, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP7 field. */
#define AIPS_RD_PACRM_TP7(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP7_MASK) >> AIPS_PACRM_TP7_SHIFT)
#define AIPS_BRD_PACRM_TP7(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP7_SHIFT, AIPS_PACRM_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRM_TP7(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP7_MASK, AIPS_PACRM_TP7(value)))
#define AIPS_BWR_PACRM_TP7(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP7_SHIFT), AIPS_PACRM_TP7_SHIFT, AIPS_PACRM_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP7 field. */
#define AIPS_RD_PACRM_WP7(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP7_MASK) >> AIPS_PACRM_WP7_SHIFT)
#define AIPS_BRD_PACRM_WP7(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP7_SHIFT, AIPS_PACRM_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRM_WP7(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP7_MASK, AIPS_PACRM_WP7(value)))
#define AIPS_BWR_PACRM_WP7(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP7_SHIFT), AIPS_PACRM_WP7_SHIFT, AIPS_PACRM_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP7 field. */
#define AIPS_RD_PACRM_SP7(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP7_MASK) >> AIPS_PACRM_SP7_SHIFT)
#define AIPS_BRD_PACRM_SP7(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP7_SHIFT, AIPS_PACRM_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRM_SP7(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP7_MASK, AIPS_PACRM_SP7(value)))
#define AIPS_BWR_PACRM_SP7(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP7_SHIFT), AIPS_PACRM_SP7_SHIFT, AIPS_PACRM_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP6 field. */
#define AIPS_RD_PACRM_TP6(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP6_MASK) >> AIPS_PACRM_TP6_SHIFT)
#define AIPS_BRD_PACRM_TP6(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP6_SHIFT, AIPS_PACRM_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRM_TP6(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP6_MASK, AIPS_PACRM_TP6(value)))
#define AIPS_BWR_PACRM_TP6(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP6_SHIFT), AIPS_PACRM_TP6_SHIFT, AIPS_PACRM_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP6 field. */
#define AIPS_RD_PACRM_WP6(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP6_MASK) >> AIPS_PACRM_WP6_SHIFT)
#define AIPS_BRD_PACRM_WP6(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP6_SHIFT, AIPS_PACRM_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRM_WP6(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP6_MASK, AIPS_PACRM_WP6(value)))
#define AIPS_BWR_PACRM_WP6(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP6_SHIFT), AIPS_PACRM_WP6_SHIFT, AIPS_PACRM_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP6 field. */
#define AIPS_RD_PACRM_SP6(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP6_MASK) >> AIPS_PACRM_SP6_SHIFT)
#define AIPS_BRD_PACRM_SP6(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP6_SHIFT, AIPS_PACRM_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRM_SP6(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP6_MASK, AIPS_PACRM_SP6(value)))
#define AIPS_BWR_PACRM_SP6(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP6_SHIFT), AIPS_PACRM_SP6_SHIFT, AIPS_PACRM_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP5 field. */
#define AIPS_RD_PACRM_TP5(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP5_MASK) >> AIPS_PACRM_TP5_SHIFT)
#define AIPS_BRD_PACRM_TP5(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP5_SHIFT, AIPS_PACRM_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRM_TP5(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP5_MASK, AIPS_PACRM_TP5(value)))
#define AIPS_BWR_PACRM_TP5(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP5_SHIFT), AIPS_PACRM_TP5_SHIFT, AIPS_PACRM_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP5 field. */
#define AIPS_RD_PACRM_WP5(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP5_MASK) >> AIPS_PACRM_WP5_SHIFT)
#define AIPS_BRD_PACRM_WP5(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP5_SHIFT, AIPS_PACRM_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRM_WP5(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP5_MASK, AIPS_PACRM_WP5(value)))
#define AIPS_BWR_PACRM_WP5(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP5_SHIFT), AIPS_PACRM_WP5_SHIFT, AIPS_PACRM_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP5 field. */
#define AIPS_RD_PACRM_SP5(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP5_MASK) >> AIPS_PACRM_SP5_SHIFT)
#define AIPS_BRD_PACRM_SP5(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP5_SHIFT, AIPS_PACRM_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRM_SP5(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP5_MASK, AIPS_PACRM_SP5(value)))
#define AIPS_BWR_PACRM_SP5(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP5_SHIFT), AIPS_PACRM_SP5_SHIFT, AIPS_PACRM_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP4 field. */
#define AIPS_RD_PACRM_TP4(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP4_MASK) >> AIPS_PACRM_TP4_SHIFT)
#define AIPS_BRD_PACRM_TP4(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP4_SHIFT, AIPS_PACRM_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRM_TP4(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP4_MASK, AIPS_PACRM_TP4(value)))
#define AIPS_BWR_PACRM_TP4(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP4_SHIFT), AIPS_PACRM_TP4_SHIFT, AIPS_PACRM_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP4 field. */
#define AIPS_RD_PACRM_WP4(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP4_MASK) >> AIPS_PACRM_WP4_SHIFT)
#define AIPS_BRD_PACRM_WP4(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP4_SHIFT, AIPS_PACRM_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRM_WP4(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP4_MASK, AIPS_PACRM_WP4(value)))
#define AIPS_BWR_PACRM_WP4(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP4_SHIFT), AIPS_PACRM_WP4_SHIFT, AIPS_PACRM_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP4 field. */
#define AIPS_RD_PACRM_SP4(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP4_MASK) >> AIPS_PACRM_SP4_SHIFT)
#define AIPS_BRD_PACRM_SP4(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP4_SHIFT, AIPS_PACRM_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRM_SP4(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP4_MASK, AIPS_PACRM_SP4(value)))
#define AIPS_BWR_PACRM_SP4(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP4_SHIFT), AIPS_PACRM_SP4_SHIFT, AIPS_PACRM_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP3 field. */
#define AIPS_RD_PACRM_TP3(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP3_MASK) >> AIPS_PACRM_TP3_SHIFT)
#define AIPS_BRD_PACRM_TP3(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP3_SHIFT, AIPS_PACRM_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRM_TP3(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP3_MASK, AIPS_PACRM_TP3(value)))
#define AIPS_BWR_PACRM_TP3(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP3_SHIFT), AIPS_PACRM_TP3_SHIFT, AIPS_PACRM_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP3 field. */
#define AIPS_RD_PACRM_WP3(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP3_MASK) >> AIPS_PACRM_WP3_SHIFT)
#define AIPS_BRD_PACRM_WP3(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP3_SHIFT, AIPS_PACRM_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRM_WP3(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP3_MASK, AIPS_PACRM_WP3(value)))
#define AIPS_BWR_PACRM_WP3(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP3_SHIFT), AIPS_PACRM_WP3_SHIFT, AIPS_PACRM_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP3 field. */
#define AIPS_RD_PACRM_SP3(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP3_MASK) >> AIPS_PACRM_SP3_SHIFT)
#define AIPS_BRD_PACRM_SP3(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP3_SHIFT, AIPS_PACRM_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRM_SP3(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP3_MASK, AIPS_PACRM_SP3(value)))
#define AIPS_BWR_PACRM_SP3(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP3_SHIFT), AIPS_PACRM_SP3_SHIFT, AIPS_PACRM_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP2 field. */
#define AIPS_RD_PACRM_TP2(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP2_MASK) >> AIPS_PACRM_TP2_SHIFT)
#define AIPS_BRD_PACRM_TP2(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP2_SHIFT, AIPS_PACRM_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRM_TP2(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP2_MASK, AIPS_PACRM_TP2(value)))
#define AIPS_BWR_PACRM_TP2(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP2_SHIFT), AIPS_PACRM_TP2_SHIFT, AIPS_PACRM_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP2 field. */
#define AIPS_RD_PACRM_WP2(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP2_MASK) >> AIPS_PACRM_WP2_SHIFT)
#define AIPS_BRD_PACRM_WP2(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP2_SHIFT, AIPS_PACRM_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRM_WP2(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP2_MASK, AIPS_PACRM_WP2(value)))
#define AIPS_BWR_PACRM_WP2(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP2_SHIFT), AIPS_PACRM_WP2_SHIFT, AIPS_PACRM_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP2 field. */
#define AIPS_RD_PACRM_SP2(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP2_MASK) >> AIPS_PACRM_SP2_SHIFT)
#define AIPS_BRD_PACRM_SP2(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP2_SHIFT, AIPS_PACRM_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRM_SP2(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP2_MASK, AIPS_PACRM_SP2(value)))
#define AIPS_BWR_PACRM_SP2(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP2_SHIFT), AIPS_PACRM_SP2_SHIFT, AIPS_PACRM_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP1 field. */
#define AIPS_RD_PACRM_TP1(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP1_MASK) >> AIPS_PACRM_TP1_SHIFT)
#define AIPS_BRD_PACRM_TP1(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP1_SHIFT, AIPS_PACRM_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRM_TP1(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP1_MASK, AIPS_PACRM_TP1(value)))
#define AIPS_BWR_PACRM_TP1(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP1_SHIFT), AIPS_PACRM_TP1_SHIFT, AIPS_PACRM_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP1 field. */
#define AIPS_RD_PACRM_WP1(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP1_MASK) >> AIPS_PACRM_WP1_SHIFT)
#define AIPS_BRD_PACRM_WP1(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP1_SHIFT, AIPS_PACRM_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRM_WP1(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP1_MASK, AIPS_PACRM_WP1(value)))
#define AIPS_BWR_PACRM_WP1(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP1_SHIFT), AIPS_PACRM_WP1_SHIFT, AIPS_PACRM_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP1 field. */
#define AIPS_RD_PACRM_SP1(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP1_MASK) >> AIPS_PACRM_SP1_SHIFT)
#define AIPS_BRD_PACRM_SP1(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP1_SHIFT, AIPS_PACRM_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRM_SP1(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP1_MASK, AIPS_PACRM_SP1(value)))
#define AIPS_BWR_PACRM_SP1(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP1_SHIFT), AIPS_PACRM_SP1_SHIFT, AIPS_PACRM_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_TP0 field. */
#define AIPS_RD_PACRM_TP0(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_TP0_MASK) >> AIPS_PACRM_TP0_SHIFT)
#define AIPS_BRD_PACRM_TP0(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_TP0_SHIFT, AIPS_PACRM_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRM_TP0(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_TP0_MASK, AIPS_PACRM_TP0(value)))
#define AIPS_BWR_PACRM_TP0(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_TP0_SHIFT), AIPS_PACRM_TP0_SHIFT, AIPS_PACRM_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_WP0 field. */
#define AIPS_RD_PACRM_WP0(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_WP0_MASK) >> AIPS_PACRM_WP0_SHIFT)
#define AIPS_BRD_PACRM_WP0(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_WP0_SHIFT, AIPS_PACRM_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRM_WP0(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_WP0_MASK, AIPS_PACRM_WP0(value)))
#define AIPS_BWR_PACRM_WP0(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_WP0_SHIFT), AIPS_PACRM_WP0_SHIFT, AIPS_PACRM_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRM, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRM_SP0 field. */
#define AIPS_RD_PACRM_SP0(base) ((AIPS_PACRM_REG(base) & AIPS_PACRM_SP0_MASK) >> AIPS_PACRM_SP0_SHIFT)
#define AIPS_BRD_PACRM_SP0(base) (BME_UBFX32(&AIPS_PACRM_REG(base), AIPS_PACRM_SP0_SHIFT, AIPS_PACRM_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRM_SP0(base, value) (AIPS_RMW_PACRM(base, AIPS_PACRM_SP0_MASK, AIPS_PACRM_SP0(value)))
#define AIPS_BWR_PACRM_SP0(base, value) (BME_BFI32(&AIPS_PACRM_REG(base), ((uint32_t)(value) << AIPS_PACRM_SP0_SHIFT), AIPS_PACRM_SP0_SHIFT, AIPS_PACRM_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRN - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRN - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRN register
 */
/*@{*/
#define AIPS_RD_PACRN(base)      (AIPS_PACRN_REG(base))
#define AIPS_WR_PACRN(base, value) (AIPS_PACRN_REG(base) = (value))
#define AIPS_RMW_PACRN(base, mask, value) (AIPS_WR_PACRN(base, (AIPS_RD_PACRN(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRN(base, value) (BME_OR32(&AIPS_PACRN_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRN(base, value) (BME_AND32(&AIPS_PACRN_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRN(base, value) (BME_XOR32(&AIPS_PACRN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRN bitfields
 */

/*!
 * @name Register AIPS_PACRN, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP7 field. */
#define AIPS_RD_PACRN_TP7(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP7_MASK) >> AIPS_PACRN_TP7_SHIFT)
#define AIPS_BRD_PACRN_TP7(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP7_SHIFT, AIPS_PACRN_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRN_TP7(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP7_MASK, AIPS_PACRN_TP7(value)))
#define AIPS_BWR_PACRN_TP7(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP7_SHIFT), AIPS_PACRN_TP7_SHIFT, AIPS_PACRN_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP7 field. */
#define AIPS_RD_PACRN_WP7(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP7_MASK) >> AIPS_PACRN_WP7_SHIFT)
#define AIPS_BRD_PACRN_WP7(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP7_SHIFT, AIPS_PACRN_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRN_WP7(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP7_MASK, AIPS_PACRN_WP7(value)))
#define AIPS_BWR_PACRN_WP7(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP7_SHIFT), AIPS_PACRN_WP7_SHIFT, AIPS_PACRN_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP7 field. */
#define AIPS_RD_PACRN_SP7(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP7_MASK) >> AIPS_PACRN_SP7_SHIFT)
#define AIPS_BRD_PACRN_SP7(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP7_SHIFT, AIPS_PACRN_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRN_SP7(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP7_MASK, AIPS_PACRN_SP7(value)))
#define AIPS_BWR_PACRN_SP7(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP7_SHIFT), AIPS_PACRN_SP7_SHIFT, AIPS_PACRN_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP6 field. */
#define AIPS_RD_PACRN_TP6(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP6_MASK) >> AIPS_PACRN_TP6_SHIFT)
#define AIPS_BRD_PACRN_TP6(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP6_SHIFT, AIPS_PACRN_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRN_TP6(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP6_MASK, AIPS_PACRN_TP6(value)))
#define AIPS_BWR_PACRN_TP6(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP6_SHIFT), AIPS_PACRN_TP6_SHIFT, AIPS_PACRN_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP6 field. */
#define AIPS_RD_PACRN_WP6(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP6_MASK) >> AIPS_PACRN_WP6_SHIFT)
#define AIPS_BRD_PACRN_WP6(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP6_SHIFT, AIPS_PACRN_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRN_WP6(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP6_MASK, AIPS_PACRN_WP6(value)))
#define AIPS_BWR_PACRN_WP6(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP6_SHIFT), AIPS_PACRN_WP6_SHIFT, AIPS_PACRN_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP6 field. */
#define AIPS_RD_PACRN_SP6(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP6_MASK) >> AIPS_PACRN_SP6_SHIFT)
#define AIPS_BRD_PACRN_SP6(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP6_SHIFT, AIPS_PACRN_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRN_SP6(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP6_MASK, AIPS_PACRN_SP6(value)))
#define AIPS_BWR_PACRN_SP6(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP6_SHIFT), AIPS_PACRN_SP6_SHIFT, AIPS_PACRN_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP5 field. */
#define AIPS_RD_PACRN_TP5(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP5_MASK) >> AIPS_PACRN_TP5_SHIFT)
#define AIPS_BRD_PACRN_TP5(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP5_SHIFT, AIPS_PACRN_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRN_TP5(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP5_MASK, AIPS_PACRN_TP5(value)))
#define AIPS_BWR_PACRN_TP5(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP5_SHIFT), AIPS_PACRN_TP5_SHIFT, AIPS_PACRN_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP5 field. */
#define AIPS_RD_PACRN_WP5(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP5_MASK) >> AIPS_PACRN_WP5_SHIFT)
#define AIPS_BRD_PACRN_WP5(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP5_SHIFT, AIPS_PACRN_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRN_WP5(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP5_MASK, AIPS_PACRN_WP5(value)))
#define AIPS_BWR_PACRN_WP5(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP5_SHIFT), AIPS_PACRN_WP5_SHIFT, AIPS_PACRN_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP5 field. */
#define AIPS_RD_PACRN_SP5(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP5_MASK) >> AIPS_PACRN_SP5_SHIFT)
#define AIPS_BRD_PACRN_SP5(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP5_SHIFT, AIPS_PACRN_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRN_SP5(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP5_MASK, AIPS_PACRN_SP5(value)))
#define AIPS_BWR_PACRN_SP5(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP5_SHIFT), AIPS_PACRN_SP5_SHIFT, AIPS_PACRN_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP4 field. */
#define AIPS_RD_PACRN_TP4(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP4_MASK) >> AIPS_PACRN_TP4_SHIFT)
#define AIPS_BRD_PACRN_TP4(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP4_SHIFT, AIPS_PACRN_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRN_TP4(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP4_MASK, AIPS_PACRN_TP4(value)))
#define AIPS_BWR_PACRN_TP4(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP4_SHIFT), AIPS_PACRN_TP4_SHIFT, AIPS_PACRN_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP4 field. */
#define AIPS_RD_PACRN_WP4(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP4_MASK) >> AIPS_PACRN_WP4_SHIFT)
#define AIPS_BRD_PACRN_WP4(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP4_SHIFT, AIPS_PACRN_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRN_WP4(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP4_MASK, AIPS_PACRN_WP4(value)))
#define AIPS_BWR_PACRN_WP4(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP4_SHIFT), AIPS_PACRN_WP4_SHIFT, AIPS_PACRN_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP4 field. */
#define AIPS_RD_PACRN_SP4(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP4_MASK) >> AIPS_PACRN_SP4_SHIFT)
#define AIPS_BRD_PACRN_SP4(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP4_SHIFT, AIPS_PACRN_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRN_SP4(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP4_MASK, AIPS_PACRN_SP4(value)))
#define AIPS_BWR_PACRN_SP4(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP4_SHIFT), AIPS_PACRN_SP4_SHIFT, AIPS_PACRN_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP3 field. */
#define AIPS_RD_PACRN_TP3(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP3_MASK) >> AIPS_PACRN_TP3_SHIFT)
#define AIPS_BRD_PACRN_TP3(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP3_SHIFT, AIPS_PACRN_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRN_TP3(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP3_MASK, AIPS_PACRN_TP3(value)))
#define AIPS_BWR_PACRN_TP3(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP3_SHIFT), AIPS_PACRN_TP3_SHIFT, AIPS_PACRN_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP3 field. */
#define AIPS_RD_PACRN_WP3(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP3_MASK) >> AIPS_PACRN_WP3_SHIFT)
#define AIPS_BRD_PACRN_WP3(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP3_SHIFT, AIPS_PACRN_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRN_WP3(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP3_MASK, AIPS_PACRN_WP3(value)))
#define AIPS_BWR_PACRN_WP3(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP3_SHIFT), AIPS_PACRN_WP3_SHIFT, AIPS_PACRN_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP3 field. */
#define AIPS_RD_PACRN_SP3(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP3_MASK) >> AIPS_PACRN_SP3_SHIFT)
#define AIPS_BRD_PACRN_SP3(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP3_SHIFT, AIPS_PACRN_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRN_SP3(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP3_MASK, AIPS_PACRN_SP3(value)))
#define AIPS_BWR_PACRN_SP3(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP3_SHIFT), AIPS_PACRN_SP3_SHIFT, AIPS_PACRN_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP2 field. */
#define AIPS_RD_PACRN_TP2(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP2_MASK) >> AIPS_PACRN_TP2_SHIFT)
#define AIPS_BRD_PACRN_TP2(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP2_SHIFT, AIPS_PACRN_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRN_TP2(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP2_MASK, AIPS_PACRN_TP2(value)))
#define AIPS_BWR_PACRN_TP2(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP2_SHIFT), AIPS_PACRN_TP2_SHIFT, AIPS_PACRN_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP2 field. */
#define AIPS_RD_PACRN_WP2(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP2_MASK) >> AIPS_PACRN_WP2_SHIFT)
#define AIPS_BRD_PACRN_WP2(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP2_SHIFT, AIPS_PACRN_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRN_WP2(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP2_MASK, AIPS_PACRN_WP2(value)))
#define AIPS_BWR_PACRN_WP2(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP2_SHIFT), AIPS_PACRN_WP2_SHIFT, AIPS_PACRN_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP2 field. */
#define AIPS_RD_PACRN_SP2(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP2_MASK) >> AIPS_PACRN_SP2_SHIFT)
#define AIPS_BRD_PACRN_SP2(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP2_SHIFT, AIPS_PACRN_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRN_SP2(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP2_MASK, AIPS_PACRN_SP2(value)))
#define AIPS_BWR_PACRN_SP2(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP2_SHIFT), AIPS_PACRN_SP2_SHIFT, AIPS_PACRN_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP1 field. */
#define AIPS_RD_PACRN_TP1(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP1_MASK) >> AIPS_PACRN_TP1_SHIFT)
#define AIPS_BRD_PACRN_TP1(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP1_SHIFT, AIPS_PACRN_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRN_TP1(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP1_MASK, AIPS_PACRN_TP1(value)))
#define AIPS_BWR_PACRN_TP1(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP1_SHIFT), AIPS_PACRN_TP1_SHIFT, AIPS_PACRN_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP1 field. */
#define AIPS_RD_PACRN_WP1(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP1_MASK) >> AIPS_PACRN_WP1_SHIFT)
#define AIPS_BRD_PACRN_WP1(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP1_SHIFT, AIPS_PACRN_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRN_WP1(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP1_MASK, AIPS_PACRN_WP1(value)))
#define AIPS_BWR_PACRN_WP1(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP1_SHIFT), AIPS_PACRN_WP1_SHIFT, AIPS_PACRN_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP1 field. */
#define AIPS_RD_PACRN_SP1(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP1_MASK) >> AIPS_PACRN_SP1_SHIFT)
#define AIPS_BRD_PACRN_SP1(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP1_SHIFT, AIPS_PACRN_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRN_SP1(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP1_MASK, AIPS_PACRN_SP1(value)))
#define AIPS_BWR_PACRN_SP1(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP1_SHIFT), AIPS_PACRN_SP1_SHIFT, AIPS_PACRN_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_TP0 field. */
#define AIPS_RD_PACRN_TP0(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_TP0_MASK) >> AIPS_PACRN_TP0_SHIFT)
#define AIPS_BRD_PACRN_TP0(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_TP0_SHIFT, AIPS_PACRN_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRN_TP0(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_TP0_MASK, AIPS_PACRN_TP0(value)))
#define AIPS_BWR_PACRN_TP0(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_TP0_SHIFT), AIPS_PACRN_TP0_SHIFT, AIPS_PACRN_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_WP0 field. */
#define AIPS_RD_PACRN_WP0(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_WP0_MASK) >> AIPS_PACRN_WP0_SHIFT)
#define AIPS_BRD_PACRN_WP0(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_WP0_SHIFT, AIPS_PACRN_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRN_WP0(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_WP0_MASK, AIPS_PACRN_WP0(value)))
#define AIPS_BWR_PACRN_WP0(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_WP0_SHIFT), AIPS_PACRN_WP0_SHIFT, AIPS_PACRN_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRN, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRN_SP0 field. */
#define AIPS_RD_PACRN_SP0(base) ((AIPS_PACRN_REG(base) & AIPS_PACRN_SP0_MASK) >> AIPS_PACRN_SP0_SHIFT)
#define AIPS_BRD_PACRN_SP0(base) (BME_UBFX32(&AIPS_PACRN_REG(base), AIPS_PACRN_SP0_SHIFT, AIPS_PACRN_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRN_SP0(base, value) (AIPS_RMW_PACRN(base, AIPS_PACRN_SP0_MASK, AIPS_PACRN_SP0(value)))
#define AIPS_BWR_PACRN_SP0(base, value) (BME_BFI32(&AIPS_PACRN_REG(base), ((uint32_t)(value) << AIPS_PACRN_SP0_SHIFT), AIPS_PACRN_SP0_SHIFT, AIPS_PACRN_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRO - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRO - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRO register
 */
/*@{*/
#define AIPS_RD_PACRO(base)      (AIPS_PACRO_REG(base))
#define AIPS_WR_PACRO(base, value) (AIPS_PACRO_REG(base) = (value))
#define AIPS_RMW_PACRO(base, mask, value) (AIPS_WR_PACRO(base, (AIPS_RD_PACRO(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRO(base, value) (BME_OR32(&AIPS_PACRO_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRO(base, value) (BME_AND32(&AIPS_PACRO_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRO(base, value) (BME_XOR32(&AIPS_PACRO_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRO bitfields
 */

/*!
 * @name Register AIPS_PACRO, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP7 field. */
#define AIPS_RD_PACRO_TP7(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP7_MASK) >> AIPS_PACRO_TP7_SHIFT)
#define AIPS_BRD_PACRO_TP7(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP7_SHIFT, AIPS_PACRO_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRO_TP7(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP7_MASK, AIPS_PACRO_TP7(value)))
#define AIPS_BWR_PACRO_TP7(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP7_SHIFT), AIPS_PACRO_TP7_SHIFT, AIPS_PACRO_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP7 field. */
#define AIPS_RD_PACRO_WP7(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP7_MASK) >> AIPS_PACRO_WP7_SHIFT)
#define AIPS_BRD_PACRO_WP7(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP7_SHIFT, AIPS_PACRO_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRO_WP7(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP7_MASK, AIPS_PACRO_WP7(value)))
#define AIPS_BWR_PACRO_WP7(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP7_SHIFT), AIPS_PACRO_WP7_SHIFT, AIPS_PACRO_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP7 field. */
#define AIPS_RD_PACRO_SP7(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP7_MASK) >> AIPS_PACRO_SP7_SHIFT)
#define AIPS_BRD_PACRO_SP7(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP7_SHIFT, AIPS_PACRO_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRO_SP7(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP7_MASK, AIPS_PACRO_SP7(value)))
#define AIPS_BWR_PACRO_SP7(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP7_SHIFT), AIPS_PACRO_SP7_SHIFT, AIPS_PACRO_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP6 field. */
#define AIPS_RD_PACRO_TP6(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP6_MASK) >> AIPS_PACRO_TP6_SHIFT)
#define AIPS_BRD_PACRO_TP6(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP6_SHIFT, AIPS_PACRO_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRO_TP6(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP6_MASK, AIPS_PACRO_TP6(value)))
#define AIPS_BWR_PACRO_TP6(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP6_SHIFT), AIPS_PACRO_TP6_SHIFT, AIPS_PACRO_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP6 field. */
#define AIPS_RD_PACRO_WP6(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP6_MASK) >> AIPS_PACRO_WP6_SHIFT)
#define AIPS_BRD_PACRO_WP6(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP6_SHIFT, AIPS_PACRO_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRO_WP6(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP6_MASK, AIPS_PACRO_WP6(value)))
#define AIPS_BWR_PACRO_WP6(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP6_SHIFT), AIPS_PACRO_WP6_SHIFT, AIPS_PACRO_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP6 field. */
#define AIPS_RD_PACRO_SP6(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP6_MASK) >> AIPS_PACRO_SP6_SHIFT)
#define AIPS_BRD_PACRO_SP6(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP6_SHIFT, AIPS_PACRO_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRO_SP6(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP6_MASK, AIPS_PACRO_SP6(value)))
#define AIPS_BWR_PACRO_SP6(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP6_SHIFT), AIPS_PACRO_SP6_SHIFT, AIPS_PACRO_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP5 field. */
#define AIPS_RD_PACRO_TP5(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP5_MASK) >> AIPS_PACRO_TP5_SHIFT)
#define AIPS_BRD_PACRO_TP5(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP5_SHIFT, AIPS_PACRO_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRO_TP5(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP5_MASK, AIPS_PACRO_TP5(value)))
#define AIPS_BWR_PACRO_TP5(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP5_SHIFT), AIPS_PACRO_TP5_SHIFT, AIPS_PACRO_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP5 field. */
#define AIPS_RD_PACRO_WP5(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP5_MASK) >> AIPS_PACRO_WP5_SHIFT)
#define AIPS_BRD_PACRO_WP5(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP5_SHIFT, AIPS_PACRO_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRO_WP5(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP5_MASK, AIPS_PACRO_WP5(value)))
#define AIPS_BWR_PACRO_WP5(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP5_SHIFT), AIPS_PACRO_WP5_SHIFT, AIPS_PACRO_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP5 field. */
#define AIPS_RD_PACRO_SP5(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP5_MASK) >> AIPS_PACRO_SP5_SHIFT)
#define AIPS_BRD_PACRO_SP5(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP5_SHIFT, AIPS_PACRO_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRO_SP5(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP5_MASK, AIPS_PACRO_SP5(value)))
#define AIPS_BWR_PACRO_SP5(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP5_SHIFT), AIPS_PACRO_SP5_SHIFT, AIPS_PACRO_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP4 field. */
#define AIPS_RD_PACRO_TP4(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP4_MASK) >> AIPS_PACRO_TP4_SHIFT)
#define AIPS_BRD_PACRO_TP4(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP4_SHIFT, AIPS_PACRO_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRO_TP4(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP4_MASK, AIPS_PACRO_TP4(value)))
#define AIPS_BWR_PACRO_TP4(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP4_SHIFT), AIPS_PACRO_TP4_SHIFT, AIPS_PACRO_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP4 field. */
#define AIPS_RD_PACRO_WP4(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP4_MASK) >> AIPS_PACRO_WP4_SHIFT)
#define AIPS_BRD_PACRO_WP4(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP4_SHIFT, AIPS_PACRO_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRO_WP4(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP4_MASK, AIPS_PACRO_WP4(value)))
#define AIPS_BWR_PACRO_WP4(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP4_SHIFT), AIPS_PACRO_WP4_SHIFT, AIPS_PACRO_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP4 field. */
#define AIPS_RD_PACRO_SP4(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP4_MASK) >> AIPS_PACRO_SP4_SHIFT)
#define AIPS_BRD_PACRO_SP4(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP4_SHIFT, AIPS_PACRO_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRO_SP4(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP4_MASK, AIPS_PACRO_SP4(value)))
#define AIPS_BWR_PACRO_SP4(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP4_SHIFT), AIPS_PACRO_SP4_SHIFT, AIPS_PACRO_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP3 field. */
#define AIPS_RD_PACRO_TP3(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP3_MASK) >> AIPS_PACRO_TP3_SHIFT)
#define AIPS_BRD_PACRO_TP3(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP3_SHIFT, AIPS_PACRO_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRO_TP3(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP3_MASK, AIPS_PACRO_TP3(value)))
#define AIPS_BWR_PACRO_TP3(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP3_SHIFT), AIPS_PACRO_TP3_SHIFT, AIPS_PACRO_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP3 field. */
#define AIPS_RD_PACRO_WP3(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP3_MASK) >> AIPS_PACRO_WP3_SHIFT)
#define AIPS_BRD_PACRO_WP3(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP3_SHIFT, AIPS_PACRO_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRO_WP3(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP3_MASK, AIPS_PACRO_WP3(value)))
#define AIPS_BWR_PACRO_WP3(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP3_SHIFT), AIPS_PACRO_WP3_SHIFT, AIPS_PACRO_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP3 field. */
#define AIPS_RD_PACRO_SP3(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP3_MASK) >> AIPS_PACRO_SP3_SHIFT)
#define AIPS_BRD_PACRO_SP3(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP3_SHIFT, AIPS_PACRO_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRO_SP3(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP3_MASK, AIPS_PACRO_SP3(value)))
#define AIPS_BWR_PACRO_SP3(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP3_SHIFT), AIPS_PACRO_SP3_SHIFT, AIPS_PACRO_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP2 field. */
#define AIPS_RD_PACRO_TP2(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP2_MASK) >> AIPS_PACRO_TP2_SHIFT)
#define AIPS_BRD_PACRO_TP2(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP2_SHIFT, AIPS_PACRO_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRO_TP2(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP2_MASK, AIPS_PACRO_TP2(value)))
#define AIPS_BWR_PACRO_TP2(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP2_SHIFT), AIPS_PACRO_TP2_SHIFT, AIPS_PACRO_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP2 field. */
#define AIPS_RD_PACRO_WP2(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP2_MASK) >> AIPS_PACRO_WP2_SHIFT)
#define AIPS_BRD_PACRO_WP2(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP2_SHIFT, AIPS_PACRO_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRO_WP2(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP2_MASK, AIPS_PACRO_WP2(value)))
#define AIPS_BWR_PACRO_WP2(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP2_SHIFT), AIPS_PACRO_WP2_SHIFT, AIPS_PACRO_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP2 field. */
#define AIPS_RD_PACRO_SP2(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP2_MASK) >> AIPS_PACRO_SP2_SHIFT)
#define AIPS_BRD_PACRO_SP2(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP2_SHIFT, AIPS_PACRO_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRO_SP2(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP2_MASK, AIPS_PACRO_SP2(value)))
#define AIPS_BWR_PACRO_SP2(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP2_SHIFT), AIPS_PACRO_SP2_SHIFT, AIPS_PACRO_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP1 field. */
#define AIPS_RD_PACRO_TP1(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP1_MASK) >> AIPS_PACRO_TP1_SHIFT)
#define AIPS_BRD_PACRO_TP1(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP1_SHIFT, AIPS_PACRO_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRO_TP1(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP1_MASK, AIPS_PACRO_TP1(value)))
#define AIPS_BWR_PACRO_TP1(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP1_SHIFT), AIPS_PACRO_TP1_SHIFT, AIPS_PACRO_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP1 field. */
#define AIPS_RD_PACRO_WP1(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP1_MASK) >> AIPS_PACRO_WP1_SHIFT)
#define AIPS_BRD_PACRO_WP1(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP1_SHIFT, AIPS_PACRO_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRO_WP1(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP1_MASK, AIPS_PACRO_WP1(value)))
#define AIPS_BWR_PACRO_WP1(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP1_SHIFT), AIPS_PACRO_WP1_SHIFT, AIPS_PACRO_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP1 field. */
#define AIPS_RD_PACRO_SP1(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP1_MASK) >> AIPS_PACRO_SP1_SHIFT)
#define AIPS_BRD_PACRO_SP1(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP1_SHIFT, AIPS_PACRO_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRO_SP1(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP1_MASK, AIPS_PACRO_SP1(value)))
#define AIPS_BWR_PACRO_SP1(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP1_SHIFT), AIPS_PACRO_SP1_SHIFT, AIPS_PACRO_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_TP0 field. */
#define AIPS_RD_PACRO_TP0(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_TP0_MASK) >> AIPS_PACRO_TP0_SHIFT)
#define AIPS_BRD_PACRO_TP0(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_TP0_SHIFT, AIPS_PACRO_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRO_TP0(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_TP0_MASK, AIPS_PACRO_TP0(value)))
#define AIPS_BWR_PACRO_TP0(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_TP0_SHIFT), AIPS_PACRO_TP0_SHIFT, AIPS_PACRO_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_WP0 field. */
#define AIPS_RD_PACRO_WP0(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_WP0_MASK) >> AIPS_PACRO_WP0_SHIFT)
#define AIPS_BRD_PACRO_WP0(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_WP0_SHIFT, AIPS_PACRO_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRO_WP0(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_WP0_MASK, AIPS_PACRO_WP0(value)))
#define AIPS_BWR_PACRO_WP0(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_WP0_SHIFT), AIPS_PACRO_WP0_SHIFT, AIPS_PACRO_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRO, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRO_SP0 field. */
#define AIPS_RD_PACRO_SP0(base) ((AIPS_PACRO_REG(base) & AIPS_PACRO_SP0_MASK) >> AIPS_PACRO_SP0_SHIFT)
#define AIPS_BRD_PACRO_SP0(base) (BME_UBFX32(&AIPS_PACRO_REG(base), AIPS_PACRO_SP0_SHIFT, AIPS_PACRO_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRO_SP0(base, value) (AIPS_RMW_PACRO(base, AIPS_PACRO_SP0_MASK, AIPS_PACRO_SP0(value)))
#define AIPS_BWR_PACRO_SP0(base, value) (BME_BFI32(&AIPS_PACRO_REG(base), ((uint32_t)(value) << AIPS_PACRO_SP0_SHIFT), AIPS_PACRO_SP0_SHIFT, AIPS_PACRO_SP0_WIDTH))
/*@}*/

/*******************************************************************************
 * AIPS_PACRP - Peripheral Access Control Register
 ******************************************************************************/

/*!
 * @brief AIPS_PACRP - Peripheral Access Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This section describes PACR registers E-P, which control peripheral slots
 * 32-127. See PACRPeripheral Access Control Register for the description of these
 * registers.
 */
/*!
 * @name Constants and macros for entire AIPS_PACRP register
 */
/*@{*/
#define AIPS_RD_PACRP(base)      (AIPS_PACRP_REG(base))
#define AIPS_WR_PACRP(base, value) (AIPS_PACRP_REG(base) = (value))
#define AIPS_RMW_PACRP(base, mask, value) (AIPS_WR_PACRP(base, (AIPS_RD_PACRP(base) & ~(mask)) | (value)))
#define AIPS_SET_PACRP(base, value) (BME_OR32(&AIPS_PACRP_REG(base), (uint32_t)(value)))
#define AIPS_CLR_PACRP(base, value) (BME_AND32(&AIPS_PACRP_REG(base), (uint32_t)(~(value))))
#define AIPS_TOG_PACRP(base, value) (BME_XOR32(&AIPS_PACRP_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AIPS_PACRP bitfields
 */

/*!
 * @name Register AIPS_PACRP, field TP7[0] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP7 field. */
#define AIPS_RD_PACRP_TP7(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP7_MASK) >> AIPS_PACRP_TP7_SHIFT)
#define AIPS_BRD_PACRP_TP7(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP7_SHIFT, AIPS_PACRP_TP7_WIDTH))

/*! @brief Set the TP7 field to a new value. */
#define AIPS_WR_PACRP_TP7(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP7_MASK, AIPS_PACRP_TP7(value)))
#define AIPS_BWR_PACRP_TP7(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP7_SHIFT), AIPS_PACRP_TP7_SHIFT, AIPS_PACRP_TP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP7[1] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP7 field. */
#define AIPS_RD_PACRP_WP7(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP7_MASK) >> AIPS_PACRP_WP7_SHIFT)
#define AIPS_BRD_PACRP_WP7(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP7_SHIFT, AIPS_PACRP_WP7_WIDTH))

/*! @brief Set the WP7 field to a new value. */
#define AIPS_WR_PACRP_WP7(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP7_MASK, AIPS_PACRP_WP7(value)))
#define AIPS_BWR_PACRP_WP7(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP7_SHIFT), AIPS_PACRP_WP7_SHIFT, AIPS_PACRP_WP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP7[2] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP7 field. */
#define AIPS_RD_PACRP_SP7(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP7_MASK) >> AIPS_PACRP_SP7_SHIFT)
#define AIPS_BRD_PACRP_SP7(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP7_SHIFT, AIPS_PACRP_SP7_WIDTH))

/*! @brief Set the SP7 field to a new value. */
#define AIPS_WR_PACRP_SP7(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP7_MASK, AIPS_PACRP_SP7(value)))
#define AIPS_BWR_PACRP_SP7(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP7_SHIFT), AIPS_PACRP_SP7_SHIFT, AIPS_PACRP_SP7_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP6[4] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP6 field. */
#define AIPS_RD_PACRP_TP6(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP6_MASK) >> AIPS_PACRP_TP6_SHIFT)
#define AIPS_BRD_PACRP_TP6(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP6_SHIFT, AIPS_PACRP_TP6_WIDTH))

/*! @brief Set the TP6 field to a new value. */
#define AIPS_WR_PACRP_TP6(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP6_MASK, AIPS_PACRP_TP6(value)))
#define AIPS_BWR_PACRP_TP6(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP6_SHIFT), AIPS_PACRP_TP6_SHIFT, AIPS_PACRP_TP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP6[5] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP6 field. */
#define AIPS_RD_PACRP_WP6(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP6_MASK) >> AIPS_PACRP_WP6_SHIFT)
#define AIPS_BRD_PACRP_WP6(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP6_SHIFT, AIPS_PACRP_WP6_WIDTH))

/*! @brief Set the WP6 field to a new value. */
#define AIPS_WR_PACRP_WP6(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP6_MASK, AIPS_PACRP_WP6(value)))
#define AIPS_BWR_PACRP_WP6(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP6_SHIFT), AIPS_PACRP_WP6_SHIFT, AIPS_PACRP_WP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP6[6] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP6 field. */
#define AIPS_RD_PACRP_SP6(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP6_MASK) >> AIPS_PACRP_SP6_SHIFT)
#define AIPS_BRD_PACRP_SP6(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP6_SHIFT, AIPS_PACRP_SP6_WIDTH))

/*! @brief Set the SP6 field to a new value. */
#define AIPS_WR_PACRP_SP6(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP6_MASK, AIPS_PACRP_SP6(value)))
#define AIPS_BWR_PACRP_SP6(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP6_SHIFT), AIPS_PACRP_SP6_SHIFT, AIPS_PACRP_SP6_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP5[8] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP5 field. */
#define AIPS_RD_PACRP_TP5(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP5_MASK) >> AIPS_PACRP_TP5_SHIFT)
#define AIPS_BRD_PACRP_TP5(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP5_SHIFT, AIPS_PACRP_TP5_WIDTH))

/*! @brief Set the TP5 field to a new value. */
#define AIPS_WR_PACRP_TP5(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP5_MASK, AIPS_PACRP_TP5(value)))
#define AIPS_BWR_PACRP_TP5(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP5_SHIFT), AIPS_PACRP_TP5_SHIFT, AIPS_PACRP_TP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP5[9] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP5 field. */
#define AIPS_RD_PACRP_WP5(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP5_MASK) >> AIPS_PACRP_WP5_SHIFT)
#define AIPS_BRD_PACRP_WP5(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP5_SHIFT, AIPS_PACRP_WP5_WIDTH))

/*! @brief Set the WP5 field to a new value. */
#define AIPS_WR_PACRP_WP5(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP5_MASK, AIPS_PACRP_WP5(value)))
#define AIPS_BWR_PACRP_WP5(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP5_SHIFT), AIPS_PACRP_WP5_SHIFT, AIPS_PACRP_WP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP5[10] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP5 field. */
#define AIPS_RD_PACRP_SP5(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP5_MASK) >> AIPS_PACRP_SP5_SHIFT)
#define AIPS_BRD_PACRP_SP5(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP5_SHIFT, AIPS_PACRP_SP5_WIDTH))

/*! @brief Set the SP5 field to a new value. */
#define AIPS_WR_PACRP_SP5(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP5_MASK, AIPS_PACRP_SP5(value)))
#define AIPS_BWR_PACRP_SP5(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP5_SHIFT), AIPS_PACRP_SP5_SHIFT, AIPS_PACRP_SP5_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP4[12] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP4 field. */
#define AIPS_RD_PACRP_TP4(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP4_MASK) >> AIPS_PACRP_TP4_SHIFT)
#define AIPS_BRD_PACRP_TP4(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP4_SHIFT, AIPS_PACRP_TP4_WIDTH))

/*! @brief Set the TP4 field to a new value. */
#define AIPS_WR_PACRP_TP4(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP4_MASK, AIPS_PACRP_TP4(value)))
#define AIPS_BWR_PACRP_TP4(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP4_SHIFT), AIPS_PACRP_TP4_SHIFT, AIPS_PACRP_TP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP4[13] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP4 field. */
#define AIPS_RD_PACRP_WP4(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP4_MASK) >> AIPS_PACRP_WP4_SHIFT)
#define AIPS_BRD_PACRP_WP4(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP4_SHIFT, AIPS_PACRP_WP4_WIDTH))

/*! @brief Set the WP4 field to a new value. */
#define AIPS_WR_PACRP_WP4(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP4_MASK, AIPS_PACRP_WP4(value)))
#define AIPS_BWR_PACRP_WP4(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP4_SHIFT), AIPS_PACRP_WP4_SHIFT, AIPS_PACRP_WP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP4[14] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP4 field. */
#define AIPS_RD_PACRP_SP4(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP4_MASK) >> AIPS_PACRP_SP4_SHIFT)
#define AIPS_BRD_PACRP_SP4(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP4_SHIFT, AIPS_PACRP_SP4_WIDTH))

/*! @brief Set the SP4 field to a new value. */
#define AIPS_WR_PACRP_SP4(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP4_MASK, AIPS_PACRP_SP4(value)))
#define AIPS_BWR_PACRP_SP4(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP4_SHIFT), AIPS_PACRP_SP4_SHIFT, AIPS_PACRP_SP4_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP3[16] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP3 field. */
#define AIPS_RD_PACRP_TP3(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP3_MASK) >> AIPS_PACRP_TP3_SHIFT)
#define AIPS_BRD_PACRP_TP3(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP3_SHIFT, AIPS_PACRP_TP3_WIDTH))

/*! @brief Set the TP3 field to a new value. */
#define AIPS_WR_PACRP_TP3(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP3_MASK, AIPS_PACRP_TP3(value)))
#define AIPS_BWR_PACRP_TP3(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP3_SHIFT), AIPS_PACRP_TP3_SHIFT, AIPS_PACRP_TP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP3[17] (RW)
 *
 * Determines whether the peripheral allows write access. When this bit is set
 * and a write access is attempted, access terminates with an error response and
 * no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP3 field. */
#define AIPS_RD_PACRP_WP3(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP3_MASK) >> AIPS_PACRP_WP3_SHIFT)
#define AIPS_BRD_PACRP_WP3(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP3_SHIFT, AIPS_PACRP_WP3_WIDTH))

/*! @brief Set the WP3 field to a new value. */
#define AIPS_WR_PACRP_WP3(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP3_MASK, AIPS_PACRP_WP3(value)))
#define AIPS_BWR_PACRP_WP3(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP3_SHIFT), AIPS_PACRP_WP3_SHIFT, AIPS_PACRP_WP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP3[18] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP3 field. */
#define AIPS_RD_PACRP_SP3(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP3_MASK) >> AIPS_PACRP_SP3_SHIFT)
#define AIPS_BRD_PACRP_SP3(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP3_SHIFT, AIPS_PACRP_SP3_WIDTH))

/*! @brief Set the SP3 field to a new value. */
#define AIPS_WR_PACRP_SP3(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP3_MASK, AIPS_PACRP_SP3(value)))
#define AIPS_BWR_PACRP_SP3(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP3_SHIFT), AIPS_PACRP_SP3_SHIFT, AIPS_PACRP_SP3_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP2[20] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP2 field. */
#define AIPS_RD_PACRP_TP2(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP2_MASK) >> AIPS_PACRP_TP2_SHIFT)
#define AIPS_BRD_PACRP_TP2(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP2_SHIFT, AIPS_PACRP_TP2_WIDTH))

/*! @brief Set the TP2 field to a new value. */
#define AIPS_WR_PACRP_TP2(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP2_MASK, AIPS_PACRP_TP2(value)))
#define AIPS_BWR_PACRP_TP2(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP2_SHIFT), AIPS_PACRP_TP2_SHIFT, AIPS_PACRP_TP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP2[21] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP2 field. */
#define AIPS_RD_PACRP_WP2(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP2_MASK) >> AIPS_PACRP_WP2_SHIFT)
#define AIPS_BRD_PACRP_WP2(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP2_SHIFT, AIPS_PACRP_WP2_WIDTH))

/*! @brief Set the WP2 field to a new value. */
#define AIPS_WR_PACRP_WP2(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP2_MASK, AIPS_PACRP_WP2(value)))
#define AIPS_BWR_PACRP_WP2(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP2_SHIFT), AIPS_PACRP_WP2_SHIFT, AIPS_PACRP_WP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP2[22] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this bit is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control bit for the master must be
 * set. If not, access terminates with an error response and no peripheral access
 * initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP2 field. */
#define AIPS_RD_PACRP_SP2(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP2_MASK) >> AIPS_PACRP_SP2_SHIFT)
#define AIPS_BRD_PACRP_SP2(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP2_SHIFT, AIPS_PACRP_SP2_WIDTH))

/*! @brief Set the SP2 field to a new value. */
#define AIPS_WR_PACRP_SP2(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP2_MASK, AIPS_PACRP_SP2(value)))
#define AIPS_BWR_PACRP_SP2(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP2_SHIFT), AIPS_PACRP_SP2_SHIFT, AIPS_PACRP_SP2_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP1[24] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this field is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP1 field. */
#define AIPS_RD_PACRP_TP1(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP1_MASK) >> AIPS_PACRP_TP1_SHIFT)
#define AIPS_BRD_PACRP_TP1(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP1_SHIFT, AIPS_PACRP_TP1_WIDTH))

/*! @brief Set the TP1 field to a new value. */
#define AIPS_WR_PACRP_TP1(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP1_MASK, AIPS_PACRP_TP1(value)))
#define AIPS_BWR_PACRP_TP1(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP1_SHIFT), AIPS_PACRP_TP1_SHIFT, AIPS_PACRP_TP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP1[25] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP1 field. */
#define AIPS_RD_PACRP_WP1(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP1_MASK) >> AIPS_PACRP_WP1_SHIFT)
#define AIPS_BRD_PACRP_WP1(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP1_SHIFT, AIPS_PACRP_WP1_WIDTH))

/*! @brief Set the WP1 field to a new value. */
#define AIPS_WR_PACRP_WP1(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP1_MASK, AIPS_PACRP_WP1(value)))
#define AIPS_BWR_PACRP_WP1(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP1_SHIFT), AIPS_PACRP_WP1_SHIFT, AIPS_PACRP_WP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP1[26] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * access. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master must
 * be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP1 field. */
#define AIPS_RD_PACRP_SP1(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP1_MASK) >> AIPS_PACRP_SP1_SHIFT)
#define AIPS_BRD_PACRP_SP1(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP1_SHIFT, AIPS_PACRP_SP1_WIDTH))

/*! @brief Set the SP1 field to a new value. */
#define AIPS_WR_PACRP_SP1(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP1_MASK, AIPS_PACRP_SP1(value)))
#define AIPS_BWR_PACRP_SP1(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP1_SHIFT), AIPS_PACRP_SP1_SHIFT, AIPS_PACRP_SP1_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field TP0[28] (RW)
 *
 * Determines whether the peripheral allows accesses from an untrusted master.
 * When this bit is set and an access is attempted by an untrusted master, the
 * access terminates with an error response and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - Accesses from an untrusted master are allowed.
 * - 0b1 - Accesses from an untrusted master are not allowed.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_TP0 field. */
#define AIPS_RD_PACRP_TP0(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_TP0_MASK) >> AIPS_PACRP_TP0_SHIFT)
#define AIPS_BRD_PACRP_TP0(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_TP0_SHIFT, AIPS_PACRP_TP0_WIDTH))

/*! @brief Set the TP0 field to a new value. */
#define AIPS_WR_PACRP_TP0(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_TP0_MASK, AIPS_PACRP_TP0(value)))
#define AIPS_BWR_PACRP_TP0(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_TP0_SHIFT), AIPS_PACRP_TP0_SHIFT, AIPS_PACRP_TP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field WP0[29] (RW)
 *
 * Determines whether the peripheral allows write accesses. When this field is
 * set and a write access is attempted, access terminates with an error response
 * and no peripheral access initiates.
 *
 * Values:
 * - 0b0 - This peripheral allows write accesses.
 * - 0b1 - This peripheral is write protected.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_WP0 field. */
#define AIPS_RD_PACRP_WP0(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_WP0_MASK) >> AIPS_PACRP_WP0_SHIFT)
#define AIPS_BRD_PACRP_WP0(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_WP0_SHIFT, AIPS_PACRP_WP0_WIDTH))

/*! @brief Set the WP0 field to a new value. */
#define AIPS_WR_PACRP_WP0(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_WP0_MASK, AIPS_PACRP_WP0(value)))
#define AIPS_BWR_PACRP_WP0(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_WP0_SHIFT), AIPS_PACRP_WP0_SHIFT, AIPS_PACRP_WP0_WIDTH))
/*@}*/

/*!
 * @name Register AIPS_PACRP, field SP0[30] (RW)
 *
 * Determines whether the peripheral requires supervisor privilege level for
 * accesses. When this field is set, the master privilege level must indicate the
 * supervisor access attribute, and the MPRx[MPLn] control field for the master
 * must be set. If not, access terminates with an error response and no peripheral
 * access initiates.
 *
 * Values:
 * - 0b0 - This peripheral does not require supervisor privilege level for
 *     accesses.
 * - 0b1 - This peripheral requires supervisor privilege level for accesses.
 */
/*@{*/
/*! @brief Read current value of the AIPS_PACRP_SP0 field. */
#define AIPS_RD_PACRP_SP0(base) ((AIPS_PACRP_REG(base) & AIPS_PACRP_SP0_MASK) >> AIPS_PACRP_SP0_SHIFT)
#define AIPS_BRD_PACRP_SP0(base) (BME_UBFX32(&AIPS_PACRP_REG(base), AIPS_PACRP_SP0_SHIFT, AIPS_PACRP_SP0_WIDTH))

/*! @brief Set the SP0 field to a new value. */
#define AIPS_WR_PACRP_SP0(base, value) (AIPS_RMW_PACRP(base, AIPS_PACRP_SP0_MASK, AIPS_PACRP_SP0(value)))
#define AIPS_BWR_PACRP_SP0(base, value) (BME_BFI32(&AIPS_PACRP_REG(base), ((uint32_t)(value) << AIPS_PACRP_SP0_SHIFT), AIPS_PACRP_SP0_SHIFT, AIPS_PACRP_SP0_WIDTH))
/*@}*/

/*
 * MKV58F24 AOI
 *
 * AND/OR/INVERT module
 *
 * Registers defined in this header file:
 * - AOI_BFCRT01 - Boolean Function Term 0 and 1 Configuration Register for EVENTn
 * - AOI_BFCRT23 - Boolean Function Term 2 and 3 Configuration Register for EVENTn
 */

#define AOI_INSTANCE_COUNT (1U) /*!< Number of instances of the AOI module. */
#define AOI0_IDX (0U) /*!< Instance number for AOI0. */

/*******************************************************************************
 * AOI_BFCRT01 - Boolean Function Term 0 and 1 Configuration Register for EVENTn
 ******************************************************************************/

/*!
 * @brief AOI_BFCRT01 - Boolean Function Term 0 and 1 Configuration Register for EVENTn (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire AOI_BFCRT01 register
 */
/*@{*/
#define AOI_RD_BFCRT01(base, index) (AOI_BFCRT01_REG(base, index))
#define AOI_WR_BFCRT01(base, index, value) (AOI_BFCRT01_REG(base, index) = (value))
#define AOI_RMW_BFCRT01(base, index, mask, value) (AOI_WR_BFCRT01(base, index, (AOI_RD_BFCRT01(base, index) & ~(mask)) | (value)))
#define AOI_SET_BFCRT01(base, index, value) (BME_OR16(&AOI_BFCRT01_REG(base, index), (uint16_t)(value)))
#define AOI_CLR_BFCRT01(base, index, value) (BME_AND16(&AOI_BFCRT01_REG(base, index), (uint16_t)(~(value))))
#define AOI_TOG_BFCRT01(base, index, value) (BME_XOR16(&AOI_BFCRT01_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AOI_BFCRT01 bitfields
 */

/*!
 * @name Register AOI_BFCRT01, field PT1_DC[1:0] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input D in product term 1.
 *
 * Values:
 * - 0b00 - Force the D input in this product term to a logical zero
 * - 0b01 - Pass the D input in this product term
 * - 0b10 - Complement the D input in this product term
 * - 0b11 - Force the D input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT1_DC field. */
#define AOI_RD_BFCRT01_PT1_DC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT1_DC_MASK) >> AOI_BFCRT01_PT1_DC_SHIFT)
#define AOI_BRD_BFCRT01_PT1_DC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT1_DC_SHIFT, AOI_BFCRT01_PT1_DC_WIDTH))

/*! @brief Set the PT1_DC field to a new value. */
#define AOI_WR_BFCRT01_PT1_DC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT1_DC_MASK, AOI_BFCRT01_PT1_DC(value)))
#define AOI_BWR_BFCRT01_PT1_DC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT1_DC_SHIFT), AOI_BFCRT01_PT1_DC_SHIFT, AOI_BFCRT01_PT1_DC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT1_CC[3:2] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input C in product term 1.
 *
 * Values:
 * - 0b00 - Force the C input in this product term to a logical zero
 * - 0b01 - Pass the C input in this product term
 * - 0b10 - Complement the C input in this product term
 * - 0b11 - Force the C input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT1_CC field. */
#define AOI_RD_BFCRT01_PT1_CC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT1_CC_MASK) >> AOI_BFCRT01_PT1_CC_SHIFT)
#define AOI_BRD_BFCRT01_PT1_CC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT1_CC_SHIFT, AOI_BFCRT01_PT1_CC_WIDTH))

/*! @brief Set the PT1_CC field to a new value. */
#define AOI_WR_BFCRT01_PT1_CC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT1_CC_MASK, AOI_BFCRT01_PT1_CC(value)))
#define AOI_BWR_BFCRT01_PT1_CC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT1_CC_SHIFT), AOI_BFCRT01_PT1_CC_SHIFT, AOI_BFCRT01_PT1_CC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT1_BC[5:4] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input B in product term 1.
 *
 * Values:
 * - 0b00 - Force the B input in this product term to a logical zero
 * - 0b01 - Pass the B input in this product term
 * - 0b10 - Complement the B input in this product term
 * - 0b11 - Force the B input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT1_BC field. */
#define AOI_RD_BFCRT01_PT1_BC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT1_BC_MASK) >> AOI_BFCRT01_PT1_BC_SHIFT)
#define AOI_BRD_BFCRT01_PT1_BC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT1_BC_SHIFT, AOI_BFCRT01_PT1_BC_WIDTH))

/*! @brief Set the PT1_BC field to a new value. */
#define AOI_WR_BFCRT01_PT1_BC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT1_BC_MASK, AOI_BFCRT01_PT1_BC(value)))
#define AOI_BWR_BFCRT01_PT1_BC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT1_BC_SHIFT), AOI_BFCRT01_PT1_BC_SHIFT, AOI_BFCRT01_PT1_BC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT1_AC[7:6] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input A in product term 1.
 *
 * Values:
 * - 0b00 - Force the A input in this product term to a logical zero
 * - 0b01 - Pass the A input in this product term
 * - 0b10 - Complement the A input in this product term
 * - 0b11 - Force the A input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT1_AC field. */
#define AOI_RD_BFCRT01_PT1_AC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT1_AC_MASK) >> AOI_BFCRT01_PT1_AC_SHIFT)
#define AOI_BRD_BFCRT01_PT1_AC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT1_AC_SHIFT, AOI_BFCRT01_PT1_AC_WIDTH))

/*! @brief Set the PT1_AC field to a new value. */
#define AOI_WR_BFCRT01_PT1_AC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT1_AC_MASK, AOI_BFCRT01_PT1_AC(value)))
#define AOI_BWR_BFCRT01_PT1_AC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT1_AC_SHIFT), AOI_BFCRT01_PT1_AC_SHIFT, AOI_BFCRT01_PT1_AC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT0_DC[9:8] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input D in product term 0.
 *
 * Values:
 * - 0b00 - Force the D input in this product term to a logical zero
 * - 0b01 - Pass the D input in this product term
 * - 0b10 - Complement the D input in this product term
 * - 0b11 - Force the D input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT0_DC field. */
#define AOI_RD_BFCRT01_PT0_DC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT0_DC_MASK) >> AOI_BFCRT01_PT0_DC_SHIFT)
#define AOI_BRD_BFCRT01_PT0_DC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT0_DC_SHIFT, AOI_BFCRT01_PT0_DC_WIDTH))

/*! @brief Set the PT0_DC field to a new value. */
#define AOI_WR_BFCRT01_PT0_DC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT0_DC_MASK, AOI_BFCRT01_PT0_DC(value)))
#define AOI_BWR_BFCRT01_PT0_DC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT0_DC_SHIFT), AOI_BFCRT01_PT0_DC_SHIFT, AOI_BFCRT01_PT0_DC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT0_CC[11:10] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input C in product term 0.
 *
 * Values:
 * - 0b00 - Force the C input in this product term to a logical zero
 * - 0b01 - Pass the C input in this product term
 * - 0b10 - Complement the C input in this product term
 * - 0b11 - Force the C input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT0_CC field. */
#define AOI_RD_BFCRT01_PT0_CC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT0_CC_MASK) >> AOI_BFCRT01_PT0_CC_SHIFT)
#define AOI_BRD_BFCRT01_PT0_CC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT0_CC_SHIFT, AOI_BFCRT01_PT0_CC_WIDTH))

/*! @brief Set the PT0_CC field to a new value. */
#define AOI_WR_BFCRT01_PT0_CC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT0_CC_MASK, AOI_BFCRT01_PT0_CC(value)))
#define AOI_BWR_BFCRT01_PT0_CC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT0_CC_SHIFT), AOI_BFCRT01_PT0_CC_SHIFT, AOI_BFCRT01_PT0_CC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT0_BC[13:12] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input B in product term 0.
 *
 * Values:
 * - 0b00 - Force the B input in this product term to a logical zero
 * - 0b01 - Pass the B input in this product term
 * - 0b10 - Complement the B input in this product term
 * - 0b11 - Force the B input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT0_BC field. */
#define AOI_RD_BFCRT01_PT0_BC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT0_BC_MASK) >> AOI_BFCRT01_PT0_BC_SHIFT)
#define AOI_BRD_BFCRT01_PT0_BC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT0_BC_SHIFT, AOI_BFCRT01_PT0_BC_WIDTH))

/*! @brief Set the PT0_BC field to a new value. */
#define AOI_WR_BFCRT01_PT0_BC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT0_BC_MASK, AOI_BFCRT01_PT0_BC(value)))
#define AOI_BWR_BFCRT01_PT0_BC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT0_BC_SHIFT), AOI_BFCRT01_PT0_BC_SHIFT, AOI_BFCRT01_PT0_BC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT01, field PT0_AC[15:14] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input A in product term 0.
 *
 * Values:
 * - 0b00 - Force the A input in this product term to a logical zero
 * - 0b01 - Pass the A input in this product term
 * - 0b10 - Complement the A input in this product term
 * - 0b11 - Force the A input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT01_PT0_AC field. */
#define AOI_RD_BFCRT01_PT0_AC(base, index) ((AOI_BFCRT01_REG(base, index) & AOI_BFCRT01_PT0_AC_MASK) >> AOI_BFCRT01_PT0_AC_SHIFT)
#define AOI_BRD_BFCRT01_PT0_AC(base, index) (BME_UBFX16(&AOI_BFCRT01_REG(base, index), AOI_BFCRT01_PT0_AC_SHIFT, AOI_BFCRT01_PT0_AC_WIDTH))

/*! @brief Set the PT0_AC field to a new value. */
#define AOI_WR_BFCRT01_PT0_AC(base, index, value) (AOI_RMW_BFCRT01(base, index, AOI_BFCRT01_PT0_AC_MASK, AOI_BFCRT01_PT0_AC(value)))
#define AOI_BWR_BFCRT01_PT0_AC(base, index, value) (BME_BFI16(&AOI_BFCRT01_REG(base, index), ((uint16_t)(value) << AOI_BFCRT01_PT0_AC_SHIFT), AOI_BFCRT01_PT0_AC_SHIFT, AOI_BFCRT01_PT0_AC_WIDTH))
/*@}*/

/*******************************************************************************
 * AOI_BFCRT23 - Boolean Function Term 2 and 3 Configuration Register for EVENTn
 ******************************************************************************/

/*!
 * @brief AOI_BFCRT23 - Boolean Function Term 2 and 3 Configuration Register for EVENTn (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire AOI_BFCRT23 register
 */
/*@{*/
#define AOI_RD_BFCRT23(base, index) (AOI_BFCRT23_REG(base, index))
#define AOI_WR_BFCRT23(base, index, value) (AOI_BFCRT23_REG(base, index) = (value))
#define AOI_RMW_BFCRT23(base, index, mask, value) (AOI_WR_BFCRT23(base, index, (AOI_RD_BFCRT23(base, index) & ~(mask)) | (value)))
#define AOI_SET_BFCRT23(base, index, value) (BME_OR16(&AOI_BFCRT23_REG(base, index), (uint16_t)(value)))
#define AOI_CLR_BFCRT23(base, index, value) (BME_AND16(&AOI_BFCRT23_REG(base, index), (uint16_t)(~(value))))
#define AOI_TOG_BFCRT23(base, index, value) (BME_XOR16(&AOI_BFCRT23_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AOI_BFCRT23 bitfields
 */

/*!
 * @name Register AOI_BFCRT23, field PT3_DC[1:0] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input D in product term 3.
 *
 * Values:
 * - 0b00 - Force the D input in this product term to a logical zero
 * - 0b01 - Pass the D input in this product term
 * - 0b10 - Complement the D input in this product term
 * - 0b11 - Force the D input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT3_DC field. */
#define AOI_RD_BFCRT23_PT3_DC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT3_DC_MASK) >> AOI_BFCRT23_PT3_DC_SHIFT)
#define AOI_BRD_BFCRT23_PT3_DC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT3_DC_SHIFT, AOI_BFCRT23_PT3_DC_WIDTH))

/*! @brief Set the PT3_DC field to a new value. */
#define AOI_WR_BFCRT23_PT3_DC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT3_DC_MASK, AOI_BFCRT23_PT3_DC(value)))
#define AOI_BWR_BFCRT23_PT3_DC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT3_DC_SHIFT), AOI_BFCRT23_PT3_DC_SHIFT, AOI_BFCRT23_PT3_DC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT3_CC[3:2] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input C in product term 3.
 *
 * Values:
 * - 0b00 - Force the C input in this product term to a logical zero
 * - 0b01 - Pass the C input in this product term
 * - 0b10 - Complement the C input in this product term
 * - 0b11 - Force the C input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT3_CC field. */
#define AOI_RD_BFCRT23_PT3_CC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT3_CC_MASK) >> AOI_BFCRT23_PT3_CC_SHIFT)
#define AOI_BRD_BFCRT23_PT3_CC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT3_CC_SHIFT, AOI_BFCRT23_PT3_CC_WIDTH))

/*! @brief Set the PT3_CC field to a new value. */
#define AOI_WR_BFCRT23_PT3_CC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT3_CC_MASK, AOI_BFCRT23_PT3_CC(value)))
#define AOI_BWR_BFCRT23_PT3_CC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT3_CC_SHIFT), AOI_BFCRT23_PT3_CC_SHIFT, AOI_BFCRT23_PT3_CC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT3_BC[5:4] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input B in product term 3.
 *
 * Values:
 * - 0b00 - Force the B input in this product term to a logical zero
 * - 0b01 - Pass the B input in this product term
 * - 0b10 - Complement the B input in this product term
 * - 0b11 - Force the B input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT3_BC field. */
#define AOI_RD_BFCRT23_PT3_BC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT3_BC_MASK) >> AOI_BFCRT23_PT3_BC_SHIFT)
#define AOI_BRD_BFCRT23_PT3_BC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT3_BC_SHIFT, AOI_BFCRT23_PT3_BC_WIDTH))

/*! @brief Set the PT3_BC field to a new value. */
#define AOI_WR_BFCRT23_PT3_BC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT3_BC_MASK, AOI_BFCRT23_PT3_BC(value)))
#define AOI_BWR_BFCRT23_PT3_BC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT3_BC_SHIFT), AOI_BFCRT23_PT3_BC_SHIFT, AOI_BFCRT23_PT3_BC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT3_AC[7:6] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input A in product term 3.
 *
 * Values:
 * - 0b00 - Force the A input in this product term to a logical zero
 * - 0b01 - Pass the A input in this product term
 * - 0b10 - Complement the A input in this product term
 * - 0b11 - Force the A input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT3_AC field. */
#define AOI_RD_BFCRT23_PT3_AC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT3_AC_MASK) >> AOI_BFCRT23_PT3_AC_SHIFT)
#define AOI_BRD_BFCRT23_PT3_AC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT3_AC_SHIFT, AOI_BFCRT23_PT3_AC_WIDTH))

/*! @brief Set the PT3_AC field to a new value. */
#define AOI_WR_BFCRT23_PT3_AC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT3_AC_MASK, AOI_BFCRT23_PT3_AC(value)))
#define AOI_BWR_BFCRT23_PT3_AC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT3_AC_SHIFT), AOI_BFCRT23_PT3_AC_SHIFT, AOI_BFCRT23_PT3_AC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT2_DC[9:8] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input D in product term 2.
 *
 * Values:
 * - 0b00 - Force the D input in this product term to a logical zero
 * - 0b01 - Pass the D input in this product term
 * - 0b10 - Complement the D input in this product term
 * - 0b11 - Force the D input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT2_DC field. */
#define AOI_RD_BFCRT23_PT2_DC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT2_DC_MASK) >> AOI_BFCRT23_PT2_DC_SHIFT)
#define AOI_BRD_BFCRT23_PT2_DC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT2_DC_SHIFT, AOI_BFCRT23_PT2_DC_WIDTH))

/*! @brief Set the PT2_DC field to a new value. */
#define AOI_WR_BFCRT23_PT2_DC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT2_DC_MASK, AOI_BFCRT23_PT2_DC(value)))
#define AOI_BWR_BFCRT23_PT2_DC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT2_DC_SHIFT), AOI_BFCRT23_PT2_DC_SHIFT, AOI_BFCRT23_PT2_DC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT2_CC[11:10] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input C in product term 2.
 *
 * Values:
 * - 0b00 - Force the C input in this product term to a logical zero
 * - 0b01 - Pass the C input in this product term
 * - 0b10 - Complement the C input in this product term
 * - 0b11 - Force the C input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT2_CC field. */
#define AOI_RD_BFCRT23_PT2_CC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT2_CC_MASK) >> AOI_BFCRT23_PT2_CC_SHIFT)
#define AOI_BRD_BFCRT23_PT2_CC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT2_CC_SHIFT, AOI_BFCRT23_PT2_CC_WIDTH))

/*! @brief Set the PT2_CC field to a new value. */
#define AOI_WR_BFCRT23_PT2_CC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT2_CC_MASK, AOI_BFCRT23_PT2_CC(value)))
#define AOI_BWR_BFCRT23_PT2_CC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT2_CC_SHIFT), AOI_BFCRT23_PT2_CC_SHIFT, AOI_BFCRT23_PT2_CC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT2_BC[13:12] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input B in product term 2.
 *
 * Values:
 * - 0b00 - Force the B input in this product term to a logical zero
 * - 0b01 - Pass the B input in this product term
 * - 0b10 - Complement the B input in this product term
 * - 0b11 - Force the B input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT2_BC field. */
#define AOI_RD_BFCRT23_PT2_BC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT2_BC_MASK) >> AOI_BFCRT23_PT2_BC_SHIFT)
#define AOI_BRD_BFCRT23_PT2_BC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT2_BC_SHIFT, AOI_BFCRT23_PT2_BC_WIDTH))

/*! @brief Set the PT2_BC field to a new value. */
#define AOI_WR_BFCRT23_PT2_BC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT2_BC_MASK, AOI_BFCRT23_PT2_BC(value)))
#define AOI_BWR_BFCRT23_PT2_BC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT2_BC_SHIFT), AOI_BFCRT23_PT2_BC_SHIFT, AOI_BFCRT23_PT2_BC_WIDTH))
/*@}*/

/*!
 * @name Register AOI_BFCRT23, field PT2_AC[15:14] (RW)
 *
 * This 2-bit field defines the Boolean evaluation associated with the selected
 * input A in product term 2.
 *
 * Values:
 * - 0b00 - Force the A input in this product term to a logical zero
 * - 0b01 - Pass the A input in this product term
 * - 0b10 - Complement the A input in this product term
 * - 0b11 - Force the A input in this product term to a logical one
 */
/*@{*/
/*! @brief Read current value of the AOI_BFCRT23_PT2_AC field. */
#define AOI_RD_BFCRT23_PT2_AC(base, index) ((AOI_BFCRT23_REG(base, index) & AOI_BFCRT23_PT2_AC_MASK) >> AOI_BFCRT23_PT2_AC_SHIFT)
#define AOI_BRD_BFCRT23_PT2_AC(base, index) (BME_UBFX16(&AOI_BFCRT23_REG(base, index), AOI_BFCRT23_PT2_AC_SHIFT, AOI_BFCRT23_PT2_AC_WIDTH))

/*! @brief Set the PT2_AC field to a new value. */
#define AOI_WR_BFCRT23_PT2_AC(base, index, value) (AOI_RMW_BFCRT23(base, index, AOI_BFCRT23_PT2_AC_MASK, AOI_BFCRT23_PT2_AC(value)))
#define AOI_BWR_BFCRT23_PT2_AC(base, index, value) (BME_BFI16(&AOI_BFCRT23_REG(base, index), ((uint16_t)(value) << AOI_BFCRT23_PT2_AC_SHIFT), AOI_BFCRT23_PT2_AC_SHIFT, AOI_BFCRT23_PT2_AC_WIDTH))
/*@}*/

/*
 * MKV58F24 AXBS
 *
 * Crossbar switch
 *
 * Registers defined in this header file:
 * - AXBS_PRS - Priority Registers Slave
 * - AXBS_CRS - Control Register
 * - AXBS_MGPCR0 - Master General Purpose Control Register
 * - AXBS_MGPCR1 - Master General Purpose Control Register
 * - AXBS_MGPCR2 - Master General Purpose Control Register
 * - AXBS_MGPCR3 - Master General Purpose Control Register
 */

#define AXBS_INSTANCE_COUNT (1U) /*!< Number of instances of the AXBS module. */
#define AXBS_IDX (0U) /*!< Instance number for AXBS. */

/*******************************************************************************
 * AXBS_PRS - Priority Registers Slave
 ******************************************************************************/

/*!
 * @brief AXBS_PRS - Priority Registers Slave (RW)
 *
 * Reset value: 0x00003210U
 *
 * The priority registers (PRSn) set the priority of each master port on a per
 * slave port basis and reside in each slave port. The priority register can be
 * accessed only with 32-bit accesses. After the CRSn[RO] bit is set, the PRSn
 * register can only be read; attempts to write to it have no effect on PRSn and
 * result in a bus-error response to the master initiating the write. Two available
 * masters must not be programmed with the same priority level. Attempts to
 * program two or more masters with the same priority level result in a bus-error
 * response and the PRSn is not updated. Valid values for the Mn priority fields
 * depend on which masters are available on the chip. This information can be found in
 * the chip-specific information for the crossbar. If the chip contains less
 * than five masters, values 0 to 3 are valid. Writing other values will result in
 * an error. If the chip contains five or more masters, valid values are 0 to n-1,
 * where n is the number of masters attached to the Crossbar Switch. Other
 * values will result in an error. See the chip-specific crossbar information for the
 * reset value of this register.
 */
/*!
 * @name Constants and macros for entire AXBS_PRS register
 */
/*@{*/
#define AXBS_RD_PRS(base, index) (AXBS_PRS_REG(base, index))
#define AXBS_WR_PRS(base, index, value) (AXBS_PRS_REG(base, index) = (value))
#define AXBS_RMW_PRS(base, index, mask, value) (AXBS_WR_PRS(base, index, (AXBS_RD_PRS(base, index) & ~(mask)) | (value)))
#define AXBS_SET_PRS(base, index, value) (BME_OR32(&AXBS_PRS_REG(base, index), (uint32_t)(value)))
#define AXBS_CLR_PRS(base, index, value) (BME_AND32(&AXBS_PRS_REG(base, index), (uint32_t)(~(value))))
#define AXBS_TOG_PRS(base, index, value) (BME_XOR32(&AXBS_PRS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_PRS bitfields
 */

/*!
 * @name Register AXBS_PRS, field M0[2:0] (RW)
 *
 * Values:
 * - 0b000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 0b001 - This master has level 2 priority when accessing the slave port.
 * - 0b010 - This master has level 3 priority when accessing the slave port.
 * - 0b011 - This master has level 4 priority when accessing the slave port.
 * - 0b100 - This master has level 5 priority when accessing the slave port.
 * - 0b101 - This master has level 6 priority when accessing the slave port.
 * - 0b110 - This master has level 7 priority when accessing the slave port.
 * - 0b111 - This master has level 8, or lowest, priority when accessing the
 *     slave port.
 */
/*@{*/
/*! @brief Read current value of the AXBS_PRS_M0 field. */
#define AXBS_RD_PRS_M0(base, index) ((AXBS_PRS_REG(base, index) & AXBS_PRS_M0_MASK) >> AXBS_PRS_M0_SHIFT)
#define AXBS_BRD_PRS_M0(base, index) (BME_UBFX32(&AXBS_PRS_REG(base, index), AXBS_PRS_M0_SHIFT, AXBS_PRS_M0_WIDTH))

/*! @brief Set the M0 field to a new value. */
#define AXBS_WR_PRS_M0(base, index, value) (AXBS_RMW_PRS(base, index, AXBS_PRS_M0_MASK, AXBS_PRS_M0(value)))
#define AXBS_BWR_PRS_M0(base, index, value) (BME_BFI32(&AXBS_PRS_REG(base, index), ((uint32_t)(value) << AXBS_PRS_M0_SHIFT), AXBS_PRS_M0_SHIFT, AXBS_PRS_M0_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_PRS, field M1[6:4] (RW)
 *
 * Values:
 * - 0b000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 0b001 - This master has level 2 priority when accessing the slave port.
 * - 0b010 - This master has level 3 priority when accessing the slave port.
 * - 0b011 - This master has level 4 priority when accessing the slave port.
 * - 0b100 - This master has level 5 priority when accessing the slave port.
 * - 0b101 - This master has level 6 priority when accessing the slave port.
 * - 0b110 - This master has level 7 priority when accessing the slave port.
 * - 0b111 - This master has level 8, or lowest, priority when accessing the
 *     slave port.
 */
/*@{*/
/*! @brief Read current value of the AXBS_PRS_M1 field. */
#define AXBS_RD_PRS_M1(base, index) ((AXBS_PRS_REG(base, index) & AXBS_PRS_M1_MASK) >> AXBS_PRS_M1_SHIFT)
#define AXBS_BRD_PRS_M1(base, index) (BME_UBFX32(&AXBS_PRS_REG(base, index), AXBS_PRS_M1_SHIFT, AXBS_PRS_M1_WIDTH))

/*! @brief Set the M1 field to a new value. */
#define AXBS_WR_PRS_M1(base, index, value) (AXBS_RMW_PRS(base, index, AXBS_PRS_M1_MASK, AXBS_PRS_M1(value)))
#define AXBS_BWR_PRS_M1(base, index, value) (BME_BFI32(&AXBS_PRS_REG(base, index), ((uint32_t)(value) << AXBS_PRS_M1_SHIFT), AXBS_PRS_M1_SHIFT, AXBS_PRS_M1_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_PRS, field M2[10:8] (RW)
 *
 * Values:
 * - 0b000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 0b001 - This master has level 2 priority when accessing the slave port.
 * - 0b010 - This master has level 3 priority when accessing the slave port.
 * - 0b011 - This master has level 4 priority when accessing the slave port.
 * - 0b100 - This master has level 5 priority when accessing the slave port.
 * - 0b101 - This master has level 6 priority when accessing the slave port.
 * - 0b110 - This master has level 7 priority when accessing the slave port.
 * - 0b111 - This master has level 8, or lowest, priority when accessing the
 *     slave port.
 */
/*@{*/
/*! @brief Read current value of the AXBS_PRS_M2 field. */
#define AXBS_RD_PRS_M2(base, index) ((AXBS_PRS_REG(base, index) & AXBS_PRS_M2_MASK) >> AXBS_PRS_M2_SHIFT)
#define AXBS_BRD_PRS_M2(base, index) (BME_UBFX32(&AXBS_PRS_REG(base, index), AXBS_PRS_M2_SHIFT, AXBS_PRS_M2_WIDTH))

/*! @brief Set the M2 field to a new value. */
#define AXBS_WR_PRS_M2(base, index, value) (AXBS_RMW_PRS(base, index, AXBS_PRS_M2_MASK, AXBS_PRS_M2(value)))
#define AXBS_BWR_PRS_M2(base, index, value) (BME_BFI32(&AXBS_PRS_REG(base, index), ((uint32_t)(value) << AXBS_PRS_M2_SHIFT), AXBS_PRS_M2_SHIFT, AXBS_PRS_M2_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_PRS, field M3[14:12] (RW)
 *
 * Values:
 * - 0b000 - This master has level 1, or highest, priority when accessing the
 *     slave port.
 * - 0b001 - This master has level 2 priority when accessing the slave port.
 * - 0b010 - This master has level 3 priority when accessing the slave port.
 * - 0b011 - This master has level 4 priority when accessing the slave port.
 * - 0b100 - This master has level 5 priority when accessing the slave port.
 * - 0b101 - This master has level 6 priority when accessing the slave port.
 * - 0b110 - This master has level 7 priority when accessing the slave port.
 * - 0b111 - This master has level 8, or lowest, priority when accessing the
 *     slave port.
 */
/*@{*/
/*! @brief Read current value of the AXBS_PRS_M3 field. */
#define AXBS_RD_PRS_M3(base, index) ((AXBS_PRS_REG(base, index) & AXBS_PRS_M3_MASK) >> AXBS_PRS_M3_SHIFT)
#define AXBS_BRD_PRS_M3(base, index) (BME_UBFX32(&AXBS_PRS_REG(base, index), AXBS_PRS_M3_SHIFT, AXBS_PRS_M3_WIDTH))

/*! @brief Set the M3 field to a new value. */
#define AXBS_WR_PRS_M3(base, index, value) (AXBS_RMW_PRS(base, index, AXBS_PRS_M3_MASK, AXBS_PRS_M3(value)))
#define AXBS_BWR_PRS_M3(base, index, value) (BME_BFI32(&AXBS_PRS_REG(base, index), ((uint32_t)(value) << AXBS_PRS_M3_SHIFT), AXBS_PRS_M3_SHIFT, AXBS_PRS_M3_WIDTH))
/*@}*/

/*******************************************************************************
 * AXBS_CRS - Control Register
 ******************************************************************************/

/*!
 * @brief AXBS_CRS - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers control several features of each slave port and must be
 * accessed using 32-bit accesses. After CRSn[RO] is set, the PRSn can only be read;
 * attempts to write to it have no effect and result in an error response. See the
 * chip-specific crossbar information for the reset value of this register.
 */
/*!
 * @name Constants and macros for entire AXBS_CRS register
 */
/*@{*/
#define AXBS_RD_CRS(base, index) (AXBS_CRS_REG(base, index))
#define AXBS_WR_CRS(base, index, value) (AXBS_CRS_REG(base, index) = (value))
#define AXBS_RMW_CRS(base, index, mask, value) (AXBS_WR_CRS(base, index, (AXBS_RD_CRS(base, index) & ~(mask)) | (value)))
#define AXBS_SET_CRS(base, index, value) (BME_OR32(&AXBS_CRS_REG(base, index), (uint32_t)(value)))
#define AXBS_CLR_CRS(base, index, value) (BME_AND32(&AXBS_CRS_REG(base, index), (uint32_t)(~(value))))
#define AXBS_TOG_CRS(base, index, value) (BME_XOR32(&AXBS_CRS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_CRS bitfields
 */

/*!
 * @name Register AXBS_CRS, field PARK[2:0] (RW)
 *
 * Determines which master port the current slave port parks on when no masters
 * are actively making requests and the PCTL bits are cleared. Select only master
 * ports that are present on the chip. Otherwise, undefined behavior might occur.
 *
 * Values:
 * - 0b000 - Park on master port M0
 * - 0b001 - Park on master port M1
 * - 0b010 - Park on master port M2
 * - 0b011 - Park on master port M3
 * - 0b100 - Park on master port M4
 * - 0b101 - Park on master port M5
 * - 0b110 - Park on master port M6
 * - 0b111 - Park on master port M7
 */
/*@{*/
/*! @brief Read current value of the AXBS_CRS_PARK field. */
#define AXBS_RD_CRS_PARK(base, index) ((AXBS_CRS_REG(base, index) & AXBS_CRS_PARK_MASK) >> AXBS_CRS_PARK_SHIFT)
#define AXBS_BRD_CRS_PARK(base, index) (BME_UBFX32(&AXBS_CRS_REG(base, index), AXBS_CRS_PARK_SHIFT, AXBS_CRS_PARK_WIDTH))

/*! @brief Set the PARK field to a new value. */
#define AXBS_WR_CRS_PARK(base, index, value) (AXBS_RMW_CRS(base, index, AXBS_CRS_PARK_MASK, AXBS_CRS_PARK(value)))
#define AXBS_BWR_CRS_PARK(base, index, value) (BME_BFI32(&AXBS_CRS_REG(base, index), ((uint32_t)(value) << AXBS_CRS_PARK_SHIFT), AXBS_CRS_PARK_SHIFT, AXBS_CRS_PARK_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_CRS, field PCTL[5:4] (RW)
 *
 * Determines the slave port's parking control. The low-power park feature
 * results in an overall power savings if the slave port is not saturated. However,
 * this forces an extra latency clock when any master tries to access the slave
 * port while not in use because it is not parked on any master.
 *
 * Values:
 * - 0b00 - When no master makes a request, the arbiter parks the slave port on
 *     the master port defined by the PARK field
 * - 0b01 - When no master makes a request, the arbiter parks the slave port on
 *     the last master to be in control of the slave port
 * - 0b10 - When no master makes a request, the slave port is not parked on a
 *     master and the arbiter drives all outputs to a constant safe state
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_CRS_PCTL field. */
#define AXBS_RD_CRS_PCTL(base, index) ((AXBS_CRS_REG(base, index) & AXBS_CRS_PCTL_MASK) >> AXBS_CRS_PCTL_SHIFT)
#define AXBS_BRD_CRS_PCTL(base, index) (BME_UBFX32(&AXBS_CRS_REG(base, index), AXBS_CRS_PCTL_SHIFT, AXBS_CRS_PCTL_WIDTH))

/*! @brief Set the PCTL field to a new value. */
#define AXBS_WR_CRS_PCTL(base, index, value) (AXBS_RMW_CRS(base, index, AXBS_CRS_PCTL_MASK, AXBS_CRS_PCTL(value)))
#define AXBS_BWR_CRS_PCTL(base, index, value) (BME_BFI32(&AXBS_CRS_REG(base, index), ((uint32_t)(value) << AXBS_CRS_PCTL_SHIFT), AXBS_CRS_PCTL_SHIFT, AXBS_CRS_PCTL_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_CRS, field ARB[9:8] (RW)
 *
 * Selects the arbitration policy for the slave port.
 *
 * Values:
 * - 0b00 - Fixed priority
 * - 0b01 - Round-robin, or rotating, priority
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_CRS_ARB field. */
#define AXBS_RD_CRS_ARB(base, index) ((AXBS_CRS_REG(base, index) & AXBS_CRS_ARB_MASK) >> AXBS_CRS_ARB_SHIFT)
#define AXBS_BRD_CRS_ARB(base, index) (BME_UBFX32(&AXBS_CRS_REG(base, index), AXBS_CRS_ARB_SHIFT, AXBS_CRS_ARB_WIDTH))

/*! @brief Set the ARB field to a new value. */
#define AXBS_WR_CRS_ARB(base, index, value) (AXBS_RMW_CRS(base, index, AXBS_CRS_ARB_MASK, AXBS_CRS_ARB(value)))
#define AXBS_BWR_CRS_ARB(base, index, value) (BME_BFI32(&AXBS_CRS_REG(base, index), ((uint32_t)(value) << AXBS_CRS_ARB_SHIFT), AXBS_CRS_ARB_SHIFT, AXBS_CRS_ARB_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_CRS, field HLP[30] (RW)
 *
 * Sets the initial arbitration priority for low power mode requests . Setting
 * this bit will not affect the request for low power mode from attaining highest
 * priority once it has control of the slave ports.
 *
 * Values:
 * - 0b0 - The low power mode request has the highest priority for arbitration
 *     on this slave port
 * - 0b1 - The low power mode request has the lowest initial priority for
 *     arbitration on this slave port
 */
/*@{*/
/*! @brief Read current value of the AXBS_CRS_HLP field. */
#define AXBS_RD_CRS_HLP(base, index) ((AXBS_CRS_REG(base, index) & AXBS_CRS_HLP_MASK) >> AXBS_CRS_HLP_SHIFT)
#define AXBS_BRD_CRS_HLP(base, index) (BME_UBFX32(&AXBS_CRS_REG(base, index), AXBS_CRS_HLP_SHIFT, AXBS_CRS_HLP_WIDTH))

/*! @brief Set the HLP field to a new value. */
#define AXBS_WR_CRS_HLP(base, index, value) (AXBS_RMW_CRS(base, index, AXBS_CRS_HLP_MASK, AXBS_CRS_HLP(value)))
#define AXBS_BWR_CRS_HLP(base, index, value) (BME_BFI32(&AXBS_CRS_REG(base, index), ((uint32_t)(value) << AXBS_CRS_HLP_SHIFT), AXBS_CRS_HLP_SHIFT, AXBS_CRS_HLP_WIDTH))
/*@}*/

/*!
 * @name Register AXBS_CRS, field RO[31] (RW)
 *
 * Forces the slave port's CSRn and PRSn registers to be read-only. After set,
 * only a hardware reset clears it.
 *
 * Values:
 * - 0b0 - The slave port's registers are writeable
 * - 0b1 - The slave port's registers are read-only and cannot be written.
 *     Attempted writes have no effect on the registers and result in a bus error
 *     response.
 */
/*@{*/
/*! @brief Read current value of the AXBS_CRS_RO field. */
#define AXBS_RD_CRS_RO(base, index) ((AXBS_CRS_REG(base, index) & AXBS_CRS_RO_MASK) >> AXBS_CRS_RO_SHIFT)
#define AXBS_BRD_CRS_RO(base, index) (BME_UBFX32(&AXBS_CRS_REG(base, index), AXBS_CRS_RO_SHIFT, AXBS_CRS_RO_WIDTH))

/*! @brief Set the RO field to a new value. */
#define AXBS_WR_CRS_RO(base, index, value) (AXBS_RMW_CRS(base, index, AXBS_CRS_RO_MASK, AXBS_CRS_RO(value)))
#define AXBS_BWR_CRS_RO(base, index, value) (BME_BFI32(&AXBS_CRS_REG(base, index), ((uint32_t)(value) << AXBS_CRS_RO_SHIFT), AXBS_CRS_RO_SHIFT, AXBS_CRS_RO_WIDTH))
/*@}*/

/*******************************************************************************
 * AXBS_MGPCR0 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief AXBS_MGPCR0 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses. If there are fewer than eight master ports, only the
 * registers associated with those masters are present. Register addresses
 * associated with master ports that are not present are reserved. Please see this
 * module's chip-specific information for which master ports are present on this
 * module.
 */
/*!
 * @name Constants and macros for entire AXBS_MGPCR0 register
 */
/*@{*/
#define AXBS_RD_MGPCR0(base)     (AXBS_MGPCR0_REG(base))
#define AXBS_WR_MGPCR0(base, value) (AXBS_MGPCR0_REG(base) = (value))
#define AXBS_RMW_MGPCR0(base, mask, value) (AXBS_WR_MGPCR0(base, (AXBS_RD_MGPCR0(base) & ~(mask)) | (value)))
#define AXBS_SET_MGPCR0(base, value) (BME_OR32(&AXBS_MGPCR0_REG(base), (uint32_t)(value)))
#define AXBS_CLR_MGPCR0(base, value) (BME_AND32(&AXBS_MGPCR0_REG(base), (uint32_t)(~(value))))
#define AXBS_TOG_MGPCR0(base, value) (BME_XOR32(&AXBS_MGPCR0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR0 bitfields
 */

/*!
 * @name Register AXBS_MGPCR0, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 0b000 - No arbitration is allowed during an undefined length burst
 * - 0b001 - Arbitration is allowed at any time during an undefined length burst
 * - 0b010 - Arbitration is allowed after four beats of an undefined length burst
 * - 0b011 - Arbitration is allowed after eight beats of an undefined length
 *     burst
 * - 0b100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_MGPCR0_AULB field. */
#define AXBS_RD_MGPCR0_AULB(base) ((AXBS_MGPCR0_REG(base) & AXBS_MGPCR0_AULB_MASK) >> AXBS_MGPCR0_AULB_SHIFT)
#define AXBS_BRD_MGPCR0_AULB(base) (BME_UBFX32(&AXBS_MGPCR0_REG(base), AXBS_MGPCR0_AULB_SHIFT, AXBS_MGPCR0_AULB_WIDTH))

/*! @brief Set the AULB field to a new value. */
#define AXBS_WR_MGPCR0_AULB(base, value) (AXBS_RMW_MGPCR0(base, AXBS_MGPCR0_AULB_MASK, AXBS_MGPCR0_AULB(value)))
#define AXBS_BWR_MGPCR0_AULB(base, value) (BME_BFI32(&AXBS_MGPCR0_REG(base), ((uint32_t)(value) << AXBS_MGPCR0_AULB_SHIFT), AXBS_MGPCR0_AULB_SHIFT, AXBS_MGPCR0_AULB_WIDTH))
/*@}*/

/*******************************************************************************
 * AXBS_MGPCR1 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief AXBS_MGPCR1 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses. If there are fewer than eight master ports, only the
 * registers associated with those masters are present. Register addresses
 * associated with master ports that are not present are reserved. Please see this
 * module's chip-specific information for which master ports are present on this
 * module.
 */
/*!
 * @name Constants and macros for entire AXBS_MGPCR1 register
 */
/*@{*/
#define AXBS_RD_MGPCR1(base)     (AXBS_MGPCR1_REG(base))
#define AXBS_WR_MGPCR1(base, value) (AXBS_MGPCR1_REG(base) = (value))
#define AXBS_RMW_MGPCR1(base, mask, value) (AXBS_WR_MGPCR1(base, (AXBS_RD_MGPCR1(base) & ~(mask)) | (value)))
#define AXBS_SET_MGPCR1(base, value) (BME_OR32(&AXBS_MGPCR1_REG(base), (uint32_t)(value)))
#define AXBS_CLR_MGPCR1(base, value) (BME_AND32(&AXBS_MGPCR1_REG(base), (uint32_t)(~(value))))
#define AXBS_TOG_MGPCR1(base, value) (BME_XOR32(&AXBS_MGPCR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR1 bitfields
 */

/*!
 * @name Register AXBS_MGPCR1, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 0b000 - No arbitration is allowed during an undefined length burst
 * - 0b001 - Arbitration is allowed at any time during an undefined length burst
 * - 0b010 - Arbitration is allowed after four beats of an undefined length burst
 * - 0b011 - Arbitration is allowed after eight beats of an undefined length
 *     burst
 * - 0b100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_MGPCR1_AULB field. */
#define AXBS_RD_MGPCR1_AULB(base) ((AXBS_MGPCR1_REG(base) & AXBS_MGPCR1_AULB_MASK) >> AXBS_MGPCR1_AULB_SHIFT)
#define AXBS_BRD_MGPCR1_AULB(base) (BME_UBFX32(&AXBS_MGPCR1_REG(base), AXBS_MGPCR1_AULB_SHIFT, AXBS_MGPCR1_AULB_WIDTH))

/*! @brief Set the AULB field to a new value. */
#define AXBS_WR_MGPCR1_AULB(base, value) (AXBS_RMW_MGPCR1(base, AXBS_MGPCR1_AULB_MASK, AXBS_MGPCR1_AULB(value)))
#define AXBS_BWR_MGPCR1_AULB(base, value) (BME_BFI32(&AXBS_MGPCR1_REG(base), ((uint32_t)(value) << AXBS_MGPCR1_AULB_SHIFT), AXBS_MGPCR1_AULB_SHIFT, AXBS_MGPCR1_AULB_WIDTH))
/*@}*/

/*******************************************************************************
 * AXBS_MGPCR2 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief AXBS_MGPCR2 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses. If there are fewer than eight master ports, only the
 * registers associated with those masters are present. Register addresses
 * associated with master ports that are not present are reserved. Please see this
 * module's chip-specific information for which master ports are present on this
 * module.
 */
/*!
 * @name Constants and macros for entire AXBS_MGPCR2 register
 */
/*@{*/
#define AXBS_RD_MGPCR2(base)     (AXBS_MGPCR2_REG(base))
#define AXBS_WR_MGPCR2(base, value) (AXBS_MGPCR2_REG(base) = (value))
#define AXBS_RMW_MGPCR2(base, mask, value) (AXBS_WR_MGPCR2(base, (AXBS_RD_MGPCR2(base) & ~(mask)) | (value)))
#define AXBS_SET_MGPCR2(base, value) (BME_OR32(&AXBS_MGPCR2_REG(base), (uint32_t)(value)))
#define AXBS_CLR_MGPCR2(base, value) (BME_AND32(&AXBS_MGPCR2_REG(base), (uint32_t)(~(value))))
#define AXBS_TOG_MGPCR2(base, value) (BME_XOR32(&AXBS_MGPCR2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR2 bitfields
 */

/*!
 * @name Register AXBS_MGPCR2, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 0b000 - No arbitration is allowed during an undefined length burst
 * - 0b001 - Arbitration is allowed at any time during an undefined length burst
 * - 0b010 - Arbitration is allowed after four beats of an undefined length burst
 * - 0b011 - Arbitration is allowed after eight beats of an undefined length
 *     burst
 * - 0b100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_MGPCR2_AULB field. */
#define AXBS_RD_MGPCR2_AULB(base) ((AXBS_MGPCR2_REG(base) & AXBS_MGPCR2_AULB_MASK) >> AXBS_MGPCR2_AULB_SHIFT)
#define AXBS_BRD_MGPCR2_AULB(base) (BME_UBFX32(&AXBS_MGPCR2_REG(base), AXBS_MGPCR2_AULB_SHIFT, AXBS_MGPCR2_AULB_WIDTH))

/*! @brief Set the AULB field to a new value. */
#define AXBS_WR_MGPCR2_AULB(base, value) (AXBS_RMW_MGPCR2(base, AXBS_MGPCR2_AULB_MASK, AXBS_MGPCR2_AULB(value)))
#define AXBS_BWR_MGPCR2_AULB(base, value) (BME_BFI32(&AXBS_MGPCR2_REG(base), ((uint32_t)(value) << AXBS_MGPCR2_AULB_SHIFT), AXBS_MGPCR2_AULB_SHIFT, AXBS_MGPCR2_AULB_WIDTH))
/*@}*/

/*******************************************************************************
 * AXBS_MGPCR3 - Master General Purpose Control Register
 ******************************************************************************/

/*!
 * @brief AXBS_MGPCR3 - Master General Purpose Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MGPCR controls only whether the master's undefined length burst accesses
 * are allowed to complete uninterrupted or whether they can be broken by
 * requests from higher priority masters. The MGPCR can be accessed only in Supervisor
 * mode with 32-bit accesses. If there are fewer than eight master ports, only the
 * registers associated with those masters are present. Register addresses
 * associated with master ports that are not present are reserved. Please see this
 * module's chip-specific information for which master ports are present on this
 * module.
 */
/*!
 * @name Constants and macros for entire AXBS_MGPCR3 register
 */
/*@{*/
#define AXBS_RD_MGPCR3(base)     (AXBS_MGPCR3_REG(base))
#define AXBS_WR_MGPCR3(base, value) (AXBS_MGPCR3_REG(base) = (value))
#define AXBS_RMW_MGPCR3(base, mask, value) (AXBS_WR_MGPCR3(base, (AXBS_RD_MGPCR3(base) & ~(mask)) | (value)))
#define AXBS_SET_MGPCR3(base, value) (BME_OR32(&AXBS_MGPCR3_REG(base), (uint32_t)(value)))
#define AXBS_CLR_MGPCR3(base, value) (BME_AND32(&AXBS_MGPCR3_REG(base), (uint32_t)(~(value))))
#define AXBS_TOG_MGPCR3(base, value) (BME_XOR32(&AXBS_MGPCR3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual AXBS_MGPCR3 bitfields
 */

/*!
 * @name Register AXBS_MGPCR3, field AULB[2:0] (RW)
 *
 * Determines whether, and when, the crossbar switch arbitrates away the slave
 * port the master owns when the master is performing undefined length burst
 * accesses.
 *
 * Values:
 * - 0b000 - No arbitration is allowed during an undefined length burst
 * - 0b001 - Arbitration is allowed at any time during an undefined length burst
 * - 0b010 - Arbitration is allowed after four beats of an undefined length burst
 * - 0b011 - Arbitration is allowed after eight beats of an undefined length
 *     burst
 * - 0b100 - Arbitration is allowed after 16 beats of an undefined length burst
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the AXBS_MGPCR3_AULB field. */
#define AXBS_RD_MGPCR3_AULB(base) ((AXBS_MGPCR3_REG(base) & AXBS_MGPCR3_AULB_MASK) >> AXBS_MGPCR3_AULB_SHIFT)
#define AXBS_BRD_MGPCR3_AULB(base) (BME_UBFX32(&AXBS_MGPCR3_REG(base), AXBS_MGPCR3_AULB_SHIFT, AXBS_MGPCR3_AULB_WIDTH))

/*! @brief Set the AULB field to a new value. */
#define AXBS_WR_MGPCR3_AULB(base, value) (AXBS_RMW_MGPCR3(base, AXBS_MGPCR3_AULB_MASK, AXBS_MGPCR3_AULB(value)))
#define AXBS_BWR_MGPCR3_AULB(base, value) (BME_BFI32(&AXBS_MGPCR3_REG(base), ((uint32_t)(value) << AXBS_MGPCR3_AULB_SHIFT), AXBS_MGPCR3_AULB_SHIFT, AXBS_MGPCR3_AULB_WIDTH))
/*@}*/

/*
 * MKV58F24 CAN
 *
 * Flex Controller Area Network module
 *
 * Registers defined in this header file:
 * - CAN_MCR - Module Configuration Register
 * - CAN_CTRL1 - Control 1 register
 * - CAN_TIMER - Free Running Timer
 * - CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 * - CAN_RX14MASK - Rx 14 Mask register
 * - CAN_RX15MASK - Rx 15 Mask register
 * - CAN_ECR - Error Counter
 * - CAN_ESR1 - Error and Status 1 register
 * - CAN_IMASK1 - Interrupt Masks 1 register
 * - CAN_IFLAG1 - Interrupt Flags 1 register
 * - CAN_CTRL2 - Control 2 register
 * - CAN_ESR2 - Error and Status 2 register
 * - CAN_CRCR - CRC Register
 * - CAN_RXFGMASK - Rx FIFO Global Mask register
 * - CAN_RXFIR - Rx FIFO Information Register
 * - CAN_CBT - CAN Bit Timing Register
 * - CAN_CS - Message Buffer 0 CS Register
 * - CAN_ID - Message Buffer 0 ID Register
 * - CAN_WORD0 - Message Buffer 0 WORD0 Register
 * - CAN_WORD1 - Message Buffer 0 WORD1 Register
 * - CAN_RXIMR - Rx Individual Mask Registers
 */

#define CAN_INSTANCE_COUNT (3U) /*!< Number of instances of the CAN module. */
#define CAN0_IDX (0U) /*!< Instance number for CAN0. */
#define CAN1_IDX (1U) /*!< Instance number for CAN1. */
#define CAN2_IDX (2U) /*!< Instance number for CAN2. */

/*******************************************************************************
 * CAN_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief CAN_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0xD890000FU
 *
 * This register defines global system configurations, such as the module
 * operation modes and the maximum message buffer configuration.
 */
/*!
 * @name Constants and macros for entire CAN_MCR register
 */
/*@{*/
#define CAN_RD_MCR(base)         (CAN_MCR_REG(base))
#define CAN_WR_MCR(base, value)  (CAN_MCR_REG(base) = (value))
#define CAN_RMW_MCR(base, mask, value) (CAN_WR_MCR(base, (CAN_RD_MCR(base) & ~(mask)) | (value)))
#define CAN_SET_MCR(base, value) (BME_OR32(&CAN_MCR_REG(base), (uint32_t)(value)))
#define CAN_CLR_MCR(base, value) (BME_AND32(&CAN_MCR_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_MCR(base, value) (BME_XOR32(&CAN_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_MCR bitfields
 */

/*!
 * @name Register CAN_MCR, field MAXMB[6:0] (RW)
 *
 * This 7-bit field defines the number of the last Message Buffers that will
 * take part in the matching and arbitration processes. The reset value (0x0F) is
 * equivalent to a 16 MB configuration. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Number of the last MB =
 * MAXMB MAXMB must be programmed with a value smaller than or equal to the number
 * of available Message Buffers. Additionally, the definition of MAXMB value
 * must take into account the region of MBs occupied by Rx FIFO and its ID filters
 * table space defined by RFFN bit in CAN_CTRL2 register. MAXMB also impacts the
 * definition of the minimum number of peripheral clocks per CAN bit as described
 * in Table "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate"
 * (see Arbitration and matching timing).
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MAXMB field. */
#define CAN_RD_MCR_MAXMB(base) ((CAN_MCR_REG(base) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT)
#define CAN_BRD_MCR_MAXMB(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_MAXMB_SHIFT, CAN_MCR_MAXMB_WIDTH))

/*! @brief Set the MAXMB field to a new value. */
#define CAN_WR_MCR_MAXMB(base, value) (CAN_RMW_MCR(base, CAN_MCR_MAXMB_MASK, CAN_MCR_MAXMB(value)))
#define CAN_BWR_MCR_MAXMB(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_MAXMB_SHIFT), CAN_MCR_MAXMB_SHIFT, CAN_MCR_MAXMB_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field IDAM[9:8] (RW)
 *
 * This 2-bit field identifies the format of the Rx FIFO ID Filter Table
 * elements. Note that all elements of the table are configured at the same time by this
 * field (they are all the same format). See Section "Rx FIFO Structure". This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes.
 *
 * Values:
 * - 0b00 - Format A: One full ID (standard and extended) per ID Filter Table
 *     element.
 * - 0b01 - Format B: Two full standard IDs or two partial 14-bit (standard and
 *     extended) IDs per ID Filter Table element.
 * - 0b10 - Format C: Four partial 8-bit Standard IDs per ID Filter Table
 *     element.
 * - 0b11 - Format D: All frames rejected.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IDAM field. */
#define CAN_RD_MCR_IDAM(base) ((CAN_MCR_REG(base) & CAN_MCR_IDAM_MASK) >> CAN_MCR_IDAM_SHIFT)
#define CAN_BRD_MCR_IDAM(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_IDAM_SHIFT, CAN_MCR_IDAM_WIDTH))

/*! @brief Set the IDAM field to a new value. */
#define CAN_WR_MCR_IDAM(base, value) (CAN_RMW_MCR(base, CAN_MCR_IDAM_MASK, CAN_MCR_IDAM(value)))
#define CAN_BWR_MCR_IDAM(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_IDAM_SHIFT), CAN_MCR_IDAM_SHIFT, CAN_MCR_IDAM_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field AEN[12] (RW)
 *
 * When asserted, this bit enables the Tx abort mechanism. This mechanism
 * guarantees a safe procedure for aborting a pending transmission, so that no frame is
 * sent in the CAN bus without notification. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes. When CAN_MCR[AEN]
 * is asserted, only the abort mechanism (see Transmission abort mechanism) must
 * be used for updating Mailboxes configured for transmission. Writing the Abort
 * code into Rx Mailboxes can cause unpredictable results when the CAN_MCR[AEN] is
 * asserted.
 *
 * Values:
 * - 0b0 - Abort disabled.
 * - 0b1 - Abort enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_AEN field. */
#define CAN_RD_MCR_AEN(base) ((CAN_MCR_REG(base) & CAN_MCR_AEN_MASK) >> CAN_MCR_AEN_SHIFT)
#define CAN_BRD_MCR_AEN(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_AEN_SHIFT, CAN_MCR_AEN_WIDTH))

/*! @brief Set the AEN field to a new value. */
#define CAN_WR_MCR_AEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_AEN_MASK, CAN_MCR_AEN(value)))
#define CAN_BWR_MCR_AEN(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_AEN_SHIFT), CAN_MCR_AEN_SHIFT, CAN_MCR_AEN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPRIOEN[13] (RW)
 *
 * This bit is provided for backwards compatibility with legacy applications. It
 * controls whether the local priority feature is enabled or not. It is used to
 * expand the ID used during the arbitration process. With this expanded ID
 * concept, the arbitration process is done based on the full 32-bit word, but the
 * actual transmitted ID still has 11-bit for standard frames and 29-bit for
 * extended frames. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes.
 *
 * Values:
 * - 0b0 - Local Priority disabled.
 * - 0b1 - Local Priority enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPRIOEN field. */
#define CAN_RD_MCR_LPRIOEN(base) ((CAN_MCR_REG(base) & CAN_MCR_LPRIOEN_MASK) >> CAN_MCR_LPRIOEN_SHIFT)
#define CAN_BRD_MCR_LPRIOEN(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_LPRIOEN_SHIFT, CAN_MCR_LPRIOEN_WIDTH))

/*! @brief Set the LPRIOEN field to a new value. */
#define CAN_WR_MCR_LPRIOEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_LPRIOEN_MASK, CAN_MCR_LPRIOEN(value)))
#define CAN_BWR_MCR_LPRIOEN(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_LPRIOEN_SHIFT), CAN_MCR_LPRIOEN_SHIFT, CAN_MCR_LPRIOEN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field DMA[15] (RW)
 *
 * The DMA Enable bit controls whether the DMA feature is enabled or not. The
 * DMA feature can only be used in Rx FIFO, consequently the bit CAN_MCR[RFEN] must
 * be asserted. When DMA and RFEN are set, the CAN_IFLAG1[BUF5I] generates the
 * DMA request and no RX FIFO interrupt is generated. This bit can be written in
 * Freeze mode only as it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - DMA feature for RX FIFO disabled.
 * - 0b1 - DMA feature for RX FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_DMA field. */
#define CAN_RD_MCR_DMA(base) ((CAN_MCR_REG(base) & CAN_MCR_DMA_MASK) >> CAN_MCR_DMA_SHIFT)
#define CAN_BRD_MCR_DMA(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_DMA_SHIFT, CAN_MCR_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define CAN_WR_MCR_DMA(base, value) (CAN_RMW_MCR(base, CAN_MCR_DMA_MASK, CAN_MCR_DMA(value)))
#define CAN_BWR_MCR_DMA(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_DMA_SHIFT), CAN_MCR_DMA_SHIFT, CAN_MCR_DMA_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field IRMQ[16] (RW)
 *
 * This bit indicates whether Rx matching process will be based either on
 * individual masking and queue or on masking scheme with CAN_RXMGMASK, CAN_RX14MASK,
 * CAN_RX15MASK and CAN_RXFGMASK. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Individual Rx masking and queue feature are disabled. For backward
 *     compatibility with legacy applications, the reading of C/S word locks the MB
 *     even if it is EMPTY.
 * - 0b1 - Individual Rx masking and queue feature are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IRMQ field. */
#define CAN_RD_MCR_IRMQ(base) ((CAN_MCR_REG(base) & CAN_MCR_IRMQ_MASK) >> CAN_MCR_IRMQ_SHIFT)
#define CAN_BRD_MCR_IRMQ(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_IRMQ_SHIFT, CAN_MCR_IRMQ_WIDTH))

/*! @brief Set the IRMQ field to a new value. */
#define CAN_WR_MCR_IRMQ(base, value) (CAN_RMW_MCR(base, CAN_MCR_IRMQ_MASK, CAN_MCR_IRMQ(value)))
#define CAN_BWR_MCR_IRMQ(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_IRMQ_SHIFT), CAN_MCR_IRMQ_SHIFT, CAN_MCR_IRMQ_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field SRXDIS[17] (RW)
 *
 * This bit defines whether FlexCAN is allowed to receive frames transmitted by
 * itself. If this bit is asserted, frames transmitted by the module will not be
 * stored in any MB, regardless if the MB is programmed with an ID that matches
 * the transmitted frame, and no interrupt flag or interrupt signal will be
 * generated due to the frame reception. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Self reception enabled.
 * - 0b1 - Self reception disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SRXDIS field. */
#define CAN_RD_MCR_SRXDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_SRXDIS_MASK) >> CAN_MCR_SRXDIS_SHIFT)
#define CAN_BRD_MCR_SRXDIS(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_SRXDIS_SHIFT, CAN_MCR_SRXDIS_WIDTH))

/*! @brief Set the SRXDIS field to a new value. */
#define CAN_WR_MCR_SRXDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_SRXDIS_MASK, CAN_MCR_SRXDIS(value)))
#define CAN_BWR_MCR_SRXDIS(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_SRXDIS_SHIFT), CAN_MCR_SRXDIS_SHIFT, CAN_MCR_SRXDIS_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field DOZE[18] (RW)
 *
 * This bit defines whether FlexCAN is allowed to enter low-power mode when Doze
 * mode is requested at chip level . This bit is automatically reset when
 * FlexCAN wakes up from Doze mode upon detecting activity on the CAN bus (self wake-up
 * enabled).
 *
 * Values:
 * - 0b0 - FlexCAN is not enabled to enter low-power mode when Doze mode is
 *     requested.
 * - 0b1 - FlexCAN is enabled to enter low-power mode when Doze mode is
 *     requested.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_DOZE field. */
#define CAN_RD_MCR_DOZE(base) ((CAN_MCR_REG(base) & CAN_MCR_DOZE_MASK) >> CAN_MCR_DOZE_SHIFT)
#define CAN_BRD_MCR_DOZE(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_DOZE_SHIFT, CAN_MCR_DOZE_WIDTH))

/*! @brief Set the DOZE field to a new value. */
#define CAN_WR_MCR_DOZE(base, value) (CAN_RMW_MCR(base, CAN_MCR_DOZE_MASK, CAN_MCR_DOZE(value)))
#define CAN_BWR_MCR_DOZE(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_DOZE_SHIFT), CAN_MCR_DOZE_SHIFT, CAN_MCR_DOZE_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKSRC[19] (RW)
 *
 * This bit defines whether the integrated low-pass filter is applied to protect
 * the Rx CAN input from spurious wake up. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - FlexCAN uses the unfiltered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 * - 0b1 - FlexCAN uses the filtered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKSRC field. */
#define CAN_RD_MCR_WAKSRC(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKSRC_MASK) >> CAN_MCR_WAKSRC_SHIFT)
#define CAN_BRD_MCR_WAKSRC(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_WAKSRC_SHIFT, CAN_MCR_WAKSRC_WIDTH))

/*! @brief Set the WAKSRC field to a new value. */
#define CAN_WR_MCR_WAKSRC(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKSRC_MASK, CAN_MCR_WAKSRC(value)))
#define CAN_BWR_MCR_WAKSRC(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_WAKSRC_SHIFT), CAN_MCR_WAKSRC_SHIFT, CAN_MCR_WAKSRC_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPMACK[20] (RO)
 *
 * This read-only bit indicates that FlexCAN is in a low-power mode (Disable
 * mode, Doze mode , Stop mode). A low-power mode cannot be entered until all
 * current transmission or reception processes have finished, so the CPU can poll the
 * LPMACK bit to know when FlexCAN has actually entered low power mode. This bit
 * is not affected by soft reset. LPMACK will be asserted within 180 CAN bits from
 * the low-power mode request by the CPU, and negated within 2 CAN bits after
 * the low-power mode request removal (see Section "Protocol Timing").
 *
 * Values:
 * - 0b0 - FlexCAN is not in a low-power mode.
 * - 0b1 - FlexCAN is in a low-power mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPMACK field. */
#define CAN_RD_MCR_LPMACK(base) ((CAN_MCR_REG(base) & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT)
#define CAN_BRD_MCR_LPMACK(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_LPMACK_SHIFT, CAN_MCR_LPMACK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field WRNEN[21] (RW)
 *
 * When asserted, this bit enables the generation of the TWRNINT and RWRNINT
 * flags in the Error and Status Register 1 (ESR1). If WRNEN is negated, the TWRNINT
 * and RWRNINT flags will always be zero, independent of the values of the error
 * counters, and no warning interrupt will ever be generated. This bit can be
 * written in Freeze mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - TWRNINT and RWRNINT bits are zero, independent of the values in the
 *     error counters.
 * - 0b1 - TWRNINT and RWRNINT bits are set when the respective error counter
 *     transitions from less than 96 to greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WRNEN field. */
#define CAN_RD_MCR_WRNEN(base) ((CAN_MCR_REG(base) & CAN_MCR_WRNEN_MASK) >> CAN_MCR_WRNEN_SHIFT)
#define CAN_BRD_MCR_WRNEN(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_WRNEN_SHIFT, CAN_MCR_WRNEN_WIDTH))

/*! @brief Set the WRNEN field to a new value. */
#define CAN_WR_MCR_WRNEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_WRNEN_MASK, CAN_MCR_WRNEN(value)))
#define CAN_BWR_MCR_WRNEN(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_WRNEN_SHIFT), CAN_MCR_WRNEN_SHIFT, CAN_MCR_WRNEN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field SLFWAK[22] (RW)
 *
 * This bit enables the Self Wake Up feature when FlexCAN is in a low-power mode
 * other than Disable mode. When this feature is enabled, the FlexCAN module
 * monitors the bus for wake up event, that is, a recessive-to-dominant transition.
 * If a wake up event is detected during Doze mode, FlexCAN requests to resume
 * its clocks and, if enabled to do so, generates a Wake Up interrupt to the CPU.
 * If a wake up event is detected during Stop mode, then FlexCAN generates, if
 * enabled to do so, a Wake Up interrupt to the CPU so that it can exit Stop mode
 * globally and FlexCAN can request to resume the clocks. When FlexCAN is in a
 * low-power mode other than Disable mode, this bit cannot be written as it is
 * blocked by hardware.
 *
 * Values:
 * - 0b0 - FlexCAN Self Wake Up feature is disabled.
 * - 0b1 - FlexCAN Self Wake Up feature is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SLFWAK field. */
#define CAN_RD_MCR_SLFWAK(base) ((CAN_MCR_REG(base) & CAN_MCR_SLFWAK_MASK) >> CAN_MCR_SLFWAK_SHIFT)
#define CAN_BRD_MCR_SLFWAK(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_SLFWAK_SHIFT, CAN_MCR_SLFWAK_WIDTH))

/*! @brief Set the SLFWAK field to a new value. */
#define CAN_WR_MCR_SLFWAK(base, value) (CAN_RMW_MCR(base, CAN_MCR_SLFWAK_MASK, CAN_MCR_SLFWAK(value)))
#define CAN_BWR_MCR_SLFWAK(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_SLFWAK_SHIFT), CAN_MCR_SLFWAK_SHIFT, CAN_MCR_SLFWAK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field SUPV[23] (RW)
 *
 * This bit configures the FlexCAN to be either in Supervisor or User mode. The
 * registers affected by this bit are marked as S/U in the Access Type column of
 * the module memory map. Reset value of this bit is 1, so the affected registers
 * start with Supervisor access allowance only. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - FlexCAN is in User mode. Affected registers allow both Supervisor and
 *     Unrestricted accesses.
 * - 0b1 - FlexCAN is in Supervisor mode. Affected registers allow only
 *     Supervisor access. Unrestricted access behaves as though the access was done to an
 *     unimplemented register location.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SUPV field. */
#define CAN_RD_MCR_SUPV(base) ((CAN_MCR_REG(base) & CAN_MCR_SUPV_MASK) >> CAN_MCR_SUPV_SHIFT)
#define CAN_BRD_MCR_SUPV(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_SUPV_SHIFT, CAN_MCR_SUPV_WIDTH))

/*! @brief Set the SUPV field to a new value. */
#define CAN_WR_MCR_SUPV(base, value) (CAN_RMW_MCR(base, CAN_MCR_SUPV_MASK, CAN_MCR_SUPV(value)))
#define CAN_BWR_MCR_SUPV(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_SUPV_SHIFT), CAN_MCR_SUPV_SHIFT, CAN_MCR_SUPV_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZACK[24] (RO)
 *
 * This read-only bit indicates that FlexCAN is in Freeze mode and its prescaler
 * is stopped. The Freeze mode request cannot be granted until current
 * transmission or reception processes have finished. Therefore the software can poll the
 * FRZACK bit to know when FlexCAN has actually entered Freeze mode. If Freeze
 * Mode request is negated, then this bit is negated after the FlexCAN prescaler is
 * running again. If Freeze mode is requested while FlexCAN is in a low power
 * mode, then the FRZACK bit will be set only when the low-power mode is exited.
 * See Section "Freeze Mode". This bit is not affected by soft reset. FRZACK will
 * be asserted within 178 CAN bits from the freeze mode request by the CPU, and
 * negated within 2 CAN bits after the freeze mode request removal (see Section
 * "Protocol Timing").
 *
 * Values:
 * - 0b0 - FlexCAN not in Freeze mode, prescaler running.
 * - 0b1 - FlexCAN in Freeze mode, prescaler stopped.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZACK field. */
#define CAN_RD_MCR_FRZACK(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZACK_MASK) >> CAN_MCR_FRZACK_SHIFT)
#define CAN_BRD_MCR_FRZACK(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_FRZACK_SHIFT, CAN_MCR_FRZACK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field SOFTRST[25] (RW)
 *
 * When this bit is asserted, FlexCAN resets its internal state machines and
 * some of the memory mapped registers. The SOFTRST bit can be asserted directly by
 * the CPU when it writes to the MCR Register, but it is also asserted when
 * global soft reset is requested at chip level. Because soft reset is synchronous and
 * has to follow a request/acknowledge procedure across clock domains, it may
 * take some time to fully propagate its effect. The SOFTRST bit remains asserted
 * while reset is pending, and is automatically negated when reset completes.
 * Therefore, software can poll this bit to know when the soft reset has completed.
 * Soft reset cannot be applied while clocks are shut down in a low power mode.
 * The module should be first removed from low power mode, and then soft reset can
 * be applied. This bit is not affected by soft reset.
 *
 * Values:
 * - 0b0 - No reset request.
 * - 0b1 - Resets the registers affected by soft reset.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SOFTRST field. */
#define CAN_RD_MCR_SOFTRST(base) ((CAN_MCR_REG(base) & CAN_MCR_SOFTRST_MASK) >> CAN_MCR_SOFTRST_SHIFT)
#define CAN_BRD_MCR_SOFTRST(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_SOFTRST_SHIFT, CAN_MCR_SOFTRST_WIDTH))

/*! @brief Set the SOFTRST field to a new value. */
#define CAN_WR_MCR_SOFTRST(base, value) (CAN_RMW_MCR(base, CAN_MCR_SOFTRST_MASK, CAN_MCR_SOFTRST(value)))
#define CAN_BWR_MCR_SOFTRST(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_SOFTRST_SHIFT), CAN_MCR_SOFTRST_SHIFT, CAN_MCR_SOFTRST_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKMSK[26] (RW)
 *
 * This bit enables the Wake Up Interrupt generation under Self Wake Up
 * mechanism.
 *
 * Values:
 * - 0b0 - Wake Up Interrupt is disabled.
 * - 0b1 - Wake Up Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKMSK field. */
#define CAN_RD_MCR_WAKMSK(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKMSK_MASK) >> CAN_MCR_WAKMSK_SHIFT)
#define CAN_BRD_MCR_WAKMSK(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_WAKMSK_SHIFT, CAN_MCR_WAKMSK_WIDTH))

/*! @brief Set the WAKMSK field to a new value. */
#define CAN_WR_MCR_WAKMSK(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKMSK_MASK, CAN_MCR_WAKMSK(value)))
#define CAN_BWR_MCR_WAKMSK(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_WAKMSK_SHIFT), CAN_MCR_WAKMSK_SHIFT, CAN_MCR_WAKMSK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field NOTRDY[27] (RO)
 *
 * This read-only bit indicates that FlexCAN is either in Disable mode, Doze
 * mode , Stop mode or Freeze mode. It is negated once FlexCAN has exited these
 * modes. This bit is not affected by soft reset.
 *
 * Values:
 * - 0b0 - FlexCAN module is either in Normal mode, Listen-Only mode or
 *     Loop-Back mode.
 * - 0b1 - FlexCAN module is either in Disable mode, Doze mode , Stop mode or
 *     Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_NOTRDY field. */
#define CAN_RD_MCR_NOTRDY(base) ((CAN_MCR_REG(base) & CAN_MCR_NOTRDY_MASK) >> CAN_MCR_NOTRDY_SHIFT)
#define CAN_BRD_MCR_NOTRDY(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_NOTRDY_SHIFT, CAN_MCR_NOTRDY_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field HALT[28] (RW)
 *
 * Assertion of this bit puts the FlexCAN module into Freeze mode. The CPU
 * should clear it after initializing the Message Buffers and the Control Registers
 * CAN_CTRL1 and CAN_CTRL2. No reception or transmission is performed by FlexCAN
 * before this bit is cleared. Freeze mode cannot be entered while FlexCAN is in a
 * low power mode.
 *
 * Values:
 * - 0b0 - No Freeze mode request.
 * - 0b1 - Enters Freeze mode if the FRZ bit is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_HALT field. */
#define CAN_RD_MCR_HALT(base) ((CAN_MCR_REG(base) & CAN_MCR_HALT_MASK) >> CAN_MCR_HALT_SHIFT)
#define CAN_BRD_MCR_HALT(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_HALT_SHIFT, CAN_MCR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define CAN_WR_MCR_HALT(base, value) (CAN_RMW_MCR(base, CAN_MCR_HALT_MASK, CAN_MCR_HALT(value)))
#define CAN_BWR_MCR_HALT(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_HALT_SHIFT), CAN_MCR_HALT_SHIFT, CAN_MCR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field RFEN[29] (RW)
 *
 * This bit controls whether the Rx FIFO feature is enabled or not. When RFEN is
 * set, MBs 0 to 5 cannot be used for normal reception and transmission because
 * the corresponding memory region (0x80-0xDC) is used by the FIFO engine as well
 * as additional MBs (up to 32, depending on CAN_CTRL2[RFFN] setting) which are
 * used as Rx FIFO ID Filter Table elements. RFEN also impacts the definition of
 * the minimum number of peripheral clocks per CAN bit as described in the table
 * "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate" (see
 * Arbitration and matching timing). This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Rx FIFO not enabled.
 * - 0b1 - Rx FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_RFEN field. */
#define CAN_RD_MCR_RFEN(base) ((CAN_MCR_REG(base) & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT)
#define CAN_BRD_MCR_RFEN(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_RFEN_SHIFT, CAN_MCR_RFEN_WIDTH))

/*! @brief Set the RFEN field to a new value. */
#define CAN_WR_MCR_RFEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_RFEN_MASK, CAN_MCR_RFEN(value)))
#define CAN_BWR_MCR_RFEN(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_RFEN_SHIFT), CAN_MCR_RFEN_SHIFT, CAN_MCR_RFEN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZ[30] (RW)
 *
 * The FRZ bit specifies the FlexCAN behavior when the HALT bit in the CAN_MCR
 * Register is set or when Debug mode is requested at chip level. When FRZ is
 * asserted, FlexCAN is enabled to enter Freeze mode. Negation of this bit field
 * causes FlexCAN to exit from Freeze mode.
 *
 * Values:
 * - 0b0 - Not enabled to enter Freeze mode.
 * - 0b1 - Enabled to enter Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZ field. */
#define CAN_RD_MCR_FRZ(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZ_MASK) >> CAN_MCR_FRZ_SHIFT)
#define CAN_BRD_MCR_FRZ(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_FRZ_SHIFT, CAN_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define CAN_WR_MCR_FRZ(base, value) (CAN_RMW_MCR(base, CAN_MCR_FRZ_MASK, CAN_MCR_FRZ(value)))
#define CAN_BWR_MCR_FRZ(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_FRZ_SHIFT), CAN_MCR_FRZ_SHIFT, CAN_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register CAN_MCR, field MDIS[31] (RW)
 *
 * This bit controls whether FlexCAN is enabled or not. When disabled, FlexCAN
 * disables the clocks to the CAN Protocol Engine and Controller Host Interface
 * sub-modules. This bit is not affected by soft reset.
 *
 * Values:
 * - 0b0 - Enable the FlexCAN module.
 * - 0b1 - Disable the FlexCAN module.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MDIS field. */
#define CAN_RD_MCR_MDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT)
#define CAN_BRD_MCR_MDIS(base) (BME_UBFX32(&CAN_MCR_REG(base), CAN_MCR_MDIS_SHIFT, CAN_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define CAN_WR_MCR_MDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_MDIS_MASK, CAN_MCR_MDIS(value)))
#define CAN_BWR_MCR_MDIS(base, value) (BME_BFI32(&CAN_MCR_REG(base), ((uint32_t)(value) << CAN_MCR_MDIS_SHIFT), CAN_MCR_MDIS_SHIFT, CAN_MCR_MDIS_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_CTRL1 - Control 1 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL1 - Control 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is defined for specific FlexCAN control features related to the
 * CAN bus, such as bit-rate, programmable sampling point within an Rx bit, Loop
 * Back mode, Listen-Only mode, Bus Off recovery behavior and interrupt enabling
 * (Bus-Off, Error, Warning). It also determines the Division Factor for the
 * clock prescaler. The CAN bit timing variables (PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW) can also be configured in CAN_CBT register, which extends the range of
 * all these variables. If CAN_CBT[BTF] is set, PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW fields of CAN_CTRL1 become read only. The contents of this register are
 * not affected by soft reset. The CAN bit variables in CAN_CTRL1 and in CAN_CBT
 * are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL1 register
 */
/*@{*/
#define CAN_RD_CTRL1(base)       (CAN_CTRL1_REG(base))
#define CAN_WR_CTRL1(base, value) (CAN_CTRL1_REG(base) = (value))
#define CAN_RMW_CTRL1(base, mask, value) (CAN_WR_CTRL1(base, (CAN_RD_CTRL1(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL1(base, value) (BME_OR32(&CAN_CTRL1_REG(base), (uint32_t)(value)))
#define CAN_CLR_CTRL1(base, value) (BME_AND32(&CAN_CTRL1_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_CTRL1(base, value) (BME_XOR32(&CAN_CTRL1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL1 bitfields
 */

/*!
 * @name Register CAN_CTRL1, field PROPSEG[2:0] (RW)
 *
 * This 3-bit field defines the length of the Propagation Segment in the bit
 * time. The valid programmable values are 0-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Propagation
 * Segment Time = (PROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PROPSEG field. */
#define CAN_RD_CTRL1_PROPSEG(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PROPSEG_MASK) >> CAN_CTRL1_PROPSEG_SHIFT)
#define CAN_BRD_CTRL1_PROPSEG(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_PROPSEG_SHIFT, CAN_CTRL1_PROPSEG_WIDTH))

/*! @brief Set the PROPSEG field to a new value. */
#define CAN_WR_CTRL1_PROPSEG(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PROPSEG_MASK, CAN_CTRL1_PROPSEG(value)))
#define CAN_BWR_CTRL1_PROPSEG(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_PROPSEG_SHIFT), CAN_CTRL1_PROPSEG_SHIFT, CAN_CTRL1_PROPSEG_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LOM[3] (RW)
 *
 * This bit configures FlexCAN to operate in Listen-Only mode. In this mode,
 * transmission is disabled, all error counters described in CAN_ECR register are
 * frozen and the module operates in a CAN Error Passive mode. Only messages
 * acknowledged by another CAN station will be received. If FlexCAN detects a message
 * that has not been acknowledged, it will flag a BIT0 error without changing the
 * receive error counter (RXERRCNT) in CAN_ECR register, as if it was trying to
 * acknowledge the message. Listen-Only mode is acknowledged by the state of
 * CAN_ESR1[FLTCONF] field indicating Passive Error. There can be some delay between
 * the Listen-Only mode request and acknowledge. This bit can be written in Freeze
 * mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Listen-Only mode is deactivated.
 * - 0b1 - FlexCAN module operates in Listen-Only mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LOM field. */
#define CAN_RD_CTRL1_LOM(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LOM_MASK) >> CAN_CTRL1_LOM_SHIFT)
#define CAN_BRD_CTRL1_LOM(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_LOM_SHIFT, CAN_CTRL1_LOM_WIDTH))

/*! @brief Set the LOM field to a new value. */
#define CAN_WR_CTRL1_LOM(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LOM_MASK, CAN_CTRL1_LOM(value)))
#define CAN_BWR_CTRL1_LOM(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_LOM_SHIFT), CAN_CTRL1_LOM_SHIFT, CAN_CTRL1_LOM_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LBUF[4] (RW)
 *
 * This bit defines the ordering mechanism for Message Buffer transmission. When
 * asserted, the CAN_MCR[LPRIOEN] bit does not affect the priority arbitration.
 * This bit can be written in Freeze mode only because it is blocked by hardware
 * in other modes.
 *
 * Values:
 * - 0b0 - Buffer with highest priority is transmitted first.
 * - 0b1 - Lowest number buffer is transmitted first.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LBUF field. */
#define CAN_RD_CTRL1_LBUF(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LBUF_MASK) >> CAN_CTRL1_LBUF_SHIFT)
#define CAN_BRD_CTRL1_LBUF(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_LBUF_SHIFT, CAN_CTRL1_LBUF_WIDTH))

/*! @brief Set the LBUF field to a new value. */
#define CAN_WR_CTRL1_LBUF(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LBUF_MASK, CAN_CTRL1_LBUF(value)))
#define CAN_BWR_CTRL1_LBUF(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_LBUF_SHIFT), CAN_CTRL1_LBUF_SHIFT, CAN_CTRL1_LBUF_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TSYN[5] (RW)
 *
 * This bit enables a mechanism that resets the free-running timer each time a
 * message is received in Message Buffer 0. This feature provides means to
 * synchronize multiple FlexCAN stations with a special "SYNC" message, that is, global
 * network time. If the RFEN bit in CAN_MCR is set (Rx FIFO enabled), the first
 * available Mailbox, according to CAN_CTRL2[RFFN] setting, is used for timer
 * synchronization instead of MB0. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Timer Sync feature disabled
 * - 0b1 - Timer Sync feature enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TSYN field. */
#define CAN_RD_CTRL1_TSYN(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TSYN_MASK) >> CAN_CTRL1_TSYN_SHIFT)
#define CAN_BRD_CTRL1_TSYN(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_TSYN_SHIFT, CAN_CTRL1_TSYN_WIDTH))

/*! @brief Set the TSYN field to a new value. */
#define CAN_WR_CTRL1_TSYN(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TSYN_MASK, CAN_CTRL1_TSYN(value)))
#define CAN_BWR_CTRL1_TSYN(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_TSYN_SHIFT), CAN_CTRL1_TSYN_SHIFT, CAN_CTRL1_TSYN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFREC[6] (RW)
 *
 * This bit defines how FlexCAN recovers from Bus Off state. If this bit is
 * negated, automatic recovering from Bus Off state occurs according to the CAN
 * Specification 2.0B. If the bit is asserted, automatic recovering from Bus Off is
 * disabled and the module remains in Bus Off state until the bit is negated by the
 * user. If the negation occurs before 128 sequences of 11 recessive bits are
 * detected on the CAN bus, then Bus Off recovery happens as if the BOFFREC bit had
 * never been asserted. If the negation occurs after 128 sequences of 11
 * recessive bits occurred, then FlexCAN will re-synchronize to the bus by waiting for
 * 11 recessive bits before joining the bus. After negation, the BOFFREC bit can
 * be re-asserted again during Bus Off, but it will be effective only the next
 * time the module enters Bus Off. If BOFFREC was negated when the module entered
 * Bus Off, asserting it during Bus Off will not be effective for the current Bus
 * Off recovery.
 *
 * Values:
 * - 0b0 - Automatic recovering from Bus Off state enabled.
 * - 0b1 - Automatic recovering from Bus Off state disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFREC field. */
#define CAN_RD_CTRL1_BOFFREC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFREC_MASK) >> CAN_CTRL1_BOFFREC_SHIFT)
#define CAN_BRD_CTRL1_BOFFREC(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFREC_SHIFT, CAN_CTRL1_BOFFREC_WIDTH))

/*! @brief Set the BOFFREC field to a new value. */
#define CAN_WR_CTRL1_BOFFREC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFREC_MASK, CAN_CTRL1_BOFFREC(value)))
#define CAN_BWR_CTRL1_BOFFREC(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_BOFFREC_SHIFT), CAN_CTRL1_BOFFREC_SHIFT, CAN_CTRL1_BOFFREC_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field SMP[7] (RW)
 *
 * This bit defines the sampling mode of CAN bits at the Rx input. It can be
 * written in Freeze mode only because it is blocked by hardware in other modes. For
 * proper operation, to assert SMP it is necessary to guarantee a minimum value
 * of 2 TQs in CAN_CTRL1[PSEG1] (or CAN_CBT[EPSEG1]).
 *
 * Values:
 * - 0b0 - Just one sample is used to determine the bit value.
 * - 0b1 - Three samples are used to determine the value of the received bit:
 *     the regular one (sample point) and 2 preceding samples; a majority rule is
 *     used.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_SMP field. */
#define CAN_RD_CTRL1_SMP(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_SMP_MASK) >> CAN_CTRL1_SMP_SHIFT)
#define CAN_BRD_CTRL1_SMP(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_SMP_SHIFT, CAN_CTRL1_SMP_WIDTH))

/*! @brief Set the SMP field to a new value. */
#define CAN_WR_CTRL1_SMP(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_SMP_MASK, CAN_CTRL1_SMP(value)))
#define CAN_BWR_CTRL1_SMP(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_SMP_SHIFT), CAN_CTRL1_SMP_SHIFT, CAN_CTRL1_SMP_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RWRNMSK[10] (RW)
 *
 * This bit provides a mask for the Rx Warning Interrupt associated with the
 * RWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0b0 - Rx Warning Interrupt disabled.
 * - 0b1 - Rx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RWRNMSK field. */
#define CAN_RD_CTRL1_RWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RWRNMSK_MASK) >> CAN_CTRL1_RWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_RWRNMSK(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_RWRNMSK_SHIFT, CAN_CTRL1_RWRNMSK_WIDTH))

/*! @brief Set the RWRNMSK field to a new value. */
#define CAN_WR_CTRL1_RWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RWRNMSK_MASK, CAN_CTRL1_RWRNMSK(value)))
#define CAN_BWR_CTRL1_RWRNMSK(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_RWRNMSK_SHIFT), CAN_CTRL1_RWRNMSK_SHIFT, CAN_CTRL1_RWRNMSK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TWRNMSK[11] (RW)
 *
 * This bit provides a mask for the Tx Warning Interrupt associated with the
 * TWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0b0 - Tx Warning Interrupt disabled.
 * - 0b1 - Tx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TWRNMSK field. */
#define CAN_RD_CTRL1_TWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TWRNMSK_MASK) >> CAN_CTRL1_TWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_TWRNMSK(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_TWRNMSK_SHIFT, CAN_CTRL1_TWRNMSK_WIDTH))

/*! @brief Set the TWRNMSK field to a new value. */
#define CAN_WR_CTRL1_TWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TWRNMSK_MASK, CAN_CTRL1_TWRNMSK(value)))
#define CAN_BWR_CTRL1_TWRNMSK(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_TWRNMSK_SHIFT), CAN_CTRL1_TWRNMSK_SHIFT, CAN_CTRL1_TWRNMSK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LPB[12] (RW)
 *
 * This bit configures FlexCAN to operate in Loop-Back mode. In this mode,
 * FlexCAN performs an internal loop back that can be used for self test operation.
 * The bit stream output of the transmitter is fed back internally to the receiver
 * input. The Rx CAN input pin is ignored and the Tx CAN output goes to the
 * recessive state (logic 1). FlexCAN behaves as it normally does when transmitting,
 * and treats its own transmitted message as a message received from a remote
 * node. In this mode, FlexCAN ignores the bit sent during the ACK slot in the CAN
 * frame acknowledge field, generating an internal acknowledge bit to ensure proper
 * reception of its own message. Both transmit and receive interrupts are
 * generated. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes. In this mode, the CAN_MCR[SRXDIS] cannot be asserted
 * because this will impede the self reception of a transmitted message.
 *
 * Values:
 * - 0b0 - Loop Back disabled.
 * - 0b1 - Loop Back enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LPB field. */
#define CAN_RD_CTRL1_LPB(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LPB_MASK) >> CAN_CTRL1_LPB_SHIFT)
#define CAN_BRD_CTRL1_LPB(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_LPB_SHIFT, CAN_CTRL1_LPB_WIDTH))

/*! @brief Set the LPB field to a new value. */
#define CAN_WR_CTRL1_LPB(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LPB_MASK, CAN_CTRL1_LPB(value)))
#define CAN_BWR_CTRL1_LPB(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_LPB_SHIFT), CAN_CTRL1_LPB_SHIFT, CAN_CTRL1_LPB_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field CLKSRC[13] (RW)
 *
 * This bit selects the clock source to the CAN Protocol Engine (PE) to be
 * either the peripheral clock or the oscillator clock. The selected clock is the one
 * fed to the prescaler to generate the Serial Clock (Sclock). In order to
 * guarantee reliable operation, this bit can be written only in Disable mode because
 * it is blocked by hardware in other modes. See Protocol timing".
 *
 * Values:
 * - 0b0 - The CAN engine clock source is the oscillator clock. Under this
 *     condition, the oscillator clock frequency must be lower than the bus clock.
 * - 0b1 - The CAN engine clock source is the peripheral clock.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_CLKSRC field. */
#define CAN_RD_CTRL1_CLKSRC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_CLKSRC_MASK) >> CAN_CTRL1_CLKSRC_SHIFT)
#define CAN_BRD_CTRL1_CLKSRC(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_CLKSRC_SHIFT, CAN_CTRL1_CLKSRC_WIDTH))

/*! @brief Set the CLKSRC field to a new value. */
#define CAN_WR_CTRL1_CLKSRC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_CLKSRC_MASK, CAN_CTRL1_CLKSRC(value)))
#define CAN_BWR_CTRL1_CLKSRC(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_CLKSRC_SHIFT), CAN_CTRL1_CLKSRC_SHIFT, CAN_CTRL1_CLKSRC_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field ERRMSK[14] (RW)
 *
 * This bit provides a mask for the Error Interrupt ERRINT in the CAN_ESR1
 * register.
 *
 * Values:
 * - 0b0 - Error interrupt disabled.
 * - 0b1 - Error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_ERRMSK field. */
#define CAN_RD_CTRL1_ERRMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_ERRMSK_MASK) >> CAN_CTRL1_ERRMSK_SHIFT)
#define CAN_BRD_CTRL1_ERRMSK(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_ERRMSK_SHIFT, CAN_CTRL1_ERRMSK_WIDTH))

/*! @brief Set the ERRMSK field to a new value. */
#define CAN_WR_CTRL1_ERRMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_ERRMSK_MASK, CAN_CTRL1_ERRMSK(value)))
#define CAN_BWR_CTRL1_ERRMSK(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_ERRMSK_SHIFT), CAN_CTRL1_ERRMSK_SHIFT, CAN_CTRL1_ERRMSK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFMSK[15] (RW)
 *
 * This bit provides a mask for the Bus Off Interrupt BOFFINT in CAN_ESR1
 * register.
 *
 * Values:
 * - 0b0 - Bus Off interrupt disabled.
 * - 0b1 - Bus Off interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFMSK field. */
#define CAN_RD_CTRL1_BOFFMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFMSK_MASK) >> CAN_CTRL1_BOFFMSK_SHIFT)
#define CAN_BRD_CTRL1_BOFFMSK(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFMSK_SHIFT, CAN_CTRL1_BOFFMSK_WIDTH))

/*! @brief Set the BOFFMSK field to a new value. */
#define CAN_WR_CTRL1_BOFFMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFMSK_MASK, CAN_CTRL1_BOFFMSK(value)))
#define CAN_BWR_CTRL1_BOFFMSK(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_BOFFMSK_SHIFT), CAN_CTRL1_BOFFMSK_SHIFT, CAN_CTRL1_BOFFMSK_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG2[18:16] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 2 in the bit time. The
 * valid programmable values are 1-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 2 =
 * (PSEG2 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG2 field. */
#define CAN_RD_CTRL1_PSEG2(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG2_MASK) >> CAN_CTRL1_PSEG2_SHIFT)
#define CAN_BRD_CTRL1_PSEG2(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_PSEG2_SHIFT, CAN_CTRL1_PSEG2_WIDTH))

/*! @brief Set the PSEG2 field to a new value. */
#define CAN_WR_CTRL1_PSEG2(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG2_MASK, CAN_CTRL1_PSEG2(value)))
#define CAN_BWR_CTRL1_PSEG2(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_PSEG2_SHIFT), CAN_CTRL1_PSEG2_SHIFT, CAN_CTRL1_PSEG2_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG1[21:19] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 1 in the bit time. The
 * valid programmable values are 0-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 1 =
 * (PSEG1 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG1 field. */
#define CAN_RD_CTRL1_PSEG1(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG1_MASK) >> CAN_CTRL1_PSEG1_SHIFT)
#define CAN_BRD_CTRL1_PSEG1(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_PSEG1_SHIFT, CAN_CTRL1_PSEG1_WIDTH))

/*! @brief Set the PSEG1 field to a new value. */
#define CAN_WR_CTRL1_PSEG1(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG1_MASK, CAN_CTRL1_PSEG1(value)))
#define CAN_BWR_CTRL1_PSEG1(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_PSEG1_SHIFT), CAN_CTRL1_PSEG1_SHIFT, CAN_CTRL1_PSEG1_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RJW[23:22] (RW)
 *
 * This 2-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization. One time quantum is equal to the
 * Sclock period. The valid programmable values are 0-3. This field can be written
 * only in Freeze mode because it is blocked by hardware in other modes. Resync Jump
 * Width = RJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RJW field. */
#define CAN_RD_CTRL1_RJW(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RJW_MASK) >> CAN_CTRL1_RJW_SHIFT)
#define CAN_BRD_CTRL1_RJW(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_RJW_SHIFT, CAN_CTRL1_RJW_WIDTH))

/*! @brief Set the RJW field to a new value. */
#define CAN_WR_CTRL1_RJW(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RJW_MASK, CAN_CTRL1_RJW(value)))
#define CAN_BWR_CTRL1_RJW(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_RJW_SHIFT), CAN_CTRL1_RJW_SHIFT, CAN_CTRL1_RJW_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PRESDIV[31:24] (RW)
 *
 * This 8-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency. The Sclock period defines the time quantum of
 * the CAN protocol. For the reset value, the Sclock frequency is equal to the PE
 * clock frequency. The Maximum value of this field is 0xFF, that gives a minimum
 * Sclock frequency equal to the PE clock frequency divided by 256. See Section
 * "Protocol Timing". This field can be written only in Freeze mode because it is
 * blocked by hardware in other modes. Sclock frequency = PE clock frequency /
 * (PRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PRESDIV field. */
#define CAN_RD_CTRL1_PRESDIV(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PRESDIV_MASK) >> CAN_CTRL1_PRESDIV_SHIFT)
#define CAN_BRD_CTRL1_PRESDIV(base) (BME_UBFX32(&CAN_CTRL1_REG(base), CAN_CTRL1_PRESDIV_SHIFT, CAN_CTRL1_PRESDIV_WIDTH))

/*! @brief Set the PRESDIV field to a new value. */
#define CAN_WR_CTRL1_PRESDIV(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PRESDIV_MASK, CAN_CTRL1_PRESDIV(value)))
#define CAN_BWR_CTRL1_PRESDIV(base, value) (BME_BFI32(&CAN_CTRL1_REG(base), ((uint32_t)(value) << CAN_CTRL1_PRESDIV_SHIFT), CAN_CTRL1_PRESDIV_SHIFT, CAN_CTRL1_PRESDIV_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_TIMER - Free Running Timer
 ******************************************************************************/

/*!
 * @brief CAN_TIMER - Free Running Timer (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register represents a 16-bit free running counter that can be read and
 * written by the CPU. The timer starts from 0x0 after Reset, counts linearly to
 * 0xFFFF, and wraps around. The timer is incremented by the CAN bit clock, which
 * defines the baud rate on the CAN bus. During a message transmission/reception,
 * it increments by one for each bit that is received or transmitted. When there
 * is no message on the bus, it counts using the previously programmed baud
 * rate. The timer is not incremented during Disable, Doze , Stop and Freeze modes.
 * The timer value is captured when the second bit of the identifier field of any
 * frame is on the CAN bus. This captured value is written into the Time Stamp
 * entry in a message buffer after a successful reception or transmission of a
 * message. If bit CAN_CTRL1[TSYN] is asserted, the Timer is reset whenever a message
 * is received in the first available Mailbox, according to CAN_CTRL2[RFFN]
 * setting. The CPU can write to this register anytime. However, if the write occurs
 * at the same time that the Timer is being reset by a reception in the first
 * Mailbox, then the write value is discarded. Reading this register affects the
 * Mailbox Unlocking procedure, see Section "Mailbox Lock Mechanism".
 */
/*!
 * @name Constants and macros for entire CAN_TIMER register
 */
/*@{*/
#define CAN_RD_TIMER(base)       (CAN_TIMER_REG(base))
#define CAN_WR_TIMER(base, value) (CAN_TIMER_REG(base) = (value))
#define CAN_RMW_TIMER(base, mask, value) (CAN_WR_TIMER(base, (CAN_RD_TIMER(base) & ~(mask)) | (value)))
#define CAN_SET_TIMER(base, value) (BME_OR32(&CAN_TIMER_REG(base), (uint32_t)(value)))
#define CAN_CLR_TIMER(base, value) (BME_AND32(&CAN_TIMER_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_TIMER(base, value) (BME_XOR32(&CAN_TIMER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_TIMER bitfields
 */

/*!
 * @name Register CAN_TIMER, field TIMER[15:0] (RW)
 *
 * Contains the free-running counter value.
 */
/*@{*/
/*! @brief Read current value of the CAN_TIMER_TIMER field. */
#define CAN_RD_TIMER_TIMER(base) ((CAN_TIMER_REG(base) & CAN_TIMER_TIMER_MASK) >> CAN_TIMER_TIMER_SHIFT)
#define CAN_BRD_TIMER_TIMER(base) (CAN_RD_TIMER_TIMER(base))

/*! @brief Set the TIMER field to a new value. */
#define CAN_WR_TIMER_TIMER(base, value) (CAN_RMW_TIMER(base, CAN_TIMER_TIMER_MASK, CAN_TIMER_TIMER(value)))
#define CAN_BWR_TIMER_TIMER(base, value) (CAN_WR_TIMER_TIMER(base, value))
/*@}*/

/*******************************************************************************
 * CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_RXMGMASK - Rx Mailboxes Global Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RXMGMASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is negated, RXMGMASK is always in effect
 * (the bits in the MG field will mask the Mailbox filter bits). When the
 * CAN_MCR[IRMQ] bit is asserted, RXMGMASK has no effect (the bits in the MG field will
 * not mask the Mailbox filter bits). RXMGMASK is used to mask the filter fields
 * of all Rx MBs, excluding MBs 14-15, which have individual mask registers. This
 * register can only be written in Freeze mode as it is blocked by hardware in
 * other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXMGMASK register
 */
/*@{*/
#define CAN_RD_RXMGMASK(base)    (CAN_RXMGMASK_REG(base))
#define CAN_WR_RXMGMASK(base, value) (CAN_RXMGMASK_REG(base) = (value))
#define CAN_RMW_RXMGMASK(base, mask, value) (CAN_WR_RXMGMASK(base, (CAN_RD_RXMGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXMGMASK(base, value) (BME_OR32(&CAN_RXMGMASK_REG(base), (uint32_t)(value)))
#define CAN_CLR_RXMGMASK(base, value) (BME_AND32(&CAN_RXMGMASK_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_RXMGMASK(base, value) (BME_XOR32(&CAN_RXMGMASK_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * CAN_RX14MASK - Rx 14 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX14MASK - Rx 14 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX14MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX14MASK has no effect.
 * RX14MASK is used to mask the filter fields of Message Buffer 14. This register can
 * only be programmed while the module is in Freeze mode as it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX14MASK register
 */
/*@{*/
#define CAN_RD_RX14MASK(base)    (CAN_RX14MASK_REG(base))
#define CAN_WR_RX14MASK(base, value) (CAN_RX14MASK_REG(base) = (value))
#define CAN_RMW_RX14MASK(base, mask, value) (CAN_WR_RX14MASK(base, (CAN_RD_RX14MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX14MASK(base, value) (BME_OR32(&CAN_RX14MASK_REG(base), (uint32_t)(value)))
#define CAN_CLR_RX14MASK(base, value) (BME_AND32(&CAN_RX14MASK_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_RX14MASK(base, value) (BME_XOR32(&CAN_RX14MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * CAN_RX15MASK - Rx 15 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX15MASK - Rx 15 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX15MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX15MASK has no effect.
 * RX15MASK is used to mask the filter fields of Message Buffer 15. This register can
 * be programmed only while the module is in Freeze mode because it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX15MASK register
 */
/*@{*/
#define CAN_RD_RX15MASK(base)    (CAN_RX15MASK_REG(base))
#define CAN_WR_RX15MASK(base, value) (CAN_RX15MASK_REG(base) = (value))
#define CAN_RMW_RX15MASK(base, mask, value) (CAN_WR_RX15MASK(base, (CAN_RD_RX15MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX15MASK(base, value) (BME_OR32(&CAN_RX15MASK_REG(base), (uint32_t)(value)))
#define CAN_CLR_RX15MASK(base, value) (BME_AND32(&CAN_RX15MASK_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_RX15MASK(base, value) (BME_XOR32(&CAN_RX15MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * CAN_ECR - Error Counter
 ******************************************************************************/

/*!
 * @brief CAN_ECR - Error Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has two 8-bit fields reflecting the value of the FlexCAN error
 * counters: Transmit Error Counter (TXERRCNT field) Receive Error Counter
 * (RXERRCNT field) The Fault Confinement State (FLTCONF field in Error and Status
 * Register 1 - CAN_ESR1) is updated based on TXERRCNT and RXERRCNT counters.
 * TXERRCNT and RXERRCNT counters can be written in Freeze mode only. The rules for
 * increasing and decreasing these counters are described in the CAN protocol and are
 * completely implemented in the FlexCAN module. The following are the basic
 * rules for FlexCAN bus state transitions: If the value of TXERRCNT or RXERRCNT
 * increases to be greater than or equal to 128, the FLTCONF field in the Error and
 * Status Register is updated to reflect "Error Passive" state. If the FlexCAN
 * state is "Error Passive", and either TXERRCNT or RXERRCNT decrements to a value
 * less than or equal to 127 while the other already satisfies this condition,
 * the FLTCONF field in the Error and Status Register is updated to reflect "Error
 * Active" state. If the value of TXERRCNT increases to be greater than 255, the
 * FLTCONF field in the Error and Status Register is updated to reflect "Bus Off"
 * state, and an interrupt may be issued. The value of TXERRCNT is then reset to
 * zero. If FlexCAN is in "Bus Off' state, then TXERRCNT is cascaded together
 * with another internal counter to count the 128th occurrences of 11 consecutive
 * recessive bits on the bus. Hence, TXERRCNT is reset to zero and counts in a
 * manner where the internal counter counts 11 such bits and then wraps around while
 * incrementing the TXERRCNT. When TXERRCNT reaches the value of 128, the
 * FLTCONF field in the Error and Status Register is updated to be "Error Active" and
 * both error counters are reset to zero. At any instance of dominant bit
 * following a stream of less than 11 consecutive recessive bits, the internal counter
 * resets itself to zero without affecting the TXERRCNT value. If during system
 * start-up, only one node is operating, then its TXERRCNT increases in each message
 * it is trying to transmit, as a result of acknowledge errors (indicated by the
 * ACKERR bit in the Error and Status Register). After the transition to "Error
 * Passive" state, the TXERRCNT does not increment anymore by acknowledge errors.
 * Therefore the device never goes to the "Bus Off" state. If the RXERRCNT
 * increases to a value greater than 127, it is not incremented further, even if more
 * errors are detected while being a receiver. At the next successful message
 * reception, the counter is set to a value between 119 and 127 to resume to "Error
 * Active" state.
 */
/*!
 * @name Constants and macros for entire CAN_ECR register
 */
/*@{*/
#define CAN_RD_ECR(base)         (CAN_ECR_REG(base))
#define CAN_WR_ECR(base, value)  (CAN_ECR_REG(base) = (value))
#define CAN_RMW_ECR(base, mask, value) (CAN_WR_ECR(base, (CAN_RD_ECR(base) & ~(mask)) | (value)))
#define CAN_SET_ECR(base, value) (BME_OR32(&CAN_ECR_REG(base), (uint32_t)(value)))
#define CAN_CLR_ECR(base, value) (BME_AND32(&CAN_ECR_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_ECR(base, value) (BME_XOR32(&CAN_ECR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ECR bitfields
 */

/*!
 * @name Register CAN_ECR, field TXERRCNT[7:0] (RW)
 *
 * Transmit Error Counter for all errors detected in transmitted messages. The
 * TXERRCNT counter is read-only except in Freeze mode, where it can be written by
 * the CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_TXERRCNT field. */
#define CAN_RD_ECR_TXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_TXERRCNT_MASK) >> CAN_ECR_TXERRCNT_SHIFT)
#define CAN_BRD_ECR_TXERRCNT(base) (BME_UBFX32(&CAN_ECR_REG(base), CAN_ECR_TXERRCNT_SHIFT, CAN_ECR_TXERRCNT_WIDTH))

/*! @brief Set the TXERRCNT field to a new value. */
#define CAN_WR_ECR_TXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_TXERRCNT_MASK, CAN_ECR_TXERRCNT(value)))
#define CAN_BWR_ECR_TXERRCNT(base, value) (BME_BFI32(&CAN_ECR_REG(base), ((uint32_t)(value) << CAN_ECR_TXERRCNT_SHIFT), CAN_ECR_TXERRCNT_SHIFT, CAN_ECR_TXERRCNT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ECR, field RXERRCNT[15:8] (RW)
 *
 * Receive Error Counter for all errors detected in received messages. The
 * RXERRCNT counter is read-only except in Freeze mode, where it can be written by the
 * CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_RXERRCNT field. */
#define CAN_RD_ECR_RXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_RXERRCNT_MASK) >> CAN_ECR_RXERRCNT_SHIFT)
#define CAN_BRD_ECR_RXERRCNT(base) (BME_UBFX32(&CAN_ECR_REG(base), CAN_ECR_RXERRCNT_SHIFT, CAN_ECR_RXERRCNT_WIDTH))

/*! @brief Set the RXERRCNT field to a new value. */
#define CAN_WR_ECR_RXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_RXERRCNT_MASK, CAN_ECR_RXERRCNT(value)))
#define CAN_BWR_ECR_RXERRCNT(base, value) (BME_BFI32(&CAN_ECR_REG(base), ((uint32_t)(value) << CAN_ECR_RXERRCNT_SHIFT), CAN_ECR_RXERRCNT_SHIFT, CAN_ECR_RXERRCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_ESR1 - Error and Status 1 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR1 - Error and Status 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register reports various error conditions detected in the reception and
 * transmission of a CAN frame, some general status of the device and it is the
 * source of some interrupts to the CPU. The reported error conditions are
 * BIT1ERR, BIT0ERR, ACKKERR, CRCERR, FRMERR and STFERR. An error detected in a single
 * CAN frame may be reported by one or more error flags. Also, error reporting is
 * cummulative in case more error events happen in the next frames while the CPU
 * does not attempt to read this register. TXWRN, RXWRN, IDLE, TX, FLTCONF, RX
 * and SYNCH are status bits. BOFFINT, BOFFDONEINT, ERRINT, WAKINT, TWRNINT and
 * RWRNINT are interrupt bits. It is recommended the CPU to use the following
 * procedure when servicing interrupt requests generated by these bits: Read this
 * register to capture all error condition and status bits. This action clear the
 * respective bits that were set since the last read access. Write 1 to clear the
 * interrupt bit that has triggered the interrupt request. Write 1 to clear the
 * ERR_OVR bit if it is set. Starting from all error flags cleared, a first error
 * event sets the ERRINT (provided the corresponding mask bit is asserted). If other
 * error events in subsequent frames happen before the CPU to serve the
 * interrupt request, the ERR_OVR bit is set to indicate that errors from different
 * frames had accumulated. SYNCH IDLE TX RX FlexCAN State 0 0 0 0 Not synchronized to
 * CAN bus 1 1 x x Idle 1 0 1 0 Transmitting 1 0 0 1 Receiving
 */
/*!
 * @name Constants and macros for entire CAN_ESR1 register
 */
/*@{*/
#define CAN_RD_ESR1(base)        (CAN_ESR1_REG(base))
#define CAN_WR_ESR1(base, value) (CAN_ESR1_REG(base) = (value))
#define CAN_RMW_ESR1(base, mask, value) (CAN_WR_ESR1(base, (CAN_RD_ESR1(base) & ~(mask)) | (value)))
#define CAN_SET_ESR1(base, value) (BME_OR32(&CAN_ESR1_REG(base), (uint32_t)(value)))
#define CAN_CLR_ESR1(base, value) (BME_AND32(&CAN_ESR1_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_ESR1(base, value) (BME_XOR32(&CAN_ESR1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR1 bitfields
 */

/*!
 * @name Register CAN_ESR1, field WAKINT[0] (W1C)
 *
 * This field applies when FlexCAN is in low-power mode under Self Wake Up
 * mechanism: Doze mode Stop mode When a recessive-to-dominant transition is detected
 * on the CAN bus and if the CAN_MCR[WAKMSK] bit is set, an interrupt is
 * generated to the CPU. This bit is cleared by writing it to 1. When CAN_MCR[SLFWAK] is
 * negated, this flag is masked. The CPU must clear this flag before disabling
 * the bit. Otherwise it will be set when the SLFWAK is set again. Writing 0 has no
 * effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - Indicates a recessive to dominant transition was received on the CAN
 *     bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_WAKINT field. */
#define CAN_RD_ESR1_WAKINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_WAKINT_MASK) >> CAN_ESR1_WAKINT_SHIFT)
#define CAN_BRD_ESR1_WAKINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_WAKINT_SHIFT, CAN_ESR1_WAKINT_WIDTH))

/*! @brief Set the WAKINT field to a new value. */
#define CAN_WR_ESR1_WAKINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_WAKINT(value)))
#define CAN_BWR_ESR1_WAKINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_WAKINT_SHIFT), CAN_ESR1_WAKINT_SHIFT, CAN_ESR1_WAKINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERRINT[1] (W1C)
 *
 * This bit indicates that at least one of the Error Bits (BIT1ERR, BIT0ERR,
 * ACKERR. CRCERR, FRMERR or STFERR) is set. If the corresponding mask bit
 * CAN_CTRL1[ERRMSK] is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - Indicates setting of any Error Bit in the Error and Status Register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERRINT field. */
#define CAN_RD_ESR1_ERRINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERRINT_MASK) >> CAN_ESR1_ERRINT_SHIFT)
#define CAN_BRD_ESR1_ERRINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_SHIFT, CAN_ESR1_ERRINT_WIDTH))

/*! @brief Set the ERRINT field to a new value. */
#define CAN_WR_ESR1_ERRINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERRINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_ERRINT(value)))
#define CAN_BWR_ESR1_ERRINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_ERRINT_SHIFT), CAN_ESR1_ERRINT_SHIFT, CAN_ESR1_ERRINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFINT[2] (W1C)
 *
 * This bit is set when FlexCAN enters 'Bus Off' state. If the corresponding
 * mask bit in the Control Register 1 (CAN_CTRL1[BOFFMSK]) is set, an interrupt is
 * generated to the CPU. This bit is cleared by writing it to 1. Writing 0 has no
 * effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - FlexCAN module entered Bus Off state.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFINT field. */
#define CAN_RD_ESR1_BOFFINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFINT_MASK) >> CAN_ESR1_BOFFINT_SHIFT)
#define CAN_BRD_ESR1_BOFFINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFINT_SHIFT, CAN_ESR1_BOFFINT_WIDTH))

/*! @brief Set the BOFFINT field to a new value. */
#define CAN_WR_ESR1_BOFFINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFINT(value)))
#define CAN_BWR_ESR1_BOFFINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_BOFFINT_SHIFT), CAN_ESR1_BOFFINT_SHIFT, CAN_ESR1_BOFFINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RX[3] (RO)
 *
 * This bit indicates if FlexCAN is receiving a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not receiving a message.
 * - 0b1 - FlexCAN is receiving a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RX field. */
#define CAN_RD_ESR1_RX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RX_MASK) >> CAN_ESR1_RX_SHIFT)
#define CAN_BRD_ESR1_RX(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_RX_SHIFT, CAN_ESR1_RX_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FLTCONF[5:4] (RO)
 *
 * This 2-bit field indicates the Confinement State of the FlexCAN module. If
 * the LOM bit in the Control Register 1 is asserted, after some delay that depends
 * on the CAN bit timing the FLTCONF field will indicate "Error Passive". The
 * very same delay affects the way how FLTCONF reflects an update to CAN_ECR
 * register by the CPU. It may be necessary up to one CAN bit time to get them coherent
 * again. This bit field is affected by soft reset, but if the LOM bit is
 * asserted, its reset value lasts just one CAN bit. After this time, FLTCONF reports
 * "Error Passive".
 *
 * Values:
 * - 0b00 - Error Active
 * - 0b01 - Error Passive
 * - 0b1x - Bus Off
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FLTCONF field. */
#define CAN_RD_ESR1_FLTCONF(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FLTCONF_MASK) >> CAN_ESR1_FLTCONF_SHIFT)
#define CAN_BRD_ESR1_FLTCONF(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_FLTCONF_SHIFT, CAN_ESR1_FLTCONF_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TX[6] (RO)
 *
 * This bit indicates if FlexCAN is transmitting a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not transmitting a message.
 * - 0b1 - FlexCAN is transmitting a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TX field. */
#define CAN_RD_ESR1_TX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TX_MASK) >> CAN_ESR1_TX_SHIFT)
#define CAN_BRD_ESR1_TX(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_TX_SHIFT, CAN_ESR1_TX_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field IDLE[7] (RO)
 *
 * This bit indicates when CAN bus is in IDLE state. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - CAN bus is now IDLE.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_IDLE field. */
#define CAN_RD_ESR1_IDLE(base) ((CAN_ESR1_REG(base) & CAN_ESR1_IDLE_MASK) >> CAN_ESR1_IDLE_SHIFT)
#define CAN_BRD_ESR1_IDLE(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_IDLE_SHIFT, CAN_ESR1_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RXWRN[8] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * reception and is affected by the value of RXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - RXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RXWRN field. */
#define CAN_RD_ESR1_RXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RXWRN_MASK) >> CAN_ESR1_RXWRN_SHIFT)
#define CAN_BRD_ESR1_RXWRN(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_RXWRN_SHIFT, CAN_ESR1_RXWRN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TXWRN[9] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * transmission and is affected by the value of TXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - TXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TXWRN field. */
#define CAN_RD_ESR1_TXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TXWRN_MASK) >> CAN_ESR1_TXWRN_SHIFT)
#define CAN_BRD_ESR1_TXWRN(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_TXWRN_SHIFT, CAN_ESR1_TXWRN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field STFERR[10] (RO)
 *
 * This bit indicates that a Stuffing Error has been detected by the receiver
 * node.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Stuffing Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_STFERR field. */
#define CAN_RD_ESR1_STFERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_STFERR_MASK) >> CAN_ESR1_STFERR_SHIFT)
#define CAN_BRD_ESR1_STFERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_STFERR_SHIFT, CAN_ESR1_STFERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FRMERR[11] (RO)
 *
 * This bit indicates that a Form Error has been detected by the receiver node,
 * that is, a fixed-form bit field contains at least one illegal bit.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A Form Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FRMERR field. */
#define CAN_RD_ESR1_FRMERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FRMERR_MASK) >> CAN_ESR1_FRMERR_SHIFT)
#define CAN_BRD_ESR1_FRMERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_FRMERR_SHIFT, CAN_ESR1_FRMERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field CRCERR[12] (RO)
 *
 * This bit indicates that a CRC Error has been detected by the receiver node,
 * that is, the calculated CRC is different from the received.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - A CRC error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_CRCERR field. */
#define CAN_RD_ESR1_CRCERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_CRCERR_MASK) >> CAN_ESR1_CRCERR_SHIFT)
#define CAN_BRD_ESR1_CRCERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_CRCERR_SHIFT, CAN_ESR1_CRCERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ACKERR[13] (RO)
 *
 * This bit indicates that an Acknowledge Error has been detected by the
 * transmitter node, that is, a dominant bit has not been detected during the ACK SLOT.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - An ACK error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ACKERR field. */
#define CAN_RD_ESR1_ACKERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ACKERR_MASK) >> CAN_ESR1_ACKERR_SHIFT)
#define CAN_BRD_ESR1_ACKERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_ACKERR_SHIFT, CAN_ESR1_ACKERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT0ERR[14] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as dominant is received as recessive.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT0ERR field. */
#define CAN_RD_ESR1_BIT0ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT0ERR_MASK) >> CAN_ESR1_BIT0ERR_SHIFT)
#define CAN_BRD_ESR1_BIT0ERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_BIT0ERR_SHIFT, CAN_ESR1_BIT0ERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT1ERR[15] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message. This bit is not set by a transmitter in case of
 * arbitration field or ACK slot, or in case of a node sending a passive error
 * flag that detects dominant bits.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - At least one bit sent as recessive is received as dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT1ERR field. */
#define CAN_RD_ESR1_BIT1ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT1ERR_MASK) >> CAN_ESR1_BIT1ERR_SHIFT)
#define CAN_BRD_ESR1_BIT1ERR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_BIT1ERR_SHIFT, CAN_ESR1_BIT1ERR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RWRNINT[16] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the RWRNINT bit is set when the
 * RXWRN flag transitions from 0 to 1, meaning that the Rx error counters reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[RWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing
 * it to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This bit is not updated during Freeze mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - The Rx error counter transitioned from less than 96 to greater than
 *     or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RWRNINT field. */
#define CAN_RD_ESR1_RWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RWRNINT_MASK) >> CAN_ESR1_RWRNINT_SHIFT)
#define CAN_BRD_ESR1_RWRNINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_RWRNINT_SHIFT, CAN_ESR1_RWRNINT_WIDTH))

/*! @brief Set the RWRNINT field to a new value. */
#define CAN_WR_ESR1_RWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_RWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_RWRNINT(value)))
#define CAN_BWR_ESR1_RWRNINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_RWRNINT_SHIFT), CAN_ESR1_RWRNINT_SHIFT, CAN_ESR1_RWRNINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TWRNINT[17] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the TWRNINT bit is set when the
 * TXWRN flag transitions from 0 to 1, meaning that the Tx error counter reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[TWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing it
 * to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This flag is not generated during Bus Off state. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - The Tx error counter transitioned from less than 96 to greater than
 *     or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TWRNINT field. */
#define CAN_RD_ESR1_TWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TWRNINT_MASK) >> CAN_ESR1_TWRNINT_SHIFT)
#define CAN_BRD_ESR1_TWRNINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_TWRNINT_SHIFT, CAN_ESR1_TWRNINT_WIDTH))

/*! @brief Set the TWRNINT field to a new value. */
#define CAN_WR_ESR1_TWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_TWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_TWRNINT(value)))
#define CAN_BWR_ESR1_TWRNINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_TWRNINT_SHIFT), CAN_ESR1_TWRNINT_SHIFT, CAN_ESR1_TWRNINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field SYNCH[18] (RO)
 *
 * This read-only flag indicates whether the FlexCAN is synchronized to the CAN
 * bus and able to participate in the communication process. It is set and
 * cleared by the FlexCAN. See the table in the overall CAN_ESR1 register description.
 *
 * Values:
 * - 0b0 - FlexCAN is not synchronized to the CAN bus.
 * - 0b1 - FlexCAN is synchronized to the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_SYNCH field. */
#define CAN_RD_ESR1_SYNCH(base) ((CAN_ESR1_REG(base) & CAN_ESR1_SYNCH_MASK) >> CAN_ESR1_SYNCH_SHIFT)
#define CAN_BRD_ESR1_SYNCH(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_SYNCH_SHIFT, CAN_ESR1_SYNCH_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFDONEINT[19] (W1C)
 *
 * This bit is set when the Tx Error Counter (TXERRCNT) has finished counting
 * 128 occurrences of 11 consecutive recessive bits on the CAN bus and is ready to
 * leave Bus Off. If the corresponding mask bit in the Control 2 Register
 * (BOFFDONEMSK) is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0b0 - No such occurrence.
 * - 0b1 - FlexCAN module has completed Bus Off process.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFDONEINT field. */
#define CAN_RD_ESR1_BOFFDONEINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFDONEINT_MASK) >> CAN_ESR1_BOFFDONEINT_SHIFT)
#define CAN_BRD_ESR1_BOFFDONEINT(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFDONEINT_SHIFT, CAN_ESR1_BOFFDONEINT_WIDTH))

/*! @brief Set the BOFFDONEINT field to a new value. */
#define CAN_WR_ESR1_BOFFDONEINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFDONEINT(value)))
#define CAN_BWR_ESR1_BOFFDONEINT(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_BOFFDONEINT_SHIFT), CAN_ESR1_BOFFDONEINT_SHIFT, CAN_ESR1_BOFFDONEINT_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERROVR[21] (W1C)
 *
 * This bit indicates that an error condition occurred when any error flag is
 * already set. This bit is cleared by writing it to 1.
 *
 * Values:
 * - 0b0 - Overrun has not occurred.
 * - 0b1 - Overrun has occured.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERROVR field. */
#define CAN_RD_ESR1_ERROVR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERROVR_MASK) >> CAN_ESR1_ERROVR_SHIFT)
#define CAN_BRD_ESR1_ERROVR(base) (BME_UBFX32(&CAN_ESR1_REG(base), CAN_ESR1_ERROVR_SHIFT, CAN_ESR1_ERROVR_WIDTH))

/*! @brief Set the ERROVR field to a new value. */
#define CAN_WR_ESR1_ERROVR(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERROVR_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK), CAN_ESR1_ERROVR(value)))
#define CAN_BWR_ESR1_ERROVR(base, value) (BME_BFI32(&CAN_ESR1_REG(base), ((uint32_t)(value) << CAN_ESR1_ERROVR_SHIFT), CAN_ESR1_ERROVR_SHIFT, CAN_ESR1_ERROVR_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_IMASK1 - Interrupt Masks 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IMASK1 - Interrupt Masks 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows any number of a range of the 16 Message Buffer
 * Interrupts to be enabled or disabled for MB15 to MB0. It contains one interrupt mask
 * bit per buffer, enabling the CPU to determine which buffer generates an
 * interrupt after a successful transmission or reception, that is, when the
 * corresponding CAN_IFLAG1 bit is set.
 */
/*!
 * @name Constants and macros for entire CAN_IMASK1 register
 */
/*@{*/
#define CAN_RD_IMASK1(base)      (CAN_IMASK1_REG(base))
#define CAN_WR_IMASK1(base, value) (CAN_IMASK1_REG(base) = (value))
#define CAN_RMW_IMASK1(base, mask, value) (CAN_WR_IMASK1(base, (CAN_RD_IMASK1(base) & ~(mask)) | (value)))
#define CAN_SET_IMASK1(base, value) (BME_OR32(&CAN_IMASK1_REG(base), (uint32_t)(value)))
#define CAN_CLR_IMASK1(base, value) (BME_AND32(&CAN_IMASK1_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_IMASK1(base, value) (BME_XOR32(&CAN_IMASK1_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * CAN_IFLAG1 - Interrupt Flags 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IFLAG1 - Interrupt Flags 1 register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the flags for the 16 Message Buffer interrupts for MB15
 * to MB0. It contains one interrupt flag bit per buffer. Each successful
 * transmission or reception sets the corresponding CAN_IFLAG1 bit. If the
 * corresponding CAN_IMASK1 bit is set, an interrupt will be generated. The interrupt flag
 * must be cleared by writing 1 to it. Writing 0 has no effect. There is an
 * exception when DMA for Rx FIFO is enabled, as described below. The BUF7I to BUF5I
 * flags are also used to represent FIFO interrupts when the Rx FIFO is enabled.
 * When the bit CAN_MCR[RFEN] is set and the bit CAN_MCR[DMA] is negated, the
 * function of the 8 least significant interrupt flags changes: BUF7I, BUF6I and BUF5I
 * indicate operating conditions of the FIFO, BUF0I is used to empty FIFO, and
 * BUF4I to BUF1I bits are reserved. Before enabling the CAN_MCR[RFEN], the CPU
 * must service the IFLAG bits asserted in the Rx FIFO region; see Section "Rx
 * FIFO". Otherwise, these IFLAG bits will mistakenly show the related MBs now
 * belonging to FIFO as having contents to be serviced. When the CAN_MCR[RFEN] bit is
 * negated, the FIFO flags must be cleared. The same care must be taken when an
 * CAN_CTRL2[RFFN] value is selected extending Rx FIFO filters beyond MB7. For
 * example, when RFFN is 0x8, the MB0-23 range is occupied by Rx FIFO filters and
 * related IFLAG bits must be cleared. When both the CAN_MCR[RFEN] and CAN_MCR[DMA]
 * bits are asserted (DMA feature for Rx FIFO enabled), the function of the 8
 * least significant interrupt flags (BUF7I - BUF0I) are changed to support the DMA
 * operation. BUF7I and BUF6I are not used, as well as, BUF4I to BUF1I. BUF5I
 * indicates operating condition of FIFO, and BUF0I is used to empty FIFO. Moreover,
 * BUF5I does not generate a CPU interrupt, but generates a DMA request. IMASK1
 * bits in Rx FIFO region are not considered when bit CAN_MCR[DMA] is enabled. In
 * addition the CPU must not clear the flag BUF5I when DMA is enabled. Before
 * enabling the bit CAN_MCR[DMA], the CPU must service the IFLAGs asserted in the Rx
 * FIFO region. When the bit CAN_MCR[DMA] is negated, the FIFO must be empty.
 * Before updating CAN_MCR[MAXMB] field, CPU must service the CAN_IFLAG1 bits whose
 * MB value is greater than the CAN_MCR[MAXMB] to be updated; otherwise, they
 * will remain set and be inconsistent with the number of MBs available.
 */
/*!
 * @name Constants and macros for entire CAN_IFLAG1 register
 */
/*@{*/
#define CAN_RD_IFLAG1(base)      (CAN_IFLAG1_REG(base))
#define CAN_WR_IFLAG1(base, value) (CAN_IFLAG1_REG(base) = (value))
#define CAN_RMW_IFLAG1(base, mask, value) (CAN_WR_IFLAG1(base, (CAN_RD_IFLAG1(base) & ~(mask)) | (value)))
#define CAN_SET_IFLAG1(base, value) (BME_OR32(&CAN_IFLAG1_REG(base), (uint32_t)(value)))
#define CAN_CLR_IFLAG1(base, value) (BME_AND32(&CAN_IFLAG1_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_IFLAG1(base, value) (BME_XOR32(&CAN_IFLAG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_IFLAG1 bitfields
 */

/*!
 * @name Register CAN_IFLAG1, field BUF0I[0] (W1C)
 *
 * When the RFEN bit in MCR is cleared (Rx FIFO disabled), this bit flags the
 * interrupt for MB0. If the Rx FIFO is enabled, this bit is used to trigger the
 * clear FIFO operation. This operation empties FIFO contents. Before performing
 * this operation the CPU must service all FIFO related IFLAGs. When the bit
 * MCR[DMA] is enabled this operation also clears the BUF5I flag and consequently abort
 * the DMA request. The clear FIFO operation occurs when the CPU writes 1 in
 * BUF0I. It is only allowed in Freeze Mode and is blocked by hardware in other
 * conditions.
 *
 * Values:
 * - 0b0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 0b1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF0I field. */
#define CAN_RD_IFLAG1_BUF0I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF0I_MASK) >> CAN_IFLAG1_BUF0I_SHIFT)
#define CAN_BRD_IFLAG1_BUF0I(base) (BME_UBFX32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF0I_SHIFT, CAN_IFLAG1_BUF0I_WIDTH))

/*! @brief Set the BUF0I field to a new value. */
#define CAN_WR_IFLAG1_BUF0I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF0I(value)))
#define CAN_BWR_IFLAG1_BUF0I(base, value) (BME_BFI32(&CAN_IFLAG1_REG(base), ((uint32_t)(value) << CAN_IFLAG1_BUF0I_SHIFT), CAN_IFLAG1_BUF0I_SHIFT, CAN_IFLAG1_BUF0I_WIDTH))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF4TO1I[4:1] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled),
 * these bits flag the interrupts for MB4 to MB1. These flags are cleared by the
 * FlexCAN whenever the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF4TO1I
 * flags are reserved when CAN_MCR[RFEN] is set.
 *
 * Values:
 * - 0b0000 - The corresponding buffer has no occurrence of successfully
 *     completed transmission or reception when MCR[RFEN]=0.
 * - 0b0001 - The corresponding buffer has successfully completed transmission
 *     or reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF4TO1I field. */
#define CAN_RD_IFLAG1_BUF4TO1I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF4TO1I_MASK) >> CAN_IFLAG1_BUF4TO1I_SHIFT)
#define CAN_BRD_IFLAG1_BUF4TO1I(base) (BME_UBFX32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF4TO1I_SHIFT, CAN_IFLAG1_BUF4TO1I_WIDTH))

/*! @brief Set the BUF4TO1I field to a new value. */
#define CAN_WR_IFLAG1_BUF4TO1I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF4TO1I(value)))
#define CAN_BWR_IFLAG1_BUF4TO1I(base, value) (BME_BFI32(&CAN_IFLAG1_REG(base), ((uint32_t)(value) << CAN_IFLAG1_BUF4TO1I_SHIFT), CAN_IFLAG1_BUF4TO1I_SHIFT, CAN_IFLAG1_BUF4TO1I_WIDTH))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF5I[5] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB5. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. When MCR[RFEN] is set (Rx FIFO enabled), the
 * BUF5I flag represents "Frames available in Rx FIFO" and indicates that at least
 * one frame is available to be read from the Rx FIFO. When the MCR[DMA] bit is
 * enabled, this flag generates a DMA request and the CPU must not clear this bit
 * by writing 1 in BUF5I.
 *
 * Values:
 * - 0b0 - No occurrence of MB5 completing transmission/reception when
 *     MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
 * - 0b1 - MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s)
 *     available in the Rx FIFO when MCR[RFEN]=1. It generates a DMA request in
 *     case of MCR[RFEN] and MCR[DMA] are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF5I field. */
#define CAN_RD_IFLAG1_BUF5I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF5I_MASK) >> CAN_IFLAG1_BUF5I_SHIFT)
#define CAN_BRD_IFLAG1_BUF5I(base) (BME_UBFX32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF5I_SHIFT, CAN_IFLAG1_BUF5I_WIDTH))

/*! @brief Set the BUF5I field to a new value. */
#define CAN_WR_IFLAG1_BUF5I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF5I(value)))
#define CAN_BWR_IFLAG1_BUF5I(base, value) (BME_BFI32(&CAN_IFLAG1_REG(base), ((uint32_t)(value) << CAN_IFLAG1_BUF5I_SHIFT), CAN_IFLAG1_BUF5I_SHIFT, CAN_IFLAG1_BUF5I_WIDTH))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF6I[6] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB6. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF6I flag represents "Rx
 * FIFO Warning" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * when the number of unread messages within the Rx FIFO is increased to 5 from 4
 * due to the reception of a new one, meaning that the Rx FIFO is almost full. Note
 * that if the flag is cleared while the number of unread messages is greater
 * than 4, it does not assert again until the number of unread messages within the
 * Rx FIFO is decreased to be equal to or less than 4.
 *
 * Values:
 * - 0b0 - No occurrence of MB6 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
 * - 0b1 - MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     almost full when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF6I field. */
#define CAN_RD_IFLAG1_BUF6I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF6I_MASK) >> CAN_IFLAG1_BUF6I_SHIFT)
#define CAN_BRD_IFLAG1_BUF6I(base) (BME_UBFX32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF6I_SHIFT, CAN_IFLAG1_BUF6I_WIDTH))

/*! @brief Set the BUF6I field to a new value. */
#define CAN_WR_IFLAG1_BUF6I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF6I(value)))
#define CAN_BWR_IFLAG1_BUF6I(base, value) (BME_BFI32(&CAN_IFLAG1_REG(base), ((uint32_t)(value) << CAN_IFLAG1_BUF6I_SHIFT), CAN_IFLAG1_BUF6I_SHIFT, CAN_IFLAG1_BUF6I_WIDTH))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF7I[7] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB7. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF7I flag represents "Rx
 * FIFO Overflow" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * that a message was lost because the Rx FIFO is full. Note that the flag will not
 * be asserted when the Rx FIFO is full and the message was captured by a
 * Mailbox.
 *
 * Values:
 * - 0b0 - No occurrence of MB7 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
 * - 0b1 - MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     overflow when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF7I field. */
#define CAN_RD_IFLAG1_BUF7I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF7I_MASK) >> CAN_IFLAG1_BUF7I_SHIFT)
#define CAN_BRD_IFLAG1_BUF7I(base) (BME_UBFX32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF7I_SHIFT, CAN_IFLAG1_BUF7I_WIDTH))

/*! @brief Set the BUF7I field to a new value. */
#define CAN_WR_IFLAG1_BUF7I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF7I(value)))
#define CAN_BWR_IFLAG1_BUF7I(base, value) (BME_BFI32(&CAN_IFLAG1_REG(base), ((uint32_t)(value) << CAN_IFLAG1_BUF7I_SHIFT), CAN_IFLAG1_BUF7I_SHIFT, CAN_IFLAG1_BUF7I_WIDTH))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF31TO8I[31:8] (W1C)
 *
 * Each bit flags the corresponding FlexCAN Message Buffer interrupt for MB15 to
 * MB8.
 *
 * Values:
 * - 0b000000000000000000000000 - The corresponding buffer has no occurrence of
 *     successfully completed transmission or reception.
 * - 0b000000000000000000000001 - The corresponding buffer has successfully
 *     completed transmission or reception.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF31TO8I field. */
#define CAN_RD_IFLAG1_BUF31TO8I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF31TO8I_MASK) >> CAN_IFLAG1_BUF31TO8I_SHIFT)
#define CAN_BRD_IFLAG1_BUF31TO8I(base) (CAN_RD_IFLAG1_BUF31TO8I(base))

/*! @brief Set the BUF31TO8I field to a new value. */
#define CAN_WR_IFLAG1_BUF31TO8I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF31TO8I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK), CAN_IFLAG1_BUF31TO8I(value)))
#define CAN_BWR_IFLAG1_BUF31TO8I(base, value) (CAN_WR_IFLAG1_BUF31TO8I(base, value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL2 - Control 2 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL2 - Control 2 register (RW)
 *
 * Reset value: 0x00B00000U
 *
 * This register complements Control1 Register providing control bits for memory
 * write access in Freeze Mode, for extending FIFO filter quantity, and for
 * adjust the operation of internal FlexCAN processes like matching and arbitration.
 * The contents of this register are not affected by soft reset.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL2 register
 */
/*@{*/
#define CAN_RD_CTRL2(base)       (CAN_CTRL2_REG(base))
#define CAN_WR_CTRL2(base, value) (CAN_CTRL2_REG(base) = (value))
#define CAN_RMW_CTRL2(base, mask, value) (CAN_WR_CTRL2(base, (CAN_RD_CTRL2(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL2(base, value) (BME_OR32(&CAN_CTRL2_REG(base), (uint32_t)(value)))
#define CAN_CLR_CTRL2(base, value) (BME_AND32(&CAN_CTRL2_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_CTRL2(base, value) (BME_XOR32(&CAN_CTRL2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL2 bitfields
 */

/*!
 * @name Register CAN_CTRL2, field EACEN[16] (RW)
 *
 * This bit controls the comparison of IDE and RTR bits within Rx Mailboxes
 * filters with their corresponding bits in the incoming frame by the matching
 * process. This bit does not affect matching for Rx FIFO. This bit can be written only
 * in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Rx Mailbox filter's IDE bit is always compared and RTR is never
 *     compared despite mask bits.
 * - 0b1 - Enables the comparison of both Rx Mailbox filter's IDE and RTR bit
 *     with their corresponding bits within the incoming frame. Mask bits do apply.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_EACEN field. */
#define CAN_RD_CTRL2_EACEN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_EACEN_MASK) >> CAN_CTRL2_EACEN_SHIFT)
#define CAN_BRD_CTRL2_EACEN(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_EACEN_SHIFT, CAN_CTRL2_EACEN_WIDTH))

/*! @brief Set the EACEN field to a new value. */
#define CAN_WR_CTRL2_EACEN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_EACEN_MASK, CAN_CTRL2_EACEN(value)))
#define CAN_BWR_CTRL2_EACEN(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_EACEN_SHIFT), CAN_CTRL2_EACEN_SHIFT, CAN_CTRL2_EACEN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RRS[17] (RW)
 *
 * If this bit is asserted Remote Request Frame is submitted to a matching
 * process and stored in the corresponding Message Buffer in the same fashion of a
 * Data Frame. No automatic Remote Response Frame will be generated. If this bit is
 * negated the Remote Request Frame is submitted to a matching process and an
 * automatic Remote Response Frame is generated if a Message Buffer with CODE=0b1010
 * is found with the same ID. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Remote Response Frame is generated.
 * - 0b1 - Remote Request Frame is stored.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RRS field. */
#define CAN_RD_CTRL2_RRS(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RRS_MASK) >> CAN_CTRL2_RRS_SHIFT)
#define CAN_BRD_CTRL2_RRS(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_RRS_SHIFT, CAN_CTRL2_RRS_WIDTH))

/*! @brief Set the RRS field to a new value. */
#define CAN_WR_CTRL2_RRS(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RRS_MASK, CAN_CTRL2_RRS(value)))
#define CAN_BWR_CTRL2_RRS(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_RRS_SHIFT), CAN_CTRL2_RRS_SHIFT, CAN_CTRL2_RRS_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field MRP[18] (RW)
 *
 * If this bit is set the matching process starts from the Mailboxes and if no
 * match occurs the matching continues on the Rx FIFO. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0b0 - Matching starts from Rx FIFO and continues on Mailboxes.
 * - 0b1 - Matching starts from Mailboxes and continues on Rx FIFO.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_MRP field. */
#define CAN_RD_CTRL2_MRP(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_MRP_MASK) >> CAN_CTRL2_MRP_SHIFT)
#define CAN_BRD_CTRL2_MRP(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_MRP_SHIFT, CAN_CTRL2_MRP_WIDTH))

/*! @brief Set the MRP field to a new value. */
#define CAN_WR_CTRL2_MRP(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_MRP_MASK, CAN_CTRL2_MRP(value)))
#define CAN_BWR_CTRL2_MRP(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_MRP_SHIFT), CAN_CTRL2_MRP_SHIFT, CAN_CTRL2_MRP_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field TASD[23:19] (RW)
 *
 * This 5-bit field indicates how many CAN bits the Tx arbitration process start
 * point can be delayed from the first bit of CRC field on CAN bus. See Tx
 * Arbitration start delay for more details. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_TASD field. */
#define CAN_RD_CTRL2_TASD(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_TASD_MASK) >> CAN_CTRL2_TASD_SHIFT)
#define CAN_BRD_CTRL2_TASD(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_TASD_SHIFT, CAN_CTRL2_TASD_WIDTH))

/*! @brief Set the TASD field to a new value. */
#define CAN_WR_CTRL2_TASD(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_TASD_MASK, CAN_CTRL2_TASD(value)))
#define CAN_BWR_CTRL2_TASD(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_TASD_SHIFT), CAN_CTRL2_TASD_SHIFT, CAN_CTRL2_TASD_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RFFN[27:24] (RW)
 *
 * This 4-bit field defines the number of Rx FIFO filters, as shown in the
 * following table. The maximum selectable number of filters is determined by the
 * chip. This field can only be written in Freeze mode as it is blocked by hardware
 * in other modes. This field must not be programmed with values that make the
 * number of Message Buffers occupied by Rx FIFO and ID Filter exceed the number of
 * Mailboxes present, defined by CAN_MCR[MAXMB]. Each group of eight filters
 * occupies a memory space equivalent to two Message Buffers which means that the
 * more filters are implemented the less Mailboxes will be available. Considering
 * that the Rx FIFO occupies the memory space originally reserved for MB0-5, RFFN
 * should be programmed with a value corresponding to a number of filters not
 * greater than the number of available memory words which can be calculated as
 * follows: (SETUP_MB - 6) * 4 where SETUP_MB is the least between the parameter
 * NUMBER_OF_MB and CAN_MCR[MAXMB]. The number of remaining Mailboxes available will
 * be: (SETUP_MB - 8) - (RFFN * 2) If the Number of Rx FIFO Filters programmed
 * through RFFN exceeds the SETUP_MB value (memory space available) the exceeding
 * ones will not be functional. The number of the last remaining available
 * mailboxes is defined by the least value between the NUMBER_OF_MB minus 1 and the
 * CAN_MCR[MAXMB] field. If Rx Individual Mask Registers are not enabled then all Rx
 * FIFO filters are affected by the Rx FIFO Global Mask. RFFN[3:0] Number of Rx
 * FIFO filter elements Message Buffers occupied by Rx FIFO and ID Filter Table
 * Remaining Available Mailboxes Rx FIFO ID Filter Table Elements Affected by Rx
 * Individual Masks Rx FIFO ID Filter Table Elements Affected by Rx FIFO Global Mask
 * 0x0 8 MB 0-7 MB 8-63 Elements 0-7 none 0x1 16 MB 0-9 MB 10-63 Elements 0-9
 * Elements 10-15 0x2 24 MB 0-11 MB 12-63 Elements 0-11 Elements 12-23 0x3 32 MB
 * 0-13 MB 14-63 Elements 0-13 Elements 14-31 0x4 40 MB 0-15 MB 16-63 Elements 0-15
 * Elements 16-39 0x5 48 MB 0-17 MB 18-63 Elements 0-17 Elements 18-47 0x6 56 MB
 * 0-19 MB 20-63 Elements 0-19 Elements 20-55 0x7 64 MB 0-21 MB 22-63 Elements
 * 0-21 Elements 22-63 0x8 72 MB 0-23 MB 24-63 Elements 0-23 Elements 24-71 0x9 80
 * MB 0-25 MB 26-63 Elements 0-25 Elements 26-79 0xA 88 MB 0-27 MB 28-63
 * Elements 0-27 Elements 28-87 0xB 96 MB 0-29 MB 30-63 Elements 0-29 Elements 30-95 0xC
 * 104 MB 0-31 MB 32-63 Elements 0-31 Elements 32-103 0xD 112 MB 0-33 MB 34-63
 * Elements 0-31 Elements 32-111 0xE 120 MB 0-35 MB 36-63 Elements 0-31 Elements
 * 32-119 0xF 128 MB 0-37 MB 38-63 Elements 0-31 Elements 32-127
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RFFN field. */
#define CAN_RD_CTRL2_RFFN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT)
#define CAN_BRD_CTRL2_RFFN(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_RFFN_SHIFT, CAN_CTRL2_RFFN_WIDTH))

/*! @brief Set the RFFN field to a new value. */
#define CAN_WR_CTRL2_RFFN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RFFN_MASK, CAN_CTRL2_RFFN(value)))
#define CAN_BWR_CTRL2_RFFN(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_RFFN_SHIFT), CAN_CTRL2_RFFN_SHIFT, CAN_CTRL2_RFFN_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field BOFFDONEMSK[30] (RW)
 *
 * This bit provides a mask for the Bus Off Done Interrupt in CAN_ESR1 register.
 *
 * Values:
 * - 0b0 - Bus Off Done interrupt disabled.
 * - 0b1 - Bus Off Done interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_BOFFDONEMSK field. */
#define CAN_RD_CTRL2_BOFFDONEMSK(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_BOFFDONEMSK_MASK) >> CAN_CTRL2_BOFFDONEMSK_SHIFT)
#define CAN_BRD_CTRL2_BOFFDONEMSK(base) (BME_UBFX32(&CAN_CTRL2_REG(base), CAN_CTRL2_BOFFDONEMSK_SHIFT, CAN_CTRL2_BOFFDONEMSK_WIDTH))

/*! @brief Set the BOFFDONEMSK field to a new value. */
#define CAN_WR_CTRL2_BOFFDONEMSK(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_BOFFDONEMSK_MASK, CAN_CTRL2_BOFFDONEMSK(value)))
#define CAN_BWR_CTRL2_BOFFDONEMSK(base, value) (BME_BFI32(&CAN_CTRL2_REG(base), ((uint32_t)(value) << CAN_CTRL2_BOFFDONEMSK_SHIFT), CAN_CTRL2_BOFFDONEMSK_SHIFT, CAN_CTRL2_BOFFDONEMSK_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_ESR2 - Error and Status 2 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR2 - Error and Status 2 register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register reports some general status information.
 */
/*!
 * @name Constants and macros for entire CAN_ESR2 register
 */
/*@{*/
#define CAN_RD_ESR2(base)        (CAN_ESR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR2 bitfields
 */

/*!
 * @name Register CAN_ESR2, field IMB[13] (RO)
 *
 * If ESR2[VPS] is asserted, this bit indicates whether there is any inactive
 * Mailbox (CODE field is either 0b1000 or 0b0000). This bit is asserted in the
 * following cases: During arbitration, if an CAN_ESR2[LPTM] is found and it is
 * inactive. If CAN_ESR2[IMB] is not asserted and a frame is transmitted
 * successfully. This bit is cleared in all start of arbitration (see Section "Arbitration
 * process"). CAN_ESR2[LPTM] mechanism have the following behavior: if an MB is
 * successfully transmitted and CAN_ESR2[IMB]=0 (no inactive Mailbox), then
 * CAN_ESR2[VPS] and CAN_ESR2[IMB] are asserted and the index related to the MB just
 * transmitted is loaded into CAN_ESR2[LPTM].
 *
 * Values:
 * - 0b0 - If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
 * - 0b1 - If ESR2[VPS] is asserted, there is at least one inactive Mailbox.
 *     LPTM content is the number of the first one.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_IMB field. */
#define CAN_RD_ESR2_IMB(base) ((CAN_ESR2_REG(base) & CAN_ESR2_IMB_MASK) >> CAN_ESR2_IMB_SHIFT)
#define CAN_BRD_ESR2_IMB(base) (BME_UBFX32(&CAN_ESR2_REG(base), CAN_ESR2_IMB_SHIFT, CAN_ESR2_IMB_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR2, field VPS[14] (RO)
 *
 * This bit indicates whether CAN_ESR2[IMB] and CAN_ESR2[LPTM] contents are
 * currently valid or not. It is asserted upon every complete Tx arbitration process
 * unless the CPU writes to Control and Status word of a Mailbox that has already
 * been scanned, that is, it is behind Tx Arbitration Pointer, during the Tx
 * arbitration process. If there is no inactive Mailbox and only one Tx Mailbox that
 * is being transmitted then VPS is not asserted. This bit is negated upon the
 * start of every Tx arbitration process or upon a write to Control and Status
 * word of any Mailbox. CAN_ESR2[VPS] is not affected by any CPU write into Control
 * Status (C/S) of a MB that is blocked by abort mechanism. When CAN_MCR[AEN] is
 * asserted, the abort code write in C/S of a MB that is being transmitted
 * (pending abort), or any write attempt into a Tx MB with CAN_IFLAG set is blocked.
 *
 * Values:
 * - 0b0 - Contents of IMB and LPTM are invalid.
 * - 0b1 - Contents of IMB and LPTM are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_VPS field. */
#define CAN_RD_ESR2_VPS(base) ((CAN_ESR2_REG(base) & CAN_ESR2_VPS_MASK) >> CAN_ESR2_VPS_SHIFT)
#define CAN_BRD_ESR2_VPS(base) (BME_UBFX32(&CAN_ESR2_REG(base), CAN_ESR2_VPS_SHIFT, CAN_ESR2_VPS_WIDTH))
/*@}*/

/*!
 * @name Register CAN_ESR2, field LPTM[22:16] (RO)
 *
 * If CAN_ESR2[VPS] is asserted, this field indicates the lowest number inactive
 * Mailbox (see the CAN_ESR2[IMB] bit description). If there is no inactive
 * Mailbox then the Mailbox indicated depends on CAN_CTRL1[LBUF] bit value. If
 * CAN_CTRL1[LBUF] bit is negated then the Mailbox indicated is the one that has the
 * greatest arbitration value (see the "Highest priority Mailbox first" section).
 * If CAN_CTRL1[LBUF] bit is asserted then the Mailbox indicated is the highest
 * number active Tx Mailbox. If a Tx Mailbox is being transmitted it is not
 * considered in LPTM calculation. If CAN_ESR2[IMB] is not asserted and a frame is
 * transmitted successfully, LPTM is updated with its Mailbox number.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_LPTM field. */
#define CAN_RD_ESR2_LPTM(base) ((CAN_ESR2_REG(base) & CAN_ESR2_LPTM_MASK) >> CAN_ESR2_LPTM_SHIFT)
#define CAN_BRD_ESR2_LPTM(base) (BME_UBFX32(&CAN_ESR2_REG(base), CAN_ESR2_LPTM_SHIFT, CAN_ESR2_LPTM_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_CRCR - CRC Register
 ******************************************************************************/

/*!
 * @brief CAN_CRCR - CRC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register provides information about the CRC of transmitted messages.
 * This register is updated at the same time the Tx Interrupt Flag is asserted.
 */
/*!
 * @name Constants and macros for entire CAN_CRCR register
 */
/*@{*/
#define CAN_RD_CRCR(base)        (CAN_CRCR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_CRCR bitfields
 */

/*!
 * @name Register CAN_CRCR, field TXCRC[14:0] (RO)
 *
 * This field indicates the CRC value of the last transmitted message.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_TXCRC field. */
#define CAN_RD_CRCR_TXCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_TXCRC_MASK) >> CAN_CRCR_TXCRC_SHIFT)
#define CAN_BRD_CRCR_TXCRC(base) (CAN_RD_CRCR_TXCRC(base))
/*@}*/

/*!
 * @name Register CAN_CRCR, field MBCRC[22:16] (RO)
 *
 * This field indicates the number of the Mailbox corresponding to the value in
 * CAN_CRCR[TXCRC] field.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_MBCRC field. */
#define CAN_RD_CRCR_MBCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_MBCRC_MASK) >> CAN_CRCR_MBCRC_SHIFT)
#define CAN_BRD_CRCR_MBCRC(base) (BME_UBFX32(&CAN_CRCR_REG(base), CAN_CRCR_MBCRC_SHIFT, CAN_CRCR_MBCRC_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_RXFGMASK - Rx FIFO Global Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RXFGMASK - Rx FIFO Global Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. If Rx FIFO is enabled, RXFGMASK is used to
 * mask the Rx FIFO ID Filter Table elements that do not have a corresponding
 * RXIMR according to CAN_CTRL2[RFFN] field setting. This register can only be
 * written in Freeze mode as it is blocked by hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXFGMASK register
 */
/*@{*/
#define CAN_RD_RXFGMASK(base)    (CAN_RXFGMASK_REG(base))
#define CAN_WR_RXFGMASK(base, value) (CAN_RXFGMASK_REG(base) = (value))
#define CAN_RMW_RXFGMASK(base, mask, value) (CAN_WR_RXFGMASK(base, (CAN_RD_RXFGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXFGMASK(base, value) (BME_OR32(&CAN_RXFGMASK_REG(base), (uint32_t)(value)))
#define CAN_CLR_RXFGMASK(base, value) (BME_AND32(&CAN_RXFGMASK_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_RXFGMASK(base, value) (BME_XOR32(&CAN_RXFGMASK_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * CAN_RXFIR - Rx FIFO Information Register
 ******************************************************************************/

/*!
 * @brief CAN_RXFIR - Rx FIFO Information Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFIR provides information on Rx FIFO. This register is the port through
 * which the CPU accesses the output of the RXFIR FIFO located in RAM. The RXFIR FIFO
 * is written by the FlexCAN whenever a new message is moved into the Rx FIFO as
 * well as its output is updated whenever the output of the Rx FIFO is updated
 * with the next message. See Section "Rx FIFO" for instructions on reading this
 * register.
 */
/*!
 * @name Constants and macros for entire CAN_RXFIR register
 */
/*@{*/
#define CAN_RD_RXFIR(base)       (CAN_RXFIR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_RXFIR bitfields
 */

/*!
 * @name Register CAN_RXFIR, field IDHIT[8:0] (RO)
 *
 * This field indicates which Identifier Acceptance Filter was hit by the
 * received message that is in the output of the Rx FIFO. If multiple filters match the
 * incoming message ID then the first matching IDAF found (lowest number) by the
 * matching process is indicated. This field is valid only while the
 * CAN_IFLAG1[BUF5I] is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_RXFIR_IDHIT field. */
#define CAN_RD_RXFIR_IDHIT(base) ((CAN_RXFIR_REG(base) & CAN_RXFIR_IDHIT_MASK) >> CAN_RXFIR_IDHIT_SHIFT)
#define CAN_BRD_RXFIR_IDHIT(base) (CAN_RD_RXFIR_IDHIT(base))
/*@}*/

/*******************************************************************************
 * CAN_CBT - CAN Bit Timing Register
 ******************************************************************************/

/*!
 * @brief CAN_CBT - CAN Bit Timing Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is an alternative way to store the CAN bit timing variables
 * described in CAN_CTRL1 register. EPRESDIV, EPROPSEG, EPSEG1, EPSEG2 and ERJW are
 * extended versions of PRESDIV, PROPSEG, PSEG1, PSEG2 and RJW bit fields
 * respectively. The BTF bit selects the use of the timing variables defined in this
 * register. The contents of this register are not affected by soft reset. The CAN
 * bit variables in CAN_CTRL1 and in CAN_CBT are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CBT register
 */
/*@{*/
#define CAN_RD_CBT(base)         (CAN_CBT_REG(base))
#define CAN_WR_CBT(base, value)  (CAN_CBT_REG(base) = (value))
#define CAN_RMW_CBT(base, mask, value) (CAN_WR_CBT(base, (CAN_RD_CBT(base) & ~(mask)) | (value)))
#define CAN_SET_CBT(base, value) (BME_OR32(&CAN_CBT_REG(base), (uint32_t)(value)))
#define CAN_CLR_CBT(base, value) (BME_AND32(&CAN_CBT_REG(base), (uint32_t)(~(value))))
#define CAN_TOG_CBT(base, value) (BME_XOR32(&CAN_CBT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CBT bitfields
 */

/*!
 * @name Register CAN_CBT, field EPSEG2[4:0] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 2 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG2] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG2 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG2 field. */
#define CAN_RD_CBT_EPSEG2(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG2_MASK) >> CAN_CBT_EPSEG2_SHIFT)
#define CAN_BRD_CBT_EPSEG2(base) (BME_UBFX32(&CAN_CBT_REG(base), CAN_CBT_EPSEG2_SHIFT, CAN_CBT_EPSEG2_WIDTH))

/*! @brief Set the EPSEG2 field to a new value. */
#define CAN_WR_CBT_EPSEG2(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG2_MASK, CAN_CBT_EPSEG2(value)))
#define CAN_BWR_CBT_EPSEG2(base, value) (BME_BFI32(&CAN_CBT_REG(base), ((uint32_t)(value) << CAN_CBT_EPSEG2_SHIFT), CAN_CBT_EPSEG2_SHIFT, CAN_CBT_EPSEG2_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPSEG1[9:5] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 1 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG1] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG1 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG1 field. */
#define CAN_RD_CBT_EPSEG1(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG1_MASK) >> CAN_CBT_EPSEG1_SHIFT)
#define CAN_BRD_CBT_EPSEG1(base) (BME_UBFX32(&CAN_CBT_REG(base), CAN_CBT_EPSEG1_SHIFT, CAN_CBT_EPSEG1_WIDTH))

/*! @brief Set the EPSEG1 field to a new value. */
#define CAN_WR_CBT_EPSEG1(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG1_MASK, CAN_CBT_EPSEG1(value)))
#define CAN_BWR_CBT_EPSEG1(base, value) (BME_BFI32(&CAN_CBT_REG(base), ((uint32_t)(value) << CAN_CBT_EPSEG1_SHIFT), CAN_CBT_EPSEG1_SHIFT, CAN_CBT_EPSEG1_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPROPSEG[15:10] (RW)
 *
 * This 6-bit field defines the length of the Propagation Segment in the bit
 * time when CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends
 * the CAN_CTRL1[PROPSEG] value range. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Propagation Segment Time =
 * (EPROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPROPSEG field. */
#define CAN_RD_CBT_EPROPSEG(base) ((CAN_CBT_REG(base) & CAN_CBT_EPROPSEG_MASK) >> CAN_CBT_EPROPSEG_SHIFT)
#define CAN_BRD_CBT_EPROPSEG(base) (BME_UBFX32(&CAN_CBT_REG(base), CAN_CBT_EPROPSEG_SHIFT, CAN_CBT_EPROPSEG_WIDTH))

/*! @brief Set the EPROPSEG field to a new value. */
#define CAN_WR_CBT_EPROPSEG(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPROPSEG_MASK, CAN_CBT_EPROPSEG(value)))
#define CAN_BWR_CBT_EPROPSEG(base, value) (BME_BFI32(&CAN_CBT_REG(base), ((uint32_t)(value) << CAN_CBT_EPROPSEG_SHIFT), CAN_CBT_EPROPSEG_SHIFT, CAN_CBT_EPROPSEG_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CBT, field ERJW[19:16] (RW)
 *
 * This 4-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization when CAN_CBT[BTF] bit is asserted,
 * otherwise it has no effect. It extends the CAN_CTRL1[RJW] value range. One time
 * quantum is equal to the Sclock period. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Resync Jump Width =
 * ERJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_ERJW field. */
#define CAN_RD_CBT_ERJW(base) ((CAN_CBT_REG(base) & CAN_CBT_ERJW_MASK) >> CAN_CBT_ERJW_SHIFT)
#define CAN_BRD_CBT_ERJW(base) (BME_UBFX32(&CAN_CBT_REG(base), CAN_CBT_ERJW_SHIFT, CAN_CBT_ERJW_WIDTH))

/*! @brief Set the ERJW field to a new value. */
#define CAN_WR_CBT_ERJW(base, value) (CAN_RMW_CBT(base, CAN_CBT_ERJW_MASK, CAN_CBT_ERJW(value)))
#define CAN_BWR_CBT_ERJW(base, value) (BME_BFI32(&CAN_CBT_REG(base), ((uint32_t)(value) << CAN_CBT_ERJW_SHIFT), CAN_CBT_ERJW_SHIFT, CAN_CBT_ERJW_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPRESDIV[30:21] (RW)
 *
 * This 10-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency when CAN_CBT[BTF] bit is asserted, otherwise it
 * has no effect. It extends the CAN_CTRL1[PRESDIV] value range. The Sclock
 * period defines the time quantum of the CAN protocol. For the reset value, the
 * Sclock frequency is equal to the PE clock frequency (see Protocol timing). This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes. Sclock frequency = PE clock frequency / (EPRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPRESDIV field. */
#define CAN_RD_CBT_EPRESDIV(base) ((CAN_CBT_REG(base) & CAN_CBT_EPRESDIV_MASK) >> CAN_CBT_EPRESDIV_SHIFT)
#define CAN_BRD_CBT_EPRESDIV(base) (CAN_RD_CBT_EPRESDIV(base))

/*! @brief Set the EPRESDIV field to a new value. */
#define CAN_WR_CBT_EPRESDIV(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPRESDIV_MASK, CAN_CBT_EPRESDIV(value)))
#define CAN_BWR_CBT_EPRESDIV(base, value) (CAN_WR_CBT_EPRESDIV(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field BTF[31] (RW)
 *
 * Enables the use of extended CAN bit timing fields EPRESDIV, EPROPSEG, EPSEG1,
 * EPSEG2 and ERJW replacing the CAN bit timing variables defined in CAN_CTRL1
 * register. This field can be written in Freeze mode only.
 *
 * Values:
 * - 0b0 - Extended bit time definitions disabled.
 * - 0b1 - Extended bit time definitions enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_BTF field. */
#define CAN_RD_CBT_BTF(base) ((CAN_CBT_REG(base) & CAN_CBT_BTF_MASK) >> CAN_CBT_BTF_SHIFT)
#define CAN_BRD_CBT_BTF(base) (BME_UBFX32(&CAN_CBT_REG(base), CAN_CBT_BTF_SHIFT, CAN_CBT_BTF_WIDTH))

/*! @brief Set the BTF field to a new value. */
#define CAN_WR_CBT_BTF(base, value) (CAN_RMW_CBT(base, CAN_CBT_BTF_MASK, CAN_CBT_BTF(value)))
#define CAN_BWR_CBT_BTF(base, value) (BME_BFI32(&CAN_CBT_REG(base), ((uint32_t)(value) << CAN_CBT_BTF_SHIFT), CAN_CBT_BTF_SHIFT, CAN_CBT_BTF_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_CS - Message Buffer 0 CS Register
 ******************************************************************************/

/*!
 * @brief CAN_CS - Message Buffer 0 CS Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_CS register
 */
/*@{*/
#define CAN_RD_CS(base, index)   (CAN_CS_REG(base, index))
#define CAN_WR_CS(base, index, value) (CAN_CS_REG(base, index) = (value))
#define CAN_RMW_CS(base, index, mask, value) (CAN_WR_CS(base, index, (CAN_RD_CS(base, index) & ~(mask)) | (value)))
#define CAN_SET_CS(base, index, value) (BME_OR32(&CAN_CS_REG(base, index), (uint32_t)(value)))
#define CAN_CLR_CS(base, index, value) (BME_AND32(&CAN_CS_REG(base, index), (uint32_t)(~(value))))
#define CAN_TOG_CS(base, index, value) (BME_XOR32(&CAN_CS_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CS bitfields
 */

/*!
 * @name Register CAN_CS, field TIME_STAMP[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_TIME_STAMP field. */
#define CAN_RD_CS_TIME_STAMP(base, index) ((CAN_CS_REG(base, index) & CAN_CS_TIME_STAMP_MASK) >> CAN_CS_TIME_STAMP_SHIFT)
#define CAN_BRD_CS_TIME_STAMP(base, index) (CAN_RD_CS_TIME_STAMP(base, index))

/*! @brief Set the TIME_STAMP field to a new value. */
#define CAN_WR_CS_TIME_STAMP(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_TIME_STAMP_MASK, CAN_CS_TIME_STAMP(value)))
#define CAN_BWR_CS_TIME_STAMP(base, index, value) (CAN_WR_CS_TIME_STAMP(base, index, value))
/*@}*/

/*!
 * @name Register CAN_CS, field DLC[19:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_DLC field. */
#define CAN_RD_CS_DLC(base, index) ((CAN_CS_REG(base, index) & CAN_CS_DLC_MASK) >> CAN_CS_DLC_SHIFT)
#define CAN_BRD_CS_DLC(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_DLC_SHIFT, CAN_CS_DLC_WIDTH))

/*! @brief Set the DLC field to a new value. */
#define CAN_WR_CS_DLC(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_DLC_MASK, CAN_CS_DLC(value)))
#define CAN_BWR_CS_DLC(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_DLC_SHIFT), CAN_CS_DLC_SHIFT, CAN_CS_DLC_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field RTR[20] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_RTR field. */
#define CAN_RD_CS_RTR(base, index) ((CAN_CS_REG(base, index) & CAN_CS_RTR_MASK) >> CAN_CS_RTR_SHIFT)
#define CAN_BRD_CS_RTR(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_RTR_SHIFT, CAN_CS_RTR_WIDTH))

/*! @brief Set the RTR field to a new value. */
#define CAN_WR_CS_RTR(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_RTR_MASK, CAN_CS_RTR(value)))
#define CAN_BWR_CS_RTR(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_RTR_SHIFT), CAN_CS_RTR_SHIFT, CAN_CS_RTR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field IDE[21] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_IDE field. */
#define CAN_RD_CS_IDE(base, index) ((CAN_CS_REG(base, index) & CAN_CS_IDE_MASK) >> CAN_CS_IDE_SHIFT)
#define CAN_BRD_CS_IDE(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_IDE_SHIFT, CAN_CS_IDE_WIDTH))

/*! @brief Set the IDE field to a new value. */
#define CAN_WR_CS_IDE(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_IDE_MASK, CAN_CS_IDE(value)))
#define CAN_BWR_CS_IDE(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_IDE_SHIFT), CAN_CS_IDE_SHIFT, CAN_CS_IDE_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field SRR[22] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_SRR field. */
#define CAN_RD_CS_SRR(base, index) ((CAN_CS_REG(base, index) & CAN_CS_SRR_MASK) >> CAN_CS_SRR_SHIFT)
#define CAN_BRD_CS_SRR(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_SRR_SHIFT, CAN_CS_SRR_WIDTH))

/*! @brief Set the SRR field to a new value. */
#define CAN_WR_CS_SRR(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_SRR_MASK, CAN_CS_SRR(value)))
#define CAN_BWR_CS_SRR(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_SRR_SHIFT), CAN_CS_SRR_SHIFT, CAN_CS_SRR_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field CODE[27:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_CODE field. */
#define CAN_RD_CS_CODE(base, index) ((CAN_CS_REG(base, index) & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT)
#define CAN_BRD_CS_CODE(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_CODE_SHIFT, CAN_CS_CODE_WIDTH))

/*! @brief Set the CODE field to a new value. */
#define CAN_WR_CS_CODE(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_CODE_MASK, CAN_CS_CODE(value)))
#define CAN_BWR_CS_CODE(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_CODE_SHIFT), CAN_CS_CODE_SHIFT, CAN_CS_CODE_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field ESI[29] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_ESI field. */
#define CAN_RD_CS_ESI(base, index) ((CAN_CS_REG(base, index) & CAN_CS_ESI_MASK) >> CAN_CS_ESI_SHIFT)
#define CAN_BRD_CS_ESI(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_ESI_SHIFT, CAN_CS_ESI_WIDTH))

/*! @brief Set the ESI field to a new value. */
#define CAN_WR_CS_ESI(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_ESI_MASK, CAN_CS_ESI(value)))
#define CAN_BWR_CS_ESI(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_ESI_SHIFT), CAN_CS_ESI_SHIFT, CAN_CS_ESI_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field BRS[30] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_BRS field. */
#define CAN_RD_CS_BRS(base, index) ((CAN_CS_REG(base, index) & CAN_CS_BRS_MASK) >> CAN_CS_BRS_SHIFT)
#define CAN_BRD_CS_BRS(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_BRS_SHIFT, CAN_CS_BRS_WIDTH))

/*! @brief Set the BRS field to a new value. */
#define CAN_WR_CS_BRS(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_BRS_MASK, CAN_CS_BRS(value)))
#define CAN_BWR_CS_BRS(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_BRS_SHIFT), CAN_CS_BRS_SHIFT, CAN_CS_BRS_WIDTH))
/*@}*/

/*!
 * @name Register CAN_CS, field EDL[31] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_EDL field. */
#define CAN_RD_CS_EDL(base, index) ((CAN_CS_REG(base, index) & CAN_CS_EDL_MASK) >> CAN_CS_EDL_SHIFT)
#define CAN_BRD_CS_EDL(base, index) (BME_UBFX32(&CAN_CS_REG(base, index), CAN_CS_EDL_SHIFT, CAN_CS_EDL_WIDTH))

/*! @brief Set the EDL field to a new value. */
#define CAN_WR_CS_EDL(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_EDL_MASK, CAN_CS_EDL(value)))
#define CAN_BWR_CS_EDL(base, index, value) (BME_BFI32(&CAN_CS_REG(base, index), ((uint32_t)(value) << CAN_CS_EDL_SHIFT), CAN_CS_EDL_SHIFT, CAN_CS_EDL_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_ID - Message Buffer 0 ID Register
 ******************************************************************************/

/*!
 * @brief CAN_ID - Message Buffer 0 ID Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_ID register
 */
/*@{*/
#define CAN_RD_ID(base, index)   (CAN_ID_REG(base, index))
#define CAN_WR_ID(base, index, value) (CAN_ID_REG(base, index) = (value))
#define CAN_RMW_ID(base, index, mask, value) (CAN_WR_ID(base, index, (CAN_RD_ID(base, index) & ~(mask)) | (value)))
#define CAN_SET_ID(base, index, value) (BME_OR32(&CAN_ID_REG(base, index), (uint32_t)(value)))
#define CAN_CLR_ID(base, index, value) (BME_AND32(&CAN_ID_REG(base, index), (uint32_t)(~(value))))
#define CAN_TOG_ID(base, index, value) (BME_XOR32(&CAN_ID_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ID bitfields
 */

/*!
 * @name Register CAN_ID, field EXT[17:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_EXT field. */
#define CAN_RD_ID_EXT(base, index) ((CAN_ID_REG(base, index) & CAN_ID_EXT_MASK) >> CAN_ID_EXT_SHIFT)
#define CAN_BRD_ID_EXT(base, index) (CAN_RD_ID_EXT(base, index))

/*! @brief Set the EXT field to a new value. */
#define CAN_WR_ID_EXT(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_EXT_MASK, CAN_ID_EXT(value)))
#define CAN_BWR_ID_EXT(base, index, value) (CAN_WR_ID_EXT(base, index, value))
/*@}*/

/*!
 * @name Register CAN_ID, field STD[28:18] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_STD field. */
#define CAN_RD_ID_STD(base, index) ((CAN_ID_REG(base, index) & CAN_ID_STD_MASK) >> CAN_ID_STD_SHIFT)
#define CAN_BRD_ID_STD(base, index) (CAN_RD_ID_STD(base, index))

/*! @brief Set the STD field to a new value. */
#define CAN_WR_ID_STD(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_STD_MASK, CAN_ID_STD(value)))
#define CAN_BWR_ID_STD(base, index, value) (CAN_WR_ID_STD(base, index, value))
/*@}*/

/*!
 * @name Register CAN_ID, field PRIO[31:29] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_PRIO field. */
#define CAN_RD_ID_PRIO(base, index) ((CAN_ID_REG(base, index) & CAN_ID_PRIO_MASK) >> CAN_ID_PRIO_SHIFT)
#define CAN_BRD_ID_PRIO(base, index) (BME_UBFX32(&CAN_ID_REG(base, index), CAN_ID_PRIO_SHIFT, CAN_ID_PRIO_WIDTH))

/*! @brief Set the PRIO field to a new value. */
#define CAN_WR_ID_PRIO(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_PRIO_MASK, CAN_ID_PRIO(value)))
#define CAN_BWR_ID_PRIO(base, index, value) (BME_BFI32(&CAN_ID_REG(base, index), ((uint32_t)(value) << CAN_ID_PRIO_SHIFT), CAN_ID_PRIO_SHIFT, CAN_ID_PRIO_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_WORD0 - Message Buffer 0 WORD0 Register
 ******************************************************************************/

/*!
 * @brief CAN_WORD0 - Message Buffer 0 WORD0 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_WORD0 register
 */
/*@{*/
#define CAN_RD_WORD0(base, index) (CAN_WORD0_REG(base, index))
#define CAN_WR_WORD0(base, index, value) (CAN_WORD0_REG(base, index) = (value))
#define CAN_RMW_WORD0(base, index, mask, value) (CAN_WR_WORD0(base, index, (CAN_RD_WORD0(base, index) & ~(mask)) | (value)))
#define CAN_SET_WORD0(base, index, value) (BME_OR32(&CAN_WORD0_REG(base, index), (uint32_t)(value)))
#define CAN_CLR_WORD0(base, index, value) (BME_AND32(&CAN_WORD0_REG(base, index), (uint32_t)(~(value))))
#define CAN_TOG_WORD0(base, index, value) (BME_XOR32(&CAN_WORD0_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD0 bitfields
 */

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_3[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_3 field. */
#define CAN_RD_WORD0_DATA_BYTE_3(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_3_MASK) >> CAN_WORD0_DATA_BYTE_3_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_3(base, index) (BME_UBFX32(&CAN_WORD0_REG(base, index), CAN_WORD0_DATA_BYTE_3_SHIFT, CAN_WORD0_DATA_BYTE_3_WIDTH))

/*! @brief Set the DATA_BYTE_3 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_3(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_3_MASK, CAN_WORD0_DATA_BYTE_3(value)))
#define CAN_BWR_WORD0_DATA_BYTE_3(base, index, value) (BME_BFI32(&CAN_WORD0_REG(base, index), ((uint32_t)(value) << CAN_WORD0_DATA_BYTE_3_SHIFT), CAN_WORD0_DATA_BYTE_3_SHIFT, CAN_WORD0_DATA_BYTE_3_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_2[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_2 field. */
#define CAN_RD_WORD0_DATA_BYTE_2(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_2_MASK) >> CAN_WORD0_DATA_BYTE_2_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_2(base, index) (BME_UBFX32(&CAN_WORD0_REG(base, index), CAN_WORD0_DATA_BYTE_2_SHIFT, CAN_WORD0_DATA_BYTE_2_WIDTH))

/*! @brief Set the DATA_BYTE_2 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_2(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_2_MASK, CAN_WORD0_DATA_BYTE_2(value)))
#define CAN_BWR_WORD0_DATA_BYTE_2(base, index, value) (BME_BFI32(&CAN_WORD0_REG(base, index), ((uint32_t)(value) << CAN_WORD0_DATA_BYTE_2_SHIFT), CAN_WORD0_DATA_BYTE_2_SHIFT, CAN_WORD0_DATA_BYTE_2_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_1[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_1 field. */
#define CAN_RD_WORD0_DATA_BYTE_1(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_1_MASK) >> CAN_WORD0_DATA_BYTE_1_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_1(base, index) (BME_UBFX32(&CAN_WORD0_REG(base, index), CAN_WORD0_DATA_BYTE_1_SHIFT, CAN_WORD0_DATA_BYTE_1_WIDTH))

/*! @brief Set the DATA_BYTE_1 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_1(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_1_MASK, CAN_WORD0_DATA_BYTE_1(value)))
#define CAN_BWR_WORD0_DATA_BYTE_1(base, index, value) (BME_BFI32(&CAN_WORD0_REG(base, index), ((uint32_t)(value) << CAN_WORD0_DATA_BYTE_1_SHIFT), CAN_WORD0_DATA_BYTE_1_SHIFT, CAN_WORD0_DATA_BYTE_1_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_0[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_0 field. */
#define CAN_RD_WORD0_DATA_BYTE_0(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_0_MASK) >> CAN_WORD0_DATA_BYTE_0_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_0(base, index) (BME_UBFX32(&CAN_WORD0_REG(base, index), CAN_WORD0_DATA_BYTE_0_SHIFT, CAN_WORD0_DATA_BYTE_0_WIDTH))

/*! @brief Set the DATA_BYTE_0 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_0(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_0_MASK, CAN_WORD0_DATA_BYTE_0(value)))
#define CAN_BWR_WORD0_DATA_BYTE_0(base, index, value) (BME_BFI32(&CAN_WORD0_REG(base, index), ((uint32_t)(value) << CAN_WORD0_DATA_BYTE_0_SHIFT), CAN_WORD0_DATA_BYTE_0_SHIFT, CAN_WORD0_DATA_BYTE_0_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_WORD1 - Message Buffer 0 WORD1 Register
 ******************************************************************************/

/*!
 * @brief CAN_WORD1 - Message Buffer 0 WORD1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_WORD1 register
 */
/*@{*/
#define CAN_RD_WORD1(base, index) (CAN_WORD1_REG(base, index))
#define CAN_WR_WORD1(base, index, value) (CAN_WORD1_REG(base, index) = (value))
#define CAN_RMW_WORD1(base, index, mask, value) (CAN_WR_WORD1(base, index, (CAN_RD_WORD1(base, index) & ~(mask)) | (value)))
#define CAN_SET_WORD1(base, index, value) (BME_OR32(&CAN_WORD1_REG(base, index), (uint32_t)(value)))
#define CAN_CLR_WORD1(base, index, value) (BME_AND32(&CAN_WORD1_REG(base, index), (uint32_t)(~(value))))
#define CAN_TOG_WORD1(base, index, value) (BME_XOR32(&CAN_WORD1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD1 bitfields
 */

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_7[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_7 field. */
#define CAN_RD_WORD1_DATA_BYTE_7(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_7_MASK) >> CAN_WORD1_DATA_BYTE_7_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_7(base, index) (BME_UBFX32(&CAN_WORD1_REG(base, index), CAN_WORD1_DATA_BYTE_7_SHIFT, CAN_WORD1_DATA_BYTE_7_WIDTH))

/*! @brief Set the DATA_BYTE_7 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_7(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_7_MASK, CAN_WORD1_DATA_BYTE_7(value)))
#define CAN_BWR_WORD1_DATA_BYTE_7(base, index, value) (BME_BFI32(&CAN_WORD1_REG(base, index), ((uint32_t)(value) << CAN_WORD1_DATA_BYTE_7_SHIFT), CAN_WORD1_DATA_BYTE_7_SHIFT, CAN_WORD1_DATA_BYTE_7_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_6[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_6 field. */
#define CAN_RD_WORD1_DATA_BYTE_6(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_6_MASK) >> CAN_WORD1_DATA_BYTE_6_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_6(base, index) (BME_UBFX32(&CAN_WORD1_REG(base, index), CAN_WORD1_DATA_BYTE_6_SHIFT, CAN_WORD1_DATA_BYTE_6_WIDTH))

/*! @brief Set the DATA_BYTE_6 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_6(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_6_MASK, CAN_WORD1_DATA_BYTE_6(value)))
#define CAN_BWR_WORD1_DATA_BYTE_6(base, index, value) (BME_BFI32(&CAN_WORD1_REG(base, index), ((uint32_t)(value) << CAN_WORD1_DATA_BYTE_6_SHIFT), CAN_WORD1_DATA_BYTE_6_SHIFT, CAN_WORD1_DATA_BYTE_6_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_5[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_5 field. */
#define CAN_RD_WORD1_DATA_BYTE_5(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_5_MASK) >> CAN_WORD1_DATA_BYTE_5_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_5(base, index) (BME_UBFX32(&CAN_WORD1_REG(base, index), CAN_WORD1_DATA_BYTE_5_SHIFT, CAN_WORD1_DATA_BYTE_5_WIDTH))

/*! @brief Set the DATA_BYTE_5 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_5(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_5_MASK, CAN_WORD1_DATA_BYTE_5(value)))
#define CAN_BWR_WORD1_DATA_BYTE_5(base, index, value) (BME_BFI32(&CAN_WORD1_REG(base, index), ((uint32_t)(value) << CAN_WORD1_DATA_BYTE_5_SHIFT), CAN_WORD1_DATA_BYTE_5_SHIFT, CAN_WORD1_DATA_BYTE_5_WIDTH))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_4[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_4 field. */
#define CAN_RD_WORD1_DATA_BYTE_4(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_4_MASK) >> CAN_WORD1_DATA_BYTE_4_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_4(base, index) (BME_UBFX32(&CAN_WORD1_REG(base, index), CAN_WORD1_DATA_BYTE_4_SHIFT, CAN_WORD1_DATA_BYTE_4_WIDTH))

/*! @brief Set the DATA_BYTE_4 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_4(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_4_MASK, CAN_WORD1_DATA_BYTE_4(value)))
#define CAN_BWR_WORD1_DATA_BYTE_4(base, index, value) (BME_BFI32(&CAN_WORD1_REG(base, index), ((uint32_t)(value) << CAN_WORD1_DATA_BYTE_4_SHIFT), CAN_WORD1_DATA_BYTE_4_SHIFT, CAN_WORD1_DATA_BYTE_4_WIDTH))
/*@}*/

/*******************************************************************************
 * CAN_RXIMR - Rx Individual Mask Registers
 ******************************************************************************/

/*!
 * @brief CAN_RXIMR - Rx Individual Mask Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RX Individual Mask Registers are used to store the acceptance masks for
 * ID filtering in Rx MBs and the Rx FIFO. When the Rx FIFO is disabled
 * (CAN_MCR[RFEN] bit is negated), an individual mask is provided for each available Rx
 * Mailbox on a one-to-one correspondence. When the Rx FIFO is enabled
 * (CAN_MCR[RFEN] bit is asserted), an individual mask is provided for each Rx FIFO ID Filter
 * Table Element on a one-to-one correspondence depending on the setting of
 * CAN_CTRL2[RFFN] (see Rx FIFO). CAN_RXIMR0 stores the individual mask associated to
 * either MB0 or ID Filter Table Element 0, CAN_RXIMR1 stores the individual mask
 * associated to either MB1 or ID Filter Table Element 1 and so on. CAN_RXIMR
 * registers can only be accessed by the CPU while the module is in Freeze mode,
 * otherwise, they are blocked by hardware. These registers are not affected by
 * reset. They are located in RAM and must be explicitly initialized prior to any
 * reception.
 */
/*!
 * @name Constants and macros for entire CAN_RXIMR register
 */
/*@{*/
#define CAN_RD_RXIMR(base, index) (CAN_RXIMR_REG(base, index))
#define CAN_WR_RXIMR(base, index, value) (CAN_RXIMR_REG(base, index) = (value))
#define CAN_RMW_RXIMR(base, index, mask, value) (CAN_WR_RXIMR(base, index, (CAN_RD_RXIMR(base, index) & ~(mask)) | (value)))
#define CAN_SET_RXIMR(base, index, value) (BME_OR32(&CAN_RXIMR_REG(base, index), (uint32_t)(value)))
#define CAN_CLR_RXIMR(base, index, value) (BME_AND32(&CAN_RXIMR_REG(base, index), (uint32_t)(~(value))))
#define CAN_TOG_RXIMR(base, index, value) (BME_XOR32(&CAN_RXIMR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * MKV58F24 CAU
 *
 * Memory Mapped Cryptographic Acceleration Unit (MMCAU)
 *
 * Registers defined in this header file:
 * - CAU_DIRECT - Direct access register 0
 * - CAU_LDR_CASR - Status register - Load Register command
 * - CAU_LDR_CAA - Accumulator register - Load Register command
 * - CAU_LDR_CA - General Purpose Register 0 - Load Register command
 * - CAU_STR_CASR - Status register - Store Register command
 * - CAU_STR_CAA - Accumulator register - Store Register command
 * - CAU_STR_CA - General Purpose Register 0 - Store Register command
 * - CAU_ADR_CASR - Status register - Add Register command
 * - CAU_ADR_CAA - Accumulator register - Add to register command
 * - CAU_ADR_CA - General Purpose Register 0 - Add to register command
 * - CAU_RADR_CASR - Status register - Reverse and Add to Register command
 * - CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 * - CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 * - CAU_XOR_CASR - Status register - Exclusive Or command
 * - CAU_XOR_CAA - Accumulator register - Exclusive Or command
 * - CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 * - CAU_ROTL_CASR - Status register - Rotate Left command
 * - CAU_ROTL_CAA - Accumulator register - Rotate Left command
 * - CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 * - CAU_AESC_CASR - Status register - AES Column Operation command
 * - CAU_AESC_CAA - Accumulator register - AES Column Operation command
 * - CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 * - CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 * - CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 * - CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 */

#define CAU_INSTANCE_COUNT (1U) /*!< Number of instances of the CAU module. */
#define CAU_IDX (0U) /*!< Instance number for CAU. */

/*******************************************************************************
 * CAU_DIRECT - Direct access register 0
 ******************************************************************************/

/*!
 * @brief CAU_DIRECT - Direct access register 0 (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_DIRECT register
 */
/*@{*/
#define CAU_WR_DIRECT(base, index, value) (CAU_DIRECT_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CASR - Status register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CASR - Status register - Load Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CASR register
 */
/*@{*/
#define CAU_WR_LDR_CASR(base, value) (CAU_LDR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_LDR_CASR bitfields
 */

/*!
 * @name Register CAU_LDR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_IC(value)))
#define CAU_BWR_LDR_CASR_IC(base, value) (CAU_WR_LDR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_DPE(value)))
#define CAU_BWR_LDR_CASR_DPE(base, value) (CAU_WR_LDR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_LDR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR(base, CAU_LDR_CASR_VER(value)))
#define CAU_BWR_LDR_CASR_VER(base, value) (CAU_WR_LDR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CAA - Accumulator register - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CAA - Accumulator register - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CAA register
 */
/*@{*/
#define CAU_WR_LDR_CAA(base, value) (CAU_LDR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_LDR_CA - General Purpose Register 0 - Load Register command
 ******************************************************************************/

/*!
 * @brief CAU_LDR_CA - General Purpose Register 0 - Load Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_LDR_CA register
 */
/*@{*/
#define CAU_WR_LDR_CA(base, index, value) (CAU_LDR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_STR_CASR - Status register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CASR - Status register - Store Register command (RO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CASR register
 */
/*@{*/
#define CAU_RD_STR_CASR(base)    (CAU_STR_CASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAU_STR_CASR bitfields
 */

/*!
 * @name Register CAU_STR_CASR, field IC[0] (RO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_IC field. */
#define CAU_RD_STR_CASR_IC(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_IC_MASK) >> CAU_STR_CASR_IC_SHIFT)
#define CAU_BRD_STR_CASR_IC(base) (CAU_RD_STR_CASR_IC(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field DPE[1] (RO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_DPE field. */
#define CAU_RD_STR_CASR_DPE(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_DPE_MASK) >> CAU_STR_CASR_DPE_SHIFT)
#define CAU_BRD_STR_CASR_DPE(base) (CAU_RD_STR_CASR_DPE(base))
/*@}*/

/*!
 * @name Register CAU_STR_CASR, field VER[31:28] (RO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Read current value of the CAU_STR_CASR_VER field. */
#define CAU_RD_STR_CASR_VER(base) ((CAU_STR_CASR_REG(base) & CAU_STR_CASR_VER_MASK) >> CAU_STR_CASR_VER_SHIFT)
#define CAU_BRD_STR_CASR_VER(base) (CAU_RD_STR_CASR_VER(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CAA - Accumulator register - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CAA - Accumulator register - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CAA register
 */
/*@{*/
#define CAU_RD_STR_CAA(base)     (CAU_STR_CAA_REG(base))
/*@}*/

/*******************************************************************************
 * CAU_STR_CA - General Purpose Register 0 - Store Register command
 ******************************************************************************/

/*!
 * @brief CAU_STR_CA - General Purpose Register 0 - Store Register command (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_STR_CA register
 */
/*@{*/
#define CAU_RD_STR_CA(base, index) (CAU_STR_CA_REG(base, index))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CASR - Status register - Add Register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CASR - Status register - Add Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CASR register
 */
/*@{*/
#define CAU_WR_ADR_CASR(base, value) (CAU_ADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ADR_CASR bitfields
 */

/*!
 * @name Register CAU_ADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_IC(value)))
#define CAU_BWR_ADR_CASR_IC(base, value) (CAU_WR_ADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_DPE(value)))
#define CAU_BWR_ADR_CASR_DPE(base, value) (CAU_WR_ADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR(base, CAU_ADR_CASR_VER(value)))
#define CAU_BWR_ADR_CASR_VER(base, value) (CAU_WR_ADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CAA - Accumulator register - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CAA - Accumulator register - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CAA register
 */
/*@{*/
#define CAU_WR_ADR_CAA(base, value) (CAU_ADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ADR_CA - General Purpose Register 0 - Add to register command
 ******************************************************************************/

/*!
 * @brief CAU_ADR_CA - General Purpose Register 0 - Add to register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ADR_CA register
 */
/*@{*/
#define CAU_WR_ADR_CA(base, index, value) (CAU_ADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CASR - Status register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CASR - Status register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CASR register
 */
/*@{*/
#define CAU_WR_RADR_CASR(base, value) (CAU_RADR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_RADR_CASR bitfields
 */

/*!
 * @name Register CAU_RADR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_IC(value)))
#define CAU_BWR_RADR_CASR_IC(base, value) (CAU_WR_RADR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_DPE(value)))
#define CAU_BWR_RADR_CASR_DPE(base, value) (CAU_WR_RADR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_RADR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR(base, CAU_RADR_CASR_VER(value)))
#define CAU_BWR_RADR_CASR_VER(base, value) (CAU_WR_RADR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CAA - Accumulator register - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CAA register
 */
/*@{*/
#define CAU_WR_RADR_CAA(base, value) (CAU_RADR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command
 ******************************************************************************/

/*!
 * @brief CAU_RADR_CA - General Purpose Register 0 - Reverse and Add to Register command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_RADR_CA register
 */
/*@{*/
#define CAU_WR_RADR_CA(base, index, value) (CAU_RADR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CASR - Status register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CASR - Status register - Exclusive Or command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CASR register
 */
/*@{*/
#define CAU_WR_XOR_CASR(base, value) (CAU_XOR_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_XOR_CASR bitfields
 */

/*!
 * @name Register CAU_XOR_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_IC(value)))
#define CAU_BWR_XOR_CASR_IC(base, value) (CAU_WR_XOR_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_DPE(value)))
#define CAU_BWR_XOR_CASR_DPE(base, value) (CAU_WR_XOR_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_XOR_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR(base, CAU_XOR_CASR_VER(value)))
#define CAU_BWR_XOR_CASR_VER(base, value) (CAU_WR_XOR_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CAA - Accumulator register - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CAA - Accumulator register - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CAA register
 */
/*@{*/
#define CAU_WR_XOR_CAA(base, value) (CAU_XOR_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command
 ******************************************************************************/

/*!
 * @brief CAU_XOR_CA - General Purpose Register 0 - Exclusive Or command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_XOR_CA register
 */
/*@{*/
#define CAU_WR_XOR_CA(base, index, value) (CAU_XOR_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CASR - Status register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CASR - Status register - Rotate Left command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CASR register
 */
/*@{*/
#define CAU_WR_ROTL_CASR(base, value) (CAU_ROTL_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_ROTL_CASR bitfields
 */

/*!
 * @name Register CAU_ROTL_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_IC(value)))
#define CAU_BWR_ROTL_CASR_IC(base, value) (CAU_WR_ROTL_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_DPE(value)))
#define CAU_BWR_ROTL_CASR_DPE(base, value) (CAU_WR_ROTL_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_ROTL_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR(base, CAU_ROTL_CASR_VER(value)))
#define CAU_BWR_ROTL_CASR_VER(base, value) (CAU_WR_ROTL_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CAA - Accumulator register - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CAA - Accumulator register - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CAA register
 */
/*@{*/
#define CAU_WR_ROTL_CAA(base, value) (CAU_ROTL_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command
 ******************************************************************************/

/*!
 * @brief CAU_ROTL_CA - General Purpose Register 0 - Rotate Left command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_ROTL_CA register
 */
/*@{*/
#define CAU_WR_ROTL_CA(base, index, value) (CAU_ROTL_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CASR - Status register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CASR - Status register - AES Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CASR register
 */
/*@{*/
#define CAU_WR_AESC_CASR(base, value) (CAU_AESC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESC_CASR bitfields
 */

/*!
 * @name Register CAU_AESC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_IC(value)))
#define CAU_BWR_AESC_CASR_IC(base, value) (CAU_WR_AESC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_DPE(value)))
#define CAU_BWR_AESC_CASR_DPE(base, value) (CAU_WR_AESC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR(base, CAU_AESC_CASR_VER(value)))
#define CAU_BWR_AESC_CASR_VER(base, value) (CAU_WR_AESC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CAA - Accumulator register - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CAA - Accumulator register - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CAA register
 */
/*@{*/
#define CAU_WR_AESC_CAA(base, value) (CAU_AESC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESC_CA - General Purpose Register 0 - AES Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESC_CA register
 */
/*@{*/
#define CAU_WR_AESC_CA(base, index, value) (CAU_AESC_CA_REG(base, index) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CASR - Status register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CASR - Status register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x20000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CASR register
 */
/*@{*/
#define CAU_WR_AESIC_CASR(base, value) (CAU_AESIC_CASR_REG(base) = (value))
/*@}*/

/*
 * Constants & macros for individual CAU_AESIC_CASR bitfields
 */

/*!
 * @name Register CAU_AESIC_CASR, field IC[0] (WO)
 *
 * Values:
 * - 0b0 - No illegal commands issued
 * - 0b1 - Illegal command issued
 */
/*@{*/
/*! @brief Set the IC field to a new value. */
#define CAU_WR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_IC(value)))
#define CAU_BWR_AESIC_CASR_IC(base, value) (CAU_WR_AESIC_CASR_IC(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field DPE[1] (WO)
 *
 * Values:
 * - 0b0 - No error detected
 * - 0b1 - DES key parity error detected
 */
/*@{*/
/*! @brief Set the DPE field to a new value. */
#define CAU_WR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_DPE(value)))
#define CAU_BWR_AESIC_CASR_DPE(base, value) (CAU_WR_AESIC_CASR_DPE(base, value))
/*@}*/

/*!
 * @name Register CAU_AESIC_CASR, field VER[31:28] (WO)
 *
 * Values:
 * - 0b0001 - Initial CAU version
 * - 0b0010 - Second version, added support for SHA-256 algorithm.(This is the
 *     value on this device)
 */
/*@{*/
/*! @brief Set the VER field to a new value. */
#define CAU_WR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR(base, CAU_AESIC_CASR_VER(value)))
#define CAU_BWR_AESIC_CASR_VER(base, value) (CAU_WR_AESIC_CASR_VER(base, value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CAA - Accumulator register - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CAA register
 */
/*@{*/
#define CAU_WR_AESIC_CAA(base, value) (CAU_AESIC_CAA_REG(base) = (value))
/*@}*/

/*******************************************************************************
 * CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command
 ******************************************************************************/

/*!
 * @brief CAU_AESIC_CA - General Purpose Register 0 - AES Inverse Column Operation command (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAU_AESIC_CA register
 */
/*@{*/
#define CAU_WR_AESIC_CA(base, index, value) (CAU_AESIC_CA_REG(base, index) = (value))
/*@}*/

/*
 * MKV58F24 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (4U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */
#define CMP1_IDX (1U) /*!< Instance number for CMP1. */
#define CMP2_IDX (2U) /*!< Instance number for CMP2. */
#define CMP3_IDX (3U) /*!< Instance number for CMP3. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (BME_OR8(&CMP_CR0_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR0(base, value) (BME_AND8(&CMP_CR0_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR0(base, value) (BME_XOR8(&CMP_CR0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 0b00 - Level 0
 * - 0b01 - Level 1
 * - 0b10 - Level 2
 * - 0b11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_HYSTCTR_SHIFT), CMP_CR0_HYSTCTR_SHIFT, CMP_CR0_HYSTCTR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 0b000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not
 *     a legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 0b001 - One sample must agree. The comparator output is simply sampled.
 * - 0b010 - 2 consecutive samples must agree.
 * - 0b011 - 3 consecutive samples must agree.
 * - 0b100 - 4 consecutive samples must agree.
 * - 0b101 - 5 consecutive samples must agree.
 * - 0b110 - 6 consecutive samples must agree.
 * - 0b111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (BME_UBFX8(&CMP_CR0_REG(base), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (BME_BFI8(&CMP_CR0_REG(base), ((uint8_t)(value) << CMP_CR0_FILTER_CNT_SHIFT), CMP_CR0_FILTER_CNT_SHIFT, CMP_CR0_FILTER_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (BME_OR8(&CMP_CR1_REG(base), (uint8_t)(value)))
#define CMP_CLR_CR1(base, value) (BME_AND8(&CMP_CR1_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_CR1(base, value) (BME_XOR8(&CMP_CR1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0b0 - Analog Comparator is disabled.
 * - 0b1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_EN_SHIFT), CMP_CR1_EN_SHIFT, CMP_CR1_EN_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0b0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 0b1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has
 *     no effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_OPE_SHIFT), CMP_CR1_OPE_SHIFT, CMP_CR1_OPE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0b0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 0b1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_COS_SHIFT), CMP_CR1_COS_SHIFT, CMP_CR1_COS_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0b0 - Does not invert the comparator output.
 * - 0b1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_INV_SHIFT), CMP_CR1_INV_SHIFT, CMP_CR1_INV_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0b0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 0b1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has
 *     faster output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_PMODE_SHIFT), CMP_CR1_PMODE_SHIFT, CMP_CR1_PMODE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0b0 - Trigger mode is disabled.
 * - 0b1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_TRIGM_SHIFT), CMP_CR1_TRIGM_SHIFT, CMP_CR1_TRIGM_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. It is mandatory request to not
 * set SE and WE both at a given time.
 *
 * Values:
 * - 0b0 - Windowing mode is not selected.
 * - 0b1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_WE_SHIFT), CMP_CR1_WE_SHIFT, CMP_CR1_WE_WIDTH))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. It is mandatory request to not
 * set SE and WE both at a given time.
 *
 * Values:
 * - 0b0 - Sampling mode is not selected.
 * - 0b1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BME_UBFX8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BME_BFI8(&CMP_CR1_REG(base), ((uint8_t)(value) << CMP_CR1_SE_SHIFT), CMP_CR1_SE_SHIFT, CMP_CR1_SE_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (BME_OR8(&CMP_FPR_REG(base), (uint8_t)(value)))
#define CMP_CLR_FPR(base, value) (BME_AND8(&CMP_FPR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_FPR(base, value) (BME_XOR8(&CMP_FPR_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (BME_OR8(&CMP_SCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_SCR(base, value) (BME_AND8(&CMP_SCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_SCR(base, value) (BME_XOR8(&CMP_SCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT, CMP_SCR_COUT_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is edge sensitive .
 *
 * Values:
 * - 0b0 - Falling-edge on COUT has not been detected.
 * - 0b1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFF_SHIFT), CMP_SCR_CFF_SHIFT, CMP_SCR_CFF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is edge sensitive .
 *
 * Values:
 * - 0b0 - Rising-edge on COUT has not been detected.
 * - 0b1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_CFR_SHIFT), CMP_SCR_CFR_SHIFT, CMP_SCR_CFR_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IEF_SHIFT), CMP_SCR_IEF_SHIFT, CMP_SCR_IEF_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0b0 - Interrupt is disabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_IER_SHIFT), CMP_SCR_IER_SHIFT, CMP_SCR_IER_WIDTH))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BME_UBFX8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BME_BFI8(&CMP_SCR_REG(base), ((uint8_t)(value) << CMP_SCR_DMAEN_SHIFT), CMP_SCR_DMAEN_SHIFT, CMP_SCR_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (BME_OR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_DACCR(base, value) (BME_AND8(&CMP_DACCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_DACCR(base, value) (BME_XOR8(&CMP_DACCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VOSEL_SHIFT), CMP_DACCR_VOSEL_SHIFT, CMP_DACCR_VOSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0b0 - Vin1 is selected as resistor ladder network supply reference.
 * - 0b1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_VRSEL_SHIFT), CMP_DACCR_VRSEL_SHIFT, CMP_DACCR_VRSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0b0 - DAC is disabled.
 * - 0b1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BME_UBFX8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BME_BFI8(&CMP_DACCR_REG(base), ((uint8_t)(value) << CMP_DACCR_DACEN_SHIFT), CMP_DACCR_DACEN_SHIFT, CMP_DACCR_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (BME_OR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
#define CMP_CLR_MUXCR(base, value) (BME_AND8(&CMP_MUXCR_REG(base), (uint8_t)(~(value))))
#define CMP_TOG_MUXCR(base, value) (BME_XOR8(&CMP_MUXCR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_MSEL_SHIFT), CMP_MUXCR_MSEL_SHIFT, CMP_MUXCR_MSEL_WIDTH))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 0b000 - IN0
 * - 0b001 - IN1
 * - 0b010 - IN2
 * - 0b011 - IN3
 * - 0b100 - IN4
 * - 0b101 - IN5
 * - 0b110 - IN6
 * - 0b111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (BME_UBFX8(&CMP_MUXCR_REG(base), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (BME_BFI8(&CMP_MUXCR_REG(base), ((uint8_t)(value) << CMP_MUXCR_PSEL_SHIFT), CMP_MUXCR_PSEL_SHIFT, CMP_MUXCR_PSEL_WIDTH))
/*@}*/

/*
 * MKV58F24 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATAL - CRC_DATAL register.
 * - CRC_DATAH - CRC_DATAH register.
 * - CRC_DATALL - CRC_DATALL register.
 * - CRC_DATALU - CRC_DATALU register.
 * - CRC_DATAHL - CRC_DATAHL register.
 * - CRC_DATAHU - CRC_DATAHU register.
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define CRC_RD_DATALL(base)      (CRC_DATALL_REG(base))
#define CRC_WR_DATALL(base, value) (CRC_DATALL_REG(base) = (value))
#define CRC_RMW_DATALL(base, mask, value) (CRC_WR_DATALL(base, (CRC_RD_DATALL(base) & ~(mask)) | (value)))
#define CRC_SET_DATALL(base, value) (BME_OR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALL(base, value) (BME_AND8(&CRC_DATALL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALL(base, value) (BME_XOR8(&CRC_DATALL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define CRC_RD_DATAL(base)       (CRC_DATAL_REG(base))
#define CRC_WR_DATAL(base, value) (CRC_DATAL_REG(base) = (value))
#define CRC_RMW_DATAL(base, mask, value) (CRC_WR_DATAL(base, (CRC_RD_DATAL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAL(base, value) (BME_OR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAL(base, value) (BME_AND16(&CRC_DATAL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAL(base, value) (BME_XOR16(&CRC_DATAL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (BME_OR32(&CRC_DATA_REG(base), (uint32_t)(value)))
#define CRC_CLR_DATA(base, value) (BME_AND32(&CRC_DATA_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_DATA(base, value) (BME_XOR32(&CRC_DATA_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LL_SHIFT), CRC_DATA_LL_SHIFT, CRC_DATA_LL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_LU_SHIFT), CRC_DATA_LU_SHIFT, CRC_DATA_LU_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HL_SHIFT), CRC_DATA_HL_SHIFT, CRC_DATA_HL_WIDTH))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (BME_UBFX32(&CRC_DATA_REG(base), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (BME_BFI32(&CRC_DATA_REG(base), ((uint32_t)(value) << CRC_DATA_HU_SHIFT), CRC_DATA_HU_SHIFT, CRC_DATA_HU_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define CRC_RD_DATALU(base)      (CRC_DATALU_REG(base))
#define CRC_WR_DATALU(base, value) (CRC_DATALU_REG(base) = (value))
#define CRC_RMW_DATALU(base, mask, value) (CRC_WR_DATALU(base, (CRC_RD_DATALU(base) & ~(mask)) | (value)))
#define CRC_SET_DATALU(base, value) (BME_OR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATALU(base, value) (BME_AND8(&CRC_DATALU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATALU(base, value) (BME_XOR8(&CRC_DATALU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define CRC_RD_DATAHL(base)      (CRC_DATAHL_REG(base))
#define CRC_WR_DATAHL(base, value) (CRC_DATAHL_REG(base) = (value))
#define CRC_RMW_DATAHL(base, mask, value) (CRC_WR_DATAHL(base, (CRC_RD_DATAHL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHL(base, value) (BME_OR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHL(base, value) (BME_AND8(&CRC_DATAHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHL(base, value) (BME_XOR8(&CRC_DATAHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define CRC_RD_DATAH(base)       (CRC_DATAH_REG(base))
#define CRC_WR_DATAH(base, value) (CRC_DATAH_REG(base) = (value))
#define CRC_RMW_DATAH(base, mask, value) (CRC_WR_DATAH(base, (CRC_RD_DATAH(base) & ~(mask)) | (value)))
#define CRC_SET_DATAH(base, value) (BME_OR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
#define CRC_CLR_DATAH(base, value) (BME_AND16(&CRC_DATAH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_DATAH(base, value) (BME_XOR16(&CRC_DATAH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define CRC_RD_DATAHU(base)      (CRC_DATAHU_REG(base))
#define CRC_WR_DATAHU(base, value) (CRC_DATAHU_REG(base) = (value))
#define CRC_RMW_DATAHU(base, mask, value) (CRC_WR_DATAHU(base, (CRC_RD_DATAHU(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHU(base, value) (BME_OR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_DATAHU(base, value) (BME_AND8(&CRC_DATAHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_DATAHU(base, value) (BME_XOR8(&CRC_DATAHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (BME_OR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLL(base, value) (BME_AND8(&CRC_GPOLYLL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLL(base, value) (BME_XOR8(&CRC_GPOLYLL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (BME_OR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
#define CRC_CLR_GPOLY(base, value) (BME_AND32(&CRC_GPOLY_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_GPOLY(base, value) (BME_XOR32(&CRC_GPOLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (CRC_RD_GPOLY_LOW(base))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (CRC_WR_GPOLY_LOW(base, value))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (CRC_RD_GPOLY_HIGH(base))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (CRC_WR_GPOLY_HIGH(base, value))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (BME_OR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYL(base, value) (BME_AND16(&CRC_GPOLYL_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYL(base, value) (BME_XOR16(&CRC_GPOLYL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (BME_OR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYLU(base, value) (BME_AND8(&CRC_GPOLYLU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYLU(base, value) (BME_XOR8(&CRC_GPOLYLU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (BME_OR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
#define CRC_CLR_GPOLYH(base, value) (BME_AND16(&CRC_GPOLYH_REG(base), (uint16_t)(~(value))))
#define CRC_TOG_GPOLYH(base, value) (BME_XOR16(&CRC_GPOLYH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (BME_OR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHL(base, value) (BME_AND8(&CRC_GPOLYHL_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHL(base, value) (BME_XOR8(&CRC_GPOLYHL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (BME_OR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_GPOLYHU(base, value) (BME_AND8(&CRC_GPOLYHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_GPOLYHU(base, value) (BME_XOR8(&CRC_GPOLYHU_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (BME_OR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
#define CRC_CLR_CTRL(base, value) (BME_AND32(&CRC_CTRL_REG(base), (uint32_t)(~(value))))
#define CRC_TOG_CTRL(base, value) (BME_XOR32(&CRC_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TCRC_SHIFT), CRC_CTRL_TCRC_SHIFT, CRC_CTRL_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0b0 - Writes to the CRC data register are data values.
 * - 0b1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_WAS_SHIFT), CRC_CTRL_WAS_SHIFT, CRC_CTRL_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_FXOR_SHIFT), CRC_CTRL_FXOR_SHIFT, CRC_CTRL_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOTR_SHIFT), CRC_CTRL_TOTR_SHIFT, CRC_CTRL_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 0b00 - No transposition.
 * - 0b01 - Bits in bytes are transposed; bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (BME_UBFX32(&CRC_CTRL_REG(base), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (BME_BFI32(&CRC_CTRL_REG(base), ((uint32_t)(value) << CRC_CTRL_TOT_SHIFT), CRC_CTRL_TOT_SHIFT, CRC_CTRL_TOT_WIDTH))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (BME_OR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
#define CRC_CLR_CTRLHU(base, value) (BME_AND8(&CRC_CTRLHU_REG(base), (uint8_t)(~(value))))
#define CRC_TOG_CTRLHU(base, value) (BME_XOR8(&CRC_CTRLHU_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0b0 - 16-bit CRC protocol.
 * - 0b1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TCRC_SHIFT), CRC_CTRLHU_TCRC_SHIFT, CRC_CTRLHU_TCRC_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0b0 - Writes to CRC data register are data values.
 * - 0b1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_WAS_SHIFT), CRC_CTRLHU_WAS_SHIFT, CRC_CTRLHU_WAS_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0b0 - No XOR on reading.
 * - 0b1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_FXOR_SHIFT), CRC_CTRLHU_FXOR_SHIFT, CRC_CTRLHU_FXOR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOTR_SHIFT), CRC_CTRLHU_TOTR_SHIFT, CRC_CTRLHU_TOTR_WIDTH))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 0b00 - No Transposition.
 * - 0b01 - Bits in bytes are transposed, bytes are not transposed.
 * - 0b10 - Both bits in bytes and bytes are transposed.
 * - 0b11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (BME_UBFX8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (BME_BFI8(&CRC_CTRLHU_REG(base), ((uint8_t)(value) << CRC_CTRLHU_TOT_SHIFT), CRC_CTRLHU_TOT_SHIFT, CRC_CTRLHU_TOT_WIDTH))
/*@}*/

/*
 * MKV58F24 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - DAC_DATL - DAC Data Low Register
 * - DAC_DATH - DAC Data High Register
 * - DAC_SR - DAC Status Register
 * - DAC_C0 - DAC Control Register
 * - DAC_C1 - DAC Control Register 1
 * - DAC_C2 - DAC Control Register 2
 */

#define DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define DAC0_IDX (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * DAC_DATL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief DAC_DATL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATL register
 */
/*@{*/
#define DAC_RD_DATL(base, index) (DAC_DATL_REG(base, index))
#define DAC_WR_DATL(base, index, value) (DAC_DATL_REG(base, index) = (value))
#define DAC_RMW_DATL(base, index, mask, value) (DAC_WR_DATL(base, index, (DAC_RD_DATL(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATL(base, index, value) (BME_OR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATL(base, index, value) (BME_AND8(&DAC_DATL_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATL(base, index, value) (BME_XOR8(&DAC_DATL_REG(base, index), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * DAC_DATH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief DAC_DATH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATH register
 */
/*@{*/
#define DAC_RD_DATH(base, index) (DAC_DATH_REG(base, index))
#define DAC_WR_DATH(base, index, value) (DAC_DATH_REG(base, index) = (value))
#define DAC_RMW_DATH(base, index, mask, value) (DAC_WR_DATH(base, index, (DAC_RD_DATH(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATH(base, index, value) (BME_OR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
#define DAC_CLR_DATH(base, index, value) (BME_AND8(&DAC_DATH_REG(base, index), (uint8_t)(~(value))))
#define DAC_TOG_DATH(base, index, value) (BME_XOR8(&DAC_DATH_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATH bitfields
 */

/*!
 * @name Register DAC_DATH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_DATH_DATA1 field. */
#define DAC_RD_DATH_DATA1(base, index) ((DAC_DATH_REG(base, index) & DAC_DATH_DATA1_MASK) >> DAC_DATH_DATA1_SHIFT)
#define DAC_BRD_DATH_DATA1(base, index) (BME_UBFX8(&DAC_DATH_REG(base, index), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))

/*! @brief Set the DATA1 field to a new value. */
#define DAC_WR_DATH_DATA1(base, index, value) (DAC_RMW_DATH(base, index, DAC_DATH_DATA1_MASK, DAC_DATH_DATA1(value)))
#define DAC_BWR_DATH_DATA1(base, index, value) (BME_BFI8(&DAC_DATH_REG(base, index), ((uint8_t)(value) << DAC_DATH_DATA1_SHIFT), DAC_DATH_DATA1_SHIFT, DAC_DATH_DATA1_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed.
 */
/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define DAC_RD_SR(base)          (DAC_SR_REG(base))
#define DAC_WR_SR(base, value)   (DAC_SR_REG(base) = (value))
#define DAC_RMW_SR(base, mask, value) (DAC_WR_SR(base, (DAC_RD_SR(base) & ~(mask)) | (value)))
#define DAC_SET_SR(base, value)  (BME_OR8(&DAC_SR_REG(base), (uint8_t)(value)))
#define DAC_CLR_SR(base, value)  (BME_AND8(&DAC_SR_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_SR(base, value)  (BME_XOR8(&DAC_SR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * In FIFO mode, it is FIFO FULL status bit. It means FIFO read pointer equals
 * Write Pointer because of Write Pointer increase. If this bit is set, any write
 * to FIFO from either DMA or CPU is ignored by DAC. It is cleared if there is
 * any DAC trigger making the DAC read pointer increase. Write to this bit is
 * ignored in FIFO mode.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 0b1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define DAC_RD_SR_DACBFRPBF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPBF_MASK) >> DAC_SR_DACBFRPBF_SHIFT)
#define DAC_BRD_SR_DACBFRPBF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))

/*! @brief Set the DACBFRPBF field to a new value. */
#define DAC_WR_SR_DACBFRPBF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPBF_MASK, DAC_SR_DACBFRPBF(value)))
#define DAC_BWR_SR_DACBFRPBF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPBF_SHIFT), DAC_SR_DACBFRPBF_SHIFT, DAC_SR_DACBFRPBF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * In FIFO mode, it is FIFO nearly empty flag. It is set when only one data
 * remains in FIFO. Any DAC trigger does not increase the Read Pointer if this bit is
 * set to avoid any possible glitch or abrupt change at DAC output. It is
 * cleared automatically if FIFO is not empty.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer is not zero.
 * - 0b1 - The DAC buffer read pointer is zero.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define DAC_RD_SR_DACBFRPTF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPTF_MASK) >> DAC_SR_DACBFRPTF_SHIFT)
#define DAC_BRD_SR_DACBFRPTF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))

/*! @brief Set the DACBFRPTF field to a new value. */
#define DAC_WR_SR_DACBFRPTF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPTF_MASK, DAC_SR_DACBFRPTF(value)))
#define DAC_BWR_SR_DACBFRPTF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFRPTF_SHIFT), DAC_SR_DACBFRPTF_SHIFT, DAC_SR_DACBFRPTF_WIDTH))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFWMF[2] (RW)
 *
 * This bit is set if the remaining FIFO data is less than the watermark
 * setting. It is cleared automatically by writing data into FIFO by DMA or CPU. Write
 * to this bit is ignored in FIFO mode.
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer has not reached the watermark level.
 * - 0b1 - The DAC buffer read pointer has reached the watermark level.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFWMF field. */
#define DAC_RD_SR_DACBFWMF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFWMF_MASK) >> DAC_SR_DACBFWMF_SHIFT)
#define DAC_BRD_SR_DACBFWMF(base) (BME_UBFX8(&DAC_SR_REG(base), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))

/*! @brief Set the DACBFWMF field to a new value. */
#define DAC_WR_SR_DACBFWMF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFWMF_MASK, DAC_SR_DACBFWMF(value)))
#define DAC_BWR_SR_DACBFWMF(base, value) (BME_BFI8(&DAC_SR_REG(base), ((uint8_t)(value) << DAC_SR_DACBFWMF_SHIFT), DAC_SR_DACBFWMF_SHIFT, DAC_SR_DACBFWMF_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define DAC_RD_C0(base)          (DAC_C0_REG(base))
#define DAC_WR_C0(base, value)   (DAC_C0_REG(base) = (value))
#define DAC_RMW_C0(base, mask, value) (DAC_WR_C0(base, (DAC_RD_C0(base) & ~(mask)) | (value)))
#define DAC_SET_C0(base, value)  (BME_OR8(&DAC_C0_REG(base), (uint8_t)(value)))
#define DAC_CLR_C0(base, value)  (BME_AND8(&DAC_C0_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C0(base, value)  (BME_XOR8(&DAC_C0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define DAC_RD_C0_DACBBIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBBIEN_MASK) >> DAC_C0_DACBBIEN_SHIFT)
#define DAC_BRD_C0_DACBBIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))

/*! @brief Set the DACBBIEN field to a new value. */
#define DAC_WR_C0_DACBBIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBBIEN_MASK, DAC_C0_DACBBIEN(value)))
#define DAC_BWR_C0_DACBBIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBBIEN_SHIFT), DAC_C0_DACBBIEN_SHIFT, DAC_C0_DACBBIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 0b1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define DAC_RD_C0_DACBTIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBTIEN_MASK) >> DAC_C0_DACBTIEN_SHIFT)
#define DAC_BRD_C0_DACBTIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))

/*! @brief Set the DACBTIEN field to a new value. */
#define DAC_WR_C0_DACBTIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBTIEN_MASK, DAC_C0_DACBTIEN(value)))
#define DAC_BWR_C0_DACBTIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBTIEN_SHIFT), DAC_C0_DACBTIEN_SHIFT, DAC_C0_DACBTIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBWIEN[2] (RW)
 *
 * Values:
 * - 0b0 - The DAC buffer watermark interrupt is disabled.
 * - 0b1 - The DAC buffer watermark interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBWIEN field. */
#define DAC_RD_C0_DACBWIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBWIEN_MASK) >> DAC_C0_DACBWIEN_SHIFT)
#define DAC_BRD_C0_DACBWIEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))

/*! @brief Set the DACBWIEN field to a new value. */
#define DAC_WR_C0_DACBWIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBWIEN_MASK, DAC_C0_DACBWIEN(value)))
#define DAC_BWR_C0_DACBWIEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACBWIEN_SHIFT), DAC_C0_DACBWIEN_SHIFT, DAC_C0_DACBWIEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0b0 - High-Power mode
 * - 0b1 - Low-Power mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_LPEN field. */
#define DAC_RD_C0_LPEN(base) ((DAC_C0_REG(base) & DAC_C0_LPEN_MASK) >> DAC_C0_LPEN_SHIFT)
#define DAC_BRD_C0_LPEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))

/*! @brief Set the LPEN field to a new value. */
#define DAC_WR_C0_LPEN(base, value) (DAC_RMW_C0(base, DAC_C0_LPEN_MASK, DAC_C0_LPEN(value)))
#define DAC_BWR_C0_LPEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_LPEN_SHIFT), DAC_C0_LPEN_SHIFT, DAC_C0_LPEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0b0 - The DAC soft trigger is not valid.
 * - 0b1 - The DAC soft trigger is valid.
 */
/*@{*/
/*! @brief Set the DACSWTRG field to a new value. */
#define DAC_WR_C0_DACSWTRG(base, value) (DAC_RMW_C0(base, DAC_C0_DACSWTRG_MASK, DAC_C0_DACSWTRG(value)))
#define DAC_BWR_C0_DACSWTRG(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACSWTRG_SHIFT), DAC_C0_DACSWTRG_SHIFT, DAC_C0_DACSWTRG_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0b0 - The DAC hardware trigger is selected.
 * - 0b1 - The DAC software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define DAC_RD_C0_DACTRGSEL(base) ((DAC_C0_REG(base) & DAC_C0_DACTRGSEL_MASK) >> DAC_C0_DACTRGSEL_SHIFT)
#define DAC_BRD_C0_DACTRGSEL(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))

/*! @brief Set the DACTRGSEL field to a new value. */
#define DAC_WR_C0_DACTRGSEL(base, value) (DAC_RMW_C0(base, DAC_C0_DACTRGSEL_MASK, DAC_C0_DACTRGSEL(value)))
#define DAC_BWR_C0_DACTRGSEL(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACTRGSEL_SHIFT), DAC_C0_DACTRGSEL_SHIFT, DAC_C0_DACTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0b0 - The DAC selects DACREF_1 as the reference voltage.
 * - 0b1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define DAC_RD_C0_DACRFS(base) ((DAC_C0_REG(base) & DAC_C0_DACRFS_MASK) >> DAC_C0_DACRFS_SHIFT)
#define DAC_BRD_C0_DACRFS(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))

/*! @brief Set the DACRFS field to a new value. */
#define DAC_WR_C0_DACRFS(base, value) (DAC_RMW_C0(base, DAC_C0_DACRFS_MASK, DAC_C0_DACRFS(value)))
#define DAC_BWR_C0_DACRFS(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACRFS_SHIFT), DAC_C0_DACRFS_SHIFT, DAC_C0_DACRFS_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0b0 - The DAC system is disabled.
 * - 0b1 - The DAC system is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACEN field. */
#define DAC_RD_C0_DACEN(base) ((DAC_C0_REG(base) & DAC_C0_DACEN_MASK) >> DAC_C0_DACEN_SHIFT)
#define DAC_BRD_C0_DACEN(base) (BME_UBFX8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))

/*! @brief Set the DACEN field to a new value. */
#define DAC_WR_C0_DACEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACEN_MASK, DAC_C0_DACEN(value)))
#define DAC_BWR_C0_DACEN(base, value) (BME_BFI8(&DAC_C0_REG(base), ((uint8_t)(value) << DAC_C0_DACEN_SHIFT), DAC_C0_DACEN_SHIFT, DAC_C0_DACEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define DAC_RD_C1(base)          (DAC_C1_REG(base))
#define DAC_WR_C1(base, value)   (DAC_C1_REG(base) = (value))
#define DAC_RMW_C1(base, mask, value) (DAC_WR_C1(base, (DAC_RD_C1(base) & ~(mask)) | (value)))
#define DAC_SET_C1(base, value)  (BME_OR8(&DAC_C1_REG(base), (uint8_t)(value)))
#define DAC_CLR_C1(base, value)  (BME_AND8(&DAC_C1_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C1(base, value)  (BME_XOR8(&DAC_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0b0 - Buffer read pointer is disabled. The converted data is always the
 *     first word of the buffer.
 * - 0b1 - Buffer read pointer is enabled. The converted data is the word that
 *     the read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define DAC_RD_C1_DACBFEN(base) ((DAC_C1_REG(base) & DAC_C1_DACBFEN_MASK) >> DAC_C1_DACBFEN_SHIFT)
#define DAC_BRD_C1_DACBFEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))

/*! @brief Set the DACBFEN field to a new value. */
#define DAC_WR_C1_DACBFEN(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFEN_MASK, DAC_C1_DACBFEN(value)))
#define DAC_BWR_C1_DACBFEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFEN_SHIFT), DAC_C1_DACBFEN_SHIFT, DAC_C1_DACBFEN_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2:1] (RW)
 *
 * Values:
 * - 0b00 - Normal mode
 * - 0b01 - Swing mode
 * - 0b10 - One-Time Scan mode
 * - 0b11 - FIFO mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define DAC_RD_C1_DACBFMD(base) ((DAC_C1_REG(base) & DAC_C1_DACBFMD_MASK) >> DAC_C1_DACBFMD_SHIFT)
#define DAC_BRD_C1_DACBFMD(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))

/*! @brief Set the DACBFMD field to a new value. */
#define DAC_WR_C1_DACBFMD(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFMD_MASK, DAC_C1_DACBFMD(value)))
#define DAC_BWR_C1_DACBFMD(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFMD_SHIFT), DAC_C1_DACBFMD_SHIFT, DAC_C1_DACBFMD_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFWM[4:3] (RW)
 *
 * In normal mode it controls when SR[DACBFWMF] is set. When the DAC buffer read
 * pointer reaches the word defined by this field, which is 1-4 words away from
 * the upper limit (DACBUP), SR[DACBFWMF] will be set. This allows user
 * configuration of the watermark interrupt. In FIFO mode, it is FIFO watermark select
 * field.
 *
 * Values:
 * - 0b00 - In normal mode, 1 word . In FIFO mode, 2 or less than 2 data
 *     remaining in FIFO will set watermark status bit.
 * - 0b01 - In normal mode, 2 words . In FIFO mode, Max/4 or less than Max/4
 *     data remaining in FIFO will set watermark status bit.
 * - 0b10 - In normal mode, 3 words . In FIFO mode, Max/2 or less than Max/2
 *     data remaining in FIFO will set watermark status bit.
 * - 0b11 - In normal mode, 4 words . In FIFO mode, Max-2 or less than Max-2
 *     data remaining in FIFO will set watermark status bit.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFWM field. */
#define DAC_RD_C1_DACBFWM(base) ((DAC_C1_REG(base) & DAC_C1_DACBFWM_MASK) >> DAC_C1_DACBFWM_SHIFT)
#define DAC_BRD_C1_DACBFWM(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DACBFWM_SHIFT, DAC_C1_DACBFWM_WIDTH))

/*! @brief Set the DACBFWM field to a new value. */
#define DAC_WR_C1_DACBFWM(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFWM_MASK, DAC_C1_DACBFWM(value)))
#define DAC_BWR_C1_DACBFWM(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DACBFWM_SHIFT), DAC_C1_DACBFWM_SHIFT, DAC_C1_DACBFWM_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0b0 - DMA is disabled.
 * - 0b1 - DMA is enabled. When DMA is enabled, the DMA request will be
 *     generated by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define DAC_RD_C1_DMAEN(base) ((DAC_C1_REG(base) & DAC_C1_DMAEN_MASK) >> DAC_C1_DMAEN_SHIFT)
#define DAC_BRD_C1_DMAEN(base) (BME_UBFX8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define DAC_WR_C1_DMAEN(base, value) (DAC_RMW_C1(base, DAC_C1_DMAEN_MASK, DAC_C1_DMAEN(value)))
#define DAC_BWR_C1_DMAEN(base, value) (BME_BFI8(&DAC_C1_REG(base), ((uint8_t)(value) << DAC_C1_DMAEN_SHIFT), DAC_C1_DMAEN_SHIFT, DAC_C1_DMAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x0FU
 */
/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define DAC_RD_C2(base)          (DAC_C2_REG(base))
#define DAC_WR_C2(base, value)   (DAC_C2_REG(base) = (value))
#define DAC_RMW_C2(base, mask, value) (DAC_WR_C2(base, (DAC_RD_C2(base) & ~(mask)) | (value)))
#define DAC_SET_C2(base, value)  (BME_OR8(&DAC_C2_REG(base), (uint8_t)(value)))
#define DAC_CLR_C2(base, value)  (BME_AND8(&DAC_C2_REG(base), (uint8_t)(~(value))))
#define DAC_TOG_C2(base, value)  (BME_XOR8(&DAC_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[3:0] (RW)
 *
 * In normal mode it selects the upper limit of the DAC buffer. The buffer read
 * pointer cannot exceed it. In FIFO mode it is the FIFO write pointer. User
 * cannot set Buffer Up limit in FIFO mode. In Normal mode its reset value is MAX.
 * When IP is configured to FIFO mode, this register becomes Write_Pointer, and its
 * value is initially set to equal READ_POINTER automatically, and the FIFO
 * status is empty. It is writable and user can configure it to the same address to
 * reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define DAC_RD_C2_DACBFUP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFUP_MASK) >> DAC_C2_DACBFUP_SHIFT)
#define DAC_BRD_C2_DACBFUP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))

/*! @brief Set the DACBFUP field to a new value. */
#define DAC_WR_C2_DACBFUP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFUP_MASK, DAC_C2_DACBFUP(value)))
#define DAC_BWR_C2_DACBFUP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFUP_SHIFT), DAC_C2_DACBFUP_SHIFT, DAC_C2_DACBFUP_WIDTH))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[7:4] (RW)
 *
 * In normal mode it keeps the current value of the buffer read pointer. FIFO
 * mode, it is the FIFO read pointer. It is writable in FIFO mode. User can
 * configure it to same address to reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define DAC_RD_C2_DACBFRP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFRP_MASK) >> DAC_C2_DACBFRP_SHIFT)
#define DAC_BRD_C2_DACBFRP(base) (BME_UBFX8(&DAC_C2_REG(base), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))

/*! @brief Set the DACBFRP field to a new value. */
#define DAC_WR_C2_DACBFRP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFRP_MASK, DAC_C2_DACBFRP(value)))
#define DAC_BWR_C2_DACBFRP(base, value) (BME_BFI8(&DAC_C2_REG(base), ((uint8_t)(value) << DAC_C2_DACBFRP_SHIFT), DAC_C2_DACBFRP_SHIFT, DAC_C2_DACBFRP_WIDTH))
/*@}*/

/*
 * MKV58F24 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_EARS - Enable Asynchronous Request in Stop Register
 * - DMA_DCHPRI3 - Channel n Priority Register
 * - DMA_DCHPRI2 - Channel n Priority Register
 * - DMA_DCHPRI1 - Channel n Priority Register
 * - DMA_DCHPRI0 - Channel n Priority Register
 * - DMA_DCHPRI7 - Channel n Priority Register
 * - DMA_DCHPRI6 - Channel n Priority Register
 * - DMA_DCHPRI5 - Channel n Priority Register
 * - DMA_DCHPRI4 - Channel n Priority Register
 * - DMA_DCHPRI11 - Channel n Priority Register
 * - DMA_DCHPRI10 - Channel n Priority Register
 * - DMA_DCHPRI9 - Channel n Priority Register
 * - DMA_DCHPRI8 - Channel n Priority Register
 * - DMA_DCHPRI15 - Channel n Priority Register
 * - DMA_DCHPRI14 - Channel n Priority Register
 * - DMA_DCHPRI13 - Channel n Priority Register
 * - DMA_DCHPRI12 - Channel n Priority Register
 * - DMA_DCHPRI19 - Channel n Priority Register
 * - DMA_DCHPRI18 - Channel n Priority Register
 * - DMA_DCHPRI17 - Channel n Priority Register
 * - DMA_DCHPRI16 - Channel n Priority Register
 * - DMA_DCHPRI23 - Channel n Priority Register
 * - DMA_DCHPRI22 - Channel n Priority Register
 * - DMA_DCHPRI21 - Channel n Priority Register
 * - DMA_DCHPRI20 - Channel n Priority Register
 * - DMA_DCHPRI27 - Channel n Priority Register
 * - DMA_DCHPRI26 - Channel n Priority Register
 * - DMA_DCHPRI25 - Channel n Priority Register
 * - DMA_DCHPRI24 - Channel n Priority Register
 * - DMA_DCHPRI31 - Channel n Priority Register
 * - DMA_DCHPRI30 - Channel n Priority Register
 * - DMA_DCHPRI29 - Channel n Priority Register
 * - DMA_DCHPRI28 - Channel n Priority Register
 * - DMA_SADDR - TCD Source Address
 * - DMA_SOFF - TCD Signed Source Address Offset
 * - DMA_ATTR - TCD Transfer Attributes
 * - DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_SLAST - TCD Last Source Address Adjustment
 * - DMA_DADDR - TCD Destination Address
 * - DMA_DOFF - TCD Signed Destination Address Offset
 * - DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_CSR - TCD Control and Status
 * - DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000400U
 *
 * The CR defines the basic operating configuration of the DMA. The DMA
 * arbitrates channel service requests in two groups of 16 channels each: Group 1
 * contains channels 31-16 Group 0 contains channels 15-0 Arbitration within a group can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels within each group are cycled through (from high to low
 * channel number) without regard to priority. For correct operation, writes to the
 * CR register must be performed only when the DMA channels are inactive; that
 * is, when TCDn_CSR[ACTIVE] bits are cleared. The group priorities operate in a
 * similar fashion. In group fixed priority arbitration mode, channel service
 * requests in the highest priority group are executed first, where priority level 1
 * is the highest and priority level 0 is the lowest. The group priorities are
 * assigned in the GRPnPRI fields of the DMA Control Register (CR). All group
 * priorities must have unique values prior to any channel service requests occurring;
 * otherwise, a configuration error will be reported. For group round robin
 * arbitration, the group priorities are ignored and the groups are cycled through
 * (from high to low group number) without regard to priority. Minor loop offsets
 * are address offset values added to the final source address (TCDn_SADDR) or
 * destination address (TCDn_DADDR) upon minor loop completion. When minor loop
 * offsets are enabled, the minor loop offset (MLOFF) is added to the final source
 * address (TCDn_SADDR), to the final destination address (TCDn_DADDR), or to both
 * prior to the addresses being written back into the TCD. If the major loop is
 * complete, the minor loop offset is ignored and the major loop address offsets
 * (TCDn_SLAST and TCDn_DLAST_SGA) are used to compute the next TCDn_SADDR and
 * TCDn_DADDR values. When minor loop mapping is enabled (EMLM is 1), TCDn word2 is
 * redefined. A portion of TCDn word2 is used to specify multiple fields: a
 * source enable bit (SMLOE) to specify the minor loop offset should be applied to the
 * source address (TCDn_SADDR) upon minor loop completion, a destination enable
 * bit (DMLOE) to specify the minor loop offset should be applied to the
 * destination address (TCDn_DADDR) upon minor loop completion, and the sign extended
 * minor loop offset value (MLOFF). The same offset value (MLOFF) is used for both
 * source and destination minor loop offsets. When either minor loop offset is
 * enabled (SMLOE set or DMLOE set), the NBYTES field is reduced to 10 bits. When
 * both minor loop offsets are disabled (SMLOE cleared and DMLOE cleared), the
 * NBYTES field is a 30-bit vector. When minor loop mapping is disabled (EMLM is 0),
 * all 32 bits of TCDn word2 are assigned to the NBYTES field.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (BME_OR32(&DMA_CR_REG(base), (uint32_t)(value)))
#define DMA_CLR_CR(base, value)  (BME_AND32(&DMA_CR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_CR(base, value)  (BME_XOR32(&DMA_CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0b0 - When in debug mode, the DMA continues to operate.
 * - 0b1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EDBG_SHIFT), DMA_CR_EDBG_SHIFT, DMA_CR_EDBG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0b0 - Fixed priority arbitration is used for channel selection within each
 *     group.
 * - 0b1 - Round robin arbitration is used for channel selection within each
 *     group.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ERCA_SHIFT), DMA_CR_ERCA_SHIFT, DMA_CR_ERCA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ERGA[3] (RW)
 *
 * Values:
 * - 0b0 - Fixed priority arbitration is used for selection among the groups.
 * - 0b1 - Round robin arbitration is used for selection among the groups.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERGA field. */
#define DMA_RD_CR_ERGA(base) ((DMA_CR_REG(base) & DMA_CR_ERGA_MASK) >> DMA_CR_ERGA_SHIFT)
#define DMA_BRD_CR_ERGA(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ERGA_SHIFT, DMA_CR_ERGA_WIDTH))

/*! @brief Set the ERGA field to a new value. */
#define DMA_WR_CR_ERGA(base, value) (DMA_RMW_CR(base, DMA_CR_ERGA_MASK, DMA_CR_ERGA(value)))
#define DMA_BWR_CR_ERGA(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ERGA_SHIFT), DMA_CR_ERGA_SHIFT, DMA_CR_ERGA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HOE_SHIFT), DMA_CR_HOE_SHIFT, DMA_CR_HOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Stall the start of any new channels. Executing channels are allowed
 *     to complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_HALT_SHIFT), DMA_CR_HALT_SHIFT, DMA_CR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Do not use continuous link mode with a channel linking to itself if there is
 * only one minor loop iteration per service request, e.g., if the channel's
 * NBYTES value is the same as either the source or destination size. The same data
 * transfer profile can be achieved by simply increasing the NBYTES value, which
 * provides more efficient, faster processing.
 *
 * Values:
 * - 0b0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 0b1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor
 *     loop offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CLM_SHIFT), DMA_CR_CLM_SHIFT, DMA_CR_CLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0b0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 0b1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the
 *     destination address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_EMLM_SHIFT), DMA_CR_EMLM_SHIFT, DMA_CR_EMLM_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field GRP0PRI[8] (RW)
 *
 * Group 0 priority level when fixed priority group arbitration is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_GRP0PRI field. */
#define DMA_RD_CR_GRP0PRI(base) ((DMA_CR_REG(base) & DMA_CR_GRP0PRI_MASK) >> DMA_CR_GRP0PRI_SHIFT)
#define DMA_BRD_CR_GRP0PRI(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_GRP0PRI_SHIFT, DMA_CR_GRP0PRI_WIDTH))

/*! @brief Set the GRP0PRI field to a new value. */
#define DMA_WR_CR_GRP0PRI(base, value) (DMA_RMW_CR(base, DMA_CR_GRP0PRI_MASK, DMA_CR_GRP0PRI(value)))
#define DMA_BWR_CR_GRP0PRI(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_GRP0PRI_SHIFT), DMA_CR_GRP0PRI_SHIFT, DMA_CR_GRP0PRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field GRP1PRI[10] (RW)
 *
 * Group 1 priority level when fixed priority group arbitration is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_GRP1PRI field. */
#define DMA_RD_CR_GRP1PRI(base) ((DMA_CR_REG(base) & DMA_CR_GRP1PRI_MASK) >> DMA_CR_GRP1PRI_SHIFT)
#define DMA_BRD_CR_GRP1PRI(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_GRP1PRI_SHIFT, DMA_CR_GRP1PRI_WIDTH))

/*! @brief Set the GRP1PRI field to a new value. */
#define DMA_WR_CR_GRP1PRI(base, value) (DMA_RMW_CR(base, DMA_CR_GRP1PRI_MASK, DMA_CR_GRP1PRI(value)))
#define DMA_BWR_CR_GRP1PRI(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_GRP1PRI_SHIFT), DMA_CR_GRP1PRI_SHIFT, DMA_CR_GRP1PRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus
 *     updating the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_ECX_SHIFT), DMA_CR_ECX_SHIFT, DMA_CR_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BME_UBFX32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BME_BFI32(&DMA_CR_REG(base), ((uint32_t)(value) << DMA_CR_CX_SHIFT), DMA_CR_CX_SHIFT, DMA_CR_CX_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle A
 * cancel transfer with error bit that will be set when a transfer is canceled
 * via the corresponding cancel transfer control bit See the Error Reporting and
 * Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0b0 - No destination bus error
 * - 0b1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT, DMA_ES_DBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0b0 - No source bus error
 * - 0b1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT, DMA_ES_SBE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0b0 - No scatter/gather configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a
 *     scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT, DMA_ES_SGE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0b0 - No NBYTES/CITER configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT, DMA_ES_NCE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0b0 - No destination offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT, DMA_ES_DOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0b0 - No destination address configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT, DMA_ES_DAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0b0 - No source offset configuration error
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT, DMA_ES_SOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0b0 - No source address configuration error.
 * - 0b1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT, DMA_ES_SAE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[12:8] (RO)
 *
 * The channel number of the last recorded error, excluding GPE and CPE errors,
 * or last recorded error canceled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ERRCHN_SHIFT, DMA_ES_ERRCHN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0b0 - No channel priority error
 * - 0b1 - The last recorded error was a configuration error in the channel
 *     priorities within a group. Channel priorities within a group are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT, DMA_ES_CPE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field GPE[15] (RO)
 *
 * Values:
 * - 0b0 - No group priority error
 * - 0b1 - The last recorded error was a configuration error among the group
 *     priorities. All group priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_GPE field. */
#define DMA_RD_ES_GPE(base)  ((DMA_ES_REG(base) & DMA_ES_GPE_MASK) >> DMA_ES_GPE_SHIFT)
#define DMA_BRD_ES_GPE(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_GPE_SHIFT, DMA_ES_GPE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0b0 - No canceled transfers
 * - 0b1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT, DMA_ES_ECX_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0b0 - No ERR bits are set.
 * - 0b1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BME_UBFX32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT, DMA_ES_VLD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 32 channels to enable the request
 * signal for each channel. The state of any given channel enable is directly
 * affected by writes to this register; it is also affected by writes to the SERQ
 * and CERQ registers. These registers are provided so the request enable for a
 * single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request
 * flag must be asserted before a channel's hardware service request is accepted.
 * The state of the DMA enable request flag does not affect a channel service
 * request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (BME_OR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERQ(base, value) (BME_AND32(&DMA_ERQ_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERQ(base, value) (BME_XOR32(&DMA_ERQ_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ0_SHIFT), DMA_ERQ_ERQ0_SHIFT, DMA_ERQ_ERQ0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ1_SHIFT), DMA_ERQ_ERQ1_SHIFT, DMA_ERQ_ERQ1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ2_SHIFT), DMA_ERQ_ERQ2_SHIFT, DMA_ERQ_ERQ2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ3_SHIFT), DMA_ERQ_ERQ3_SHIFT, DMA_ERQ_ERQ3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ4 field. */
#define DMA_RD_ERQ_ERQ4(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ4_MASK) >> DMA_ERQ_ERQ4_SHIFT)
#define DMA_BRD_ERQ_ERQ4(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT, DMA_ERQ_ERQ4_WIDTH))

/*! @brief Set the ERQ4 field to a new value. */
#define DMA_WR_ERQ_ERQ4(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ4_MASK, DMA_ERQ_ERQ4(value)))
#define DMA_BWR_ERQ_ERQ4(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ4_SHIFT), DMA_ERQ_ERQ4_SHIFT, DMA_ERQ_ERQ4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ5 field. */
#define DMA_RD_ERQ_ERQ5(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ5_MASK) >> DMA_ERQ_ERQ5_SHIFT)
#define DMA_BRD_ERQ_ERQ5(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT, DMA_ERQ_ERQ5_WIDTH))

/*! @brief Set the ERQ5 field to a new value. */
#define DMA_WR_ERQ_ERQ5(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ5_MASK, DMA_ERQ_ERQ5(value)))
#define DMA_BWR_ERQ_ERQ5(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ5_SHIFT), DMA_ERQ_ERQ5_SHIFT, DMA_ERQ_ERQ5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ6 field. */
#define DMA_RD_ERQ_ERQ6(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ6_MASK) >> DMA_ERQ_ERQ6_SHIFT)
#define DMA_BRD_ERQ_ERQ6(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT, DMA_ERQ_ERQ6_WIDTH))

/*! @brief Set the ERQ6 field to a new value. */
#define DMA_WR_ERQ_ERQ6(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ6_MASK, DMA_ERQ_ERQ6(value)))
#define DMA_BWR_ERQ_ERQ6(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ6_SHIFT), DMA_ERQ_ERQ6_SHIFT, DMA_ERQ_ERQ6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ7 field. */
#define DMA_RD_ERQ_ERQ7(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ7_MASK) >> DMA_ERQ_ERQ7_SHIFT)
#define DMA_BRD_ERQ_ERQ7(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT, DMA_ERQ_ERQ7_WIDTH))

/*! @brief Set the ERQ7 field to a new value. */
#define DMA_WR_ERQ_ERQ7(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ7_MASK, DMA_ERQ_ERQ7(value)))
#define DMA_BWR_ERQ_ERQ7(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ7_SHIFT), DMA_ERQ_ERQ7_SHIFT, DMA_ERQ_ERQ7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ8[8] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ8 field. */
#define DMA_RD_ERQ_ERQ8(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ8_MASK) >> DMA_ERQ_ERQ8_SHIFT)
#define DMA_BRD_ERQ_ERQ8(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ8_SHIFT, DMA_ERQ_ERQ8_WIDTH))

/*! @brief Set the ERQ8 field to a new value. */
#define DMA_WR_ERQ_ERQ8(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ8_MASK, DMA_ERQ_ERQ8(value)))
#define DMA_BWR_ERQ_ERQ8(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ8_SHIFT), DMA_ERQ_ERQ8_SHIFT, DMA_ERQ_ERQ8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ9[9] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ9 field. */
#define DMA_RD_ERQ_ERQ9(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ9_MASK) >> DMA_ERQ_ERQ9_SHIFT)
#define DMA_BRD_ERQ_ERQ9(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ9_SHIFT, DMA_ERQ_ERQ9_WIDTH))

/*! @brief Set the ERQ9 field to a new value. */
#define DMA_WR_ERQ_ERQ9(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ9_MASK, DMA_ERQ_ERQ9(value)))
#define DMA_BWR_ERQ_ERQ9(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ9_SHIFT), DMA_ERQ_ERQ9_SHIFT, DMA_ERQ_ERQ9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ10[10] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ10 field. */
#define DMA_RD_ERQ_ERQ10(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ10_MASK) >> DMA_ERQ_ERQ10_SHIFT)
#define DMA_BRD_ERQ_ERQ10(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ10_SHIFT, DMA_ERQ_ERQ10_WIDTH))

/*! @brief Set the ERQ10 field to a new value. */
#define DMA_WR_ERQ_ERQ10(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ10_MASK, DMA_ERQ_ERQ10(value)))
#define DMA_BWR_ERQ_ERQ10(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ10_SHIFT), DMA_ERQ_ERQ10_SHIFT, DMA_ERQ_ERQ10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ11[11] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ11 field. */
#define DMA_RD_ERQ_ERQ11(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ11_MASK) >> DMA_ERQ_ERQ11_SHIFT)
#define DMA_BRD_ERQ_ERQ11(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ11_SHIFT, DMA_ERQ_ERQ11_WIDTH))

/*! @brief Set the ERQ11 field to a new value. */
#define DMA_WR_ERQ_ERQ11(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ11_MASK, DMA_ERQ_ERQ11(value)))
#define DMA_BWR_ERQ_ERQ11(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ11_SHIFT), DMA_ERQ_ERQ11_SHIFT, DMA_ERQ_ERQ11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ12[12] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ12 field. */
#define DMA_RD_ERQ_ERQ12(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ12_MASK) >> DMA_ERQ_ERQ12_SHIFT)
#define DMA_BRD_ERQ_ERQ12(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ12_SHIFT, DMA_ERQ_ERQ12_WIDTH))

/*! @brief Set the ERQ12 field to a new value. */
#define DMA_WR_ERQ_ERQ12(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ12_MASK, DMA_ERQ_ERQ12(value)))
#define DMA_BWR_ERQ_ERQ12(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ12_SHIFT), DMA_ERQ_ERQ12_SHIFT, DMA_ERQ_ERQ12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ13[13] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ13 field. */
#define DMA_RD_ERQ_ERQ13(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ13_MASK) >> DMA_ERQ_ERQ13_SHIFT)
#define DMA_BRD_ERQ_ERQ13(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ13_SHIFT, DMA_ERQ_ERQ13_WIDTH))

/*! @brief Set the ERQ13 field to a new value. */
#define DMA_WR_ERQ_ERQ13(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ13_MASK, DMA_ERQ_ERQ13(value)))
#define DMA_BWR_ERQ_ERQ13(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ13_SHIFT), DMA_ERQ_ERQ13_SHIFT, DMA_ERQ_ERQ13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ14[14] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ14 field. */
#define DMA_RD_ERQ_ERQ14(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ14_MASK) >> DMA_ERQ_ERQ14_SHIFT)
#define DMA_BRD_ERQ_ERQ14(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ14_SHIFT, DMA_ERQ_ERQ14_WIDTH))

/*! @brief Set the ERQ14 field to a new value. */
#define DMA_WR_ERQ_ERQ14(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ14_MASK, DMA_ERQ_ERQ14(value)))
#define DMA_BWR_ERQ_ERQ14(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ14_SHIFT), DMA_ERQ_ERQ14_SHIFT, DMA_ERQ_ERQ14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ15[15] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ15 field. */
#define DMA_RD_ERQ_ERQ15(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ15_MASK) >> DMA_ERQ_ERQ15_SHIFT)
#define DMA_BRD_ERQ_ERQ15(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ15_SHIFT, DMA_ERQ_ERQ15_WIDTH))

/*! @brief Set the ERQ15 field to a new value. */
#define DMA_WR_ERQ_ERQ15(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ15_MASK, DMA_ERQ_ERQ15(value)))
#define DMA_BWR_ERQ_ERQ15(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ15_SHIFT), DMA_ERQ_ERQ15_SHIFT, DMA_ERQ_ERQ15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ16[16] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ16 field. */
#define DMA_RD_ERQ_ERQ16(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ16_MASK) >> DMA_ERQ_ERQ16_SHIFT)
#define DMA_BRD_ERQ_ERQ16(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ16_SHIFT, DMA_ERQ_ERQ16_WIDTH))

/*! @brief Set the ERQ16 field to a new value. */
#define DMA_WR_ERQ_ERQ16(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ16_MASK, DMA_ERQ_ERQ16(value)))
#define DMA_BWR_ERQ_ERQ16(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ16_SHIFT), DMA_ERQ_ERQ16_SHIFT, DMA_ERQ_ERQ16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ17[17] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ17 field. */
#define DMA_RD_ERQ_ERQ17(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ17_MASK) >> DMA_ERQ_ERQ17_SHIFT)
#define DMA_BRD_ERQ_ERQ17(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ17_SHIFT, DMA_ERQ_ERQ17_WIDTH))

/*! @brief Set the ERQ17 field to a new value. */
#define DMA_WR_ERQ_ERQ17(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ17_MASK, DMA_ERQ_ERQ17(value)))
#define DMA_BWR_ERQ_ERQ17(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ17_SHIFT), DMA_ERQ_ERQ17_SHIFT, DMA_ERQ_ERQ17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ18[18] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ18 field. */
#define DMA_RD_ERQ_ERQ18(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ18_MASK) >> DMA_ERQ_ERQ18_SHIFT)
#define DMA_BRD_ERQ_ERQ18(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ18_SHIFT, DMA_ERQ_ERQ18_WIDTH))

/*! @brief Set the ERQ18 field to a new value. */
#define DMA_WR_ERQ_ERQ18(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ18_MASK, DMA_ERQ_ERQ18(value)))
#define DMA_BWR_ERQ_ERQ18(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ18_SHIFT), DMA_ERQ_ERQ18_SHIFT, DMA_ERQ_ERQ18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ19[19] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ19 field. */
#define DMA_RD_ERQ_ERQ19(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ19_MASK) >> DMA_ERQ_ERQ19_SHIFT)
#define DMA_BRD_ERQ_ERQ19(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ19_SHIFT, DMA_ERQ_ERQ19_WIDTH))

/*! @brief Set the ERQ19 field to a new value. */
#define DMA_WR_ERQ_ERQ19(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ19_MASK, DMA_ERQ_ERQ19(value)))
#define DMA_BWR_ERQ_ERQ19(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ19_SHIFT), DMA_ERQ_ERQ19_SHIFT, DMA_ERQ_ERQ19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ20[20] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ20 field. */
#define DMA_RD_ERQ_ERQ20(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ20_MASK) >> DMA_ERQ_ERQ20_SHIFT)
#define DMA_BRD_ERQ_ERQ20(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ20_SHIFT, DMA_ERQ_ERQ20_WIDTH))

/*! @brief Set the ERQ20 field to a new value. */
#define DMA_WR_ERQ_ERQ20(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ20_MASK, DMA_ERQ_ERQ20(value)))
#define DMA_BWR_ERQ_ERQ20(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ20_SHIFT), DMA_ERQ_ERQ20_SHIFT, DMA_ERQ_ERQ20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ21[21] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ21 field. */
#define DMA_RD_ERQ_ERQ21(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ21_MASK) >> DMA_ERQ_ERQ21_SHIFT)
#define DMA_BRD_ERQ_ERQ21(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ21_SHIFT, DMA_ERQ_ERQ21_WIDTH))

/*! @brief Set the ERQ21 field to a new value. */
#define DMA_WR_ERQ_ERQ21(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ21_MASK, DMA_ERQ_ERQ21(value)))
#define DMA_BWR_ERQ_ERQ21(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ21_SHIFT), DMA_ERQ_ERQ21_SHIFT, DMA_ERQ_ERQ21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ22[22] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ22 field. */
#define DMA_RD_ERQ_ERQ22(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ22_MASK) >> DMA_ERQ_ERQ22_SHIFT)
#define DMA_BRD_ERQ_ERQ22(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ22_SHIFT, DMA_ERQ_ERQ22_WIDTH))

/*! @brief Set the ERQ22 field to a new value. */
#define DMA_WR_ERQ_ERQ22(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ22_MASK, DMA_ERQ_ERQ22(value)))
#define DMA_BWR_ERQ_ERQ22(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ22_SHIFT), DMA_ERQ_ERQ22_SHIFT, DMA_ERQ_ERQ22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ23[23] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ23 field. */
#define DMA_RD_ERQ_ERQ23(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ23_MASK) >> DMA_ERQ_ERQ23_SHIFT)
#define DMA_BRD_ERQ_ERQ23(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ23_SHIFT, DMA_ERQ_ERQ23_WIDTH))

/*! @brief Set the ERQ23 field to a new value. */
#define DMA_WR_ERQ_ERQ23(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ23_MASK, DMA_ERQ_ERQ23(value)))
#define DMA_BWR_ERQ_ERQ23(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ23_SHIFT), DMA_ERQ_ERQ23_SHIFT, DMA_ERQ_ERQ23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ24[24] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ24 field. */
#define DMA_RD_ERQ_ERQ24(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ24_MASK) >> DMA_ERQ_ERQ24_SHIFT)
#define DMA_BRD_ERQ_ERQ24(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ24_SHIFT, DMA_ERQ_ERQ24_WIDTH))

/*! @brief Set the ERQ24 field to a new value. */
#define DMA_WR_ERQ_ERQ24(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ24_MASK, DMA_ERQ_ERQ24(value)))
#define DMA_BWR_ERQ_ERQ24(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ24_SHIFT), DMA_ERQ_ERQ24_SHIFT, DMA_ERQ_ERQ24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ25[25] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ25 field. */
#define DMA_RD_ERQ_ERQ25(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ25_MASK) >> DMA_ERQ_ERQ25_SHIFT)
#define DMA_BRD_ERQ_ERQ25(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ25_SHIFT, DMA_ERQ_ERQ25_WIDTH))

/*! @brief Set the ERQ25 field to a new value. */
#define DMA_WR_ERQ_ERQ25(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ25_MASK, DMA_ERQ_ERQ25(value)))
#define DMA_BWR_ERQ_ERQ25(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ25_SHIFT), DMA_ERQ_ERQ25_SHIFT, DMA_ERQ_ERQ25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ26[26] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ26 field. */
#define DMA_RD_ERQ_ERQ26(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ26_MASK) >> DMA_ERQ_ERQ26_SHIFT)
#define DMA_BRD_ERQ_ERQ26(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ26_SHIFT, DMA_ERQ_ERQ26_WIDTH))

/*! @brief Set the ERQ26 field to a new value. */
#define DMA_WR_ERQ_ERQ26(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ26_MASK, DMA_ERQ_ERQ26(value)))
#define DMA_BWR_ERQ_ERQ26(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ26_SHIFT), DMA_ERQ_ERQ26_SHIFT, DMA_ERQ_ERQ26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ27[27] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ27 field. */
#define DMA_RD_ERQ_ERQ27(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ27_MASK) >> DMA_ERQ_ERQ27_SHIFT)
#define DMA_BRD_ERQ_ERQ27(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ27_SHIFT, DMA_ERQ_ERQ27_WIDTH))

/*! @brief Set the ERQ27 field to a new value. */
#define DMA_WR_ERQ_ERQ27(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ27_MASK, DMA_ERQ_ERQ27(value)))
#define DMA_BWR_ERQ_ERQ27(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ27_SHIFT), DMA_ERQ_ERQ27_SHIFT, DMA_ERQ_ERQ27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ28[28] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ28 field. */
#define DMA_RD_ERQ_ERQ28(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ28_MASK) >> DMA_ERQ_ERQ28_SHIFT)
#define DMA_BRD_ERQ_ERQ28(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ28_SHIFT, DMA_ERQ_ERQ28_WIDTH))

/*! @brief Set the ERQ28 field to a new value. */
#define DMA_WR_ERQ_ERQ28(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ28_MASK, DMA_ERQ_ERQ28(value)))
#define DMA_BWR_ERQ_ERQ28(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ28_SHIFT), DMA_ERQ_ERQ28_SHIFT, DMA_ERQ_ERQ28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ29[29] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ29 field. */
#define DMA_RD_ERQ_ERQ29(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ29_MASK) >> DMA_ERQ_ERQ29_SHIFT)
#define DMA_BRD_ERQ_ERQ29(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ29_SHIFT, DMA_ERQ_ERQ29_WIDTH))

/*! @brief Set the ERQ29 field to a new value. */
#define DMA_WR_ERQ_ERQ29(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ29_MASK, DMA_ERQ_ERQ29(value)))
#define DMA_BWR_ERQ_ERQ29(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ29_SHIFT), DMA_ERQ_ERQ29_SHIFT, DMA_ERQ_ERQ29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ30[30] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ30 field. */
#define DMA_RD_ERQ_ERQ30(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ30_MASK) >> DMA_ERQ_ERQ30_SHIFT)
#define DMA_BRD_ERQ_ERQ30(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ30_SHIFT, DMA_ERQ_ERQ30_WIDTH))

/*! @brief Set the ERQ30 field to a new value. */
#define DMA_WR_ERQ_ERQ30(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ30_MASK, DMA_ERQ_ERQ30(value)))
#define DMA_BWR_ERQ_ERQ30(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ30_SHIFT), DMA_ERQ_ERQ30_SHIFT, DMA_ERQ_ERQ30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ31[31] (RW)
 *
 * Values:
 * - 0b0 - The DMA request signal for the corresponding channel is disabled
 * - 0b1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ31 field. */
#define DMA_RD_ERQ_ERQ31(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ31_MASK) >> DMA_ERQ_ERQ31_SHIFT)
#define DMA_BRD_ERQ_ERQ31(base) (BME_UBFX32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ31_SHIFT, DMA_ERQ_ERQ31_WIDTH))

/*! @brief Set the ERQ31 field to a new value. */
#define DMA_WR_ERQ_ERQ31(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ31_MASK, DMA_ERQ_ERQ31(value)))
#define DMA_BWR_ERQ_ERQ31(base, value) (BME_BFI32(&DMA_ERQ_REG(base), ((uint32_t)(value) << DMA_ERQ_ERQ31_SHIFT), DMA_ERQ_ERQ31_SHIFT, DMA_ERQ_ERQ31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 32 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. These registers are provided so that the
 * error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an
 * error interrupt request for a given channel is asserted to the interrupt
 * controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (BME_OR32(&DMA_EEI_REG(base), (uint32_t)(value)))
#define DMA_CLR_EEI(base, value) (BME_AND32(&DMA_EEI_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EEI(base, value) (BME_XOR32(&DMA_EEI_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI0_SHIFT), DMA_EEI_EEI0_SHIFT, DMA_EEI_EEI0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI1_SHIFT), DMA_EEI_EEI1_SHIFT, DMA_EEI_EEI1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI2_SHIFT), DMA_EEI_EEI2_SHIFT, DMA_EEI_EEI2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI3_SHIFT), DMA_EEI_EEI3_SHIFT, DMA_EEI_EEI3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI4 field. */
#define DMA_RD_EEI_EEI4(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI4_MASK) >> DMA_EEI_EEI4_SHIFT)
#define DMA_BRD_EEI_EEI4(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT, DMA_EEI_EEI4_WIDTH))

/*! @brief Set the EEI4 field to a new value. */
#define DMA_WR_EEI_EEI4(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI4_MASK, DMA_EEI_EEI4(value)))
#define DMA_BWR_EEI_EEI4(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI4_SHIFT), DMA_EEI_EEI4_SHIFT, DMA_EEI_EEI4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI5 field. */
#define DMA_RD_EEI_EEI5(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI5_MASK) >> DMA_EEI_EEI5_SHIFT)
#define DMA_BRD_EEI_EEI5(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT, DMA_EEI_EEI5_WIDTH))

/*! @brief Set the EEI5 field to a new value. */
#define DMA_WR_EEI_EEI5(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI5_MASK, DMA_EEI_EEI5(value)))
#define DMA_BWR_EEI_EEI5(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI5_SHIFT), DMA_EEI_EEI5_SHIFT, DMA_EEI_EEI5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI6 field. */
#define DMA_RD_EEI_EEI6(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI6_MASK) >> DMA_EEI_EEI6_SHIFT)
#define DMA_BRD_EEI_EEI6(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT, DMA_EEI_EEI6_WIDTH))

/*! @brief Set the EEI6 field to a new value. */
#define DMA_WR_EEI_EEI6(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI6_MASK, DMA_EEI_EEI6(value)))
#define DMA_BWR_EEI_EEI6(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI6_SHIFT), DMA_EEI_EEI6_SHIFT, DMA_EEI_EEI6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI7 field. */
#define DMA_RD_EEI_EEI7(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI7_MASK) >> DMA_EEI_EEI7_SHIFT)
#define DMA_BRD_EEI_EEI7(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT, DMA_EEI_EEI7_WIDTH))

/*! @brief Set the EEI7 field to a new value. */
#define DMA_WR_EEI_EEI7(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI7_MASK, DMA_EEI_EEI7(value)))
#define DMA_BWR_EEI_EEI7(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI7_SHIFT), DMA_EEI_EEI7_SHIFT, DMA_EEI_EEI7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI8[8] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI8 field. */
#define DMA_RD_EEI_EEI8(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI8_MASK) >> DMA_EEI_EEI8_SHIFT)
#define DMA_BRD_EEI_EEI8(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI8_SHIFT, DMA_EEI_EEI8_WIDTH))

/*! @brief Set the EEI8 field to a new value. */
#define DMA_WR_EEI_EEI8(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI8_MASK, DMA_EEI_EEI8(value)))
#define DMA_BWR_EEI_EEI8(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI8_SHIFT), DMA_EEI_EEI8_SHIFT, DMA_EEI_EEI8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI9[9] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI9 field. */
#define DMA_RD_EEI_EEI9(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI9_MASK) >> DMA_EEI_EEI9_SHIFT)
#define DMA_BRD_EEI_EEI9(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI9_SHIFT, DMA_EEI_EEI9_WIDTH))

/*! @brief Set the EEI9 field to a new value. */
#define DMA_WR_EEI_EEI9(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI9_MASK, DMA_EEI_EEI9(value)))
#define DMA_BWR_EEI_EEI9(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI9_SHIFT), DMA_EEI_EEI9_SHIFT, DMA_EEI_EEI9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI10[10] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI10 field. */
#define DMA_RD_EEI_EEI10(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI10_MASK) >> DMA_EEI_EEI10_SHIFT)
#define DMA_BRD_EEI_EEI10(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI10_SHIFT, DMA_EEI_EEI10_WIDTH))

/*! @brief Set the EEI10 field to a new value. */
#define DMA_WR_EEI_EEI10(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI10_MASK, DMA_EEI_EEI10(value)))
#define DMA_BWR_EEI_EEI10(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI10_SHIFT), DMA_EEI_EEI10_SHIFT, DMA_EEI_EEI10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI11[11] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI11 field. */
#define DMA_RD_EEI_EEI11(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI11_MASK) >> DMA_EEI_EEI11_SHIFT)
#define DMA_BRD_EEI_EEI11(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI11_SHIFT, DMA_EEI_EEI11_WIDTH))

/*! @brief Set the EEI11 field to a new value. */
#define DMA_WR_EEI_EEI11(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI11_MASK, DMA_EEI_EEI11(value)))
#define DMA_BWR_EEI_EEI11(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI11_SHIFT), DMA_EEI_EEI11_SHIFT, DMA_EEI_EEI11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI12[12] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI12 field. */
#define DMA_RD_EEI_EEI12(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI12_MASK) >> DMA_EEI_EEI12_SHIFT)
#define DMA_BRD_EEI_EEI12(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI12_SHIFT, DMA_EEI_EEI12_WIDTH))

/*! @brief Set the EEI12 field to a new value. */
#define DMA_WR_EEI_EEI12(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI12_MASK, DMA_EEI_EEI12(value)))
#define DMA_BWR_EEI_EEI12(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI12_SHIFT), DMA_EEI_EEI12_SHIFT, DMA_EEI_EEI12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI13[13] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI13 field. */
#define DMA_RD_EEI_EEI13(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI13_MASK) >> DMA_EEI_EEI13_SHIFT)
#define DMA_BRD_EEI_EEI13(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI13_SHIFT, DMA_EEI_EEI13_WIDTH))

/*! @brief Set the EEI13 field to a new value. */
#define DMA_WR_EEI_EEI13(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI13_MASK, DMA_EEI_EEI13(value)))
#define DMA_BWR_EEI_EEI13(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI13_SHIFT), DMA_EEI_EEI13_SHIFT, DMA_EEI_EEI13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI14[14] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI14 field. */
#define DMA_RD_EEI_EEI14(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI14_MASK) >> DMA_EEI_EEI14_SHIFT)
#define DMA_BRD_EEI_EEI14(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI14_SHIFT, DMA_EEI_EEI14_WIDTH))

/*! @brief Set the EEI14 field to a new value. */
#define DMA_WR_EEI_EEI14(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI14_MASK, DMA_EEI_EEI14(value)))
#define DMA_BWR_EEI_EEI14(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI14_SHIFT), DMA_EEI_EEI14_SHIFT, DMA_EEI_EEI14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI15[15] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI15 field. */
#define DMA_RD_EEI_EEI15(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI15_MASK) >> DMA_EEI_EEI15_SHIFT)
#define DMA_BRD_EEI_EEI15(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI15_SHIFT, DMA_EEI_EEI15_WIDTH))

/*! @brief Set the EEI15 field to a new value. */
#define DMA_WR_EEI_EEI15(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI15_MASK, DMA_EEI_EEI15(value)))
#define DMA_BWR_EEI_EEI15(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI15_SHIFT), DMA_EEI_EEI15_SHIFT, DMA_EEI_EEI15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI16[16] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI16 field. */
#define DMA_RD_EEI_EEI16(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI16_MASK) >> DMA_EEI_EEI16_SHIFT)
#define DMA_BRD_EEI_EEI16(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI16_SHIFT, DMA_EEI_EEI16_WIDTH))

/*! @brief Set the EEI16 field to a new value. */
#define DMA_WR_EEI_EEI16(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI16_MASK, DMA_EEI_EEI16(value)))
#define DMA_BWR_EEI_EEI16(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI16_SHIFT), DMA_EEI_EEI16_SHIFT, DMA_EEI_EEI16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI17[17] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI17 field. */
#define DMA_RD_EEI_EEI17(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI17_MASK) >> DMA_EEI_EEI17_SHIFT)
#define DMA_BRD_EEI_EEI17(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI17_SHIFT, DMA_EEI_EEI17_WIDTH))

/*! @brief Set the EEI17 field to a new value. */
#define DMA_WR_EEI_EEI17(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI17_MASK, DMA_EEI_EEI17(value)))
#define DMA_BWR_EEI_EEI17(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI17_SHIFT), DMA_EEI_EEI17_SHIFT, DMA_EEI_EEI17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI18[18] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI18 field. */
#define DMA_RD_EEI_EEI18(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI18_MASK) >> DMA_EEI_EEI18_SHIFT)
#define DMA_BRD_EEI_EEI18(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI18_SHIFT, DMA_EEI_EEI18_WIDTH))

/*! @brief Set the EEI18 field to a new value. */
#define DMA_WR_EEI_EEI18(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI18_MASK, DMA_EEI_EEI18(value)))
#define DMA_BWR_EEI_EEI18(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI18_SHIFT), DMA_EEI_EEI18_SHIFT, DMA_EEI_EEI18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI19[19] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI19 field. */
#define DMA_RD_EEI_EEI19(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI19_MASK) >> DMA_EEI_EEI19_SHIFT)
#define DMA_BRD_EEI_EEI19(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI19_SHIFT, DMA_EEI_EEI19_WIDTH))

/*! @brief Set the EEI19 field to a new value. */
#define DMA_WR_EEI_EEI19(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI19_MASK, DMA_EEI_EEI19(value)))
#define DMA_BWR_EEI_EEI19(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI19_SHIFT), DMA_EEI_EEI19_SHIFT, DMA_EEI_EEI19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI20[20] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI20 field. */
#define DMA_RD_EEI_EEI20(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI20_MASK) >> DMA_EEI_EEI20_SHIFT)
#define DMA_BRD_EEI_EEI20(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI20_SHIFT, DMA_EEI_EEI20_WIDTH))

/*! @brief Set the EEI20 field to a new value. */
#define DMA_WR_EEI_EEI20(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI20_MASK, DMA_EEI_EEI20(value)))
#define DMA_BWR_EEI_EEI20(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI20_SHIFT), DMA_EEI_EEI20_SHIFT, DMA_EEI_EEI20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI21[21] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI21 field. */
#define DMA_RD_EEI_EEI21(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI21_MASK) >> DMA_EEI_EEI21_SHIFT)
#define DMA_BRD_EEI_EEI21(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI21_SHIFT, DMA_EEI_EEI21_WIDTH))

/*! @brief Set the EEI21 field to a new value. */
#define DMA_WR_EEI_EEI21(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI21_MASK, DMA_EEI_EEI21(value)))
#define DMA_BWR_EEI_EEI21(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI21_SHIFT), DMA_EEI_EEI21_SHIFT, DMA_EEI_EEI21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI22[22] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI22 field. */
#define DMA_RD_EEI_EEI22(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI22_MASK) >> DMA_EEI_EEI22_SHIFT)
#define DMA_BRD_EEI_EEI22(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI22_SHIFT, DMA_EEI_EEI22_WIDTH))

/*! @brief Set the EEI22 field to a new value. */
#define DMA_WR_EEI_EEI22(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI22_MASK, DMA_EEI_EEI22(value)))
#define DMA_BWR_EEI_EEI22(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI22_SHIFT), DMA_EEI_EEI22_SHIFT, DMA_EEI_EEI22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI23[23] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI23 field. */
#define DMA_RD_EEI_EEI23(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI23_MASK) >> DMA_EEI_EEI23_SHIFT)
#define DMA_BRD_EEI_EEI23(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI23_SHIFT, DMA_EEI_EEI23_WIDTH))

/*! @brief Set the EEI23 field to a new value. */
#define DMA_WR_EEI_EEI23(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI23_MASK, DMA_EEI_EEI23(value)))
#define DMA_BWR_EEI_EEI23(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI23_SHIFT), DMA_EEI_EEI23_SHIFT, DMA_EEI_EEI23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI24[24] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI24 field. */
#define DMA_RD_EEI_EEI24(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI24_MASK) >> DMA_EEI_EEI24_SHIFT)
#define DMA_BRD_EEI_EEI24(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI24_SHIFT, DMA_EEI_EEI24_WIDTH))

/*! @brief Set the EEI24 field to a new value. */
#define DMA_WR_EEI_EEI24(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI24_MASK, DMA_EEI_EEI24(value)))
#define DMA_BWR_EEI_EEI24(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI24_SHIFT), DMA_EEI_EEI24_SHIFT, DMA_EEI_EEI24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI25[25] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI25 field. */
#define DMA_RD_EEI_EEI25(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI25_MASK) >> DMA_EEI_EEI25_SHIFT)
#define DMA_BRD_EEI_EEI25(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI25_SHIFT, DMA_EEI_EEI25_WIDTH))

/*! @brief Set the EEI25 field to a new value. */
#define DMA_WR_EEI_EEI25(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI25_MASK, DMA_EEI_EEI25(value)))
#define DMA_BWR_EEI_EEI25(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI25_SHIFT), DMA_EEI_EEI25_SHIFT, DMA_EEI_EEI25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI26[26] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI26 field. */
#define DMA_RD_EEI_EEI26(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI26_MASK) >> DMA_EEI_EEI26_SHIFT)
#define DMA_BRD_EEI_EEI26(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI26_SHIFT, DMA_EEI_EEI26_WIDTH))

/*! @brief Set the EEI26 field to a new value. */
#define DMA_WR_EEI_EEI26(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI26_MASK, DMA_EEI_EEI26(value)))
#define DMA_BWR_EEI_EEI26(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI26_SHIFT), DMA_EEI_EEI26_SHIFT, DMA_EEI_EEI26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI27[27] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI27 field. */
#define DMA_RD_EEI_EEI27(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI27_MASK) >> DMA_EEI_EEI27_SHIFT)
#define DMA_BRD_EEI_EEI27(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI27_SHIFT, DMA_EEI_EEI27_WIDTH))

/*! @brief Set the EEI27 field to a new value. */
#define DMA_WR_EEI_EEI27(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI27_MASK, DMA_EEI_EEI27(value)))
#define DMA_BWR_EEI_EEI27(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI27_SHIFT), DMA_EEI_EEI27_SHIFT, DMA_EEI_EEI27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI28[28] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI28 field. */
#define DMA_RD_EEI_EEI28(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI28_MASK) >> DMA_EEI_EEI28_SHIFT)
#define DMA_BRD_EEI_EEI28(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI28_SHIFT, DMA_EEI_EEI28_WIDTH))

/*! @brief Set the EEI28 field to a new value. */
#define DMA_WR_EEI_EEI28(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI28_MASK, DMA_EEI_EEI28(value)))
#define DMA_BWR_EEI_EEI28(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI28_SHIFT), DMA_EEI_EEI28_SHIFT, DMA_EEI_EEI28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI29[29] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI29 field. */
#define DMA_RD_EEI_EEI29(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI29_MASK) >> DMA_EEI_EEI29_SHIFT)
#define DMA_BRD_EEI_EEI29(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI29_SHIFT, DMA_EEI_EEI29_WIDTH))

/*! @brief Set the EEI29 field to a new value. */
#define DMA_WR_EEI_EEI29(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI29_MASK, DMA_EEI_EEI29(value)))
#define DMA_BWR_EEI_EEI29(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI29_SHIFT), DMA_EEI_EEI29_SHIFT, DMA_EEI_EEI29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI30[30] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI30 field. */
#define DMA_RD_EEI_EEI30(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI30_MASK) >> DMA_EEI_EEI30_SHIFT)
#define DMA_BRD_EEI_EEI30(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI30_SHIFT, DMA_EEI_EEI30_WIDTH))

/*! @brief Set the EEI30 field to a new value. */
#define DMA_WR_EEI_EEI30(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI30_MASK, DMA_EEI_EEI30(value)))
#define DMA_BWR_EEI_EEI30(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI30_SHIFT), DMA_EEI_EEI30_SHIFT, DMA_EEI_EEI30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI31[31] (RW)
 *
 * Values:
 * - 0b0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 0b1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI31 field. */
#define DMA_RD_EEI_EEI31(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI31_MASK) >> DMA_EEI_EEI31_SHIFT)
#define DMA_BRD_EEI_EEI31(base) (BME_UBFX32(&DMA_EEI_REG(base), DMA_EEI_EEI31_SHIFT, DMA_EEI_EEI31_WIDTH))

/*! @brief Set the EEI31 field to a new value. */
#define DMA_WR_EEI_EEI31(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI31_MASK, DMA_EEI_EEI31(value)))
#define DMA_BWR_EEI_EEI31(base, value) (BME_BFI32(&DMA_EEI_REG(base), ((uint32_t)(value) << DMA_EEI_EEI31_SHIFT), DMA_EEI_EEI31_SHIFT, DMA_EEI_EEI31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[4:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CEEI_SHIFT), DMA_CEEI_CEEI_SHIFT, DMA_CEEI_CEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the EEI bit specified in the CEEI field
 * - 0b1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_CAEE_SHIFT), DMA_CEEI_CAEE_SHIFT, DMA_CEEI_CAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BME_BFI8(&DMA_CEEI_REG(base), ((uint8_t)(value) << DMA_CEEI_NOP_SHIFT), DMA_CEEI_NOP_SHIFT, DMA_CEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[4:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SEEI_SHIFT), DMA_SEEI_SEEI_SHIFT, DMA_SEEI_SEEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the EEI bit specified in the SEEI field.
 * - 0b1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_SAEE_SHIFT), DMA_SEEI_SAEE_SHIFT, DMA_SEEI_SAEE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BME_BFI8(&DMA_SEEI_REG(base), ((uint8_t)(value) << DMA_SEEI_NOP_SHIFT), DMA_SEEI_NOP_SHIFT, DMA_SEEI_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[4:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CERQ_SHIFT), DMA_CERQ_CERQ_SHIFT, DMA_CERQ_CERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERQ bit specified in the CERQ field
 * - 0b1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_CAER_SHIFT), DMA_CERQ_CAER_SHIFT, DMA_CERQ_CAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BME_BFI8(&DMA_CERQ_REG(base), ((uint8_t)(value) << DMA_CERQ_NOP_SHIFT), DMA_CERQ_NOP_SHIFT, DMA_CERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[4:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SERQ_SHIFT), DMA_SERQ_SERQ_SHIFT, DMA_SERQ_SERQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the ERQ bit specified in the SERQ field
 * - 0b1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_SAER_SHIFT), DMA_SERQ_SAER_SHIFT, DMA_SERQ_SAER_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BME_BFI8(&DMA_SERQ_REG(base), ((uint8_t)(value) << DMA_SERQ_NOP_SHIFT), DMA_SERQ_NOP_SHIFT, DMA_SERQ_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[4:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CDNE_SHIFT), DMA_CDNE_CDNE_SHIFT, DMA_CDNE_CDNE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 0b1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_CADN_SHIFT), DMA_CDNE_CADN_SHIFT, DMA_CDNE_CADN_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BME_BFI8(&DMA_CDNE_REG(base), ((uint8_t)(value) << DMA_CDNE_NOP_SHIFT), DMA_CDNE_NOP_SHIFT, DMA_CDNE_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[4:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SSRT_SHIFT), DMA_SSRT_SSRT_SHIFT, DMA_SSRT_SSRT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0b0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 0b1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_SAST_SHIFT), DMA_SSRT_SAST_SHIFT, DMA_SSRT_SAST_WIDTH))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BME_BFI8(&DMA_SSRT_REG(base), ((uint8_t)(value) << DMA_SSRT_NOP_SHIFT), DMA_SSRT_NOP_SHIFT, DMA_SSRT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[4:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CERR_SHIFT), DMA_CERR_CERR_SHIFT, DMA_CERR_CERR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the ERR bit specified in the CERR field
 * - 0b1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_CAEI_SHIFT), DMA_CERR_CAEI_SHIFT, DMA_CERR_CAEI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BME_BFI8(&DMA_CERR_REG(base), ((uint8_t)(value) << DMA_CERR_NOP_SHIFT), DMA_CERR_NOP_SHIFT, DMA_CERR_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[4:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CINT_SHIFT), DMA_CINT_CINT_SHIFT, DMA_CINT_CINT_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0b0 - Clear only the INT bit specified in the CINT field
 * - 0b1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_CAIR_SHIFT), DMA_CINT_CAIR_SHIFT, DMA_CINT_CAIR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BME_BFI8(&DMA_CINT_REG(base), ((uint8_t)(value) << DMA_CINT_NOP_SHIFT), DMA_CINT_NOP_SHIFT, DMA_CINT_NOP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 32 channels signaling the
 * presence of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller. During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to clear the
 * appropriate bit, negating the interrupt request. Typically, a write to the CINT
 * register in the interrupt service routine is used for this purpose. The state
 * of any given channel's interrupt request is directly affected by writes to
 * this register; it is also affected by writes to the CINT register. On writes to
 * INT, a 1 in any bit position clears the corresponding channel's interrupt
 * request. A zero in any bit position has no affect on the corresponding channel's
 * current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to perform a
 * read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (BME_OR32(&DMA_INT_REG(base), (uint32_t)(value)))
#define DMA_CLR_INT(base, value) (BME_AND32(&DMA_INT_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_INT(base, value) (BME_XOR32(&DMA_INT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT0_SHIFT), DMA_INT_INT0_SHIFT, DMA_INT_INT0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT1_SHIFT), DMA_INT_INT1_SHIFT, DMA_INT_INT1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT2_SHIFT), DMA_INT_INT2_SHIFT, DMA_INT_INT2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT3_SHIFT), DMA_INT_INT3_SHIFT, DMA_INT_INT3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT4 field. */
#define DMA_RD_INT_INT4(base) ((DMA_INT_REG(base) & DMA_INT_INT4_MASK) >> DMA_INT_INT4_SHIFT)
#define DMA_BRD_INT_INT4(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT, DMA_INT_INT4_WIDTH))

/*! @brief Set the INT4 field to a new value. */
#define DMA_WR_INT_INT4(base, value) (DMA_RMW_INT(base, (DMA_INT_INT4_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT4(value)))
#define DMA_BWR_INT_INT4(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT4_SHIFT), DMA_INT_INT4_SHIFT, DMA_INT_INT4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT5 field. */
#define DMA_RD_INT_INT5(base) ((DMA_INT_REG(base) & DMA_INT_INT5_MASK) >> DMA_INT_INT5_SHIFT)
#define DMA_BRD_INT_INT5(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT, DMA_INT_INT5_WIDTH))

/*! @brief Set the INT5 field to a new value. */
#define DMA_WR_INT_INT5(base, value) (DMA_RMW_INT(base, (DMA_INT_INT5_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT5(value)))
#define DMA_BWR_INT_INT5(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT5_SHIFT), DMA_INT_INT5_SHIFT, DMA_INT_INT5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT6 field. */
#define DMA_RD_INT_INT6(base) ((DMA_INT_REG(base) & DMA_INT_INT6_MASK) >> DMA_INT_INT6_SHIFT)
#define DMA_BRD_INT_INT6(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT, DMA_INT_INT6_WIDTH))

/*! @brief Set the INT6 field to a new value. */
#define DMA_WR_INT_INT6(base, value) (DMA_RMW_INT(base, (DMA_INT_INT6_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT6(value)))
#define DMA_BWR_INT_INT6(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT6_SHIFT), DMA_INT_INT6_SHIFT, DMA_INT_INT6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT7 field. */
#define DMA_RD_INT_INT7(base) ((DMA_INT_REG(base) & DMA_INT_INT7_MASK) >> DMA_INT_INT7_SHIFT)
#define DMA_BRD_INT_INT7(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT, DMA_INT_INT7_WIDTH))

/*! @brief Set the INT7 field to a new value. */
#define DMA_WR_INT_INT7(base, value) (DMA_RMW_INT(base, (DMA_INT_INT7_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT7(value)))
#define DMA_BWR_INT_INT7(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT7_SHIFT), DMA_INT_INT7_SHIFT, DMA_INT_INT7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT8[8] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT8 field. */
#define DMA_RD_INT_INT8(base) ((DMA_INT_REG(base) & DMA_INT_INT8_MASK) >> DMA_INT_INT8_SHIFT)
#define DMA_BRD_INT_INT8(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT8_SHIFT, DMA_INT_INT8_WIDTH))

/*! @brief Set the INT8 field to a new value. */
#define DMA_WR_INT_INT8(base, value) (DMA_RMW_INT(base, (DMA_INT_INT8_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT8(value)))
#define DMA_BWR_INT_INT8(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT8_SHIFT), DMA_INT_INT8_SHIFT, DMA_INT_INT8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT9[9] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT9 field. */
#define DMA_RD_INT_INT9(base) ((DMA_INT_REG(base) & DMA_INT_INT9_MASK) >> DMA_INT_INT9_SHIFT)
#define DMA_BRD_INT_INT9(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT9_SHIFT, DMA_INT_INT9_WIDTH))

/*! @brief Set the INT9 field to a new value. */
#define DMA_WR_INT_INT9(base, value) (DMA_RMW_INT(base, (DMA_INT_INT9_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT9(value)))
#define DMA_BWR_INT_INT9(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT9_SHIFT), DMA_INT_INT9_SHIFT, DMA_INT_INT9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT10[10] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT10 field. */
#define DMA_RD_INT_INT10(base) ((DMA_INT_REG(base) & DMA_INT_INT10_MASK) >> DMA_INT_INT10_SHIFT)
#define DMA_BRD_INT_INT10(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT10_SHIFT, DMA_INT_INT10_WIDTH))

/*! @brief Set the INT10 field to a new value. */
#define DMA_WR_INT_INT10(base, value) (DMA_RMW_INT(base, (DMA_INT_INT10_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT10(value)))
#define DMA_BWR_INT_INT10(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT10_SHIFT), DMA_INT_INT10_SHIFT, DMA_INT_INT10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT11[11] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT11 field. */
#define DMA_RD_INT_INT11(base) ((DMA_INT_REG(base) & DMA_INT_INT11_MASK) >> DMA_INT_INT11_SHIFT)
#define DMA_BRD_INT_INT11(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT11_SHIFT, DMA_INT_INT11_WIDTH))

/*! @brief Set the INT11 field to a new value. */
#define DMA_WR_INT_INT11(base, value) (DMA_RMW_INT(base, (DMA_INT_INT11_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT11(value)))
#define DMA_BWR_INT_INT11(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT11_SHIFT), DMA_INT_INT11_SHIFT, DMA_INT_INT11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT12[12] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT12 field. */
#define DMA_RD_INT_INT12(base) ((DMA_INT_REG(base) & DMA_INT_INT12_MASK) >> DMA_INT_INT12_SHIFT)
#define DMA_BRD_INT_INT12(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT12_SHIFT, DMA_INT_INT12_WIDTH))

/*! @brief Set the INT12 field to a new value. */
#define DMA_WR_INT_INT12(base, value) (DMA_RMW_INT(base, (DMA_INT_INT12_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT12(value)))
#define DMA_BWR_INT_INT12(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT12_SHIFT), DMA_INT_INT12_SHIFT, DMA_INT_INT12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT13[13] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT13 field. */
#define DMA_RD_INT_INT13(base) ((DMA_INT_REG(base) & DMA_INT_INT13_MASK) >> DMA_INT_INT13_SHIFT)
#define DMA_BRD_INT_INT13(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT13_SHIFT, DMA_INT_INT13_WIDTH))

/*! @brief Set the INT13 field to a new value. */
#define DMA_WR_INT_INT13(base, value) (DMA_RMW_INT(base, (DMA_INT_INT13_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT13(value)))
#define DMA_BWR_INT_INT13(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT13_SHIFT), DMA_INT_INT13_SHIFT, DMA_INT_INT13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT14[14] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT14 field. */
#define DMA_RD_INT_INT14(base) ((DMA_INT_REG(base) & DMA_INT_INT14_MASK) >> DMA_INT_INT14_SHIFT)
#define DMA_BRD_INT_INT14(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT14_SHIFT, DMA_INT_INT14_WIDTH))

/*! @brief Set the INT14 field to a new value. */
#define DMA_WR_INT_INT14(base, value) (DMA_RMW_INT(base, (DMA_INT_INT14_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT14(value)))
#define DMA_BWR_INT_INT14(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT14_SHIFT), DMA_INT_INT14_SHIFT, DMA_INT_INT14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT15[15] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT15 field. */
#define DMA_RD_INT_INT15(base) ((DMA_INT_REG(base) & DMA_INT_INT15_MASK) >> DMA_INT_INT15_SHIFT)
#define DMA_BRD_INT_INT15(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT15_SHIFT, DMA_INT_INT15_WIDTH))

/*! @brief Set the INT15 field to a new value. */
#define DMA_WR_INT_INT15(base, value) (DMA_RMW_INT(base, (DMA_INT_INT15_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT15(value)))
#define DMA_BWR_INT_INT15(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT15_SHIFT), DMA_INT_INT15_SHIFT, DMA_INT_INT15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT16[16] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT16 field. */
#define DMA_RD_INT_INT16(base) ((DMA_INT_REG(base) & DMA_INT_INT16_MASK) >> DMA_INT_INT16_SHIFT)
#define DMA_BRD_INT_INT16(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT16_SHIFT, DMA_INT_INT16_WIDTH))

/*! @brief Set the INT16 field to a new value. */
#define DMA_WR_INT_INT16(base, value) (DMA_RMW_INT(base, (DMA_INT_INT16_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT16(value)))
#define DMA_BWR_INT_INT16(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT16_SHIFT), DMA_INT_INT16_SHIFT, DMA_INT_INT16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT17[17] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT17 field. */
#define DMA_RD_INT_INT17(base) ((DMA_INT_REG(base) & DMA_INT_INT17_MASK) >> DMA_INT_INT17_SHIFT)
#define DMA_BRD_INT_INT17(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT17_SHIFT, DMA_INT_INT17_WIDTH))

/*! @brief Set the INT17 field to a new value. */
#define DMA_WR_INT_INT17(base, value) (DMA_RMW_INT(base, (DMA_INT_INT17_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT17(value)))
#define DMA_BWR_INT_INT17(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT17_SHIFT), DMA_INT_INT17_SHIFT, DMA_INT_INT17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT18[18] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT18 field. */
#define DMA_RD_INT_INT18(base) ((DMA_INT_REG(base) & DMA_INT_INT18_MASK) >> DMA_INT_INT18_SHIFT)
#define DMA_BRD_INT_INT18(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT18_SHIFT, DMA_INT_INT18_WIDTH))

/*! @brief Set the INT18 field to a new value. */
#define DMA_WR_INT_INT18(base, value) (DMA_RMW_INT(base, (DMA_INT_INT18_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT18(value)))
#define DMA_BWR_INT_INT18(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT18_SHIFT), DMA_INT_INT18_SHIFT, DMA_INT_INT18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT19[19] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT19 field. */
#define DMA_RD_INT_INT19(base) ((DMA_INT_REG(base) & DMA_INT_INT19_MASK) >> DMA_INT_INT19_SHIFT)
#define DMA_BRD_INT_INT19(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT19_SHIFT, DMA_INT_INT19_WIDTH))

/*! @brief Set the INT19 field to a new value. */
#define DMA_WR_INT_INT19(base, value) (DMA_RMW_INT(base, (DMA_INT_INT19_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT19(value)))
#define DMA_BWR_INT_INT19(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT19_SHIFT), DMA_INT_INT19_SHIFT, DMA_INT_INT19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT20[20] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT20 field. */
#define DMA_RD_INT_INT20(base) ((DMA_INT_REG(base) & DMA_INT_INT20_MASK) >> DMA_INT_INT20_SHIFT)
#define DMA_BRD_INT_INT20(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT20_SHIFT, DMA_INT_INT20_WIDTH))

/*! @brief Set the INT20 field to a new value. */
#define DMA_WR_INT_INT20(base, value) (DMA_RMW_INT(base, (DMA_INT_INT20_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT20(value)))
#define DMA_BWR_INT_INT20(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT20_SHIFT), DMA_INT_INT20_SHIFT, DMA_INT_INT20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT21[21] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT21 field. */
#define DMA_RD_INT_INT21(base) ((DMA_INT_REG(base) & DMA_INT_INT21_MASK) >> DMA_INT_INT21_SHIFT)
#define DMA_BRD_INT_INT21(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT21_SHIFT, DMA_INT_INT21_WIDTH))

/*! @brief Set the INT21 field to a new value. */
#define DMA_WR_INT_INT21(base, value) (DMA_RMW_INT(base, (DMA_INT_INT21_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT21(value)))
#define DMA_BWR_INT_INT21(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT21_SHIFT), DMA_INT_INT21_SHIFT, DMA_INT_INT21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT22[22] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT22 field. */
#define DMA_RD_INT_INT22(base) ((DMA_INT_REG(base) & DMA_INT_INT22_MASK) >> DMA_INT_INT22_SHIFT)
#define DMA_BRD_INT_INT22(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT22_SHIFT, DMA_INT_INT22_WIDTH))

/*! @brief Set the INT22 field to a new value. */
#define DMA_WR_INT_INT22(base, value) (DMA_RMW_INT(base, (DMA_INT_INT22_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT22(value)))
#define DMA_BWR_INT_INT22(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT22_SHIFT), DMA_INT_INT22_SHIFT, DMA_INT_INT22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT23[23] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT23 field. */
#define DMA_RD_INT_INT23(base) ((DMA_INT_REG(base) & DMA_INT_INT23_MASK) >> DMA_INT_INT23_SHIFT)
#define DMA_BRD_INT_INT23(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT23_SHIFT, DMA_INT_INT23_WIDTH))

/*! @brief Set the INT23 field to a new value. */
#define DMA_WR_INT_INT23(base, value) (DMA_RMW_INT(base, (DMA_INT_INT23_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT23(value)))
#define DMA_BWR_INT_INT23(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT23_SHIFT), DMA_INT_INT23_SHIFT, DMA_INT_INT23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT24[24] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT24 field. */
#define DMA_RD_INT_INT24(base) ((DMA_INT_REG(base) & DMA_INT_INT24_MASK) >> DMA_INT_INT24_SHIFT)
#define DMA_BRD_INT_INT24(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT24_SHIFT, DMA_INT_INT24_WIDTH))

/*! @brief Set the INT24 field to a new value. */
#define DMA_WR_INT_INT24(base, value) (DMA_RMW_INT(base, (DMA_INT_INT24_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT24(value)))
#define DMA_BWR_INT_INT24(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT24_SHIFT), DMA_INT_INT24_SHIFT, DMA_INT_INT24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT25[25] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT25 field. */
#define DMA_RD_INT_INT25(base) ((DMA_INT_REG(base) & DMA_INT_INT25_MASK) >> DMA_INT_INT25_SHIFT)
#define DMA_BRD_INT_INT25(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT25_SHIFT, DMA_INT_INT25_WIDTH))

/*! @brief Set the INT25 field to a new value. */
#define DMA_WR_INT_INT25(base, value) (DMA_RMW_INT(base, (DMA_INT_INT25_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT25(value)))
#define DMA_BWR_INT_INT25(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT25_SHIFT), DMA_INT_INT25_SHIFT, DMA_INT_INT25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT26[26] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT26 field. */
#define DMA_RD_INT_INT26(base) ((DMA_INT_REG(base) & DMA_INT_INT26_MASK) >> DMA_INT_INT26_SHIFT)
#define DMA_BRD_INT_INT26(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT26_SHIFT, DMA_INT_INT26_WIDTH))

/*! @brief Set the INT26 field to a new value. */
#define DMA_WR_INT_INT26(base, value) (DMA_RMW_INT(base, (DMA_INT_INT26_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT26(value)))
#define DMA_BWR_INT_INT26(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT26_SHIFT), DMA_INT_INT26_SHIFT, DMA_INT_INT26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT27[27] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT27 field. */
#define DMA_RD_INT_INT27(base) ((DMA_INT_REG(base) & DMA_INT_INT27_MASK) >> DMA_INT_INT27_SHIFT)
#define DMA_BRD_INT_INT27(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT27_SHIFT, DMA_INT_INT27_WIDTH))

/*! @brief Set the INT27 field to a new value. */
#define DMA_WR_INT_INT27(base, value) (DMA_RMW_INT(base, (DMA_INT_INT27_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT27(value)))
#define DMA_BWR_INT_INT27(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT27_SHIFT), DMA_INT_INT27_SHIFT, DMA_INT_INT27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT28[28] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT28 field. */
#define DMA_RD_INT_INT28(base) ((DMA_INT_REG(base) & DMA_INT_INT28_MASK) >> DMA_INT_INT28_SHIFT)
#define DMA_BRD_INT_INT28(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT28_SHIFT, DMA_INT_INT28_WIDTH))

/*! @brief Set the INT28 field to a new value. */
#define DMA_WR_INT_INT28(base, value) (DMA_RMW_INT(base, (DMA_INT_INT28_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT28(value)))
#define DMA_BWR_INT_INT28(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT28_SHIFT), DMA_INT_INT28_SHIFT, DMA_INT_INT28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT29[29] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT29 field. */
#define DMA_RD_INT_INT29(base) ((DMA_INT_REG(base) & DMA_INT_INT29_MASK) >> DMA_INT_INT29_SHIFT)
#define DMA_BRD_INT_INT29(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT29_SHIFT, DMA_INT_INT29_WIDTH))

/*! @brief Set the INT29 field to a new value. */
#define DMA_WR_INT_INT29(base, value) (DMA_RMW_INT(base, (DMA_INT_INT29_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT30_MASK | DMA_INT_INT31_MASK), DMA_INT_INT29(value)))
#define DMA_BWR_INT_INT29(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT29_SHIFT), DMA_INT_INT29_SHIFT, DMA_INT_INT29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT30[30] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT30 field. */
#define DMA_RD_INT_INT30(base) ((DMA_INT_REG(base) & DMA_INT_INT30_MASK) >> DMA_INT_INT30_SHIFT)
#define DMA_BRD_INT_INT30(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT30_SHIFT, DMA_INT_INT30_WIDTH))

/*! @brief Set the INT30 field to a new value. */
#define DMA_WR_INT_INT30(base, value) (DMA_RMW_INT(base, (DMA_INT_INT30_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT31_MASK), DMA_INT_INT30(value)))
#define DMA_BWR_INT_INT30(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT30_SHIFT), DMA_INT_INT30_SHIFT, DMA_INT_INT30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_INT, field INT31[31] (W1C)
 *
 * Values:
 * - 0b0 - The interrupt request for corresponding channel is cleared
 * - 0b1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT31 field. */
#define DMA_RD_INT_INT31(base) ((DMA_INT_REG(base) & DMA_INT_INT31_MASK) >> DMA_INT_INT31_SHIFT)
#define DMA_BRD_INT_INT31(base) (BME_UBFX32(&DMA_INT_REG(base), DMA_INT_INT31_SHIFT, DMA_INT_INT31_WIDTH))

/*! @brief Set the INT31 field to a new value. */
#define DMA_WR_INT_INT31(base, value) (DMA_RMW_INT(base, (DMA_INT_INT31_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK | DMA_INT_INT16_MASK | DMA_INT_INT17_MASK | DMA_INT_INT18_MASK | DMA_INT_INT19_MASK | DMA_INT_INT20_MASK | DMA_INT_INT21_MASK | DMA_INT_INT22_MASK | DMA_INT_INT23_MASK | DMA_INT_INT24_MASK | DMA_INT_INT25_MASK | DMA_INT_INT26_MASK | DMA_INT_INT27_MASK | DMA_INT_INT28_MASK | DMA_INT_INT29_MASK | DMA_INT_INT30_MASK), DMA_INT_INT31(value)))
#define DMA_BWR_INT_INT31(base, value) (BME_BFI32(&DMA_INT_REG(base), ((uint32_t)(value) << DMA_INT_INT31_SHIFT), DMA_INT_INT31_SHIFT, DMA_INT_INT31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 32 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, then logically summed across
 * groups of 16 and 32 channels to form several group error interrupt requests,
 * which are then routed to the interrupt controller. During the execution of the
 * interrupt-service routine associated with any DMA errors, it is software's
 * responsibility to clear the appropriate bit, negating the error-interrupt request.
 * Typically, a write to the CERR in the interrupt-service routine is used for
 * this purpose. The normal DMA channel completion indicators (setting the transfer
 * control descriptor DONE flag and the possible assertion of an interrupt
 * request) are not affected when an error is detected. The contents of this register
 * can also be polled because a non-zero value indicates the presence of a
 * channel error regardless of the state of the EEI. The state of any given channel's
 * error indicators is affected by writes to this register; it is also affected by
 * writes to the CERR. On writes to the ERR, a one in any bit position clears
 * the corresponding channel's error status. A zero in any bit position has no
 * affect on the corresponding channel's current error status. The CERR is provided
 * so the error indicator for a single channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (BME_OR32(&DMA_ERR_REG(base), (uint32_t)(value)))
#define DMA_CLR_ERR(base, value) (BME_AND32(&DMA_ERR_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_ERR(base, value) (BME_XOR32(&DMA_ERR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR0_SHIFT), DMA_ERR_ERR0_SHIFT, DMA_ERR_ERR0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR1_SHIFT), DMA_ERR_ERR1_SHIFT, DMA_ERR_ERR1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR2_SHIFT), DMA_ERR_ERR2_SHIFT, DMA_ERR_ERR2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR3_SHIFT), DMA_ERR_ERR3_SHIFT, DMA_ERR_ERR3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR4 field. */
#define DMA_RD_ERR_ERR4(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR4_MASK) >> DMA_ERR_ERR4_SHIFT)
#define DMA_BRD_ERR_ERR4(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT, DMA_ERR_ERR4_WIDTH))

/*! @brief Set the ERR4 field to a new value. */
#define DMA_WR_ERR_ERR4(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR4_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR4(value)))
#define DMA_BWR_ERR_ERR4(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR4_SHIFT), DMA_ERR_ERR4_SHIFT, DMA_ERR_ERR4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR5 field. */
#define DMA_RD_ERR_ERR5(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR5_MASK) >> DMA_ERR_ERR5_SHIFT)
#define DMA_BRD_ERR_ERR5(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT, DMA_ERR_ERR5_WIDTH))

/*! @brief Set the ERR5 field to a new value. */
#define DMA_WR_ERR_ERR5(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR5_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR5(value)))
#define DMA_BWR_ERR_ERR5(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR5_SHIFT), DMA_ERR_ERR5_SHIFT, DMA_ERR_ERR5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR6 field. */
#define DMA_RD_ERR_ERR6(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR6_MASK) >> DMA_ERR_ERR6_SHIFT)
#define DMA_BRD_ERR_ERR6(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT, DMA_ERR_ERR6_WIDTH))

/*! @brief Set the ERR6 field to a new value. */
#define DMA_WR_ERR_ERR6(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR6_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR6(value)))
#define DMA_BWR_ERR_ERR6(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR6_SHIFT), DMA_ERR_ERR6_SHIFT, DMA_ERR_ERR6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR7 field. */
#define DMA_RD_ERR_ERR7(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR7_MASK) >> DMA_ERR_ERR7_SHIFT)
#define DMA_BRD_ERR_ERR7(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT, DMA_ERR_ERR7_WIDTH))

/*! @brief Set the ERR7 field to a new value. */
#define DMA_WR_ERR_ERR7(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR7_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR7(value)))
#define DMA_BWR_ERR_ERR7(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR7_SHIFT), DMA_ERR_ERR7_SHIFT, DMA_ERR_ERR7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR8[8] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR8 field. */
#define DMA_RD_ERR_ERR8(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR8_MASK) >> DMA_ERR_ERR8_SHIFT)
#define DMA_BRD_ERR_ERR8(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR8_SHIFT, DMA_ERR_ERR8_WIDTH))

/*! @brief Set the ERR8 field to a new value. */
#define DMA_WR_ERR_ERR8(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR8_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR8(value)))
#define DMA_BWR_ERR_ERR8(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR8_SHIFT), DMA_ERR_ERR8_SHIFT, DMA_ERR_ERR8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR9[9] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR9 field. */
#define DMA_RD_ERR_ERR9(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR9_MASK) >> DMA_ERR_ERR9_SHIFT)
#define DMA_BRD_ERR_ERR9(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR9_SHIFT, DMA_ERR_ERR9_WIDTH))

/*! @brief Set the ERR9 field to a new value. */
#define DMA_WR_ERR_ERR9(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR9_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR9(value)))
#define DMA_BWR_ERR_ERR9(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR9_SHIFT), DMA_ERR_ERR9_SHIFT, DMA_ERR_ERR9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR10[10] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR10 field. */
#define DMA_RD_ERR_ERR10(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR10_MASK) >> DMA_ERR_ERR10_SHIFT)
#define DMA_BRD_ERR_ERR10(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR10_SHIFT, DMA_ERR_ERR10_WIDTH))

/*! @brief Set the ERR10 field to a new value. */
#define DMA_WR_ERR_ERR10(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR10_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR10(value)))
#define DMA_BWR_ERR_ERR10(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR10_SHIFT), DMA_ERR_ERR10_SHIFT, DMA_ERR_ERR10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR11[11] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR11 field. */
#define DMA_RD_ERR_ERR11(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR11_MASK) >> DMA_ERR_ERR11_SHIFT)
#define DMA_BRD_ERR_ERR11(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR11_SHIFT, DMA_ERR_ERR11_WIDTH))

/*! @brief Set the ERR11 field to a new value. */
#define DMA_WR_ERR_ERR11(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR11_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR11(value)))
#define DMA_BWR_ERR_ERR11(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR11_SHIFT), DMA_ERR_ERR11_SHIFT, DMA_ERR_ERR11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR12[12] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR12 field. */
#define DMA_RD_ERR_ERR12(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR12_MASK) >> DMA_ERR_ERR12_SHIFT)
#define DMA_BRD_ERR_ERR12(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR12_SHIFT, DMA_ERR_ERR12_WIDTH))

/*! @brief Set the ERR12 field to a new value. */
#define DMA_WR_ERR_ERR12(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR12_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR12(value)))
#define DMA_BWR_ERR_ERR12(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR12_SHIFT), DMA_ERR_ERR12_SHIFT, DMA_ERR_ERR12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR13[13] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR13 field. */
#define DMA_RD_ERR_ERR13(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR13_MASK) >> DMA_ERR_ERR13_SHIFT)
#define DMA_BRD_ERR_ERR13(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR13_SHIFT, DMA_ERR_ERR13_WIDTH))

/*! @brief Set the ERR13 field to a new value. */
#define DMA_WR_ERR_ERR13(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR13_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR13(value)))
#define DMA_BWR_ERR_ERR13(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR13_SHIFT), DMA_ERR_ERR13_SHIFT, DMA_ERR_ERR13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR14[14] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR14 field. */
#define DMA_RD_ERR_ERR14(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR14_MASK) >> DMA_ERR_ERR14_SHIFT)
#define DMA_BRD_ERR_ERR14(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR14_SHIFT, DMA_ERR_ERR14_WIDTH))

/*! @brief Set the ERR14 field to a new value. */
#define DMA_WR_ERR_ERR14(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR14_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR14(value)))
#define DMA_BWR_ERR_ERR14(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR14_SHIFT), DMA_ERR_ERR14_SHIFT, DMA_ERR_ERR14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR15[15] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR15 field. */
#define DMA_RD_ERR_ERR15(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR15_MASK) >> DMA_ERR_ERR15_SHIFT)
#define DMA_BRD_ERR_ERR15(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR15_SHIFT, DMA_ERR_ERR15_WIDTH))

/*! @brief Set the ERR15 field to a new value. */
#define DMA_WR_ERR_ERR15(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR15_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR15(value)))
#define DMA_BWR_ERR_ERR15(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR15_SHIFT), DMA_ERR_ERR15_SHIFT, DMA_ERR_ERR15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR16[16] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR16 field. */
#define DMA_RD_ERR_ERR16(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR16_MASK) >> DMA_ERR_ERR16_SHIFT)
#define DMA_BRD_ERR_ERR16(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR16_SHIFT, DMA_ERR_ERR16_WIDTH))

/*! @brief Set the ERR16 field to a new value. */
#define DMA_WR_ERR_ERR16(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR16_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR16(value)))
#define DMA_BWR_ERR_ERR16(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR16_SHIFT), DMA_ERR_ERR16_SHIFT, DMA_ERR_ERR16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR17[17] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR17 field. */
#define DMA_RD_ERR_ERR17(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR17_MASK) >> DMA_ERR_ERR17_SHIFT)
#define DMA_BRD_ERR_ERR17(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR17_SHIFT, DMA_ERR_ERR17_WIDTH))

/*! @brief Set the ERR17 field to a new value. */
#define DMA_WR_ERR_ERR17(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR17_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR17(value)))
#define DMA_BWR_ERR_ERR17(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR17_SHIFT), DMA_ERR_ERR17_SHIFT, DMA_ERR_ERR17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR18[18] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR18 field. */
#define DMA_RD_ERR_ERR18(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR18_MASK) >> DMA_ERR_ERR18_SHIFT)
#define DMA_BRD_ERR_ERR18(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR18_SHIFT, DMA_ERR_ERR18_WIDTH))

/*! @brief Set the ERR18 field to a new value. */
#define DMA_WR_ERR_ERR18(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR18_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR18(value)))
#define DMA_BWR_ERR_ERR18(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR18_SHIFT), DMA_ERR_ERR18_SHIFT, DMA_ERR_ERR18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR19[19] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR19 field. */
#define DMA_RD_ERR_ERR19(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR19_MASK) >> DMA_ERR_ERR19_SHIFT)
#define DMA_BRD_ERR_ERR19(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR19_SHIFT, DMA_ERR_ERR19_WIDTH))

/*! @brief Set the ERR19 field to a new value. */
#define DMA_WR_ERR_ERR19(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR19_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR19(value)))
#define DMA_BWR_ERR_ERR19(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR19_SHIFT), DMA_ERR_ERR19_SHIFT, DMA_ERR_ERR19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR20[20] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR20 field. */
#define DMA_RD_ERR_ERR20(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR20_MASK) >> DMA_ERR_ERR20_SHIFT)
#define DMA_BRD_ERR_ERR20(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR20_SHIFT, DMA_ERR_ERR20_WIDTH))

/*! @brief Set the ERR20 field to a new value. */
#define DMA_WR_ERR_ERR20(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR20_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR20(value)))
#define DMA_BWR_ERR_ERR20(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR20_SHIFT), DMA_ERR_ERR20_SHIFT, DMA_ERR_ERR20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR21[21] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR21 field. */
#define DMA_RD_ERR_ERR21(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR21_MASK) >> DMA_ERR_ERR21_SHIFT)
#define DMA_BRD_ERR_ERR21(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR21_SHIFT, DMA_ERR_ERR21_WIDTH))

/*! @brief Set the ERR21 field to a new value. */
#define DMA_WR_ERR_ERR21(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR21_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR21(value)))
#define DMA_BWR_ERR_ERR21(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR21_SHIFT), DMA_ERR_ERR21_SHIFT, DMA_ERR_ERR21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR22[22] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR22 field. */
#define DMA_RD_ERR_ERR22(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR22_MASK) >> DMA_ERR_ERR22_SHIFT)
#define DMA_BRD_ERR_ERR22(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR22_SHIFT, DMA_ERR_ERR22_WIDTH))

/*! @brief Set the ERR22 field to a new value. */
#define DMA_WR_ERR_ERR22(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR22_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR22(value)))
#define DMA_BWR_ERR_ERR22(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR22_SHIFT), DMA_ERR_ERR22_SHIFT, DMA_ERR_ERR22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR23[23] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR23 field. */
#define DMA_RD_ERR_ERR23(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR23_MASK) >> DMA_ERR_ERR23_SHIFT)
#define DMA_BRD_ERR_ERR23(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR23_SHIFT, DMA_ERR_ERR23_WIDTH))

/*! @brief Set the ERR23 field to a new value. */
#define DMA_WR_ERR_ERR23(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR23_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR23(value)))
#define DMA_BWR_ERR_ERR23(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR23_SHIFT), DMA_ERR_ERR23_SHIFT, DMA_ERR_ERR23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR24[24] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR24 field. */
#define DMA_RD_ERR_ERR24(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR24_MASK) >> DMA_ERR_ERR24_SHIFT)
#define DMA_BRD_ERR_ERR24(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR24_SHIFT, DMA_ERR_ERR24_WIDTH))

/*! @brief Set the ERR24 field to a new value. */
#define DMA_WR_ERR_ERR24(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR24_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR24(value)))
#define DMA_BWR_ERR_ERR24(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR24_SHIFT), DMA_ERR_ERR24_SHIFT, DMA_ERR_ERR24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR25[25] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR25 field. */
#define DMA_RD_ERR_ERR25(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR25_MASK) >> DMA_ERR_ERR25_SHIFT)
#define DMA_BRD_ERR_ERR25(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR25_SHIFT, DMA_ERR_ERR25_WIDTH))

/*! @brief Set the ERR25 field to a new value. */
#define DMA_WR_ERR_ERR25(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR25_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR25(value)))
#define DMA_BWR_ERR_ERR25(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR25_SHIFT), DMA_ERR_ERR25_SHIFT, DMA_ERR_ERR25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR26[26] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR26 field. */
#define DMA_RD_ERR_ERR26(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR26_MASK) >> DMA_ERR_ERR26_SHIFT)
#define DMA_BRD_ERR_ERR26(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR26_SHIFT, DMA_ERR_ERR26_WIDTH))

/*! @brief Set the ERR26 field to a new value. */
#define DMA_WR_ERR_ERR26(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR26_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR26(value)))
#define DMA_BWR_ERR_ERR26(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR26_SHIFT), DMA_ERR_ERR26_SHIFT, DMA_ERR_ERR26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR27[27] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR27 field. */
#define DMA_RD_ERR_ERR27(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR27_MASK) >> DMA_ERR_ERR27_SHIFT)
#define DMA_BRD_ERR_ERR27(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR27_SHIFT, DMA_ERR_ERR27_WIDTH))

/*! @brief Set the ERR27 field to a new value. */
#define DMA_WR_ERR_ERR27(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR27_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR27(value)))
#define DMA_BWR_ERR_ERR27(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR27_SHIFT), DMA_ERR_ERR27_SHIFT, DMA_ERR_ERR27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR28[28] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR28 field. */
#define DMA_RD_ERR_ERR28(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR28_MASK) >> DMA_ERR_ERR28_SHIFT)
#define DMA_BRD_ERR_ERR28(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR28_SHIFT, DMA_ERR_ERR28_WIDTH))

/*! @brief Set the ERR28 field to a new value. */
#define DMA_WR_ERR_ERR28(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR28_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR28(value)))
#define DMA_BWR_ERR_ERR28(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR28_SHIFT), DMA_ERR_ERR28_SHIFT, DMA_ERR_ERR28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR29[29] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR29 field. */
#define DMA_RD_ERR_ERR29(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR29_MASK) >> DMA_ERR_ERR29_SHIFT)
#define DMA_BRD_ERR_ERR29(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR29_SHIFT, DMA_ERR_ERR29_WIDTH))

/*! @brief Set the ERR29 field to a new value. */
#define DMA_WR_ERR_ERR29(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR29_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR30_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR29(value)))
#define DMA_BWR_ERR_ERR29(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR29_SHIFT), DMA_ERR_ERR29_SHIFT, DMA_ERR_ERR29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR30[30] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR30 field. */
#define DMA_RD_ERR_ERR30(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR30_MASK) >> DMA_ERR_ERR30_SHIFT)
#define DMA_BRD_ERR_ERR30(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR30_SHIFT, DMA_ERR_ERR30_WIDTH))

/*! @brief Set the ERR30 field to a new value. */
#define DMA_WR_ERR_ERR30(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR30_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR31_MASK), DMA_ERR_ERR30(value)))
#define DMA_BWR_ERR_ERR30(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR30_SHIFT), DMA_ERR_ERR30_SHIFT, DMA_ERR_ERR30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR31[31] (W1C)
 *
 * Values:
 * - 0b0 - An error in this channel has not occurred
 * - 0b1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR31 field. */
#define DMA_RD_ERR_ERR31(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR31_MASK) >> DMA_ERR_ERR31_SHIFT)
#define DMA_BRD_ERR_ERR31(base) (BME_UBFX32(&DMA_ERR_REG(base), DMA_ERR_ERR31_SHIFT, DMA_ERR_ERR31_WIDTH))

/*! @brief Set the ERR31 field to a new value. */
#define DMA_WR_ERR_ERR31(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR31_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK | DMA_ERR_ERR16_MASK | DMA_ERR_ERR17_MASK | DMA_ERR_ERR18_MASK | DMA_ERR_ERR19_MASK | DMA_ERR_ERR20_MASK | DMA_ERR_ERR21_MASK | DMA_ERR_ERR22_MASK | DMA_ERR_ERR23_MASK | DMA_ERR_ERR24_MASK | DMA_ERR_ERR25_MASK | DMA_ERR_ERR26_MASK | DMA_ERR_ERR27_MASK | DMA_ERR_ERR28_MASK | DMA_ERR_ERR29_MASK | DMA_ERR_ERR30_MASK), DMA_ERR_ERR31(value)))
#define DMA_BWR_ERR_ERR31(base, value) (BME_BFI32(&DMA_ERR_REG(base), ((uint32_t)(value) << DMA_ERR_ERR31_SHIFT), DMA_ERR_ERR31_SHIFT, DMA_ERR_ERR31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 0 is not present
 * - 0b1 - A hardware service request for channel 0 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT, DMA_HRS_HRS0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 1 is not present
 * - 0b1 - A hardware service request for channel 1 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT, DMA_HRS_HRS1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 2 is not present
 * - 0b1 - A hardware service request for channel 2 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT, DMA_HRS_HRS2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 3 is not present
 * - 0b1 - A hardware service request for channel 3 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT, DMA_HRS_HRS3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS4[4] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 4 is not present
 * - 0b1 - A hardware service request for channel 4 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS4 field. */
#define DMA_RD_HRS_HRS4(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS4_MASK) >> DMA_HRS_HRS4_SHIFT)
#define DMA_BRD_HRS_HRS4(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS4_SHIFT, DMA_HRS_HRS4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS5[5] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 5 is not present
 * - 0b1 - A hardware service request for channel 5 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS5 field. */
#define DMA_RD_HRS_HRS5(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS5_MASK) >> DMA_HRS_HRS5_SHIFT)
#define DMA_BRD_HRS_HRS5(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS5_SHIFT, DMA_HRS_HRS5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS6[6] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 6 is not present
 * - 0b1 - A hardware service request for channel 6 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS6 field. */
#define DMA_RD_HRS_HRS6(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS6_MASK) >> DMA_HRS_HRS6_SHIFT)
#define DMA_BRD_HRS_HRS6(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS6_SHIFT, DMA_HRS_HRS6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS7[7] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 7 is not present
 * - 0b1 - A hardware service request for channel 7 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS7 field. */
#define DMA_RD_HRS_HRS7(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS7_MASK) >> DMA_HRS_HRS7_SHIFT)
#define DMA_BRD_HRS_HRS7(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS7_SHIFT, DMA_HRS_HRS7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS8[8] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 8 is not present
 * - 0b1 - A hardware service request for channel 8 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS8 field. */
#define DMA_RD_HRS_HRS8(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS8_MASK) >> DMA_HRS_HRS8_SHIFT)
#define DMA_BRD_HRS_HRS8(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS8_SHIFT, DMA_HRS_HRS8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS9[9] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 9 is not present
 * - 0b1 - A hardware service request for channel 9 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS9 field. */
#define DMA_RD_HRS_HRS9(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS9_MASK) >> DMA_HRS_HRS9_SHIFT)
#define DMA_BRD_HRS_HRS9(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS9_SHIFT, DMA_HRS_HRS9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS10[10] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 10 is not present
 * - 0b1 - A hardware service request for channel 10 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS10 field. */
#define DMA_RD_HRS_HRS10(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS10_MASK) >> DMA_HRS_HRS10_SHIFT)
#define DMA_BRD_HRS_HRS10(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS10_SHIFT, DMA_HRS_HRS10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS11[11] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 11 is not present
 * - 0b1 - A hardware service request for channel 11 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS11 field. */
#define DMA_RD_HRS_HRS11(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS11_MASK) >> DMA_HRS_HRS11_SHIFT)
#define DMA_BRD_HRS_HRS11(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS11_SHIFT, DMA_HRS_HRS11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS12[12] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 12 is not present
 * - 0b1 - A hardware service request for channel 12 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS12 field. */
#define DMA_RD_HRS_HRS12(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS12_MASK) >> DMA_HRS_HRS12_SHIFT)
#define DMA_BRD_HRS_HRS12(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS12_SHIFT, DMA_HRS_HRS12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS13[13] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 13 is not present
 * - 0b1 - A hardware service request for channel 13 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS13 field. */
#define DMA_RD_HRS_HRS13(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS13_MASK) >> DMA_HRS_HRS13_SHIFT)
#define DMA_BRD_HRS_HRS13(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS13_SHIFT, DMA_HRS_HRS13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS14[14] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 14 is not present
 * - 0b1 - A hardware service request for channel 14 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS14 field. */
#define DMA_RD_HRS_HRS14(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS14_MASK) >> DMA_HRS_HRS14_SHIFT)
#define DMA_BRD_HRS_HRS14(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS14_SHIFT, DMA_HRS_HRS14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS15[15] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 15 is not present
 * - 0b1 - A hardware service request for channel 15 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS15 field. */
#define DMA_RD_HRS_HRS15(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS15_MASK) >> DMA_HRS_HRS15_SHIFT)
#define DMA_BRD_HRS_HRS15(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS15_SHIFT, DMA_HRS_HRS15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS16[16] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 16 is not present
 * - 0b1 - A hardware service request for channel 16 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS16 field. */
#define DMA_RD_HRS_HRS16(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS16_MASK) >> DMA_HRS_HRS16_SHIFT)
#define DMA_BRD_HRS_HRS16(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS16_SHIFT, DMA_HRS_HRS16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS17[17] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 17 is not present
 * - 0b1 - A hardware service request for channel 17 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS17 field. */
#define DMA_RD_HRS_HRS17(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS17_MASK) >> DMA_HRS_HRS17_SHIFT)
#define DMA_BRD_HRS_HRS17(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS17_SHIFT, DMA_HRS_HRS17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS18[18] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 18 is not present
 * - 0b1 - A hardware service request for channel 18 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS18 field. */
#define DMA_RD_HRS_HRS18(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS18_MASK) >> DMA_HRS_HRS18_SHIFT)
#define DMA_BRD_HRS_HRS18(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS18_SHIFT, DMA_HRS_HRS18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS19[19] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 19 is not present
 * - 0b1 - A hardware service request for channel 19 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS19 field. */
#define DMA_RD_HRS_HRS19(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS19_MASK) >> DMA_HRS_HRS19_SHIFT)
#define DMA_BRD_HRS_HRS19(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS19_SHIFT, DMA_HRS_HRS19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS20[20] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 20 is not present
 * - 0b1 - A hardware service request for channel 20 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS20 field. */
#define DMA_RD_HRS_HRS20(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS20_MASK) >> DMA_HRS_HRS20_SHIFT)
#define DMA_BRD_HRS_HRS20(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS20_SHIFT, DMA_HRS_HRS20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS21[21] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 21 is not present
 * - 0b1 - A hardware service request for channel 21 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS21 field. */
#define DMA_RD_HRS_HRS21(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS21_MASK) >> DMA_HRS_HRS21_SHIFT)
#define DMA_BRD_HRS_HRS21(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS21_SHIFT, DMA_HRS_HRS21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS22[22] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 22 is not present
 * - 0b1 - A hardware service request for channel 22 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS22 field. */
#define DMA_RD_HRS_HRS22(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS22_MASK) >> DMA_HRS_HRS22_SHIFT)
#define DMA_BRD_HRS_HRS22(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS22_SHIFT, DMA_HRS_HRS22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS23[23] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 23 is not present
 * - 0b1 - A hardware service request for channel 23 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS23 field. */
#define DMA_RD_HRS_HRS23(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS23_MASK) >> DMA_HRS_HRS23_SHIFT)
#define DMA_BRD_HRS_HRS23(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS23_SHIFT, DMA_HRS_HRS23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS24[24] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 24 is not present
 * - 0b1 - A hardware service request for channel 24 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS24 field. */
#define DMA_RD_HRS_HRS24(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS24_MASK) >> DMA_HRS_HRS24_SHIFT)
#define DMA_BRD_HRS_HRS24(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS24_SHIFT, DMA_HRS_HRS24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS25[25] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 25 is not present
 * - 0b1 - A hardware service request for channel 25 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS25 field. */
#define DMA_RD_HRS_HRS25(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS25_MASK) >> DMA_HRS_HRS25_SHIFT)
#define DMA_BRD_HRS_HRS25(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS25_SHIFT, DMA_HRS_HRS25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS26[26] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 26 is not present
 * - 0b1 - A hardware service request for channel 26 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS26 field. */
#define DMA_RD_HRS_HRS26(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS26_MASK) >> DMA_HRS_HRS26_SHIFT)
#define DMA_BRD_HRS_HRS26(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS26_SHIFT, DMA_HRS_HRS26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS27[27] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 27 is not present
 * - 0b1 - A hardware service request for channel 27 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS27 field. */
#define DMA_RD_HRS_HRS27(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS27_MASK) >> DMA_HRS_HRS27_SHIFT)
#define DMA_BRD_HRS_HRS27(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS27_SHIFT, DMA_HRS_HRS27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS28[28] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 28 is not present
 * - 0b1 - A hardware service request for channel 28 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS28 field. */
#define DMA_RD_HRS_HRS28(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS28_MASK) >> DMA_HRS_HRS28_SHIFT)
#define DMA_BRD_HRS_HRS28(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS28_SHIFT, DMA_HRS_HRS28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS29[29] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 29 is not preset
 * - 0b1 - A hardware service request for channel 29 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS29 field. */
#define DMA_RD_HRS_HRS29(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS29_MASK) >> DMA_HRS_HRS29_SHIFT)
#define DMA_BRD_HRS_HRS29(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS29_SHIFT, DMA_HRS_HRS29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS30[30] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 30 is not present
 * - 0b1 - A hardware service request for for channel 30 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS30 field. */
#define DMA_RD_HRS_HRS30(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS30_MASK) >> DMA_HRS_HRS30_SHIFT)
#define DMA_BRD_HRS_HRS30(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS30_SHIFT, DMA_HRS_HRS30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS31[31] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0b0 - A hardware service request for channel 31 is not present
 * - 0b1 - A hardware service request for channel 31 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS31 field. */
#define DMA_RD_HRS_HRS31(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS31_MASK) >> DMA_HRS_HRS31_SHIFT)
#define DMA_BRD_HRS_HRS31(base) (BME_UBFX32(&DMA_HRS_REG(base), DMA_HRS_HRS31_SHIFT, DMA_HRS_HRS31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_EARS - Enable Asynchronous Request in Stop Register
 ******************************************************************************/

/*!
 * @brief DMA_EARS - Enable Asynchronous Request in Stop Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_EARS register
 */
/*@{*/
#define DMA_RD_EARS(base)        (DMA_EARS_REG(base))
#define DMA_WR_EARS(base, value) (DMA_EARS_REG(base) = (value))
#define DMA_RMW_EARS(base, mask, value) (DMA_WR_EARS(base, (DMA_RD_EARS(base) & ~(mask)) | (value)))
#define DMA_SET_EARS(base, value) (BME_OR32(&DMA_EARS_REG(base), (uint32_t)(value)))
#define DMA_CLR_EARS(base, value) (BME_AND32(&DMA_EARS_REG(base), (uint32_t)(~(value))))
#define DMA_TOG_EARS(base, value) (BME_XOR32(&DMA_EARS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EARS bitfields
 */

/*!
 * @name Register DMA_EARS, field EDREQ_0[0] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 0.
 * - 0b1 - Enable asynchronous DMA request for channel 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_0 field. */
#define DMA_RD_EARS_EDREQ_0(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_0_MASK) >> DMA_EARS_EDREQ_0_SHIFT)
#define DMA_BRD_EARS_EDREQ_0(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))

/*! @brief Set the EDREQ_0 field to a new value. */
#define DMA_WR_EARS_EDREQ_0(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_0_MASK, DMA_EARS_EDREQ_0(value)))
#define DMA_BWR_EARS_EDREQ_0(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_0_SHIFT), DMA_EARS_EDREQ_0_SHIFT, DMA_EARS_EDREQ_0_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_1[1] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 1
 * - 0b1 - Enable asynchronous DMA request for channel 1.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_1 field. */
#define DMA_RD_EARS_EDREQ_1(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_1_MASK) >> DMA_EARS_EDREQ_1_SHIFT)
#define DMA_BRD_EARS_EDREQ_1(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))

/*! @brief Set the EDREQ_1 field to a new value. */
#define DMA_WR_EARS_EDREQ_1(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_1_MASK, DMA_EARS_EDREQ_1(value)))
#define DMA_BWR_EARS_EDREQ_1(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_1_SHIFT), DMA_EARS_EDREQ_1_SHIFT, DMA_EARS_EDREQ_1_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_2[2] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 2.
 * - 0b1 - Enable asynchronous DMA request for channel 2.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_2 field. */
#define DMA_RD_EARS_EDREQ_2(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_2_MASK) >> DMA_EARS_EDREQ_2_SHIFT)
#define DMA_BRD_EARS_EDREQ_2(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))

/*! @brief Set the EDREQ_2 field to a new value. */
#define DMA_WR_EARS_EDREQ_2(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_2_MASK, DMA_EARS_EDREQ_2(value)))
#define DMA_BWR_EARS_EDREQ_2(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_2_SHIFT), DMA_EARS_EDREQ_2_SHIFT, DMA_EARS_EDREQ_2_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_3[3] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 3.
 * - 0b1 - Enable asynchronous DMA request for channel 3.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_3 field. */
#define DMA_RD_EARS_EDREQ_3(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_3_MASK) >> DMA_EARS_EDREQ_3_SHIFT)
#define DMA_BRD_EARS_EDREQ_3(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))

/*! @brief Set the EDREQ_3 field to a new value. */
#define DMA_WR_EARS_EDREQ_3(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_3_MASK, DMA_EARS_EDREQ_3(value)))
#define DMA_BWR_EARS_EDREQ_3(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_3_SHIFT), DMA_EARS_EDREQ_3_SHIFT, DMA_EARS_EDREQ_3_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_4[4] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 4.
 * - 0b1 - Enable asynchronous DMA request for channel 4.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_4 field. */
#define DMA_RD_EARS_EDREQ_4(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_4_MASK) >> DMA_EARS_EDREQ_4_SHIFT)
#define DMA_BRD_EARS_EDREQ_4(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT, DMA_EARS_EDREQ_4_WIDTH))

/*! @brief Set the EDREQ_4 field to a new value. */
#define DMA_WR_EARS_EDREQ_4(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_4_MASK, DMA_EARS_EDREQ_4(value)))
#define DMA_BWR_EARS_EDREQ_4(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_4_SHIFT), DMA_EARS_EDREQ_4_SHIFT, DMA_EARS_EDREQ_4_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_5[5] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 5.
 * - 0b1 - Enable asynchronous DMA request for channel 5.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_5 field. */
#define DMA_RD_EARS_EDREQ_5(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_5_MASK) >> DMA_EARS_EDREQ_5_SHIFT)
#define DMA_BRD_EARS_EDREQ_5(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT, DMA_EARS_EDREQ_5_WIDTH))

/*! @brief Set the EDREQ_5 field to a new value. */
#define DMA_WR_EARS_EDREQ_5(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_5_MASK, DMA_EARS_EDREQ_5(value)))
#define DMA_BWR_EARS_EDREQ_5(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_5_SHIFT), DMA_EARS_EDREQ_5_SHIFT, DMA_EARS_EDREQ_5_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_6[6] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 6.
 * - 0b1 - Enable asynchronous DMA request for channel 6.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_6 field. */
#define DMA_RD_EARS_EDREQ_6(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_6_MASK) >> DMA_EARS_EDREQ_6_SHIFT)
#define DMA_BRD_EARS_EDREQ_6(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT, DMA_EARS_EDREQ_6_WIDTH))

/*! @brief Set the EDREQ_6 field to a new value. */
#define DMA_WR_EARS_EDREQ_6(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_6_MASK, DMA_EARS_EDREQ_6(value)))
#define DMA_BWR_EARS_EDREQ_6(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_6_SHIFT), DMA_EARS_EDREQ_6_SHIFT, DMA_EARS_EDREQ_6_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_7[7] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 7.
 * - 0b1 - Enable asynchronous DMA request for channel 7.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_7 field. */
#define DMA_RD_EARS_EDREQ_7(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_7_MASK) >> DMA_EARS_EDREQ_7_SHIFT)
#define DMA_BRD_EARS_EDREQ_7(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT, DMA_EARS_EDREQ_7_WIDTH))

/*! @brief Set the EDREQ_7 field to a new value. */
#define DMA_WR_EARS_EDREQ_7(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_7_MASK, DMA_EARS_EDREQ_7(value)))
#define DMA_BWR_EARS_EDREQ_7(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_7_SHIFT), DMA_EARS_EDREQ_7_SHIFT, DMA_EARS_EDREQ_7_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_8[8] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 8.
 * - 0b1 - Enable asynchronous DMA request for channel 8.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_8 field. */
#define DMA_RD_EARS_EDREQ_8(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_8_MASK) >> DMA_EARS_EDREQ_8_SHIFT)
#define DMA_BRD_EARS_EDREQ_8(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_8_SHIFT, DMA_EARS_EDREQ_8_WIDTH))

/*! @brief Set the EDREQ_8 field to a new value. */
#define DMA_WR_EARS_EDREQ_8(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_8_MASK, DMA_EARS_EDREQ_8(value)))
#define DMA_BWR_EARS_EDREQ_8(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_8_SHIFT), DMA_EARS_EDREQ_8_SHIFT, DMA_EARS_EDREQ_8_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_9[9] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 9.
 * - 0b1 - Enable asynchronous DMA request for channel 9.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_9 field. */
#define DMA_RD_EARS_EDREQ_9(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_9_MASK) >> DMA_EARS_EDREQ_9_SHIFT)
#define DMA_BRD_EARS_EDREQ_9(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_9_SHIFT, DMA_EARS_EDREQ_9_WIDTH))

/*! @brief Set the EDREQ_9 field to a new value. */
#define DMA_WR_EARS_EDREQ_9(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_9_MASK, DMA_EARS_EDREQ_9(value)))
#define DMA_BWR_EARS_EDREQ_9(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_9_SHIFT), DMA_EARS_EDREQ_9_SHIFT, DMA_EARS_EDREQ_9_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_10[10] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 10.
 * - 0b1 - Enable asynchronous DMA request for channel 10.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_10 field. */
#define DMA_RD_EARS_EDREQ_10(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_10_MASK) >> DMA_EARS_EDREQ_10_SHIFT)
#define DMA_BRD_EARS_EDREQ_10(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_10_SHIFT, DMA_EARS_EDREQ_10_WIDTH))

/*! @brief Set the EDREQ_10 field to a new value. */
#define DMA_WR_EARS_EDREQ_10(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_10_MASK, DMA_EARS_EDREQ_10(value)))
#define DMA_BWR_EARS_EDREQ_10(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_10_SHIFT), DMA_EARS_EDREQ_10_SHIFT, DMA_EARS_EDREQ_10_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_11[11] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 11.
 * - 0b1 - Enable asynchronous DMA request for channel 11.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_11 field. */
#define DMA_RD_EARS_EDREQ_11(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_11_MASK) >> DMA_EARS_EDREQ_11_SHIFT)
#define DMA_BRD_EARS_EDREQ_11(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_11_SHIFT, DMA_EARS_EDREQ_11_WIDTH))

/*! @brief Set the EDREQ_11 field to a new value. */
#define DMA_WR_EARS_EDREQ_11(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_11_MASK, DMA_EARS_EDREQ_11(value)))
#define DMA_BWR_EARS_EDREQ_11(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_11_SHIFT), DMA_EARS_EDREQ_11_SHIFT, DMA_EARS_EDREQ_11_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_12[12] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 12.
 * - 0b1 - Enable asynchronous DMA request for channel 12.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_12 field. */
#define DMA_RD_EARS_EDREQ_12(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_12_MASK) >> DMA_EARS_EDREQ_12_SHIFT)
#define DMA_BRD_EARS_EDREQ_12(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_12_SHIFT, DMA_EARS_EDREQ_12_WIDTH))

/*! @brief Set the EDREQ_12 field to a new value. */
#define DMA_WR_EARS_EDREQ_12(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_12_MASK, DMA_EARS_EDREQ_12(value)))
#define DMA_BWR_EARS_EDREQ_12(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_12_SHIFT), DMA_EARS_EDREQ_12_SHIFT, DMA_EARS_EDREQ_12_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_13[13] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 13.
 * - 0b1 - Enable asynchronous DMA request for channel 13.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_13 field. */
#define DMA_RD_EARS_EDREQ_13(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_13_MASK) >> DMA_EARS_EDREQ_13_SHIFT)
#define DMA_BRD_EARS_EDREQ_13(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_13_SHIFT, DMA_EARS_EDREQ_13_WIDTH))

/*! @brief Set the EDREQ_13 field to a new value. */
#define DMA_WR_EARS_EDREQ_13(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_13_MASK, DMA_EARS_EDREQ_13(value)))
#define DMA_BWR_EARS_EDREQ_13(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_13_SHIFT), DMA_EARS_EDREQ_13_SHIFT, DMA_EARS_EDREQ_13_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_14[14] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 14.
 * - 0b1 - Enable asynchronous DMA request for channel 14.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_14 field. */
#define DMA_RD_EARS_EDREQ_14(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_14_MASK) >> DMA_EARS_EDREQ_14_SHIFT)
#define DMA_BRD_EARS_EDREQ_14(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_14_SHIFT, DMA_EARS_EDREQ_14_WIDTH))

/*! @brief Set the EDREQ_14 field to a new value. */
#define DMA_WR_EARS_EDREQ_14(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_14_MASK, DMA_EARS_EDREQ_14(value)))
#define DMA_BWR_EARS_EDREQ_14(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_14_SHIFT), DMA_EARS_EDREQ_14_SHIFT, DMA_EARS_EDREQ_14_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_15[15] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 15.
 * - 0b1 - Enable asynchronous DMA request for channel 15.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_15 field. */
#define DMA_RD_EARS_EDREQ_15(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_15_MASK) >> DMA_EARS_EDREQ_15_SHIFT)
#define DMA_BRD_EARS_EDREQ_15(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_15_SHIFT, DMA_EARS_EDREQ_15_WIDTH))

/*! @brief Set the EDREQ_15 field to a new value. */
#define DMA_WR_EARS_EDREQ_15(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_15_MASK, DMA_EARS_EDREQ_15(value)))
#define DMA_BWR_EARS_EDREQ_15(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_15_SHIFT), DMA_EARS_EDREQ_15_SHIFT, DMA_EARS_EDREQ_15_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_16[16] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 16
 * - 0b1 - Enable asynchronous DMA request for channel 16
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_16 field. */
#define DMA_RD_EARS_EDREQ_16(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_16_MASK) >> DMA_EARS_EDREQ_16_SHIFT)
#define DMA_BRD_EARS_EDREQ_16(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_16_SHIFT, DMA_EARS_EDREQ_16_WIDTH))

/*! @brief Set the EDREQ_16 field to a new value. */
#define DMA_WR_EARS_EDREQ_16(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_16_MASK, DMA_EARS_EDREQ_16(value)))
#define DMA_BWR_EARS_EDREQ_16(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_16_SHIFT), DMA_EARS_EDREQ_16_SHIFT, DMA_EARS_EDREQ_16_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_17[17] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 17
 * - 0b1 - Enable asynchronous DMA request for channel 17
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_17 field. */
#define DMA_RD_EARS_EDREQ_17(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_17_MASK) >> DMA_EARS_EDREQ_17_SHIFT)
#define DMA_BRD_EARS_EDREQ_17(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_17_SHIFT, DMA_EARS_EDREQ_17_WIDTH))

/*! @brief Set the EDREQ_17 field to a new value. */
#define DMA_WR_EARS_EDREQ_17(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_17_MASK, DMA_EARS_EDREQ_17(value)))
#define DMA_BWR_EARS_EDREQ_17(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_17_SHIFT), DMA_EARS_EDREQ_17_SHIFT, DMA_EARS_EDREQ_17_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_18[18] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 18
 * - 0b1 - Enable asynchronous DMA request for channel 18
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_18 field. */
#define DMA_RD_EARS_EDREQ_18(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_18_MASK) >> DMA_EARS_EDREQ_18_SHIFT)
#define DMA_BRD_EARS_EDREQ_18(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_18_SHIFT, DMA_EARS_EDREQ_18_WIDTH))

/*! @brief Set the EDREQ_18 field to a new value. */
#define DMA_WR_EARS_EDREQ_18(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_18_MASK, DMA_EARS_EDREQ_18(value)))
#define DMA_BWR_EARS_EDREQ_18(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_18_SHIFT), DMA_EARS_EDREQ_18_SHIFT, DMA_EARS_EDREQ_18_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_19[19] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 19
 * - 0b1 - Enable asynchronous DMA request for channel 19
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_19 field. */
#define DMA_RD_EARS_EDREQ_19(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_19_MASK) >> DMA_EARS_EDREQ_19_SHIFT)
#define DMA_BRD_EARS_EDREQ_19(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_19_SHIFT, DMA_EARS_EDREQ_19_WIDTH))

/*! @brief Set the EDREQ_19 field to a new value. */
#define DMA_WR_EARS_EDREQ_19(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_19_MASK, DMA_EARS_EDREQ_19(value)))
#define DMA_BWR_EARS_EDREQ_19(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_19_SHIFT), DMA_EARS_EDREQ_19_SHIFT, DMA_EARS_EDREQ_19_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_20[20] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 20
 * - 0b1 - Enable asynchronous DMA request for channel 20
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_20 field. */
#define DMA_RD_EARS_EDREQ_20(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_20_MASK) >> DMA_EARS_EDREQ_20_SHIFT)
#define DMA_BRD_EARS_EDREQ_20(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_20_SHIFT, DMA_EARS_EDREQ_20_WIDTH))

/*! @brief Set the EDREQ_20 field to a new value. */
#define DMA_WR_EARS_EDREQ_20(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_20_MASK, DMA_EARS_EDREQ_20(value)))
#define DMA_BWR_EARS_EDREQ_20(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_20_SHIFT), DMA_EARS_EDREQ_20_SHIFT, DMA_EARS_EDREQ_20_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_21[21] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 21
 * - 0b1 - Enable asynchronous DMA request for channel 21
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_21 field. */
#define DMA_RD_EARS_EDREQ_21(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_21_MASK) >> DMA_EARS_EDREQ_21_SHIFT)
#define DMA_BRD_EARS_EDREQ_21(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_21_SHIFT, DMA_EARS_EDREQ_21_WIDTH))

/*! @brief Set the EDREQ_21 field to a new value. */
#define DMA_WR_EARS_EDREQ_21(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_21_MASK, DMA_EARS_EDREQ_21(value)))
#define DMA_BWR_EARS_EDREQ_21(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_21_SHIFT), DMA_EARS_EDREQ_21_SHIFT, DMA_EARS_EDREQ_21_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_22[22] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 22
 * - 0b1 - Enable asynchronous DMA request for channel 22
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_22 field. */
#define DMA_RD_EARS_EDREQ_22(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_22_MASK) >> DMA_EARS_EDREQ_22_SHIFT)
#define DMA_BRD_EARS_EDREQ_22(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_22_SHIFT, DMA_EARS_EDREQ_22_WIDTH))

/*! @brief Set the EDREQ_22 field to a new value. */
#define DMA_WR_EARS_EDREQ_22(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_22_MASK, DMA_EARS_EDREQ_22(value)))
#define DMA_BWR_EARS_EDREQ_22(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_22_SHIFT), DMA_EARS_EDREQ_22_SHIFT, DMA_EARS_EDREQ_22_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_23[23] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 23
 * - 0b1 - Enable asynchronous DMA request for channel 23
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_23 field. */
#define DMA_RD_EARS_EDREQ_23(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_23_MASK) >> DMA_EARS_EDREQ_23_SHIFT)
#define DMA_BRD_EARS_EDREQ_23(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_23_SHIFT, DMA_EARS_EDREQ_23_WIDTH))

/*! @brief Set the EDREQ_23 field to a new value. */
#define DMA_WR_EARS_EDREQ_23(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_23_MASK, DMA_EARS_EDREQ_23(value)))
#define DMA_BWR_EARS_EDREQ_23(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_23_SHIFT), DMA_EARS_EDREQ_23_SHIFT, DMA_EARS_EDREQ_23_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_24[24] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 24
 * - 0b1 - Enable asynchronous DMA request for channel 24
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_24 field. */
#define DMA_RD_EARS_EDREQ_24(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_24_MASK) >> DMA_EARS_EDREQ_24_SHIFT)
#define DMA_BRD_EARS_EDREQ_24(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_24_SHIFT, DMA_EARS_EDREQ_24_WIDTH))

/*! @brief Set the EDREQ_24 field to a new value. */
#define DMA_WR_EARS_EDREQ_24(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_24_MASK, DMA_EARS_EDREQ_24(value)))
#define DMA_BWR_EARS_EDREQ_24(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_24_SHIFT), DMA_EARS_EDREQ_24_SHIFT, DMA_EARS_EDREQ_24_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_25[25] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 25
 * - 0b1 - Enable asynchronous DMA request for channel 25
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_25 field. */
#define DMA_RD_EARS_EDREQ_25(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_25_MASK) >> DMA_EARS_EDREQ_25_SHIFT)
#define DMA_BRD_EARS_EDREQ_25(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_25_SHIFT, DMA_EARS_EDREQ_25_WIDTH))

/*! @brief Set the EDREQ_25 field to a new value. */
#define DMA_WR_EARS_EDREQ_25(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_25_MASK, DMA_EARS_EDREQ_25(value)))
#define DMA_BWR_EARS_EDREQ_25(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_25_SHIFT), DMA_EARS_EDREQ_25_SHIFT, DMA_EARS_EDREQ_25_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_26[26] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 26
 * - 0b1 - Enable asynchronous DMA request for channel 26
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_26 field. */
#define DMA_RD_EARS_EDREQ_26(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_26_MASK) >> DMA_EARS_EDREQ_26_SHIFT)
#define DMA_BRD_EARS_EDREQ_26(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_26_SHIFT, DMA_EARS_EDREQ_26_WIDTH))

/*! @brief Set the EDREQ_26 field to a new value. */
#define DMA_WR_EARS_EDREQ_26(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_26_MASK, DMA_EARS_EDREQ_26(value)))
#define DMA_BWR_EARS_EDREQ_26(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_26_SHIFT), DMA_EARS_EDREQ_26_SHIFT, DMA_EARS_EDREQ_26_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_27[27] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 27
 * - 0b1 - Enable asynchronous DMA request for channel 27
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_27 field. */
#define DMA_RD_EARS_EDREQ_27(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_27_MASK) >> DMA_EARS_EDREQ_27_SHIFT)
#define DMA_BRD_EARS_EDREQ_27(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_27_SHIFT, DMA_EARS_EDREQ_27_WIDTH))

/*! @brief Set the EDREQ_27 field to a new value. */
#define DMA_WR_EARS_EDREQ_27(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_27_MASK, DMA_EARS_EDREQ_27(value)))
#define DMA_BWR_EARS_EDREQ_27(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_27_SHIFT), DMA_EARS_EDREQ_27_SHIFT, DMA_EARS_EDREQ_27_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_28[28] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 28
 * - 0b1 - Enable asynchronous DMA request for channel 28
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_28 field. */
#define DMA_RD_EARS_EDREQ_28(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_28_MASK) >> DMA_EARS_EDREQ_28_SHIFT)
#define DMA_BRD_EARS_EDREQ_28(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_28_SHIFT, DMA_EARS_EDREQ_28_WIDTH))

/*! @brief Set the EDREQ_28 field to a new value. */
#define DMA_WR_EARS_EDREQ_28(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_28_MASK, DMA_EARS_EDREQ_28(value)))
#define DMA_BWR_EARS_EDREQ_28(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_28_SHIFT), DMA_EARS_EDREQ_28_SHIFT, DMA_EARS_EDREQ_28_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_29[29] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 29
 * - 0b1 - Enable asynchronous DMA request for channel 29
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_29 field. */
#define DMA_RD_EARS_EDREQ_29(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_29_MASK) >> DMA_EARS_EDREQ_29_SHIFT)
#define DMA_BRD_EARS_EDREQ_29(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_29_SHIFT, DMA_EARS_EDREQ_29_WIDTH))

/*! @brief Set the EDREQ_29 field to a new value. */
#define DMA_WR_EARS_EDREQ_29(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_29_MASK, DMA_EARS_EDREQ_29(value)))
#define DMA_BWR_EARS_EDREQ_29(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_29_SHIFT), DMA_EARS_EDREQ_29_SHIFT, DMA_EARS_EDREQ_29_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_30[30] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 30
 * - 0b1 - Enable asynchronous DMA request for channel 30
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_30 field. */
#define DMA_RD_EARS_EDREQ_30(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_30_MASK) >> DMA_EARS_EDREQ_30_SHIFT)
#define DMA_BRD_EARS_EDREQ_30(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_30_SHIFT, DMA_EARS_EDREQ_30_WIDTH))

/*! @brief Set the EDREQ_30 field to a new value. */
#define DMA_WR_EARS_EDREQ_30(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_30_MASK, DMA_EARS_EDREQ_30(value)))
#define DMA_BWR_EARS_EDREQ_30(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_30_SHIFT), DMA_EARS_EDREQ_30_SHIFT, DMA_EARS_EDREQ_30_WIDTH))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_31[31] (RW)
 *
 * Values:
 * - 0b0 - Disable asynchronous DMA request for channel 31
 * - 0b1 - Enable asynchronous DMA request for channel 31
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_31 field. */
#define DMA_RD_EARS_EDREQ_31(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_31_MASK) >> DMA_EARS_EDREQ_31_SHIFT)
#define DMA_BRD_EARS_EDREQ_31(base) (BME_UBFX32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_31_SHIFT, DMA_EARS_EDREQ_31_WIDTH))

/*! @brief Set the EDREQ_31 field to a new value. */
#define DMA_WR_EARS_EDREQ_31(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_31_MASK, DMA_EARS_EDREQ_31(value)))
#define DMA_BWR_EARS_EDREQ_31(base, value) (BME_BFI32(&DMA_EARS_REG(base), ((uint32_t)(value) << DMA_EARS_EDREQ_31_SHIFT), DMA_EARS_EDREQ_31_SHIFT, DMA_EARS_EDREQ_31_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI3 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
/*@{*/
#define DMA_RD_DCHPRI3(base)     (DMA_DCHPRI3_REG(base))
#define DMA_WR_DCHPRI3(base, value) (DMA_DCHPRI3_REG(base) = (value))
#define DMA_RMW_DCHPRI3(base, mask, value) (DMA_WR_DCHPRI3(base, (DMA_RD_DCHPRI3(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI3(base, value) (BME_OR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI3(base, value) (BME_AND8(&DMA_DCHPRI3_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI3(base, value) (BME_XOR8(&DMA_DCHPRI3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*!
 * @name Register DMA_DCHPRI3, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_CHPRI field. */
#define DMA_RD_DCHPRI3_CHPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_CHPRI_MASK) >> DMA_DCHPRI3_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI3_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI3_CHPRI(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_CHPRI_MASK, DMA_DCHPRI3_CHPRI(value)))
#define DMA_BWR_DCHPRI3_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_CHPRI_SHIFT), DMA_DCHPRI3_CHPRI_SHIFT, DMA_DCHPRI3_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_GRPPRI field. */
#define DMA_RD_DCHPRI3_GRPPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_GRPPRI_MASK) >> DMA_DCHPRI3_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI3_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_GRPPRI_SHIFT, DMA_DCHPRI3_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_DPA field. */
#define DMA_RD_DCHPRI3_DPA(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_DPA_MASK) >> DMA_DCHPRI3_DPA_SHIFT)
#define DMA_BRD_DCHPRI3_DPA(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI3_DPA(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_DPA_MASK, DMA_DCHPRI3_DPA(value)))
#define DMA_BWR_DCHPRI3_DPA(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_DPA_SHIFT), DMA_DCHPRI3_DPA_SHIFT, DMA_DCHPRI3_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_ECP field. */
#define DMA_RD_DCHPRI3_ECP(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_ECP_MASK) >> DMA_DCHPRI3_ECP_SHIFT)
#define DMA_BRD_DCHPRI3_ECP(base) (BME_UBFX8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI3_ECP(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_ECP_MASK, DMA_DCHPRI3_ECP(value)))
#define DMA_BWR_DCHPRI3_ECP(base, value) (BME_BFI8(&DMA_DCHPRI3_REG(base), ((uint8_t)(value) << DMA_DCHPRI3_ECP_SHIFT), DMA_DCHPRI3_ECP_SHIFT, DMA_DCHPRI3_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI2 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
/*@{*/
#define DMA_RD_DCHPRI2(base)     (DMA_DCHPRI2_REG(base))
#define DMA_WR_DCHPRI2(base, value) (DMA_DCHPRI2_REG(base) = (value))
#define DMA_RMW_DCHPRI2(base, mask, value) (DMA_WR_DCHPRI2(base, (DMA_RD_DCHPRI2(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI2(base, value) (BME_OR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI2(base, value) (BME_AND8(&DMA_DCHPRI2_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI2(base, value) (BME_XOR8(&DMA_DCHPRI2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*!
 * @name Register DMA_DCHPRI2, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_CHPRI field. */
#define DMA_RD_DCHPRI2_CHPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_CHPRI_MASK) >> DMA_DCHPRI2_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI2_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI2_CHPRI(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_CHPRI_MASK, DMA_DCHPRI2_CHPRI(value)))
#define DMA_BWR_DCHPRI2_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_CHPRI_SHIFT), DMA_DCHPRI2_CHPRI_SHIFT, DMA_DCHPRI2_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_GRPPRI field. */
#define DMA_RD_DCHPRI2_GRPPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_GRPPRI_MASK) >> DMA_DCHPRI2_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI2_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_GRPPRI_SHIFT, DMA_DCHPRI2_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_DPA field. */
#define DMA_RD_DCHPRI2_DPA(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_DPA_MASK) >> DMA_DCHPRI2_DPA_SHIFT)
#define DMA_BRD_DCHPRI2_DPA(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI2_DPA(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_DPA_MASK, DMA_DCHPRI2_DPA(value)))
#define DMA_BWR_DCHPRI2_DPA(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_DPA_SHIFT), DMA_DCHPRI2_DPA_SHIFT, DMA_DCHPRI2_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_ECP field. */
#define DMA_RD_DCHPRI2_ECP(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_ECP_MASK) >> DMA_DCHPRI2_ECP_SHIFT)
#define DMA_BRD_DCHPRI2_ECP(base) (BME_UBFX8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI2_ECP(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_ECP_MASK, DMA_DCHPRI2_ECP(value)))
#define DMA_BWR_DCHPRI2_ECP(base, value) (BME_BFI8(&DMA_DCHPRI2_REG(base), ((uint8_t)(value) << DMA_DCHPRI2_ECP_SHIFT), DMA_DCHPRI2_ECP_SHIFT, DMA_DCHPRI2_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI1 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
/*@{*/
#define DMA_RD_DCHPRI1(base)     (DMA_DCHPRI1_REG(base))
#define DMA_WR_DCHPRI1(base, value) (DMA_DCHPRI1_REG(base) = (value))
#define DMA_RMW_DCHPRI1(base, mask, value) (DMA_WR_DCHPRI1(base, (DMA_RD_DCHPRI1(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI1(base, value) (BME_OR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI1(base, value) (BME_AND8(&DMA_DCHPRI1_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI1(base, value) (BME_XOR8(&DMA_DCHPRI1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*!
 * @name Register DMA_DCHPRI1, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_CHPRI field. */
#define DMA_RD_DCHPRI1_CHPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_CHPRI_MASK) >> DMA_DCHPRI1_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI1_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI1_CHPRI(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_CHPRI_MASK, DMA_DCHPRI1_CHPRI(value)))
#define DMA_BWR_DCHPRI1_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_CHPRI_SHIFT), DMA_DCHPRI1_CHPRI_SHIFT, DMA_DCHPRI1_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_GRPPRI field. */
#define DMA_RD_DCHPRI1_GRPPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_GRPPRI_MASK) >> DMA_DCHPRI1_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI1_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_GRPPRI_SHIFT, DMA_DCHPRI1_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_DPA field. */
#define DMA_RD_DCHPRI1_DPA(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_DPA_MASK) >> DMA_DCHPRI1_DPA_SHIFT)
#define DMA_BRD_DCHPRI1_DPA(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI1_DPA(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_DPA_MASK, DMA_DCHPRI1_DPA(value)))
#define DMA_BWR_DCHPRI1_DPA(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_DPA_SHIFT), DMA_DCHPRI1_DPA_SHIFT, DMA_DCHPRI1_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_ECP field. */
#define DMA_RD_DCHPRI1_ECP(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_ECP_MASK) >> DMA_DCHPRI1_ECP_SHIFT)
#define DMA_BRD_DCHPRI1_ECP(base) (BME_UBFX8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI1_ECP(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_ECP_MASK, DMA_DCHPRI1_ECP(value)))
#define DMA_BWR_DCHPRI1_ECP(base, value) (BME_BFI8(&DMA_DCHPRI1_REG(base), ((uint8_t)(value) << DMA_DCHPRI1_ECP_SHIFT), DMA_DCHPRI1_ECP_SHIFT, DMA_DCHPRI1_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI0 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
/*@{*/
#define DMA_RD_DCHPRI0(base)     (DMA_DCHPRI0_REG(base))
#define DMA_WR_DCHPRI0(base, value) (DMA_DCHPRI0_REG(base) = (value))
#define DMA_RMW_DCHPRI0(base, mask, value) (DMA_WR_DCHPRI0(base, (DMA_RD_DCHPRI0(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI0(base, value) (BME_OR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI0(base, value) (BME_AND8(&DMA_DCHPRI0_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI0(base, value) (BME_XOR8(&DMA_DCHPRI0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*!
 * @name Register DMA_DCHPRI0, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_CHPRI field. */
#define DMA_RD_DCHPRI0_CHPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI0_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI0_CHPRI(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_CHPRI_MASK, DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRI0_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_GRPPRI field. */
#define DMA_RD_DCHPRI0_GRPPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_GRPPRI_MASK) >> DMA_DCHPRI0_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI0_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_GRPPRI_SHIFT, DMA_DCHPRI0_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_DPA field. */
#define DMA_RD_DCHPRI0_DPA(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRI0_DPA(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI0_DPA(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_DPA_MASK, DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRI0_DPA(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_ECP field. */
#define DMA_RD_DCHPRI0_ECP(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRI0_ECP(base) (BME_UBFX8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI0_ECP(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_ECP_MASK, DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRI0_ECP(base, value) (BME_BFI8(&DMA_DCHPRI0_REG(base), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI7 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI7 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI7 register
 */
/*@{*/
#define DMA_RD_DCHPRI7(base)     (DMA_DCHPRI7_REG(base))
#define DMA_WR_DCHPRI7(base, value) (DMA_DCHPRI7_REG(base) = (value))
#define DMA_RMW_DCHPRI7(base, mask, value) (DMA_WR_DCHPRI7(base, (DMA_RD_DCHPRI7(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI7(base, value) (BME_OR8(&DMA_DCHPRI7_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI7(base, value) (BME_AND8(&DMA_DCHPRI7_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI7(base, value) (BME_XOR8(&DMA_DCHPRI7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI7 bitfields
 */

/*!
 * @name Register DMA_DCHPRI7, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_CHPRI field. */
#define DMA_RD_DCHPRI7_CHPRI(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_CHPRI_MASK) >> DMA_DCHPRI7_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI7_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_CHPRI_SHIFT, DMA_DCHPRI7_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI7_CHPRI(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_CHPRI_MASK, DMA_DCHPRI7_CHPRI(value)))
#define DMA_BWR_DCHPRI7_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_CHPRI_SHIFT), DMA_DCHPRI7_CHPRI_SHIFT, DMA_DCHPRI7_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_GRPPRI field. */
#define DMA_RD_DCHPRI7_GRPPRI(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_GRPPRI_MASK) >> DMA_DCHPRI7_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI7_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_GRPPRI_SHIFT, DMA_DCHPRI7_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_DPA field. */
#define DMA_RD_DCHPRI7_DPA(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_DPA_MASK) >> DMA_DCHPRI7_DPA_SHIFT)
#define DMA_BRD_DCHPRI7_DPA(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_DPA_SHIFT, DMA_DCHPRI7_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI7_DPA(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_DPA_MASK, DMA_DCHPRI7_DPA(value)))
#define DMA_BWR_DCHPRI7_DPA(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_DPA_SHIFT), DMA_DCHPRI7_DPA_SHIFT, DMA_DCHPRI7_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_ECP field. */
#define DMA_RD_DCHPRI7_ECP(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_ECP_MASK) >> DMA_DCHPRI7_ECP_SHIFT)
#define DMA_BRD_DCHPRI7_ECP(base) (BME_UBFX8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_ECP_SHIFT, DMA_DCHPRI7_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI7_ECP(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_ECP_MASK, DMA_DCHPRI7_ECP(value)))
#define DMA_BWR_DCHPRI7_ECP(base, value) (BME_BFI8(&DMA_DCHPRI7_REG(base), ((uint8_t)(value) << DMA_DCHPRI7_ECP_SHIFT), DMA_DCHPRI7_ECP_SHIFT, DMA_DCHPRI7_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI6 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI6 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI6 register
 */
/*@{*/
#define DMA_RD_DCHPRI6(base)     (DMA_DCHPRI6_REG(base))
#define DMA_WR_DCHPRI6(base, value) (DMA_DCHPRI6_REG(base) = (value))
#define DMA_RMW_DCHPRI6(base, mask, value) (DMA_WR_DCHPRI6(base, (DMA_RD_DCHPRI6(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI6(base, value) (BME_OR8(&DMA_DCHPRI6_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI6(base, value) (BME_AND8(&DMA_DCHPRI6_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI6(base, value) (BME_XOR8(&DMA_DCHPRI6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI6 bitfields
 */

/*!
 * @name Register DMA_DCHPRI6, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_CHPRI field. */
#define DMA_RD_DCHPRI6_CHPRI(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_CHPRI_MASK) >> DMA_DCHPRI6_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI6_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_CHPRI_SHIFT, DMA_DCHPRI6_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI6_CHPRI(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_CHPRI_MASK, DMA_DCHPRI6_CHPRI(value)))
#define DMA_BWR_DCHPRI6_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_CHPRI_SHIFT), DMA_DCHPRI6_CHPRI_SHIFT, DMA_DCHPRI6_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_GRPPRI field. */
#define DMA_RD_DCHPRI6_GRPPRI(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_GRPPRI_MASK) >> DMA_DCHPRI6_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI6_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_GRPPRI_SHIFT, DMA_DCHPRI6_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_DPA field. */
#define DMA_RD_DCHPRI6_DPA(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_DPA_MASK) >> DMA_DCHPRI6_DPA_SHIFT)
#define DMA_BRD_DCHPRI6_DPA(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_DPA_SHIFT, DMA_DCHPRI6_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI6_DPA(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_DPA_MASK, DMA_DCHPRI6_DPA(value)))
#define DMA_BWR_DCHPRI6_DPA(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_DPA_SHIFT), DMA_DCHPRI6_DPA_SHIFT, DMA_DCHPRI6_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_ECP field. */
#define DMA_RD_DCHPRI6_ECP(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_ECP_MASK) >> DMA_DCHPRI6_ECP_SHIFT)
#define DMA_BRD_DCHPRI6_ECP(base) (BME_UBFX8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_ECP_SHIFT, DMA_DCHPRI6_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI6_ECP(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_ECP_MASK, DMA_DCHPRI6_ECP(value)))
#define DMA_BWR_DCHPRI6_ECP(base, value) (BME_BFI8(&DMA_DCHPRI6_REG(base), ((uint8_t)(value) << DMA_DCHPRI6_ECP_SHIFT), DMA_DCHPRI6_ECP_SHIFT, DMA_DCHPRI6_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI5 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI5 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI5 register
 */
/*@{*/
#define DMA_RD_DCHPRI5(base)     (DMA_DCHPRI5_REG(base))
#define DMA_WR_DCHPRI5(base, value) (DMA_DCHPRI5_REG(base) = (value))
#define DMA_RMW_DCHPRI5(base, mask, value) (DMA_WR_DCHPRI5(base, (DMA_RD_DCHPRI5(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI5(base, value) (BME_OR8(&DMA_DCHPRI5_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI5(base, value) (BME_AND8(&DMA_DCHPRI5_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI5(base, value) (BME_XOR8(&DMA_DCHPRI5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI5 bitfields
 */

/*!
 * @name Register DMA_DCHPRI5, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_CHPRI field. */
#define DMA_RD_DCHPRI5_CHPRI(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_CHPRI_MASK) >> DMA_DCHPRI5_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI5_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_CHPRI_SHIFT, DMA_DCHPRI5_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI5_CHPRI(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_CHPRI_MASK, DMA_DCHPRI5_CHPRI(value)))
#define DMA_BWR_DCHPRI5_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_CHPRI_SHIFT), DMA_DCHPRI5_CHPRI_SHIFT, DMA_DCHPRI5_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_GRPPRI field. */
#define DMA_RD_DCHPRI5_GRPPRI(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_GRPPRI_MASK) >> DMA_DCHPRI5_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI5_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_GRPPRI_SHIFT, DMA_DCHPRI5_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_DPA field. */
#define DMA_RD_DCHPRI5_DPA(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_DPA_MASK) >> DMA_DCHPRI5_DPA_SHIFT)
#define DMA_BRD_DCHPRI5_DPA(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_DPA_SHIFT, DMA_DCHPRI5_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI5_DPA(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_DPA_MASK, DMA_DCHPRI5_DPA(value)))
#define DMA_BWR_DCHPRI5_DPA(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_DPA_SHIFT), DMA_DCHPRI5_DPA_SHIFT, DMA_DCHPRI5_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_ECP field. */
#define DMA_RD_DCHPRI5_ECP(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_ECP_MASK) >> DMA_DCHPRI5_ECP_SHIFT)
#define DMA_BRD_DCHPRI5_ECP(base) (BME_UBFX8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_ECP_SHIFT, DMA_DCHPRI5_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI5_ECP(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_ECP_MASK, DMA_DCHPRI5_ECP(value)))
#define DMA_BWR_DCHPRI5_ECP(base, value) (BME_BFI8(&DMA_DCHPRI5_REG(base), ((uint8_t)(value) << DMA_DCHPRI5_ECP_SHIFT), DMA_DCHPRI5_ECP_SHIFT, DMA_DCHPRI5_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI4 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI4 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI4 register
 */
/*@{*/
#define DMA_RD_DCHPRI4(base)     (DMA_DCHPRI4_REG(base))
#define DMA_WR_DCHPRI4(base, value) (DMA_DCHPRI4_REG(base) = (value))
#define DMA_RMW_DCHPRI4(base, mask, value) (DMA_WR_DCHPRI4(base, (DMA_RD_DCHPRI4(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI4(base, value) (BME_OR8(&DMA_DCHPRI4_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI4(base, value) (BME_AND8(&DMA_DCHPRI4_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI4(base, value) (BME_XOR8(&DMA_DCHPRI4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI4 bitfields
 */

/*!
 * @name Register DMA_DCHPRI4, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_CHPRI field. */
#define DMA_RD_DCHPRI4_CHPRI(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_CHPRI_MASK) >> DMA_DCHPRI4_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI4_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_CHPRI_SHIFT, DMA_DCHPRI4_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI4_CHPRI(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_CHPRI_MASK, DMA_DCHPRI4_CHPRI(value)))
#define DMA_BWR_DCHPRI4_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_CHPRI_SHIFT), DMA_DCHPRI4_CHPRI_SHIFT, DMA_DCHPRI4_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_GRPPRI field. */
#define DMA_RD_DCHPRI4_GRPPRI(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_GRPPRI_MASK) >> DMA_DCHPRI4_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI4_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_GRPPRI_SHIFT, DMA_DCHPRI4_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_DPA field. */
#define DMA_RD_DCHPRI4_DPA(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_DPA_MASK) >> DMA_DCHPRI4_DPA_SHIFT)
#define DMA_BRD_DCHPRI4_DPA(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_DPA_SHIFT, DMA_DCHPRI4_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI4_DPA(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_DPA_MASK, DMA_DCHPRI4_DPA(value)))
#define DMA_BWR_DCHPRI4_DPA(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_DPA_SHIFT), DMA_DCHPRI4_DPA_SHIFT, DMA_DCHPRI4_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_ECP field. */
#define DMA_RD_DCHPRI4_ECP(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_ECP_MASK) >> DMA_DCHPRI4_ECP_SHIFT)
#define DMA_BRD_DCHPRI4_ECP(base) (BME_UBFX8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_ECP_SHIFT, DMA_DCHPRI4_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI4_ECP(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_ECP_MASK, DMA_DCHPRI4_ECP(value)))
#define DMA_BWR_DCHPRI4_ECP(base, value) (BME_BFI8(&DMA_DCHPRI4_REG(base), ((uint8_t)(value) << DMA_DCHPRI4_ECP_SHIFT), DMA_DCHPRI4_ECP_SHIFT, DMA_DCHPRI4_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI11 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI11 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI11 register
 */
/*@{*/
#define DMA_RD_DCHPRI11(base)    (DMA_DCHPRI11_REG(base))
#define DMA_WR_DCHPRI11(base, value) (DMA_DCHPRI11_REG(base) = (value))
#define DMA_RMW_DCHPRI11(base, mask, value) (DMA_WR_DCHPRI11(base, (DMA_RD_DCHPRI11(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI11(base, value) (BME_OR8(&DMA_DCHPRI11_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI11(base, value) (BME_AND8(&DMA_DCHPRI11_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI11(base, value) (BME_XOR8(&DMA_DCHPRI11_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI11 bitfields
 */

/*!
 * @name Register DMA_DCHPRI11, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_CHPRI field. */
#define DMA_RD_DCHPRI11_CHPRI(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_CHPRI_MASK) >> DMA_DCHPRI11_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI11_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_CHPRI_SHIFT, DMA_DCHPRI11_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI11_CHPRI(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_CHPRI_MASK, DMA_DCHPRI11_CHPRI(value)))
#define DMA_BWR_DCHPRI11_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI11_REG(base), ((uint8_t)(value) << DMA_DCHPRI11_CHPRI_SHIFT), DMA_DCHPRI11_CHPRI_SHIFT, DMA_DCHPRI11_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI11, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_GRPPRI field. */
#define DMA_RD_DCHPRI11_GRPPRI(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_GRPPRI_MASK) >> DMA_DCHPRI11_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI11_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_GRPPRI_SHIFT, DMA_DCHPRI11_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI11, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_DPA field. */
#define DMA_RD_DCHPRI11_DPA(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_DPA_MASK) >> DMA_DCHPRI11_DPA_SHIFT)
#define DMA_BRD_DCHPRI11_DPA(base) (BME_UBFX8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_DPA_SHIFT, DMA_DCHPRI11_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI11_DPA(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_DPA_MASK, DMA_DCHPRI11_DPA(value)))
#define DMA_BWR_DCHPRI11_DPA(base, value) (BME_BFI8(&DMA_DCHPRI11_REG(base), ((uint8_t)(value) << DMA_DCHPRI11_DPA_SHIFT), DMA_DCHPRI11_DPA_SHIFT, DMA_DCHPRI11_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI11, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_ECP field. */
#define DMA_RD_DCHPRI11_ECP(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_ECP_MASK) >> DMA_DCHPRI11_ECP_SHIFT)
#define DMA_BRD_DCHPRI11_ECP(base) (BME_UBFX8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_ECP_SHIFT, DMA_DCHPRI11_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI11_ECP(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_ECP_MASK, DMA_DCHPRI11_ECP(value)))
#define DMA_BWR_DCHPRI11_ECP(base, value) (BME_BFI8(&DMA_DCHPRI11_REG(base), ((uint8_t)(value) << DMA_DCHPRI11_ECP_SHIFT), DMA_DCHPRI11_ECP_SHIFT, DMA_DCHPRI11_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI10 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI10 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI10 register
 */
/*@{*/
#define DMA_RD_DCHPRI10(base)    (DMA_DCHPRI10_REG(base))
#define DMA_WR_DCHPRI10(base, value) (DMA_DCHPRI10_REG(base) = (value))
#define DMA_RMW_DCHPRI10(base, mask, value) (DMA_WR_DCHPRI10(base, (DMA_RD_DCHPRI10(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI10(base, value) (BME_OR8(&DMA_DCHPRI10_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI10(base, value) (BME_AND8(&DMA_DCHPRI10_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI10(base, value) (BME_XOR8(&DMA_DCHPRI10_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI10 bitfields
 */

/*!
 * @name Register DMA_DCHPRI10, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_CHPRI field. */
#define DMA_RD_DCHPRI10_CHPRI(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_CHPRI_MASK) >> DMA_DCHPRI10_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI10_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_CHPRI_SHIFT, DMA_DCHPRI10_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI10_CHPRI(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_CHPRI_MASK, DMA_DCHPRI10_CHPRI(value)))
#define DMA_BWR_DCHPRI10_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI10_REG(base), ((uint8_t)(value) << DMA_DCHPRI10_CHPRI_SHIFT), DMA_DCHPRI10_CHPRI_SHIFT, DMA_DCHPRI10_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI10, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_GRPPRI field. */
#define DMA_RD_DCHPRI10_GRPPRI(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_GRPPRI_MASK) >> DMA_DCHPRI10_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI10_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_GRPPRI_SHIFT, DMA_DCHPRI10_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI10, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_DPA field. */
#define DMA_RD_DCHPRI10_DPA(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_DPA_MASK) >> DMA_DCHPRI10_DPA_SHIFT)
#define DMA_BRD_DCHPRI10_DPA(base) (BME_UBFX8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_DPA_SHIFT, DMA_DCHPRI10_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI10_DPA(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_DPA_MASK, DMA_DCHPRI10_DPA(value)))
#define DMA_BWR_DCHPRI10_DPA(base, value) (BME_BFI8(&DMA_DCHPRI10_REG(base), ((uint8_t)(value) << DMA_DCHPRI10_DPA_SHIFT), DMA_DCHPRI10_DPA_SHIFT, DMA_DCHPRI10_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI10, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_ECP field. */
#define DMA_RD_DCHPRI10_ECP(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_ECP_MASK) >> DMA_DCHPRI10_ECP_SHIFT)
#define DMA_BRD_DCHPRI10_ECP(base) (BME_UBFX8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_ECP_SHIFT, DMA_DCHPRI10_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI10_ECP(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_ECP_MASK, DMA_DCHPRI10_ECP(value)))
#define DMA_BWR_DCHPRI10_ECP(base, value) (BME_BFI8(&DMA_DCHPRI10_REG(base), ((uint8_t)(value) << DMA_DCHPRI10_ECP_SHIFT), DMA_DCHPRI10_ECP_SHIFT, DMA_DCHPRI10_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI9 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI9 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI9 register
 */
/*@{*/
#define DMA_RD_DCHPRI9(base)     (DMA_DCHPRI9_REG(base))
#define DMA_WR_DCHPRI9(base, value) (DMA_DCHPRI9_REG(base) = (value))
#define DMA_RMW_DCHPRI9(base, mask, value) (DMA_WR_DCHPRI9(base, (DMA_RD_DCHPRI9(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI9(base, value) (BME_OR8(&DMA_DCHPRI9_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI9(base, value) (BME_AND8(&DMA_DCHPRI9_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI9(base, value) (BME_XOR8(&DMA_DCHPRI9_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI9 bitfields
 */

/*!
 * @name Register DMA_DCHPRI9, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_CHPRI field. */
#define DMA_RD_DCHPRI9_CHPRI(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_CHPRI_MASK) >> DMA_DCHPRI9_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI9_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_CHPRI_SHIFT, DMA_DCHPRI9_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI9_CHPRI(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_CHPRI_MASK, DMA_DCHPRI9_CHPRI(value)))
#define DMA_BWR_DCHPRI9_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI9_REG(base), ((uint8_t)(value) << DMA_DCHPRI9_CHPRI_SHIFT), DMA_DCHPRI9_CHPRI_SHIFT, DMA_DCHPRI9_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI9, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_GRPPRI field. */
#define DMA_RD_DCHPRI9_GRPPRI(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_GRPPRI_MASK) >> DMA_DCHPRI9_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI9_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_GRPPRI_SHIFT, DMA_DCHPRI9_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI9, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_DPA field. */
#define DMA_RD_DCHPRI9_DPA(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_DPA_MASK) >> DMA_DCHPRI9_DPA_SHIFT)
#define DMA_BRD_DCHPRI9_DPA(base) (BME_UBFX8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_DPA_SHIFT, DMA_DCHPRI9_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI9_DPA(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_DPA_MASK, DMA_DCHPRI9_DPA(value)))
#define DMA_BWR_DCHPRI9_DPA(base, value) (BME_BFI8(&DMA_DCHPRI9_REG(base), ((uint8_t)(value) << DMA_DCHPRI9_DPA_SHIFT), DMA_DCHPRI9_DPA_SHIFT, DMA_DCHPRI9_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI9, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_ECP field. */
#define DMA_RD_DCHPRI9_ECP(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_ECP_MASK) >> DMA_DCHPRI9_ECP_SHIFT)
#define DMA_BRD_DCHPRI9_ECP(base) (BME_UBFX8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_ECP_SHIFT, DMA_DCHPRI9_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI9_ECP(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_ECP_MASK, DMA_DCHPRI9_ECP(value)))
#define DMA_BWR_DCHPRI9_ECP(base, value) (BME_BFI8(&DMA_DCHPRI9_REG(base), ((uint8_t)(value) << DMA_DCHPRI9_ECP_SHIFT), DMA_DCHPRI9_ECP_SHIFT, DMA_DCHPRI9_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI8 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI8 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI8 register
 */
/*@{*/
#define DMA_RD_DCHPRI8(base)     (DMA_DCHPRI8_REG(base))
#define DMA_WR_DCHPRI8(base, value) (DMA_DCHPRI8_REG(base) = (value))
#define DMA_RMW_DCHPRI8(base, mask, value) (DMA_WR_DCHPRI8(base, (DMA_RD_DCHPRI8(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI8(base, value) (BME_OR8(&DMA_DCHPRI8_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI8(base, value) (BME_AND8(&DMA_DCHPRI8_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI8(base, value) (BME_XOR8(&DMA_DCHPRI8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI8 bitfields
 */

/*!
 * @name Register DMA_DCHPRI8, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_CHPRI field. */
#define DMA_RD_DCHPRI8_CHPRI(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_CHPRI_MASK) >> DMA_DCHPRI8_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI8_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_CHPRI_SHIFT, DMA_DCHPRI8_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI8_CHPRI(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_CHPRI_MASK, DMA_DCHPRI8_CHPRI(value)))
#define DMA_BWR_DCHPRI8_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI8_REG(base), ((uint8_t)(value) << DMA_DCHPRI8_CHPRI_SHIFT), DMA_DCHPRI8_CHPRI_SHIFT, DMA_DCHPRI8_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI8, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_GRPPRI field. */
#define DMA_RD_DCHPRI8_GRPPRI(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_GRPPRI_MASK) >> DMA_DCHPRI8_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI8_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_GRPPRI_SHIFT, DMA_DCHPRI8_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI8, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_DPA field. */
#define DMA_RD_DCHPRI8_DPA(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_DPA_MASK) >> DMA_DCHPRI8_DPA_SHIFT)
#define DMA_BRD_DCHPRI8_DPA(base) (BME_UBFX8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_DPA_SHIFT, DMA_DCHPRI8_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI8_DPA(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_DPA_MASK, DMA_DCHPRI8_DPA(value)))
#define DMA_BWR_DCHPRI8_DPA(base, value) (BME_BFI8(&DMA_DCHPRI8_REG(base), ((uint8_t)(value) << DMA_DCHPRI8_DPA_SHIFT), DMA_DCHPRI8_DPA_SHIFT, DMA_DCHPRI8_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI8, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_ECP field. */
#define DMA_RD_DCHPRI8_ECP(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_ECP_MASK) >> DMA_DCHPRI8_ECP_SHIFT)
#define DMA_BRD_DCHPRI8_ECP(base) (BME_UBFX8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_ECP_SHIFT, DMA_DCHPRI8_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI8_ECP(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_ECP_MASK, DMA_DCHPRI8_ECP(value)))
#define DMA_BWR_DCHPRI8_ECP(base, value) (BME_BFI8(&DMA_DCHPRI8_REG(base), ((uint8_t)(value) << DMA_DCHPRI8_ECP_SHIFT), DMA_DCHPRI8_ECP_SHIFT, DMA_DCHPRI8_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI15 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI15 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI15 register
 */
/*@{*/
#define DMA_RD_DCHPRI15(base)    (DMA_DCHPRI15_REG(base))
#define DMA_WR_DCHPRI15(base, value) (DMA_DCHPRI15_REG(base) = (value))
#define DMA_RMW_DCHPRI15(base, mask, value) (DMA_WR_DCHPRI15(base, (DMA_RD_DCHPRI15(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI15(base, value) (BME_OR8(&DMA_DCHPRI15_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI15(base, value) (BME_AND8(&DMA_DCHPRI15_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI15(base, value) (BME_XOR8(&DMA_DCHPRI15_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI15 bitfields
 */

/*!
 * @name Register DMA_DCHPRI15, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_CHPRI field. */
#define DMA_RD_DCHPRI15_CHPRI(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_CHPRI_MASK) >> DMA_DCHPRI15_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI15_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_CHPRI_SHIFT, DMA_DCHPRI15_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI15_CHPRI(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_CHPRI_MASK, DMA_DCHPRI15_CHPRI(value)))
#define DMA_BWR_DCHPRI15_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI15_REG(base), ((uint8_t)(value) << DMA_DCHPRI15_CHPRI_SHIFT), DMA_DCHPRI15_CHPRI_SHIFT, DMA_DCHPRI15_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI15, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_GRPPRI field. */
#define DMA_RD_DCHPRI15_GRPPRI(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_GRPPRI_MASK) >> DMA_DCHPRI15_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI15_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_GRPPRI_SHIFT, DMA_DCHPRI15_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI15, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_DPA field. */
#define DMA_RD_DCHPRI15_DPA(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_DPA_MASK) >> DMA_DCHPRI15_DPA_SHIFT)
#define DMA_BRD_DCHPRI15_DPA(base) (BME_UBFX8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_DPA_SHIFT, DMA_DCHPRI15_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI15_DPA(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_DPA_MASK, DMA_DCHPRI15_DPA(value)))
#define DMA_BWR_DCHPRI15_DPA(base, value) (BME_BFI8(&DMA_DCHPRI15_REG(base), ((uint8_t)(value) << DMA_DCHPRI15_DPA_SHIFT), DMA_DCHPRI15_DPA_SHIFT, DMA_DCHPRI15_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI15, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_ECP field. */
#define DMA_RD_DCHPRI15_ECP(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_ECP_MASK) >> DMA_DCHPRI15_ECP_SHIFT)
#define DMA_BRD_DCHPRI15_ECP(base) (BME_UBFX8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_ECP_SHIFT, DMA_DCHPRI15_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI15_ECP(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_ECP_MASK, DMA_DCHPRI15_ECP(value)))
#define DMA_BWR_DCHPRI15_ECP(base, value) (BME_BFI8(&DMA_DCHPRI15_REG(base), ((uint8_t)(value) << DMA_DCHPRI15_ECP_SHIFT), DMA_DCHPRI15_ECP_SHIFT, DMA_DCHPRI15_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI14 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI14 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI14 register
 */
/*@{*/
#define DMA_RD_DCHPRI14(base)    (DMA_DCHPRI14_REG(base))
#define DMA_WR_DCHPRI14(base, value) (DMA_DCHPRI14_REG(base) = (value))
#define DMA_RMW_DCHPRI14(base, mask, value) (DMA_WR_DCHPRI14(base, (DMA_RD_DCHPRI14(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI14(base, value) (BME_OR8(&DMA_DCHPRI14_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI14(base, value) (BME_AND8(&DMA_DCHPRI14_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI14(base, value) (BME_XOR8(&DMA_DCHPRI14_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI14 bitfields
 */

/*!
 * @name Register DMA_DCHPRI14, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_CHPRI field. */
#define DMA_RD_DCHPRI14_CHPRI(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_CHPRI_MASK) >> DMA_DCHPRI14_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI14_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_CHPRI_SHIFT, DMA_DCHPRI14_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI14_CHPRI(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_CHPRI_MASK, DMA_DCHPRI14_CHPRI(value)))
#define DMA_BWR_DCHPRI14_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI14_REG(base), ((uint8_t)(value) << DMA_DCHPRI14_CHPRI_SHIFT), DMA_DCHPRI14_CHPRI_SHIFT, DMA_DCHPRI14_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI14, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_GRPPRI field. */
#define DMA_RD_DCHPRI14_GRPPRI(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_GRPPRI_MASK) >> DMA_DCHPRI14_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI14_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_GRPPRI_SHIFT, DMA_DCHPRI14_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI14, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_DPA field. */
#define DMA_RD_DCHPRI14_DPA(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_DPA_MASK) >> DMA_DCHPRI14_DPA_SHIFT)
#define DMA_BRD_DCHPRI14_DPA(base) (BME_UBFX8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_DPA_SHIFT, DMA_DCHPRI14_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI14_DPA(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_DPA_MASK, DMA_DCHPRI14_DPA(value)))
#define DMA_BWR_DCHPRI14_DPA(base, value) (BME_BFI8(&DMA_DCHPRI14_REG(base), ((uint8_t)(value) << DMA_DCHPRI14_DPA_SHIFT), DMA_DCHPRI14_DPA_SHIFT, DMA_DCHPRI14_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI14, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_ECP field. */
#define DMA_RD_DCHPRI14_ECP(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_ECP_MASK) >> DMA_DCHPRI14_ECP_SHIFT)
#define DMA_BRD_DCHPRI14_ECP(base) (BME_UBFX8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_ECP_SHIFT, DMA_DCHPRI14_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI14_ECP(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_ECP_MASK, DMA_DCHPRI14_ECP(value)))
#define DMA_BWR_DCHPRI14_ECP(base, value) (BME_BFI8(&DMA_DCHPRI14_REG(base), ((uint8_t)(value) << DMA_DCHPRI14_ECP_SHIFT), DMA_DCHPRI14_ECP_SHIFT, DMA_DCHPRI14_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI13 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI13 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI13 register
 */
/*@{*/
#define DMA_RD_DCHPRI13(base)    (DMA_DCHPRI13_REG(base))
#define DMA_WR_DCHPRI13(base, value) (DMA_DCHPRI13_REG(base) = (value))
#define DMA_RMW_DCHPRI13(base, mask, value) (DMA_WR_DCHPRI13(base, (DMA_RD_DCHPRI13(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI13(base, value) (BME_OR8(&DMA_DCHPRI13_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI13(base, value) (BME_AND8(&DMA_DCHPRI13_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI13(base, value) (BME_XOR8(&DMA_DCHPRI13_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI13 bitfields
 */

/*!
 * @name Register DMA_DCHPRI13, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_CHPRI field. */
#define DMA_RD_DCHPRI13_CHPRI(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_CHPRI_MASK) >> DMA_DCHPRI13_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI13_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_CHPRI_SHIFT, DMA_DCHPRI13_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI13_CHPRI(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_CHPRI_MASK, DMA_DCHPRI13_CHPRI(value)))
#define DMA_BWR_DCHPRI13_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI13_REG(base), ((uint8_t)(value) << DMA_DCHPRI13_CHPRI_SHIFT), DMA_DCHPRI13_CHPRI_SHIFT, DMA_DCHPRI13_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI13, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_GRPPRI field. */
#define DMA_RD_DCHPRI13_GRPPRI(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_GRPPRI_MASK) >> DMA_DCHPRI13_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI13_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_GRPPRI_SHIFT, DMA_DCHPRI13_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI13, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_DPA field. */
#define DMA_RD_DCHPRI13_DPA(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_DPA_MASK) >> DMA_DCHPRI13_DPA_SHIFT)
#define DMA_BRD_DCHPRI13_DPA(base) (BME_UBFX8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_DPA_SHIFT, DMA_DCHPRI13_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI13_DPA(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_DPA_MASK, DMA_DCHPRI13_DPA(value)))
#define DMA_BWR_DCHPRI13_DPA(base, value) (BME_BFI8(&DMA_DCHPRI13_REG(base), ((uint8_t)(value) << DMA_DCHPRI13_DPA_SHIFT), DMA_DCHPRI13_DPA_SHIFT, DMA_DCHPRI13_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI13, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_ECP field. */
#define DMA_RD_DCHPRI13_ECP(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_ECP_MASK) >> DMA_DCHPRI13_ECP_SHIFT)
#define DMA_BRD_DCHPRI13_ECP(base) (BME_UBFX8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_ECP_SHIFT, DMA_DCHPRI13_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI13_ECP(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_ECP_MASK, DMA_DCHPRI13_ECP(value)))
#define DMA_BWR_DCHPRI13_ECP(base, value) (BME_BFI8(&DMA_DCHPRI13_REG(base), ((uint8_t)(value) << DMA_DCHPRI13_ECP_SHIFT), DMA_DCHPRI13_ECP_SHIFT, DMA_DCHPRI13_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI12 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI12 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI12 register
 */
/*@{*/
#define DMA_RD_DCHPRI12(base)    (DMA_DCHPRI12_REG(base))
#define DMA_WR_DCHPRI12(base, value) (DMA_DCHPRI12_REG(base) = (value))
#define DMA_RMW_DCHPRI12(base, mask, value) (DMA_WR_DCHPRI12(base, (DMA_RD_DCHPRI12(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI12(base, value) (BME_OR8(&DMA_DCHPRI12_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI12(base, value) (BME_AND8(&DMA_DCHPRI12_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI12(base, value) (BME_XOR8(&DMA_DCHPRI12_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI12 bitfields
 */

/*!
 * @name Register DMA_DCHPRI12, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_CHPRI field. */
#define DMA_RD_DCHPRI12_CHPRI(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_CHPRI_MASK) >> DMA_DCHPRI12_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI12_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_CHPRI_SHIFT, DMA_DCHPRI12_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI12_CHPRI(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_CHPRI_MASK, DMA_DCHPRI12_CHPRI(value)))
#define DMA_BWR_DCHPRI12_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI12_REG(base), ((uint8_t)(value) << DMA_DCHPRI12_CHPRI_SHIFT), DMA_DCHPRI12_CHPRI_SHIFT, DMA_DCHPRI12_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI12, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_GRPPRI field. */
#define DMA_RD_DCHPRI12_GRPPRI(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_GRPPRI_MASK) >> DMA_DCHPRI12_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI12_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_GRPPRI_SHIFT, DMA_DCHPRI12_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI12, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_DPA field. */
#define DMA_RD_DCHPRI12_DPA(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_DPA_MASK) >> DMA_DCHPRI12_DPA_SHIFT)
#define DMA_BRD_DCHPRI12_DPA(base) (BME_UBFX8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_DPA_SHIFT, DMA_DCHPRI12_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI12_DPA(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_DPA_MASK, DMA_DCHPRI12_DPA(value)))
#define DMA_BWR_DCHPRI12_DPA(base, value) (BME_BFI8(&DMA_DCHPRI12_REG(base), ((uint8_t)(value) << DMA_DCHPRI12_DPA_SHIFT), DMA_DCHPRI12_DPA_SHIFT, DMA_DCHPRI12_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI12, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_ECP field. */
#define DMA_RD_DCHPRI12_ECP(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_ECP_MASK) >> DMA_DCHPRI12_ECP_SHIFT)
#define DMA_BRD_DCHPRI12_ECP(base) (BME_UBFX8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_ECP_SHIFT, DMA_DCHPRI12_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI12_ECP(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_ECP_MASK, DMA_DCHPRI12_ECP(value)))
#define DMA_BWR_DCHPRI12_ECP(base, value) (BME_BFI8(&DMA_DCHPRI12_REG(base), ((uint8_t)(value) << DMA_DCHPRI12_ECP_SHIFT), DMA_DCHPRI12_ECP_SHIFT, DMA_DCHPRI12_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI19 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI19 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI19 register
 */
/*@{*/
#define DMA_RD_DCHPRI19(base)    (DMA_DCHPRI19_REG(base))
#define DMA_WR_DCHPRI19(base, value) (DMA_DCHPRI19_REG(base) = (value))
#define DMA_RMW_DCHPRI19(base, mask, value) (DMA_WR_DCHPRI19(base, (DMA_RD_DCHPRI19(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI19(base, value) (BME_OR8(&DMA_DCHPRI19_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI19(base, value) (BME_AND8(&DMA_DCHPRI19_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI19(base, value) (BME_XOR8(&DMA_DCHPRI19_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI19 bitfields
 */

/*!
 * @name Register DMA_DCHPRI19, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI19_CHPRI field. */
#define DMA_RD_DCHPRI19_CHPRI(base) ((DMA_DCHPRI19_REG(base) & DMA_DCHPRI19_CHPRI_MASK) >> DMA_DCHPRI19_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI19_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI19_REG(base), DMA_DCHPRI19_CHPRI_SHIFT, DMA_DCHPRI19_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI19_CHPRI(base, value) (DMA_RMW_DCHPRI19(base, DMA_DCHPRI19_CHPRI_MASK, DMA_DCHPRI19_CHPRI(value)))
#define DMA_BWR_DCHPRI19_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI19_REG(base), ((uint8_t)(value) << DMA_DCHPRI19_CHPRI_SHIFT), DMA_DCHPRI19_CHPRI_SHIFT, DMA_DCHPRI19_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI19, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI19_GRPPRI field. */
#define DMA_RD_DCHPRI19_GRPPRI(base) ((DMA_DCHPRI19_REG(base) & DMA_DCHPRI19_GRPPRI_MASK) >> DMA_DCHPRI19_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI19_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI19_REG(base), DMA_DCHPRI19_GRPPRI_SHIFT, DMA_DCHPRI19_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI19, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI19_DPA field. */
#define DMA_RD_DCHPRI19_DPA(base) ((DMA_DCHPRI19_REG(base) & DMA_DCHPRI19_DPA_MASK) >> DMA_DCHPRI19_DPA_SHIFT)
#define DMA_BRD_DCHPRI19_DPA(base) (BME_UBFX8(&DMA_DCHPRI19_REG(base), DMA_DCHPRI19_DPA_SHIFT, DMA_DCHPRI19_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI19_DPA(base, value) (DMA_RMW_DCHPRI19(base, DMA_DCHPRI19_DPA_MASK, DMA_DCHPRI19_DPA(value)))
#define DMA_BWR_DCHPRI19_DPA(base, value) (BME_BFI8(&DMA_DCHPRI19_REG(base), ((uint8_t)(value) << DMA_DCHPRI19_DPA_SHIFT), DMA_DCHPRI19_DPA_SHIFT, DMA_DCHPRI19_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI19, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI19_ECP field. */
#define DMA_RD_DCHPRI19_ECP(base) ((DMA_DCHPRI19_REG(base) & DMA_DCHPRI19_ECP_MASK) >> DMA_DCHPRI19_ECP_SHIFT)
#define DMA_BRD_DCHPRI19_ECP(base) (BME_UBFX8(&DMA_DCHPRI19_REG(base), DMA_DCHPRI19_ECP_SHIFT, DMA_DCHPRI19_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI19_ECP(base, value) (DMA_RMW_DCHPRI19(base, DMA_DCHPRI19_ECP_MASK, DMA_DCHPRI19_ECP(value)))
#define DMA_BWR_DCHPRI19_ECP(base, value) (BME_BFI8(&DMA_DCHPRI19_REG(base), ((uint8_t)(value) << DMA_DCHPRI19_ECP_SHIFT), DMA_DCHPRI19_ECP_SHIFT, DMA_DCHPRI19_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI18 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI18 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI18 register
 */
/*@{*/
#define DMA_RD_DCHPRI18(base)    (DMA_DCHPRI18_REG(base))
#define DMA_WR_DCHPRI18(base, value) (DMA_DCHPRI18_REG(base) = (value))
#define DMA_RMW_DCHPRI18(base, mask, value) (DMA_WR_DCHPRI18(base, (DMA_RD_DCHPRI18(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI18(base, value) (BME_OR8(&DMA_DCHPRI18_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI18(base, value) (BME_AND8(&DMA_DCHPRI18_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI18(base, value) (BME_XOR8(&DMA_DCHPRI18_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI18 bitfields
 */

/*!
 * @name Register DMA_DCHPRI18, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI18_CHPRI field. */
#define DMA_RD_DCHPRI18_CHPRI(base) ((DMA_DCHPRI18_REG(base) & DMA_DCHPRI18_CHPRI_MASK) >> DMA_DCHPRI18_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI18_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI18_REG(base), DMA_DCHPRI18_CHPRI_SHIFT, DMA_DCHPRI18_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI18_CHPRI(base, value) (DMA_RMW_DCHPRI18(base, DMA_DCHPRI18_CHPRI_MASK, DMA_DCHPRI18_CHPRI(value)))
#define DMA_BWR_DCHPRI18_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI18_REG(base), ((uint8_t)(value) << DMA_DCHPRI18_CHPRI_SHIFT), DMA_DCHPRI18_CHPRI_SHIFT, DMA_DCHPRI18_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI18, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI18_GRPPRI field. */
#define DMA_RD_DCHPRI18_GRPPRI(base) ((DMA_DCHPRI18_REG(base) & DMA_DCHPRI18_GRPPRI_MASK) >> DMA_DCHPRI18_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI18_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI18_REG(base), DMA_DCHPRI18_GRPPRI_SHIFT, DMA_DCHPRI18_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI18, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI18_DPA field. */
#define DMA_RD_DCHPRI18_DPA(base) ((DMA_DCHPRI18_REG(base) & DMA_DCHPRI18_DPA_MASK) >> DMA_DCHPRI18_DPA_SHIFT)
#define DMA_BRD_DCHPRI18_DPA(base) (BME_UBFX8(&DMA_DCHPRI18_REG(base), DMA_DCHPRI18_DPA_SHIFT, DMA_DCHPRI18_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI18_DPA(base, value) (DMA_RMW_DCHPRI18(base, DMA_DCHPRI18_DPA_MASK, DMA_DCHPRI18_DPA(value)))
#define DMA_BWR_DCHPRI18_DPA(base, value) (BME_BFI8(&DMA_DCHPRI18_REG(base), ((uint8_t)(value) << DMA_DCHPRI18_DPA_SHIFT), DMA_DCHPRI18_DPA_SHIFT, DMA_DCHPRI18_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI18, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI18_ECP field. */
#define DMA_RD_DCHPRI18_ECP(base) ((DMA_DCHPRI18_REG(base) & DMA_DCHPRI18_ECP_MASK) >> DMA_DCHPRI18_ECP_SHIFT)
#define DMA_BRD_DCHPRI18_ECP(base) (BME_UBFX8(&DMA_DCHPRI18_REG(base), DMA_DCHPRI18_ECP_SHIFT, DMA_DCHPRI18_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI18_ECP(base, value) (DMA_RMW_DCHPRI18(base, DMA_DCHPRI18_ECP_MASK, DMA_DCHPRI18_ECP(value)))
#define DMA_BWR_DCHPRI18_ECP(base, value) (BME_BFI8(&DMA_DCHPRI18_REG(base), ((uint8_t)(value) << DMA_DCHPRI18_ECP_SHIFT), DMA_DCHPRI18_ECP_SHIFT, DMA_DCHPRI18_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI17 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI17 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI17 register
 */
/*@{*/
#define DMA_RD_DCHPRI17(base)    (DMA_DCHPRI17_REG(base))
#define DMA_WR_DCHPRI17(base, value) (DMA_DCHPRI17_REG(base) = (value))
#define DMA_RMW_DCHPRI17(base, mask, value) (DMA_WR_DCHPRI17(base, (DMA_RD_DCHPRI17(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI17(base, value) (BME_OR8(&DMA_DCHPRI17_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI17(base, value) (BME_AND8(&DMA_DCHPRI17_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI17(base, value) (BME_XOR8(&DMA_DCHPRI17_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI17 bitfields
 */

/*!
 * @name Register DMA_DCHPRI17, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI17_CHPRI field. */
#define DMA_RD_DCHPRI17_CHPRI(base) ((DMA_DCHPRI17_REG(base) & DMA_DCHPRI17_CHPRI_MASK) >> DMA_DCHPRI17_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI17_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI17_REG(base), DMA_DCHPRI17_CHPRI_SHIFT, DMA_DCHPRI17_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI17_CHPRI(base, value) (DMA_RMW_DCHPRI17(base, DMA_DCHPRI17_CHPRI_MASK, DMA_DCHPRI17_CHPRI(value)))
#define DMA_BWR_DCHPRI17_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI17_REG(base), ((uint8_t)(value) << DMA_DCHPRI17_CHPRI_SHIFT), DMA_DCHPRI17_CHPRI_SHIFT, DMA_DCHPRI17_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI17, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI17_GRPPRI field. */
#define DMA_RD_DCHPRI17_GRPPRI(base) ((DMA_DCHPRI17_REG(base) & DMA_DCHPRI17_GRPPRI_MASK) >> DMA_DCHPRI17_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI17_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI17_REG(base), DMA_DCHPRI17_GRPPRI_SHIFT, DMA_DCHPRI17_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI17, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI17_DPA field. */
#define DMA_RD_DCHPRI17_DPA(base) ((DMA_DCHPRI17_REG(base) & DMA_DCHPRI17_DPA_MASK) >> DMA_DCHPRI17_DPA_SHIFT)
#define DMA_BRD_DCHPRI17_DPA(base) (BME_UBFX8(&DMA_DCHPRI17_REG(base), DMA_DCHPRI17_DPA_SHIFT, DMA_DCHPRI17_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI17_DPA(base, value) (DMA_RMW_DCHPRI17(base, DMA_DCHPRI17_DPA_MASK, DMA_DCHPRI17_DPA(value)))
#define DMA_BWR_DCHPRI17_DPA(base, value) (BME_BFI8(&DMA_DCHPRI17_REG(base), ((uint8_t)(value) << DMA_DCHPRI17_DPA_SHIFT), DMA_DCHPRI17_DPA_SHIFT, DMA_DCHPRI17_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI17, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI17_ECP field. */
#define DMA_RD_DCHPRI17_ECP(base) ((DMA_DCHPRI17_REG(base) & DMA_DCHPRI17_ECP_MASK) >> DMA_DCHPRI17_ECP_SHIFT)
#define DMA_BRD_DCHPRI17_ECP(base) (BME_UBFX8(&DMA_DCHPRI17_REG(base), DMA_DCHPRI17_ECP_SHIFT, DMA_DCHPRI17_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI17_ECP(base, value) (DMA_RMW_DCHPRI17(base, DMA_DCHPRI17_ECP_MASK, DMA_DCHPRI17_ECP(value)))
#define DMA_BWR_DCHPRI17_ECP(base, value) (BME_BFI8(&DMA_DCHPRI17_REG(base), ((uint8_t)(value) << DMA_DCHPRI17_ECP_SHIFT), DMA_DCHPRI17_ECP_SHIFT, DMA_DCHPRI17_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI16 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI16 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI16 register
 */
/*@{*/
#define DMA_RD_DCHPRI16(base)    (DMA_DCHPRI16_REG(base))
#define DMA_WR_DCHPRI16(base, value) (DMA_DCHPRI16_REG(base) = (value))
#define DMA_RMW_DCHPRI16(base, mask, value) (DMA_WR_DCHPRI16(base, (DMA_RD_DCHPRI16(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI16(base, value) (BME_OR8(&DMA_DCHPRI16_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI16(base, value) (BME_AND8(&DMA_DCHPRI16_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI16(base, value) (BME_XOR8(&DMA_DCHPRI16_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI16 bitfields
 */

/*!
 * @name Register DMA_DCHPRI16, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI16_CHPRI field. */
#define DMA_RD_DCHPRI16_CHPRI(base) ((DMA_DCHPRI16_REG(base) & DMA_DCHPRI16_CHPRI_MASK) >> DMA_DCHPRI16_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI16_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI16_REG(base), DMA_DCHPRI16_CHPRI_SHIFT, DMA_DCHPRI16_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI16_CHPRI(base, value) (DMA_RMW_DCHPRI16(base, DMA_DCHPRI16_CHPRI_MASK, DMA_DCHPRI16_CHPRI(value)))
#define DMA_BWR_DCHPRI16_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI16_REG(base), ((uint8_t)(value) << DMA_DCHPRI16_CHPRI_SHIFT), DMA_DCHPRI16_CHPRI_SHIFT, DMA_DCHPRI16_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI16, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI16_GRPPRI field. */
#define DMA_RD_DCHPRI16_GRPPRI(base) ((DMA_DCHPRI16_REG(base) & DMA_DCHPRI16_GRPPRI_MASK) >> DMA_DCHPRI16_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI16_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI16_REG(base), DMA_DCHPRI16_GRPPRI_SHIFT, DMA_DCHPRI16_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI16, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI16_DPA field. */
#define DMA_RD_DCHPRI16_DPA(base) ((DMA_DCHPRI16_REG(base) & DMA_DCHPRI16_DPA_MASK) >> DMA_DCHPRI16_DPA_SHIFT)
#define DMA_BRD_DCHPRI16_DPA(base) (BME_UBFX8(&DMA_DCHPRI16_REG(base), DMA_DCHPRI16_DPA_SHIFT, DMA_DCHPRI16_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI16_DPA(base, value) (DMA_RMW_DCHPRI16(base, DMA_DCHPRI16_DPA_MASK, DMA_DCHPRI16_DPA(value)))
#define DMA_BWR_DCHPRI16_DPA(base, value) (BME_BFI8(&DMA_DCHPRI16_REG(base), ((uint8_t)(value) << DMA_DCHPRI16_DPA_SHIFT), DMA_DCHPRI16_DPA_SHIFT, DMA_DCHPRI16_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI16, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI16_ECP field. */
#define DMA_RD_DCHPRI16_ECP(base) ((DMA_DCHPRI16_REG(base) & DMA_DCHPRI16_ECP_MASK) >> DMA_DCHPRI16_ECP_SHIFT)
#define DMA_BRD_DCHPRI16_ECP(base) (BME_UBFX8(&DMA_DCHPRI16_REG(base), DMA_DCHPRI16_ECP_SHIFT, DMA_DCHPRI16_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI16_ECP(base, value) (DMA_RMW_DCHPRI16(base, DMA_DCHPRI16_ECP_MASK, DMA_DCHPRI16_ECP(value)))
#define DMA_BWR_DCHPRI16_ECP(base, value) (BME_BFI8(&DMA_DCHPRI16_REG(base), ((uint8_t)(value) << DMA_DCHPRI16_ECP_SHIFT), DMA_DCHPRI16_ECP_SHIFT, DMA_DCHPRI16_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI23 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI23 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI23 register
 */
/*@{*/
#define DMA_RD_DCHPRI23(base)    (DMA_DCHPRI23_REG(base))
#define DMA_WR_DCHPRI23(base, value) (DMA_DCHPRI23_REG(base) = (value))
#define DMA_RMW_DCHPRI23(base, mask, value) (DMA_WR_DCHPRI23(base, (DMA_RD_DCHPRI23(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI23(base, value) (BME_OR8(&DMA_DCHPRI23_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI23(base, value) (BME_AND8(&DMA_DCHPRI23_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI23(base, value) (BME_XOR8(&DMA_DCHPRI23_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI23 bitfields
 */

/*!
 * @name Register DMA_DCHPRI23, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI23_CHPRI field. */
#define DMA_RD_DCHPRI23_CHPRI(base) ((DMA_DCHPRI23_REG(base) & DMA_DCHPRI23_CHPRI_MASK) >> DMA_DCHPRI23_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI23_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI23_REG(base), DMA_DCHPRI23_CHPRI_SHIFT, DMA_DCHPRI23_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI23_CHPRI(base, value) (DMA_RMW_DCHPRI23(base, DMA_DCHPRI23_CHPRI_MASK, DMA_DCHPRI23_CHPRI(value)))
#define DMA_BWR_DCHPRI23_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI23_REG(base), ((uint8_t)(value) << DMA_DCHPRI23_CHPRI_SHIFT), DMA_DCHPRI23_CHPRI_SHIFT, DMA_DCHPRI23_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI23, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI23_GRPPRI field. */
#define DMA_RD_DCHPRI23_GRPPRI(base) ((DMA_DCHPRI23_REG(base) & DMA_DCHPRI23_GRPPRI_MASK) >> DMA_DCHPRI23_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI23_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI23_REG(base), DMA_DCHPRI23_GRPPRI_SHIFT, DMA_DCHPRI23_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI23, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI23_DPA field. */
#define DMA_RD_DCHPRI23_DPA(base) ((DMA_DCHPRI23_REG(base) & DMA_DCHPRI23_DPA_MASK) >> DMA_DCHPRI23_DPA_SHIFT)
#define DMA_BRD_DCHPRI23_DPA(base) (BME_UBFX8(&DMA_DCHPRI23_REG(base), DMA_DCHPRI23_DPA_SHIFT, DMA_DCHPRI23_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI23_DPA(base, value) (DMA_RMW_DCHPRI23(base, DMA_DCHPRI23_DPA_MASK, DMA_DCHPRI23_DPA(value)))
#define DMA_BWR_DCHPRI23_DPA(base, value) (BME_BFI8(&DMA_DCHPRI23_REG(base), ((uint8_t)(value) << DMA_DCHPRI23_DPA_SHIFT), DMA_DCHPRI23_DPA_SHIFT, DMA_DCHPRI23_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI23, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI23_ECP field. */
#define DMA_RD_DCHPRI23_ECP(base) ((DMA_DCHPRI23_REG(base) & DMA_DCHPRI23_ECP_MASK) >> DMA_DCHPRI23_ECP_SHIFT)
#define DMA_BRD_DCHPRI23_ECP(base) (BME_UBFX8(&DMA_DCHPRI23_REG(base), DMA_DCHPRI23_ECP_SHIFT, DMA_DCHPRI23_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI23_ECP(base, value) (DMA_RMW_DCHPRI23(base, DMA_DCHPRI23_ECP_MASK, DMA_DCHPRI23_ECP(value)))
#define DMA_BWR_DCHPRI23_ECP(base, value) (BME_BFI8(&DMA_DCHPRI23_REG(base), ((uint8_t)(value) << DMA_DCHPRI23_ECP_SHIFT), DMA_DCHPRI23_ECP_SHIFT, DMA_DCHPRI23_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI22 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI22 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI22 register
 */
/*@{*/
#define DMA_RD_DCHPRI22(base)    (DMA_DCHPRI22_REG(base))
#define DMA_WR_DCHPRI22(base, value) (DMA_DCHPRI22_REG(base) = (value))
#define DMA_RMW_DCHPRI22(base, mask, value) (DMA_WR_DCHPRI22(base, (DMA_RD_DCHPRI22(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI22(base, value) (BME_OR8(&DMA_DCHPRI22_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI22(base, value) (BME_AND8(&DMA_DCHPRI22_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI22(base, value) (BME_XOR8(&DMA_DCHPRI22_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI22 bitfields
 */

/*!
 * @name Register DMA_DCHPRI22, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI22_CHPRI field. */
#define DMA_RD_DCHPRI22_CHPRI(base) ((DMA_DCHPRI22_REG(base) & DMA_DCHPRI22_CHPRI_MASK) >> DMA_DCHPRI22_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI22_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI22_REG(base), DMA_DCHPRI22_CHPRI_SHIFT, DMA_DCHPRI22_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI22_CHPRI(base, value) (DMA_RMW_DCHPRI22(base, DMA_DCHPRI22_CHPRI_MASK, DMA_DCHPRI22_CHPRI(value)))
#define DMA_BWR_DCHPRI22_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI22_REG(base), ((uint8_t)(value) << DMA_DCHPRI22_CHPRI_SHIFT), DMA_DCHPRI22_CHPRI_SHIFT, DMA_DCHPRI22_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI22, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI22_GRPPRI field. */
#define DMA_RD_DCHPRI22_GRPPRI(base) ((DMA_DCHPRI22_REG(base) & DMA_DCHPRI22_GRPPRI_MASK) >> DMA_DCHPRI22_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI22_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI22_REG(base), DMA_DCHPRI22_GRPPRI_SHIFT, DMA_DCHPRI22_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI22, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI22_DPA field. */
#define DMA_RD_DCHPRI22_DPA(base) ((DMA_DCHPRI22_REG(base) & DMA_DCHPRI22_DPA_MASK) >> DMA_DCHPRI22_DPA_SHIFT)
#define DMA_BRD_DCHPRI22_DPA(base) (BME_UBFX8(&DMA_DCHPRI22_REG(base), DMA_DCHPRI22_DPA_SHIFT, DMA_DCHPRI22_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI22_DPA(base, value) (DMA_RMW_DCHPRI22(base, DMA_DCHPRI22_DPA_MASK, DMA_DCHPRI22_DPA(value)))
#define DMA_BWR_DCHPRI22_DPA(base, value) (BME_BFI8(&DMA_DCHPRI22_REG(base), ((uint8_t)(value) << DMA_DCHPRI22_DPA_SHIFT), DMA_DCHPRI22_DPA_SHIFT, DMA_DCHPRI22_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI22, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI22_ECP field. */
#define DMA_RD_DCHPRI22_ECP(base) ((DMA_DCHPRI22_REG(base) & DMA_DCHPRI22_ECP_MASK) >> DMA_DCHPRI22_ECP_SHIFT)
#define DMA_BRD_DCHPRI22_ECP(base) (BME_UBFX8(&DMA_DCHPRI22_REG(base), DMA_DCHPRI22_ECP_SHIFT, DMA_DCHPRI22_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI22_ECP(base, value) (DMA_RMW_DCHPRI22(base, DMA_DCHPRI22_ECP_MASK, DMA_DCHPRI22_ECP(value)))
#define DMA_BWR_DCHPRI22_ECP(base, value) (BME_BFI8(&DMA_DCHPRI22_REG(base), ((uint8_t)(value) << DMA_DCHPRI22_ECP_SHIFT), DMA_DCHPRI22_ECP_SHIFT, DMA_DCHPRI22_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI21 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI21 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI21 register
 */
/*@{*/
#define DMA_RD_DCHPRI21(base)    (DMA_DCHPRI21_REG(base))
#define DMA_WR_DCHPRI21(base, value) (DMA_DCHPRI21_REG(base) = (value))
#define DMA_RMW_DCHPRI21(base, mask, value) (DMA_WR_DCHPRI21(base, (DMA_RD_DCHPRI21(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI21(base, value) (BME_OR8(&DMA_DCHPRI21_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI21(base, value) (BME_AND8(&DMA_DCHPRI21_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI21(base, value) (BME_XOR8(&DMA_DCHPRI21_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI21 bitfields
 */

/*!
 * @name Register DMA_DCHPRI21, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI21_CHPRI field. */
#define DMA_RD_DCHPRI21_CHPRI(base) ((DMA_DCHPRI21_REG(base) & DMA_DCHPRI21_CHPRI_MASK) >> DMA_DCHPRI21_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI21_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI21_REG(base), DMA_DCHPRI21_CHPRI_SHIFT, DMA_DCHPRI21_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI21_CHPRI(base, value) (DMA_RMW_DCHPRI21(base, DMA_DCHPRI21_CHPRI_MASK, DMA_DCHPRI21_CHPRI(value)))
#define DMA_BWR_DCHPRI21_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI21_REG(base), ((uint8_t)(value) << DMA_DCHPRI21_CHPRI_SHIFT), DMA_DCHPRI21_CHPRI_SHIFT, DMA_DCHPRI21_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI21, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI21_GRPPRI field. */
#define DMA_RD_DCHPRI21_GRPPRI(base) ((DMA_DCHPRI21_REG(base) & DMA_DCHPRI21_GRPPRI_MASK) >> DMA_DCHPRI21_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI21_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI21_REG(base), DMA_DCHPRI21_GRPPRI_SHIFT, DMA_DCHPRI21_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI21, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI21_DPA field. */
#define DMA_RD_DCHPRI21_DPA(base) ((DMA_DCHPRI21_REG(base) & DMA_DCHPRI21_DPA_MASK) >> DMA_DCHPRI21_DPA_SHIFT)
#define DMA_BRD_DCHPRI21_DPA(base) (BME_UBFX8(&DMA_DCHPRI21_REG(base), DMA_DCHPRI21_DPA_SHIFT, DMA_DCHPRI21_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI21_DPA(base, value) (DMA_RMW_DCHPRI21(base, DMA_DCHPRI21_DPA_MASK, DMA_DCHPRI21_DPA(value)))
#define DMA_BWR_DCHPRI21_DPA(base, value) (BME_BFI8(&DMA_DCHPRI21_REG(base), ((uint8_t)(value) << DMA_DCHPRI21_DPA_SHIFT), DMA_DCHPRI21_DPA_SHIFT, DMA_DCHPRI21_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI21, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI21_ECP field. */
#define DMA_RD_DCHPRI21_ECP(base) ((DMA_DCHPRI21_REG(base) & DMA_DCHPRI21_ECP_MASK) >> DMA_DCHPRI21_ECP_SHIFT)
#define DMA_BRD_DCHPRI21_ECP(base) (BME_UBFX8(&DMA_DCHPRI21_REG(base), DMA_DCHPRI21_ECP_SHIFT, DMA_DCHPRI21_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI21_ECP(base, value) (DMA_RMW_DCHPRI21(base, DMA_DCHPRI21_ECP_MASK, DMA_DCHPRI21_ECP(value)))
#define DMA_BWR_DCHPRI21_ECP(base, value) (BME_BFI8(&DMA_DCHPRI21_REG(base), ((uint8_t)(value) << DMA_DCHPRI21_ECP_SHIFT), DMA_DCHPRI21_ECP_SHIFT, DMA_DCHPRI21_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI20 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI20 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI20 register
 */
/*@{*/
#define DMA_RD_DCHPRI20(base)    (DMA_DCHPRI20_REG(base))
#define DMA_WR_DCHPRI20(base, value) (DMA_DCHPRI20_REG(base) = (value))
#define DMA_RMW_DCHPRI20(base, mask, value) (DMA_WR_DCHPRI20(base, (DMA_RD_DCHPRI20(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI20(base, value) (BME_OR8(&DMA_DCHPRI20_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI20(base, value) (BME_AND8(&DMA_DCHPRI20_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI20(base, value) (BME_XOR8(&DMA_DCHPRI20_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI20 bitfields
 */

/*!
 * @name Register DMA_DCHPRI20, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI20_CHPRI field. */
#define DMA_RD_DCHPRI20_CHPRI(base) ((DMA_DCHPRI20_REG(base) & DMA_DCHPRI20_CHPRI_MASK) >> DMA_DCHPRI20_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI20_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI20_REG(base), DMA_DCHPRI20_CHPRI_SHIFT, DMA_DCHPRI20_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI20_CHPRI(base, value) (DMA_RMW_DCHPRI20(base, DMA_DCHPRI20_CHPRI_MASK, DMA_DCHPRI20_CHPRI(value)))
#define DMA_BWR_DCHPRI20_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI20_REG(base), ((uint8_t)(value) << DMA_DCHPRI20_CHPRI_SHIFT), DMA_DCHPRI20_CHPRI_SHIFT, DMA_DCHPRI20_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI20, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI20_GRPPRI field. */
#define DMA_RD_DCHPRI20_GRPPRI(base) ((DMA_DCHPRI20_REG(base) & DMA_DCHPRI20_GRPPRI_MASK) >> DMA_DCHPRI20_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI20_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI20_REG(base), DMA_DCHPRI20_GRPPRI_SHIFT, DMA_DCHPRI20_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI20, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI20_DPA field. */
#define DMA_RD_DCHPRI20_DPA(base) ((DMA_DCHPRI20_REG(base) & DMA_DCHPRI20_DPA_MASK) >> DMA_DCHPRI20_DPA_SHIFT)
#define DMA_BRD_DCHPRI20_DPA(base) (BME_UBFX8(&DMA_DCHPRI20_REG(base), DMA_DCHPRI20_DPA_SHIFT, DMA_DCHPRI20_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI20_DPA(base, value) (DMA_RMW_DCHPRI20(base, DMA_DCHPRI20_DPA_MASK, DMA_DCHPRI20_DPA(value)))
#define DMA_BWR_DCHPRI20_DPA(base, value) (BME_BFI8(&DMA_DCHPRI20_REG(base), ((uint8_t)(value) << DMA_DCHPRI20_DPA_SHIFT), DMA_DCHPRI20_DPA_SHIFT, DMA_DCHPRI20_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI20, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI20_ECP field. */
#define DMA_RD_DCHPRI20_ECP(base) ((DMA_DCHPRI20_REG(base) & DMA_DCHPRI20_ECP_MASK) >> DMA_DCHPRI20_ECP_SHIFT)
#define DMA_BRD_DCHPRI20_ECP(base) (BME_UBFX8(&DMA_DCHPRI20_REG(base), DMA_DCHPRI20_ECP_SHIFT, DMA_DCHPRI20_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI20_ECP(base, value) (DMA_RMW_DCHPRI20(base, DMA_DCHPRI20_ECP_MASK, DMA_DCHPRI20_ECP(value)))
#define DMA_BWR_DCHPRI20_ECP(base, value) (BME_BFI8(&DMA_DCHPRI20_REG(base), ((uint8_t)(value) << DMA_DCHPRI20_ECP_SHIFT), DMA_DCHPRI20_ECP_SHIFT, DMA_DCHPRI20_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI27 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI27 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI27 register
 */
/*@{*/
#define DMA_RD_DCHPRI27(base)    (DMA_DCHPRI27_REG(base))
#define DMA_WR_DCHPRI27(base, value) (DMA_DCHPRI27_REG(base) = (value))
#define DMA_RMW_DCHPRI27(base, mask, value) (DMA_WR_DCHPRI27(base, (DMA_RD_DCHPRI27(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI27(base, value) (BME_OR8(&DMA_DCHPRI27_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI27(base, value) (BME_AND8(&DMA_DCHPRI27_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI27(base, value) (BME_XOR8(&DMA_DCHPRI27_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI27 bitfields
 */

/*!
 * @name Register DMA_DCHPRI27, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI27_CHPRI field. */
#define DMA_RD_DCHPRI27_CHPRI(base) ((DMA_DCHPRI27_REG(base) & DMA_DCHPRI27_CHPRI_MASK) >> DMA_DCHPRI27_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI27_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI27_REG(base), DMA_DCHPRI27_CHPRI_SHIFT, DMA_DCHPRI27_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI27_CHPRI(base, value) (DMA_RMW_DCHPRI27(base, DMA_DCHPRI27_CHPRI_MASK, DMA_DCHPRI27_CHPRI(value)))
#define DMA_BWR_DCHPRI27_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI27_REG(base), ((uint8_t)(value) << DMA_DCHPRI27_CHPRI_SHIFT), DMA_DCHPRI27_CHPRI_SHIFT, DMA_DCHPRI27_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI27, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI27_GRPPRI field. */
#define DMA_RD_DCHPRI27_GRPPRI(base) ((DMA_DCHPRI27_REG(base) & DMA_DCHPRI27_GRPPRI_MASK) >> DMA_DCHPRI27_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI27_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI27_REG(base), DMA_DCHPRI27_GRPPRI_SHIFT, DMA_DCHPRI27_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI27, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI27_DPA field. */
#define DMA_RD_DCHPRI27_DPA(base) ((DMA_DCHPRI27_REG(base) & DMA_DCHPRI27_DPA_MASK) >> DMA_DCHPRI27_DPA_SHIFT)
#define DMA_BRD_DCHPRI27_DPA(base) (BME_UBFX8(&DMA_DCHPRI27_REG(base), DMA_DCHPRI27_DPA_SHIFT, DMA_DCHPRI27_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI27_DPA(base, value) (DMA_RMW_DCHPRI27(base, DMA_DCHPRI27_DPA_MASK, DMA_DCHPRI27_DPA(value)))
#define DMA_BWR_DCHPRI27_DPA(base, value) (BME_BFI8(&DMA_DCHPRI27_REG(base), ((uint8_t)(value) << DMA_DCHPRI27_DPA_SHIFT), DMA_DCHPRI27_DPA_SHIFT, DMA_DCHPRI27_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI27, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI27_ECP field. */
#define DMA_RD_DCHPRI27_ECP(base) ((DMA_DCHPRI27_REG(base) & DMA_DCHPRI27_ECP_MASK) >> DMA_DCHPRI27_ECP_SHIFT)
#define DMA_BRD_DCHPRI27_ECP(base) (BME_UBFX8(&DMA_DCHPRI27_REG(base), DMA_DCHPRI27_ECP_SHIFT, DMA_DCHPRI27_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI27_ECP(base, value) (DMA_RMW_DCHPRI27(base, DMA_DCHPRI27_ECP_MASK, DMA_DCHPRI27_ECP(value)))
#define DMA_BWR_DCHPRI27_ECP(base, value) (BME_BFI8(&DMA_DCHPRI27_REG(base), ((uint8_t)(value) << DMA_DCHPRI27_ECP_SHIFT), DMA_DCHPRI27_ECP_SHIFT, DMA_DCHPRI27_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI26 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI26 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI26 register
 */
/*@{*/
#define DMA_RD_DCHPRI26(base)    (DMA_DCHPRI26_REG(base))
#define DMA_WR_DCHPRI26(base, value) (DMA_DCHPRI26_REG(base) = (value))
#define DMA_RMW_DCHPRI26(base, mask, value) (DMA_WR_DCHPRI26(base, (DMA_RD_DCHPRI26(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI26(base, value) (BME_OR8(&DMA_DCHPRI26_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI26(base, value) (BME_AND8(&DMA_DCHPRI26_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI26(base, value) (BME_XOR8(&DMA_DCHPRI26_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI26 bitfields
 */

/*!
 * @name Register DMA_DCHPRI26, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI26_CHPRI field. */
#define DMA_RD_DCHPRI26_CHPRI(base) ((DMA_DCHPRI26_REG(base) & DMA_DCHPRI26_CHPRI_MASK) >> DMA_DCHPRI26_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI26_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI26_REG(base), DMA_DCHPRI26_CHPRI_SHIFT, DMA_DCHPRI26_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI26_CHPRI(base, value) (DMA_RMW_DCHPRI26(base, DMA_DCHPRI26_CHPRI_MASK, DMA_DCHPRI26_CHPRI(value)))
#define DMA_BWR_DCHPRI26_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI26_REG(base), ((uint8_t)(value) << DMA_DCHPRI26_CHPRI_SHIFT), DMA_DCHPRI26_CHPRI_SHIFT, DMA_DCHPRI26_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI26, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI26_GRPPRI field. */
#define DMA_RD_DCHPRI26_GRPPRI(base) ((DMA_DCHPRI26_REG(base) & DMA_DCHPRI26_GRPPRI_MASK) >> DMA_DCHPRI26_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI26_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI26_REG(base), DMA_DCHPRI26_GRPPRI_SHIFT, DMA_DCHPRI26_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI26, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI26_DPA field. */
#define DMA_RD_DCHPRI26_DPA(base) ((DMA_DCHPRI26_REG(base) & DMA_DCHPRI26_DPA_MASK) >> DMA_DCHPRI26_DPA_SHIFT)
#define DMA_BRD_DCHPRI26_DPA(base) (BME_UBFX8(&DMA_DCHPRI26_REG(base), DMA_DCHPRI26_DPA_SHIFT, DMA_DCHPRI26_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI26_DPA(base, value) (DMA_RMW_DCHPRI26(base, DMA_DCHPRI26_DPA_MASK, DMA_DCHPRI26_DPA(value)))
#define DMA_BWR_DCHPRI26_DPA(base, value) (BME_BFI8(&DMA_DCHPRI26_REG(base), ((uint8_t)(value) << DMA_DCHPRI26_DPA_SHIFT), DMA_DCHPRI26_DPA_SHIFT, DMA_DCHPRI26_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI26, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI26_ECP field. */
#define DMA_RD_DCHPRI26_ECP(base) ((DMA_DCHPRI26_REG(base) & DMA_DCHPRI26_ECP_MASK) >> DMA_DCHPRI26_ECP_SHIFT)
#define DMA_BRD_DCHPRI26_ECP(base) (BME_UBFX8(&DMA_DCHPRI26_REG(base), DMA_DCHPRI26_ECP_SHIFT, DMA_DCHPRI26_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI26_ECP(base, value) (DMA_RMW_DCHPRI26(base, DMA_DCHPRI26_ECP_MASK, DMA_DCHPRI26_ECP(value)))
#define DMA_BWR_DCHPRI26_ECP(base, value) (BME_BFI8(&DMA_DCHPRI26_REG(base), ((uint8_t)(value) << DMA_DCHPRI26_ECP_SHIFT), DMA_DCHPRI26_ECP_SHIFT, DMA_DCHPRI26_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI25 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI25 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI25 register
 */
/*@{*/
#define DMA_RD_DCHPRI25(base)    (DMA_DCHPRI25_REG(base))
#define DMA_WR_DCHPRI25(base, value) (DMA_DCHPRI25_REG(base) = (value))
#define DMA_RMW_DCHPRI25(base, mask, value) (DMA_WR_DCHPRI25(base, (DMA_RD_DCHPRI25(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI25(base, value) (BME_OR8(&DMA_DCHPRI25_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI25(base, value) (BME_AND8(&DMA_DCHPRI25_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI25(base, value) (BME_XOR8(&DMA_DCHPRI25_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI25 bitfields
 */

/*!
 * @name Register DMA_DCHPRI25, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI25_CHPRI field. */
#define DMA_RD_DCHPRI25_CHPRI(base) ((DMA_DCHPRI25_REG(base) & DMA_DCHPRI25_CHPRI_MASK) >> DMA_DCHPRI25_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI25_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI25_REG(base), DMA_DCHPRI25_CHPRI_SHIFT, DMA_DCHPRI25_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI25_CHPRI(base, value) (DMA_RMW_DCHPRI25(base, DMA_DCHPRI25_CHPRI_MASK, DMA_DCHPRI25_CHPRI(value)))
#define DMA_BWR_DCHPRI25_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI25_REG(base), ((uint8_t)(value) << DMA_DCHPRI25_CHPRI_SHIFT), DMA_DCHPRI25_CHPRI_SHIFT, DMA_DCHPRI25_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI25, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI25_GRPPRI field. */
#define DMA_RD_DCHPRI25_GRPPRI(base) ((DMA_DCHPRI25_REG(base) & DMA_DCHPRI25_GRPPRI_MASK) >> DMA_DCHPRI25_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI25_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI25_REG(base), DMA_DCHPRI25_GRPPRI_SHIFT, DMA_DCHPRI25_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI25, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI25_DPA field. */
#define DMA_RD_DCHPRI25_DPA(base) ((DMA_DCHPRI25_REG(base) & DMA_DCHPRI25_DPA_MASK) >> DMA_DCHPRI25_DPA_SHIFT)
#define DMA_BRD_DCHPRI25_DPA(base) (BME_UBFX8(&DMA_DCHPRI25_REG(base), DMA_DCHPRI25_DPA_SHIFT, DMA_DCHPRI25_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI25_DPA(base, value) (DMA_RMW_DCHPRI25(base, DMA_DCHPRI25_DPA_MASK, DMA_DCHPRI25_DPA(value)))
#define DMA_BWR_DCHPRI25_DPA(base, value) (BME_BFI8(&DMA_DCHPRI25_REG(base), ((uint8_t)(value) << DMA_DCHPRI25_DPA_SHIFT), DMA_DCHPRI25_DPA_SHIFT, DMA_DCHPRI25_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI25, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI25_ECP field. */
#define DMA_RD_DCHPRI25_ECP(base) ((DMA_DCHPRI25_REG(base) & DMA_DCHPRI25_ECP_MASK) >> DMA_DCHPRI25_ECP_SHIFT)
#define DMA_BRD_DCHPRI25_ECP(base) (BME_UBFX8(&DMA_DCHPRI25_REG(base), DMA_DCHPRI25_ECP_SHIFT, DMA_DCHPRI25_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI25_ECP(base, value) (DMA_RMW_DCHPRI25(base, DMA_DCHPRI25_ECP_MASK, DMA_DCHPRI25_ECP(value)))
#define DMA_BWR_DCHPRI25_ECP(base, value) (BME_BFI8(&DMA_DCHPRI25_REG(base), ((uint8_t)(value) << DMA_DCHPRI25_ECP_SHIFT), DMA_DCHPRI25_ECP_SHIFT, DMA_DCHPRI25_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI24 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI24 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI24 register
 */
/*@{*/
#define DMA_RD_DCHPRI24(base)    (DMA_DCHPRI24_REG(base))
#define DMA_WR_DCHPRI24(base, value) (DMA_DCHPRI24_REG(base) = (value))
#define DMA_RMW_DCHPRI24(base, mask, value) (DMA_WR_DCHPRI24(base, (DMA_RD_DCHPRI24(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI24(base, value) (BME_OR8(&DMA_DCHPRI24_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI24(base, value) (BME_AND8(&DMA_DCHPRI24_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI24(base, value) (BME_XOR8(&DMA_DCHPRI24_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI24 bitfields
 */

/*!
 * @name Register DMA_DCHPRI24, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI24_CHPRI field. */
#define DMA_RD_DCHPRI24_CHPRI(base) ((DMA_DCHPRI24_REG(base) & DMA_DCHPRI24_CHPRI_MASK) >> DMA_DCHPRI24_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI24_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI24_REG(base), DMA_DCHPRI24_CHPRI_SHIFT, DMA_DCHPRI24_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI24_CHPRI(base, value) (DMA_RMW_DCHPRI24(base, DMA_DCHPRI24_CHPRI_MASK, DMA_DCHPRI24_CHPRI(value)))
#define DMA_BWR_DCHPRI24_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI24_REG(base), ((uint8_t)(value) << DMA_DCHPRI24_CHPRI_SHIFT), DMA_DCHPRI24_CHPRI_SHIFT, DMA_DCHPRI24_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI24, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI24_GRPPRI field. */
#define DMA_RD_DCHPRI24_GRPPRI(base) ((DMA_DCHPRI24_REG(base) & DMA_DCHPRI24_GRPPRI_MASK) >> DMA_DCHPRI24_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI24_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI24_REG(base), DMA_DCHPRI24_GRPPRI_SHIFT, DMA_DCHPRI24_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI24, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI24_DPA field. */
#define DMA_RD_DCHPRI24_DPA(base) ((DMA_DCHPRI24_REG(base) & DMA_DCHPRI24_DPA_MASK) >> DMA_DCHPRI24_DPA_SHIFT)
#define DMA_BRD_DCHPRI24_DPA(base) (BME_UBFX8(&DMA_DCHPRI24_REG(base), DMA_DCHPRI24_DPA_SHIFT, DMA_DCHPRI24_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI24_DPA(base, value) (DMA_RMW_DCHPRI24(base, DMA_DCHPRI24_DPA_MASK, DMA_DCHPRI24_DPA(value)))
#define DMA_BWR_DCHPRI24_DPA(base, value) (BME_BFI8(&DMA_DCHPRI24_REG(base), ((uint8_t)(value) << DMA_DCHPRI24_DPA_SHIFT), DMA_DCHPRI24_DPA_SHIFT, DMA_DCHPRI24_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI24, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI24_ECP field. */
#define DMA_RD_DCHPRI24_ECP(base) ((DMA_DCHPRI24_REG(base) & DMA_DCHPRI24_ECP_MASK) >> DMA_DCHPRI24_ECP_SHIFT)
#define DMA_BRD_DCHPRI24_ECP(base) (BME_UBFX8(&DMA_DCHPRI24_REG(base), DMA_DCHPRI24_ECP_SHIFT, DMA_DCHPRI24_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI24_ECP(base, value) (DMA_RMW_DCHPRI24(base, DMA_DCHPRI24_ECP_MASK, DMA_DCHPRI24_ECP(value)))
#define DMA_BWR_DCHPRI24_ECP(base, value) (BME_BFI8(&DMA_DCHPRI24_REG(base), ((uint8_t)(value) << DMA_DCHPRI24_ECP_SHIFT), DMA_DCHPRI24_ECP_SHIFT, DMA_DCHPRI24_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI31 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI31 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI31 register
 */
/*@{*/
#define DMA_RD_DCHPRI31(base)    (DMA_DCHPRI31_REG(base))
#define DMA_WR_DCHPRI31(base, value) (DMA_DCHPRI31_REG(base) = (value))
#define DMA_RMW_DCHPRI31(base, mask, value) (DMA_WR_DCHPRI31(base, (DMA_RD_DCHPRI31(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI31(base, value) (BME_OR8(&DMA_DCHPRI31_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI31(base, value) (BME_AND8(&DMA_DCHPRI31_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI31(base, value) (BME_XOR8(&DMA_DCHPRI31_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI31 bitfields
 */

/*!
 * @name Register DMA_DCHPRI31, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI31_CHPRI field. */
#define DMA_RD_DCHPRI31_CHPRI(base) ((DMA_DCHPRI31_REG(base) & DMA_DCHPRI31_CHPRI_MASK) >> DMA_DCHPRI31_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI31_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI31_REG(base), DMA_DCHPRI31_CHPRI_SHIFT, DMA_DCHPRI31_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI31_CHPRI(base, value) (DMA_RMW_DCHPRI31(base, DMA_DCHPRI31_CHPRI_MASK, DMA_DCHPRI31_CHPRI(value)))
#define DMA_BWR_DCHPRI31_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI31_REG(base), ((uint8_t)(value) << DMA_DCHPRI31_CHPRI_SHIFT), DMA_DCHPRI31_CHPRI_SHIFT, DMA_DCHPRI31_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI31, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI31_GRPPRI field. */
#define DMA_RD_DCHPRI31_GRPPRI(base) ((DMA_DCHPRI31_REG(base) & DMA_DCHPRI31_GRPPRI_MASK) >> DMA_DCHPRI31_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI31_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI31_REG(base), DMA_DCHPRI31_GRPPRI_SHIFT, DMA_DCHPRI31_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI31, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI31_DPA field. */
#define DMA_RD_DCHPRI31_DPA(base) ((DMA_DCHPRI31_REG(base) & DMA_DCHPRI31_DPA_MASK) >> DMA_DCHPRI31_DPA_SHIFT)
#define DMA_BRD_DCHPRI31_DPA(base) (BME_UBFX8(&DMA_DCHPRI31_REG(base), DMA_DCHPRI31_DPA_SHIFT, DMA_DCHPRI31_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI31_DPA(base, value) (DMA_RMW_DCHPRI31(base, DMA_DCHPRI31_DPA_MASK, DMA_DCHPRI31_DPA(value)))
#define DMA_BWR_DCHPRI31_DPA(base, value) (BME_BFI8(&DMA_DCHPRI31_REG(base), ((uint8_t)(value) << DMA_DCHPRI31_DPA_SHIFT), DMA_DCHPRI31_DPA_SHIFT, DMA_DCHPRI31_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI31, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI31_ECP field. */
#define DMA_RD_DCHPRI31_ECP(base) ((DMA_DCHPRI31_REG(base) & DMA_DCHPRI31_ECP_MASK) >> DMA_DCHPRI31_ECP_SHIFT)
#define DMA_BRD_DCHPRI31_ECP(base) (BME_UBFX8(&DMA_DCHPRI31_REG(base), DMA_DCHPRI31_ECP_SHIFT, DMA_DCHPRI31_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI31_ECP(base, value) (DMA_RMW_DCHPRI31(base, DMA_DCHPRI31_ECP_MASK, DMA_DCHPRI31_ECP(value)))
#define DMA_BWR_DCHPRI31_ECP(base, value) (BME_BFI8(&DMA_DCHPRI31_REG(base), ((uint8_t)(value) << DMA_DCHPRI31_ECP_SHIFT), DMA_DCHPRI31_ECP_SHIFT, DMA_DCHPRI31_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI30 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI30 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI30 register
 */
/*@{*/
#define DMA_RD_DCHPRI30(base)    (DMA_DCHPRI30_REG(base))
#define DMA_WR_DCHPRI30(base, value) (DMA_DCHPRI30_REG(base) = (value))
#define DMA_RMW_DCHPRI30(base, mask, value) (DMA_WR_DCHPRI30(base, (DMA_RD_DCHPRI30(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI30(base, value) (BME_OR8(&DMA_DCHPRI30_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI30(base, value) (BME_AND8(&DMA_DCHPRI30_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI30(base, value) (BME_XOR8(&DMA_DCHPRI30_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI30 bitfields
 */

/*!
 * @name Register DMA_DCHPRI30, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI30_CHPRI field. */
#define DMA_RD_DCHPRI30_CHPRI(base) ((DMA_DCHPRI30_REG(base) & DMA_DCHPRI30_CHPRI_MASK) >> DMA_DCHPRI30_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI30_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI30_REG(base), DMA_DCHPRI30_CHPRI_SHIFT, DMA_DCHPRI30_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI30_CHPRI(base, value) (DMA_RMW_DCHPRI30(base, DMA_DCHPRI30_CHPRI_MASK, DMA_DCHPRI30_CHPRI(value)))
#define DMA_BWR_DCHPRI30_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI30_REG(base), ((uint8_t)(value) << DMA_DCHPRI30_CHPRI_SHIFT), DMA_DCHPRI30_CHPRI_SHIFT, DMA_DCHPRI30_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI30, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI30_GRPPRI field. */
#define DMA_RD_DCHPRI30_GRPPRI(base) ((DMA_DCHPRI30_REG(base) & DMA_DCHPRI30_GRPPRI_MASK) >> DMA_DCHPRI30_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI30_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI30_REG(base), DMA_DCHPRI30_GRPPRI_SHIFT, DMA_DCHPRI30_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI30, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI30_DPA field. */
#define DMA_RD_DCHPRI30_DPA(base) ((DMA_DCHPRI30_REG(base) & DMA_DCHPRI30_DPA_MASK) >> DMA_DCHPRI30_DPA_SHIFT)
#define DMA_BRD_DCHPRI30_DPA(base) (BME_UBFX8(&DMA_DCHPRI30_REG(base), DMA_DCHPRI30_DPA_SHIFT, DMA_DCHPRI30_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI30_DPA(base, value) (DMA_RMW_DCHPRI30(base, DMA_DCHPRI30_DPA_MASK, DMA_DCHPRI30_DPA(value)))
#define DMA_BWR_DCHPRI30_DPA(base, value) (BME_BFI8(&DMA_DCHPRI30_REG(base), ((uint8_t)(value) << DMA_DCHPRI30_DPA_SHIFT), DMA_DCHPRI30_DPA_SHIFT, DMA_DCHPRI30_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI30, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI30_ECP field. */
#define DMA_RD_DCHPRI30_ECP(base) ((DMA_DCHPRI30_REG(base) & DMA_DCHPRI30_ECP_MASK) >> DMA_DCHPRI30_ECP_SHIFT)
#define DMA_BRD_DCHPRI30_ECP(base) (BME_UBFX8(&DMA_DCHPRI30_REG(base), DMA_DCHPRI30_ECP_SHIFT, DMA_DCHPRI30_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI30_ECP(base, value) (DMA_RMW_DCHPRI30(base, DMA_DCHPRI30_ECP_MASK, DMA_DCHPRI30_ECP(value)))
#define DMA_BWR_DCHPRI30_ECP(base, value) (BME_BFI8(&DMA_DCHPRI30_REG(base), ((uint8_t)(value) << DMA_DCHPRI30_ECP_SHIFT), DMA_DCHPRI30_ECP_SHIFT, DMA_DCHPRI30_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI29 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI29 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI29 register
 */
/*@{*/
#define DMA_RD_DCHPRI29(base)    (DMA_DCHPRI29_REG(base))
#define DMA_WR_DCHPRI29(base, value) (DMA_DCHPRI29_REG(base) = (value))
#define DMA_RMW_DCHPRI29(base, mask, value) (DMA_WR_DCHPRI29(base, (DMA_RD_DCHPRI29(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI29(base, value) (BME_OR8(&DMA_DCHPRI29_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI29(base, value) (BME_AND8(&DMA_DCHPRI29_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI29(base, value) (BME_XOR8(&DMA_DCHPRI29_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI29 bitfields
 */

/*!
 * @name Register DMA_DCHPRI29, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI29_CHPRI field. */
#define DMA_RD_DCHPRI29_CHPRI(base) ((DMA_DCHPRI29_REG(base) & DMA_DCHPRI29_CHPRI_MASK) >> DMA_DCHPRI29_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI29_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI29_REG(base), DMA_DCHPRI29_CHPRI_SHIFT, DMA_DCHPRI29_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI29_CHPRI(base, value) (DMA_RMW_DCHPRI29(base, DMA_DCHPRI29_CHPRI_MASK, DMA_DCHPRI29_CHPRI(value)))
#define DMA_BWR_DCHPRI29_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI29_REG(base), ((uint8_t)(value) << DMA_DCHPRI29_CHPRI_SHIFT), DMA_DCHPRI29_CHPRI_SHIFT, DMA_DCHPRI29_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI29, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI29_GRPPRI field. */
#define DMA_RD_DCHPRI29_GRPPRI(base) ((DMA_DCHPRI29_REG(base) & DMA_DCHPRI29_GRPPRI_MASK) >> DMA_DCHPRI29_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI29_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI29_REG(base), DMA_DCHPRI29_GRPPRI_SHIFT, DMA_DCHPRI29_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI29, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI29_DPA field. */
#define DMA_RD_DCHPRI29_DPA(base) ((DMA_DCHPRI29_REG(base) & DMA_DCHPRI29_DPA_MASK) >> DMA_DCHPRI29_DPA_SHIFT)
#define DMA_BRD_DCHPRI29_DPA(base) (BME_UBFX8(&DMA_DCHPRI29_REG(base), DMA_DCHPRI29_DPA_SHIFT, DMA_DCHPRI29_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI29_DPA(base, value) (DMA_RMW_DCHPRI29(base, DMA_DCHPRI29_DPA_MASK, DMA_DCHPRI29_DPA(value)))
#define DMA_BWR_DCHPRI29_DPA(base, value) (BME_BFI8(&DMA_DCHPRI29_REG(base), ((uint8_t)(value) << DMA_DCHPRI29_DPA_SHIFT), DMA_DCHPRI29_DPA_SHIFT, DMA_DCHPRI29_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI29, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI29_ECP field. */
#define DMA_RD_DCHPRI29_ECP(base) ((DMA_DCHPRI29_REG(base) & DMA_DCHPRI29_ECP_MASK) >> DMA_DCHPRI29_ECP_SHIFT)
#define DMA_BRD_DCHPRI29_ECP(base) (BME_UBFX8(&DMA_DCHPRI29_REG(base), DMA_DCHPRI29_ECP_SHIFT, DMA_DCHPRI29_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI29_ECP(base, value) (DMA_RMW_DCHPRI29(base, DMA_DCHPRI29_ECP_MASK, DMA_DCHPRI29_ECP(value)))
#define DMA_BWR_DCHPRI29_ECP(base, value) (BME_BFI8(&DMA_DCHPRI29_REG(base), ((uint8_t)(value) << DMA_DCHPRI29_ECP_SHIFT), DMA_DCHPRI29_ECP_SHIFT, DMA_DCHPRI29_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI28 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI28 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel within a group. The channel priorities are evaluated by numeric value; for
 * example, 0 is the lowest priority, 1 is the next higher priority, then 2, 3,
 * etc. Software must program the channel priorities with unique values; otherwise,
 * a configuration error is reported. The range of the priority value is limited
 * to the values of 0 through 15. When read, the GRPPRI bits of the DCHPRIn
 * register reflect the current priority level of the group of channels in which the
 * corresponding channel resides. GRPPRI bits are not affected by writes to the
 * DCHPRIn registers. The group priority is assigned in the DMA control register.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI28 register
 */
/*@{*/
#define DMA_RD_DCHPRI28(base)    (DMA_DCHPRI28_REG(base))
#define DMA_WR_DCHPRI28(base, value) (DMA_DCHPRI28_REG(base) = (value))
#define DMA_RMW_DCHPRI28(base, mask, value) (DMA_WR_DCHPRI28(base, (DMA_RD_DCHPRI28(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI28(base, value) (BME_OR8(&DMA_DCHPRI28_REG(base), (uint8_t)(value)))
#define DMA_CLR_DCHPRI28(base, value) (BME_AND8(&DMA_DCHPRI28_REG(base), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRI28(base, value) (BME_XOR8(&DMA_DCHPRI28_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI28 bitfields
 */

/*!
 * @name Register DMA_DCHPRI28, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] = 0b01111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI28_CHPRI field. */
#define DMA_RD_DCHPRI28_CHPRI(base) ((DMA_DCHPRI28_REG(base) & DMA_DCHPRI28_CHPRI_MASK) >> DMA_DCHPRI28_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI28_CHPRI(base) (BME_UBFX8(&DMA_DCHPRI28_REG(base), DMA_DCHPRI28_CHPRI_SHIFT, DMA_DCHPRI28_CHPRI_WIDTH))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI28_CHPRI(base, value) (DMA_RMW_DCHPRI28(base, DMA_DCHPRI28_CHPRI_MASK, DMA_DCHPRI28_CHPRI(value)))
#define DMA_BWR_DCHPRI28_CHPRI(base, value) (BME_BFI8(&DMA_DCHPRI28_REG(base), ((uint8_t)(value) << DMA_DCHPRI28_CHPRI_SHIFT), DMA_DCHPRI28_CHPRI_SHIFT, DMA_DCHPRI28_CHPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI28, field GRPPRI[5:4] (RO)
 *
 * Group priority assigned to this channel group when fixed-priority arbitration
 * is enabled. This field is read-only; writes are ignored. Reset value for the
 * group and channel priority fields, GRPPRI and CHPRI, is equal to the
 * corresponding channel number for each priority register, that is, DCHPRI31[GRPPRI] =
 * 0b01 and DCHPRI31[CHPRI] equals 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI28_GRPPRI field. */
#define DMA_RD_DCHPRI28_GRPPRI(base) ((DMA_DCHPRI28_REG(base) & DMA_DCHPRI28_GRPPRI_MASK) >> DMA_DCHPRI28_GRPPRI_SHIFT)
#define DMA_BRD_DCHPRI28_GRPPRI(base) (BME_UBFX8(&DMA_DCHPRI28_REG(base), DMA_DCHPRI28_GRPPRI_SHIFT, DMA_DCHPRI28_GRPPRI_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI28, field DPA[6] (RW)
 *
 * Values:
 * - 0b0 - Channel n can suspend a lower priority channel.
 * - 0b1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI28_DPA field. */
#define DMA_RD_DCHPRI28_DPA(base) ((DMA_DCHPRI28_REG(base) & DMA_DCHPRI28_DPA_MASK) >> DMA_DCHPRI28_DPA_SHIFT)
#define DMA_BRD_DCHPRI28_DPA(base) (BME_UBFX8(&DMA_DCHPRI28_REG(base), DMA_DCHPRI28_DPA_SHIFT, DMA_DCHPRI28_DPA_WIDTH))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI28_DPA(base, value) (DMA_RMW_DCHPRI28(base, DMA_DCHPRI28_DPA_MASK, DMA_DCHPRI28_DPA(value)))
#define DMA_BWR_DCHPRI28_DPA(base, value) (BME_BFI8(&DMA_DCHPRI28_REG(base), ((uint8_t)(value) << DMA_DCHPRI28_DPA_SHIFT), DMA_DCHPRI28_DPA_SHIFT, DMA_DCHPRI28_DPA_WIDTH))
/*@}*/

/*!
 * @name Register DMA_DCHPRI28, field ECP[7] (RW)
 *
 * Values:
 * - 0b0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 0b1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI28_ECP field. */
#define DMA_RD_DCHPRI28_ECP(base) ((DMA_DCHPRI28_REG(base) & DMA_DCHPRI28_ECP_MASK) >> DMA_DCHPRI28_ECP_SHIFT)
#define DMA_BRD_DCHPRI28_ECP(base) (BME_UBFX8(&DMA_DCHPRI28_REG(base), DMA_DCHPRI28_ECP_SHIFT, DMA_DCHPRI28_ECP_WIDTH))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI28_ECP(base, value) (DMA_RMW_DCHPRI28(base, DMA_DCHPRI28_ECP_MASK, DMA_DCHPRI28_ECP(value)))
#define DMA_BWR_DCHPRI28_ECP(base, value) (BME_BFI8(&DMA_DCHPRI28_REG(base), ((uint8_t)(value) << DMA_DCHPRI28_ECP_SHIFT), DMA_DCHPRI28_ECP_SHIFT, DMA_DCHPRI28_ECP_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SADDR register
 */
/*@{*/
#define DMA_RD_SADDR(base, index) (DMA_SADDR_REG(base, index))
#define DMA_WR_SADDR(base, index, value) (DMA_SADDR_REG(base, index) = (value))
#define DMA_RMW_SADDR(base, index, mask, value) (DMA_WR_SADDR(base, index, (DMA_RD_SADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SADDR(base, index, value) (BME_OR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SADDR(base, index, value) (BME_AND32(&DMA_SADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SADDR(base, index, value) (BME_XOR32(&DMA_SADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_SOFF register
 */
/*@{*/
#define DMA_RD_SOFF(base, index) (DMA_SOFF_REG(base, index))
#define DMA_WR_SOFF(base, index, value) (DMA_SOFF_REG(base, index) = (value))
#define DMA_RMW_SOFF(base, index, mask, value) (DMA_WR_SOFF(base, index, (DMA_RD_SOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_SOFF(base, index, value) (BME_OR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_SOFF(base, index, value) (BME_AND16(&DMA_SOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_SOFF(base, index, value) (BME_XOR16(&DMA_SOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_ATTR register
 */
/*@{*/
#define DMA_RD_ATTR(base, index) (DMA_ATTR_REG(base, index))
#define DMA_WR_ATTR(base, index, value) (DMA_ATTR_REG(base, index) = (value))
#define DMA_RMW_ATTR(base, index, mask, value) (DMA_WR_ATTR(base, index, (DMA_RD_ATTR(base, index) & ~(mask)) | (value)))
#define DMA_SET_ATTR(base, index, value) (BME_OR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_ATTR(base, index, value) (BME_AND16(&DMA_ATTR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_ATTR(base, index, value) (BME_XOR16(&DMA_ATTR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ATTR bitfields
 */

/*!
 * @name Register DMA_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DSIZE field. */
#define DMA_RD_ATTR_DSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA_BRD_ATTR_DSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_ATTR_DSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DSIZE_MASK, DMA_ATTR_DSIZE(value)))
#define DMA_BWR_ATTR_DSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DSIZE_SHIFT), DMA_ATTR_DSIZE_SHIFT, DMA_ATTR_DSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DMOD field. */
#define DMA_RD_ATTR_DMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DMOD_MASK) >> DMA_ATTR_DMOD_SHIFT)
#define DMA_BRD_ATTR_DMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_ATTR_DMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DMOD_MASK, DMA_ATTR_DMOD(value)))
#define DMA_BWR_ATTR_DMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_DMOD_SHIFT), DMA_ATTR_DMOD_SHIFT, DMA_ATTR_DMOD_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 0b000 - 8-bit
 * - 0b001 - 16-bit
 * - 0b010 - 32-bit
 * - 0b011 - Reserved
 * - 0b100 - 16-byte burst
 * - 0b101 - 32-byte burst
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SSIZE field. */
#define DMA_RD_ATTR_SSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA_BRD_ATTR_SSIZE(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_ATTR_SSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SSIZE_MASK, DMA_ATTR_SSIZE(value)))
#define DMA_BWR_ATTR_SSIZE(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SSIZE_SHIFT), DMA_ATTR_SSIZE_SHIFT, DMA_ATTR_SSIZE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0b00000 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SMOD field. */
#define DMA_RD_ATTR_SMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SMOD_MASK) >> DMA_ATTR_SMOD_SHIFT)
#define DMA_BRD_ATTR_SMOD(base, index) (BME_UBFX16(&DMA_ATTR_REG(base, index), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_ATTR_SMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SMOD_MASK, DMA_ATTR_SMOD(value)))
#define DMA_BWR_ATTR_SMOD(base, index, value) (BME_BFI16(&DMA_ATTR_REG(base, index), ((uint16_t)(value) << DMA_ATTR_SMOD_SHIFT), DMA_ATTR_SMOD_SHIFT, DMA_ATTR_SMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFYES(base, index) (DMA_NBYTES_MLOFFYES_REG(base, index))
#define DMA_WR_NBYTES_MLOFFYES(base, index, value) (DMA_NBYTES_MLOFFYES_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFYES(base, index, mask, value) (DMA_WR_NBYTES_MLOFFYES(base, index, (DMA_RD_NBYTES_MLOFFYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFYES(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFYES(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFYES(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFYES_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_NBYTES_MASK, DMA_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_MLOFF(base, index) (DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_MLOFF_MASK, DMA_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_DMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_DMLOE_MASK, DMA_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_DMLOE_SHIFT), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT, DMA_NBYTES_MLOFFYES_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_SMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_SMLOE_MASK, DMA_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFYES_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFYES_SMLOE_SHIFT), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT, DMA_NBYTES_MLOFFYES_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFNO(base, index) (DMA_NBYTES_MLOFFNO_REG(base, index))
#define DMA_WR_NBYTES_MLOFFNO(base, index, value) (DMA_NBYTES_MLOFFNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFNO(base, index, mask, value) (DMA_WR_NBYTES_MLOFFNO(base, index, (DMA_RD_NBYTES_MLOFFNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLOFFNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLOFFNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLOFFNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_NBYTES_MASK, DMA_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the DADDR
 * - 0b1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_DMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_DMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_DMLOE_MASK, DMA_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_DMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_DMLOE_SHIFT), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT, DMA_NBYTES_MLOFFNO_DMLOE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0b0 - The minor loop offset is not applied to the SADDR
 * - 0b1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_SMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_SMLOE(base, index) (BME_UBFX32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_SMLOE_MASK, DMA_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_SMLOE(base, index, value) (BME_BFI32(&DMA_NBYTES_MLOFFNO_REG(base, index), ((uint32_t)(value) << DMA_NBYTES_MLOFFNO_SMLOE_SHIFT), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT, DMA_NBYTES_MLOFFNO_SMLOE_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLNO(base, index) (DMA_NBYTES_MLNO_REG(base, index))
#define DMA_WR_NBYTES_MLNO(base, index, value) (DMA_NBYTES_MLNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLNO(base, index, mask, value) (DMA_WR_NBYTES_MLNO(base, index, (DMA_RD_NBYTES_MLNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLNO(base, index, value) (BME_OR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_NBYTES_MLNO(base, index, value) (BME_AND32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_NBYTES_MLNO(base, index, value) (BME_XOR32(&DMA_NBYTES_MLNO_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SLAST register
 */
/*@{*/
#define DMA_RD_SLAST(base, index) (DMA_SLAST_REG(base, index))
#define DMA_WR_SLAST(base, index, value) (DMA_SLAST_REG(base, index) = (value))
#define DMA_RMW_SLAST(base, index, mask, value) (DMA_WR_SLAST(base, index, (DMA_RD_SLAST(base, index) & ~(mask)) | (value)))
#define DMA_SET_SLAST(base, index, value) (BME_OR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_SLAST(base, index, value) (BME_AND32(&DMA_SLAST_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_SLAST(base, index, value) (BME_XOR32(&DMA_SLAST_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DADDR register
 */
/*@{*/
#define DMA_RD_DADDR(base, index) (DMA_DADDR_REG(base, index))
#define DMA_WR_DADDR(base, index, value) (DMA_DADDR_REG(base, index) = (value))
#define DMA_RMW_DADDR(base, index, mask, value) (DMA_WR_DADDR(base, index, (DMA_RD_DADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DADDR(base, index, value) (BME_OR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DADDR(base, index, value) (BME_AND32(&DMA_DADDR_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DADDR(base, index, value) (BME_XOR32(&DMA_DADDR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_DOFF register
 */
/*@{*/
#define DMA_RD_DOFF(base, index) (DMA_DOFF_REG(base, index))
#define DMA_WR_DOFF(base, index, value) (DMA_DOFF_REG(base, index) = (value))
#define DMA_RMW_DOFF(base, index, mask, value) (DMA_WR_DOFF(base, index, (DMA_RD_DOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_DOFF(base, index, value) (BME_OR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_DOFF(base, index, value) (BME_AND16(&DMA_DOFF_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_DOFF(base, index, value) (BME_XOR16(&DMA_DOFF_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_CITER_ELINKNO(base, index) (DMA_CITER_ELINKNO_REG(base, index))
#define DMA_WR_CITER_ELINKNO(base, index, value) (DMA_CITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKNO(base, index, mask, value) (DMA_WR_CITER_ELINKNO(base, index, (DMA_RD_CITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKNO(base, index, value) (BME_OR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKNO(base, index, value) (BME_AND16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_CITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_CITER field. */
#define DMA_RD_CITER_ELINKNO_CITER(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_CITER_MASK) >> DMA_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKNO_CITER(base, index) (DMA_RD_CITER_ELINKNO_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKNO_CITER(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_CITER_MASK, DMA_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_CITER_ELINKNO_CITER(base, index, value) (DMA_WR_CITER_ELINKNO_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_ELINK field. */
#define DMA_RD_CITER_ELINKNO_ELINK(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_ELINK_MASK) >> DMA_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_ELINK_MASK, DMA_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_CITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKNO_ELINK_SHIFT), DMA_CITER_ELINKNO_ELINK_SHIFT, DMA_CITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_CITER_ELINKYES(base, index) (DMA_CITER_ELINKYES_REG(base, index))
#define DMA_WR_CITER_ELINKYES(base, index, value) (DMA_CITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKYES(base, index, mask, value) (DMA_WR_CITER_ELINKYES(base, index, (DMA_RD_CITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKYES(base, index, value) (BME_OR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CITER_ELINKYES(base, index, value) (BME_AND16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_CITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_CITER field. */
#define DMA_RD_CITER_ELINKYES_CITER(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_CITER_MASK) >> DMA_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKYES_CITER(base, index) (DMA_RD_CITER_ELINKYES_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKYES_CITER(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_CITER_MASK, DMA_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_CITER_ELINKYES_CITER(base, index, value) (DMA_WR_CITER_ELINKYES_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_CITER_ELINKYES_LINKCH(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_LINKCH_MASK) >> DMA_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_CITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_LINKCH_MASK, DMA_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_CITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_LINKCH_SHIFT), DMA_CITER_ELINKYES_LINKCH_SHIFT, DMA_CITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_ELINK field. */
#define DMA_RD_CITER_ELINKYES_ELINK(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_ELINK_MASK) >> DMA_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_ELINK_MASK, DMA_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_CITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_CITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_CITER_ELINKYES_ELINK_SHIFT), DMA_CITER_ELINKYES_ELINK_SHIFT, DMA_CITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DLAST_SGA register
 */
/*@{*/
#define DMA_RD_DLAST_SGA(base, index) (DMA_DLAST_SGA_REG(base, index))
#define DMA_WR_DLAST_SGA(base, index, value) (DMA_DLAST_SGA_REG(base, index) = (value))
#define DMA_RMW_DLAST_SGA(base, index, mask, value) (DMA_WR_DLAST_SGA(base, index, (DMA_RD_DLAST_SGA(base, index) & ~(mask)) | (value)))
#define DMA_SET_DLAST_SGA(base, index, value) (BME_OR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
#define DMA_CLR_DLAST_SGA(base, index, value) (BME_AND32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(~(value))))
#define DMA_TOG_DLAST_SGA(base, index, value) (BME_XOR32(&DMA_DLAST_SGA_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * DMA_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_CSR register
 */
/*@{*/
#define DMA_RD_CSR(base, index)  (DMA_CSR_REG(base, index))
#define DMA_WR_CSR(base, index, value) (DMA_CSR_REG(base, index) = (value))
#define DMA_RMW_CSR(base, index, mask, value) (DMA_WR_CSR(base, index, (DMA_RD_CSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_CSR(base, index, value) (BME_OR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_CSR(base, index, value) (BME_AND16(&DMA_CSR_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_CSR(base, index, value) (BME_XOR16(&DMA_CSR_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CSR bitfields
 */

/*!
 * @name Register DMA_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0b0 - The channel is not explicitly started.
 * - 0b1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_START field. */
#define DMA_RD_CSR_START(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_START_MASK) >> DMA_CSR_START_SHIFT)
#define DMA_BRD_CSR_START(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))

/*! @brief Set the START field to a new value. */
#define DMA_WR_CSR_START(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_START_MASK, DMA_CSR_START(value)))
#define DMA_BWR_CSR_START(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_START_SHIFT), DMA_CSR_START_SHIFT, DMA_CSR_START_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0b0 - The end-of-major loop interrupt is disabled.
 * - 0b1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTMAJOR field. */
#define DMA_RD_CSR_INTMAJOR(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTMAJOR_MASK) >> DMA_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_CSR_INTMAJOR(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_CSR_INTMAJOR(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTMAJOR_MASK, DMA_CSR_INTMAJOR(value)))
#define DMA_BWR_CSR_INTMAJOR(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTMAJOR_SHIFT), DMA_CSR_INTMAJOR_SHIFT, DMA_CSR_INTMAJOR_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0b0 - The half-point interrupt is disabled.
 * - 0b1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTHALF field. */
#define DMA_RD_CSR_INTHALF(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTHALF_MASK) >> DMA_CSR_INTHALF_SHIFT)
#define DMA_BRD_CSR_INTHALF(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_CSR_INTHALF(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTHALF_MASK, DMA_CSR_INTHALF(value)))
#define DMA_BWR_CSR_INTHALF(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_INTHALF_SHIFT), DMA_CSR_INTHALF_SHIFT, DMA_CSR_INTHALF_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0b0 - The channel's ERQ bit is not affected.
 * - 0b1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DREQ field. */
#define DMA_RD_CSR_DREQ(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DREQ_MASK) >> DMA_CSR_DREQ_SHIFT)
#define DMA_BRD_CSR_DREQ(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_CSR_DREQ(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DREQ_MASK, DMA_CSR_DREQ(value)))
#define DMA_BWR_CSR_DREQ(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DREQ_SHIFT), DMA_CSR_DREQ_SHIFT, DMA_CSR_DREQ_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The current channel's TCD is normal format.
 * - 0b1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into
 *     this channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ESG field. */
#define DMA_RD_CSR_ESG(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ESG_MASK) >> DMA_CSR_ESG_SHIFT)
#define DMA_BRD_CSR_ESG(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_CSR_ESG(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ESG_MASK, DMA_CSR_ESG(value)))
#define DMA_BWR_CSR_ESG(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_ESG_SHIFT), DMA_CSR_ESG_SHIFT, DMA_CSR_ESG_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled.
 * - 0b1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORELINK field. */
#define DMA_RD_CSR_MAJORELINK(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORELINK_MASK) >> DMA_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_CSR_MAJORELINK(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_CSR_MAJORELINK(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORELINK_MASK, DMA_CSR_MAJORELINK(value)))
#define DMA_BWR_CSR_MAJORELINK(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORELINK_SHIFT), DMA_CSR_MAJORELINK_SHIFT, DMA_CSR_MAJORELINK_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field ACTIVE[6] (RO)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ACTIVE field. */
#define DMA_RD_CSR_ACTIVE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ACTIVE_MASK) >> DMA_CSR_ACTIVE_SHIFT)
#define DMA_BRD_CSR_ACTIVE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT, DMA_CSR_ACTIVE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DONE field. */
#define DMA_RD_CSR_DONE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT)
#define DMA_BRD_CSR_DONE(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_CSR_DONE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DONE_MASK, DMA_CSR_DONE(value)))
#define DMA_BWR_CSR_DONE(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_DONE_SHIFT), DMA_CSR_DONE_SHIFT, DMA_CSR_DONE_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORLINKCH[12:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORLINKCH field. */
#define DMA_RD_CSR_MAJORLINKCH(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORLINKCH_MASK) >> DMA_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_CSR_MAJORLINKCH(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_CSR_MAJORLINKCH(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORLINKCH_MASK, DMA_CSR_MAJORLINKCH(value)))
#define DMA_BWR_CSR_MAJORLINKCH(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_MAJORLINKCH_SHIFT), DMA_CSR_MAJORLINKCH_SHIFT, DMA_CSR_MAJORLINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 0b00 - No eDMA engine stalls.
 * - 0b01 - Reserved
 * - 0b10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 0b11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_BWC field. */
#define DMA_RD_CSR_BWC(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_BWC_MASK) >> DMA_CSR_BWC_SHIFT)
#define DMA_BRD_CSR_BWC(base, index) (BME_UBFX16(&DMA_CSR_REG(base, index), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_CSR_BWC(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_BWC_MASK, DMA_CSR_BWC(value)))
#define DMA_BWR_CSR_BWC(base, index, value) (BME_BFI16(&DMA_CSR_REG(base, index), ((uint16_t)(value) << DMA_CSR_BWC_SHIFT), DMA_CSR_BWC_SHIFT, DMA_CSR_BWC_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_BITER_ELINKNO(base, index) (DMA_BITER_ELINKNO_REG(base, index))
#define DMA_WR_BITER_ELINKNO(base, index, value) (DMA_BITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKNO(base, index, mask, value) (DMA_WR_BITER_ELINKNO(base, index, (DMA_RD_BITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKNO(base, index, value) (BME_OR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKNO(base, index, value) (BME_AND16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKNO(base, index, value) (BME_XOR16(&DMA_BITER_ELINKNO_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_BITER field. */
#define DMA_RD_BITER_ELINKNO_BITER(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_BITER_MASK) >> DMA_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKNO_BITER(base, index) (DMA_RD_BITER_ELINKNO_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKNO_BITER(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_BITER_MASK, DMA_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_BITER_ELINKNO_BITER(base, index, value) (DMA_WR_BITER_ELINKNO_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_ELINK field. */
#define DMA_RD_BITER_ELINKNO_ELINK(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_ELINK_MASK) >> DMA_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKNO_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_ELINK_MASK, DMA_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_BITER_ELINKNO_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKNO_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKNO_ELINK_SHIFT), DMA_BITER_ELINKNO_ELINK_SHIFT, DMA_BITER_ELINKNO_ELINK_WIDTH))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_BITER_ELINKYES(base, index) (DMA_BITER_ELINKYES_REG(base, index))
#define DMA_WR_BITER_ELINKYES(base, index, value) (DMA_BITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKYES(base, index, mask, value) (DMA_WR_BITER_ELINKYES(base, index, (DMA_RD_BITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKYES(base, index, value) (BME_OR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
#define DMA_CLR_BITER_ELINKYES(base, index, value) (BME_AND16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(~(value))))
#define DMA_TOG_BITER_ELINKYES(base, index, value) (BME_XOR16(&DMA_BITER_ELINKYES_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_BITER field. */
#define DMA_RD_BITER_ELINKYES_BITER(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_BITER_MASK) >> DMA_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKYES_BITER(base, index) (DMA_RD_BITER_ELINKYES_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKYES_BITER(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_BITER_MASK, DMA_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_BITER_ELINKYES_BITER(base, index, value) (DMA_WR_BITER_ELINKYES_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field LINKCH[13:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_BITER_ELINKYES_LINKCH(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_LINKCH_MASK) >> DMA_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_BITER_ELINKYES_LINKCH(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_LINKCH_MASK, DMA_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_BITER_ELINKYES_LINKCH(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_LINKCH_SHIFT), DMA_BITER_ELINKYES_LINKCH_SHIFT, DMA_BITER_ELINKYES_LINKCH_WIDTH))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0b0 - The channel-to-channel linking is disabled
 * - 0b1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_ELINK field. */
#define DMA_RD_BITER_ELINKYES_ELINK(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_ELINK_MASK) >> DMA_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKYES_ELINK(base, index) (BME_UBFX16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_ELINK_MASK, DMA_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_BITER_ELINKYES_ELINK(base, index, value) (BME_BFI16(&DMA_BITER_ELINKYES_REG(base, index), ((uint16_t)(value) << DMA_BITER_ELINKYES_ELINK_SHIFT), DMA_BITER_ELINKYES_ELINK_SHIFT, DMA_BITER_ELINKYES_ELINK_WIDTH))
/*@}*/

/* Register macros for indexed access to DMA channel priority registers */
/*
 * Constants and macros for entire DMA_DCHPRIn register
 */
#define DMA_DCHPRIn_INDEX(channel)          (((channel) & ~0x03U) | (3 - ((channel) & 0x03U)))
#define DMA_DCHPRIn_REG(base, index)        (((volatile uint8_t *)&DMA_DCHPRI3_REG(base))[DMA_DCHPRIn_INDEX(index)])
#define DMA_RD_DCHPRIn(base, index)         (DMA_DCHPRIn_REG((base), (index)))
#define DMA_WR_DCHPRIn(base, index, value)  (DMA_DCHPRIn_REG((base), (index)) = (value))
#define DMA_SET_DCHPRIn(base, index, value) (BME_OR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))
#define DMA_CLR_DCHPRIn(base, index, value) (BME_AND8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(~(value))))
#define DMA_TOG_DCHPRIn(base, index, value) (BME_XOR8(&DMA_DCHPRIn_REG((base), (index)), (uint8_t)(value)))

/*
 * Register DMA_DCHPRIn, bit field CHPRI
 */
/* Read current value of the CHPRI bit field. */
#define DMA_RD_DCHPRIn_CHPRI(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRIn_CHPRI(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/* Set the CHPRI bit field to a new value. */
#define DMA_WR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_CHPRI_MASK) | DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRIn_CHPRI(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_CHPRI_SHIFT), DMA_DCHPRI0_CHPRI_SHIFT, DMA_DCHPRI0_CHPRI_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field DPA
 */
/* Read current value of the DPA bit field. */
#define DMA_RD_DCHPRIn_DPA(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRIn_DPA(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/* Set the DPA bit field to a new value. */
#define DMA_WR_DCHPRIn_DPA(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_DPA_MASK) | DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRIn_DPA(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_DPA_SHIFT), DMA_DCHPRI0_DPA_SHIFT, DMA_DCHPRI0_DPA_WIDTH))

/*
 * Register DMA_DCHPRIn, bit field ECP
 */
/* Read current value of the ECP bit field. */
#define DMA_RD_DCHPRIn_ECP(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRIn_ECP(base, index) (BME_UBFX8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/* Set the ECP bit field to a new value. */
#define DMA_WR_DCHPRIn_ECP(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_ECP_MASK) | DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRIn_ECP(base, index, value) (BME_BFI8(&DMA_DCHPRIn_REG((base), (index)), ((uint8_t)(value) << DMA_DCHPRI0_ECP_SHIFT), DMA_DCHPRI0_ECP_SHIFT, DMA_DCHPRI0_ECP_WIDTH))

/*
 * MKV58F24 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX_IDX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (BME_OR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (BME_AND8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(~(value))))
#define DMAMUX_TOG_CHCFG(base, index, value) (BME_XOR8(&DMAMUX_CHCFG_REG(base, index), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_SOURCE_SHIFT), DMAMUX_CHCFG_SOURCE_SHIFT, DMAMUX_CHCFG_SOURCE_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0b0 - Triggering is disabled. If triggering is disabled and ENBL is set,
 *     the DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 0b1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_TRIG_SHIFT), DMAMUX_CHCFG_TRIG_SHIFT, DMAMUX_CHCFG_TRIG_WIDTH))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0b0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 0b1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BME_UBFX8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BME_BFI8(&DMAMUX_CHCFG_REG(base, index), ((uint8_t)(value) << DMAMUX_CHCFG_ENBL_SHIFT), DMAMUX_CHCFG_ENBL_SHIFT, DMAMUX_CHCFG_ENBL_WIDTH))
/*@}*/

/*
 * MKV58F24 ENC
 *
 * Quadrature Decoder
 *
 * Registers defined in this header file:
 * - ENC_CTRL - Control Register
 * - ENC_FILT - Input Filter Register
 * - ENC_WTR - Watchdog Timeout Register
 * - ENC_POSD - Position Difference Counter Register
 * - ENC_POSDH - Position Difference Hold Register
 * - ENC_REV - Revolution Counter Register
 * - ENC_REVH - Revolution Hold Register
 * - ENC_UPOS - Upper Position Counter Register
 * - ENC_LPOS - Lower Position Counter Register
 * - ENC_UPOSH - Upper Position Hold Register
 * - ENC_LPOSH - Lower Position Hold Register
 * - ENC_UINIT - Upper Initialization Register
 * - ENC_LINIT - Lower Initialization Register
 * - ENC_IMR - Input Monitor Register
 * - ENC_TST - Test Register
 * - ENC_CTRL2 - Control 2 Register
 * - ENC_UMOD - Upper Modulus Register
 * - ENC_LMOD - Lower Modulus Register
 * - ENC_UCOMP - Upper Position Compare Register
 * - ENC_LCOMP - Lower Position Compare Register
 */

#define ENC_INSTANCE_COUNT (1U) /*!< Number of instances of the ENC module. */
#define ENC_IDX (0U) /*!< Instance number for ENC. */

/*******************************************************************************
 * ENC_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief ENC_CTRL - Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_CTRL register
 */
/*@{*/
#define ENC_RD_CTRL(base)        (ENC_CTRL_REG(base))
#define ENC_WR_CTRL(base, value) (ENC_CTRL_REG(base) = (value))
#define ENC_RMW_CTRL(base, mask, value) (ENC_WR_CTRL(base, (ENC_RD_CTRL(base) & ~(mask)) | (value)))
#define ENC_SET_CTRL(base, value) (BME_OR16(&ENC_CTRL_REG(base), (uint16_t)(value)))
#define ENC_CLR_CTRL(base, value) (BME_AND16(&ENC_CTRL_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_CTRL(base, value) (BME_XOR16(&ENC_CTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENC_CTRL bitfields
 */

/*!
 * @name Register ENC_CTRL, field CMPIE[0] (RW)
 *
 * This read/write bit enables compare interrupts.
 *
 * Values:
 * - 0b0 - Compare interrupt is disabled
 * - 0b1 - Compare interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_CMPIE field. */
#define ENC_RD_CTRL_CMPIE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_CMPIE_MASK) >> ENC_CTRL_CMPIE_SHIFT)
#define ENC_BRD_CTRL_CMPIE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_CMPIE_SHIFT, ENC_CTRL_CMPIE_WIDTH))

/*! @brief Set the CMPIE field to a new value. */
#define ENC_WR_CTRL_CMPIE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_CMPIE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_CMPIE(value)))
#define ENC_BWR_CTRL_CMPIE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_CMPIE_SHIFT), ENC_CTRL_CMPIE_SHIFT, ENC_CTRL_CMPIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field CMPIRQ[1] (W1C)
 *
 * This bit is set when a match occurs between the counter and the COMP value.
 * It will remain set until cleared by software. Write a one to this bit to clear.
 *
 * Values:
 * - 0b0 - No match has occurred
 * - 0b1 - COMP match has occurred
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_CMPIRQ field. */
#define ENC_RD_CTRL_CMPIRQ(base) ((ENC_CTRL_REG(base) & ENC_CTRL_CMPIRQ_MASK) >> ENC_CTRL_CMPIRQ_SHIFT)
#define ENC_BRD_CTRL_CMPIRQ(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_CMPIRQ_SHIFT, ENC_CTRL_CMPIRQ_WIDTH))

/*! @brief Set the CMPIRQ field to a new value. */
#define ENC_WR_CTRL_CMPIRQ(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_CMPIRQ(value)))
#define ENC_BWR_CTRL_CMPIRQ(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_CMPIRQ_SHIFT), ENC_CTRL_CMPIRQ_SHIFT, ENC_CTRL_CMPIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field WDE[2] (RW)
 *
 * This bit allows operation of the watchdog timer monitoring the PHASEA and
 * PHASEB inputs for motor movement.
 *
 * Values:
 * - 0b0 - Watchdog timer is disabled
 * - 0b1 - Watchdog timer is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_WDE field. */
#define ENC_RD_CTRL_WDE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_WDE_MASK) >> ENC_CTRL_WDE_SHIFT)
#define ENC_BRD_CTRL_WDE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_WDE_SHIFT, ENC_CTRL_WDE_WIDTH))

/*! @brief Set the WDE field to a new value. */
#define ENC_WR_CTRL_WDE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_WDE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_WDE(value)))
#define ENC_BWR_CTRL_WDE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_WDE_SHIFT), ENC_CTRL_WDE_SHIFT, ENC_CTRL_WDE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field DIE[3] (RW)
 *
 * This read/write bit enables watchdog timeout interrupts.
 *
 * Values:
 * - 0b0 - Watchdog timer interrupt is disabled
 * - 0b1 - Watchdog timer interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_DIE field. */
#define ENC_RD_CTRL_DIE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_DIE_MASK) >> ENC_CTRL_DIE_SHIFT)
#define ENC_BRD_CTRL_DIE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_DIE_SHIFT, ENC_CTRL_DIE_WIDTH))

/*! @brief Set the DIE field to a new value. */
#define ENC_WR_CTRL_DIE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_DIE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_DIE(value)))
#define ENC_BWR_CTRL_DIE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_DIE_SHIFT), ENC_CTRL_DIE_SHIFT, ENC_CTRL_DIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field DIRQ[4] (W1C)
 *
 * This bit is set when a watchdog timeout interrupt occurs. It will remain set
 * until cleared by software. Write a one to this bit to clear. This bit is also
 * cleared when CTRL[WDE] is 0.
 *
 * Values:
 * - 0b0 - No interrupt has occurred
 * - 0b1 - Watchdog timeout interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_DIRQ field. */
#define ENC_RD_CTRL_DIRQ(base) ((ENC_CTRL_REG(base) & ENC_CTRL_DIRQ_MASK) >> ENC_CTRL_DIRQ_SHIFT)
#define ENC_BRD_CTRL_DIRQ(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_DIRQ_SHIFT, ENC_CTRL_DIRQ_WIDTH))

/*! @brief Set the DIRQ field to a new value. */
#define ENC_WR_CTRL_DIRQ(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_DIRQ_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_DIRQ(value)))
#define ENC_BWR_CTRL_DIRQ(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_DIRQ_SHIFT), ENC_CTRL_DIRQ_SHIFT, ENC_CTRL_DIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field XNE[5] (RW)
 *
 * This read/write bit determines the edge of the INDEX pulse used to initialize
 * the position counter.
 *
 * Values:
 * - 0b0 - Use positive transition edge of INDEX pulse
 * - 0b1 - Use negative transition edge of INDEX pulse
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_XNE field. */
#define ENC_RD_CTRL_XNE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_XNE_MASK) >> ENC_CTRL_XNE_SHIFT)
#define ENC_BRD_CTRL_XNE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_XNE_SHIFT, ENC_CTRL_XNE_WIDTH))

/*! @brief Set the XNE field to a new value. */
#define ENC_WR_CTRL_XNE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_XNE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_XNE(value)))
#define ENC_BWR_CTRL_XNE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_XNE_SHIFT), ENC_CTRL_XNE_SHIFT, ENC_CTRL_XNE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field XIP[6] (RW)
 *
 * This read/write bit enables the position counter to be initialized by the
 * INDEX pulse.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - INDEX pulse initializes the position counter
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_XIP field. */
#define ENC_RD_CTRL_XIP(base) ((ENC_CTRL_REG(base) & ENC_CTRL_XIP_MASK) >> ENC_CTRL_XIP_SHIFT)
#define ENC_BRD_CTRL_XIP(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_XIP_SHIFT, ENC_CTRL_XIP_WIDTH))

/*! @brief Set the XIP field to a new value. */
#define ENC_WR_CTRL_XIP(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_XIP_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_XIP(value)))
#define ENC_BWR_CTRL_XIP(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_XIP_SHIFT), ENC_CTRL_XIP_SHIFT, ENC_CTRL_XIP_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field XIE[7] (RW)
 *
 * This read/write bit enables index interrupts.
 *
 * Values:
 * - 0b0 - INDEX pulse interrupt is disabled
 * - 0b1 - INDEX pulse interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_XIE field. */
#define ENC_RD_CTRL_XIE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_XIE_MASK) >> ENC_CTRL_XIE_SHIFT)
#define ENC_BRD_CTRL_XIE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_XIE_SHIFT, ENC_CTRL_XIE_WIDTH))

/*! @brief Set the XIE field to a new value. */
#define ENC_WR_CTRL_XIE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_XIE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_XIE(value)))
#define ENC_BWR_CTRL_XIE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_XIE_SHIFT), ENC_CTRL_XIE_SHIFT, ENC_CTRL_XIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field XIRQ[8] (W1C)
 *
 * This bit is set when an INDEX interrupt occurs. It will remain set until
 * cleared by software. The clearing procedure is to write a one to this bit.
 *
 * Values:
 * - 0b0 - No interrupt has occurred
 * - 0b1 - INDEX pulse interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_XIRQ field. */
#define ENC_RD_CTRL_XIRQ(base) ((ENC_CTRL_REG(base) & ENC_CTRL_XIRQ_MASK) >> ENC_CTRL_XIRQ_SHIFT)
#define ENC_BRD_CTRL_XIRQ(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_XIRQ_SHIFT, ENC_CTRL_XIRQ_WIDTH))

/*! @brief Set the XIRQ field to a new value. */
#define ENC_WR_CTRL_XIRQ(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_XIRQ_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_XIRQ(value)))
#define ENC_BWR_CTRL_XIRQ(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_XIRQ_SHIFT), ENC_CTRL_XIRQ_SHIFT, ENC_CTRL_XIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field PH1[9] (RW)
 *
 * This read/write bit bypasses the quadrature decoder logic.
 *
 * Values:
 * - 0b0 - Use standard quadrature decoder where PHASEA and PHASEB represent a
 *     two phase quadrature signal.
 * - 0b1 - Bypass the quadrature decoder. A positive transition of the PHASEA
 *     input generates a count signal. The PHASEB input and the REV bit control the
 *     counter direction. If CTRL[REV] = 0, PHASEB = 0, then count up If
 *     CTRL[REV] = 0, PHASEB = 1, then count down If CTRL[REV] = 1, PHASEB = 0, then
 *     count down If CTRL[REV] = 1, PHASEB = 1, then count up
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_PH1 field. */
#define ENC_RD_CTRL_PH1(base) ((ENC_CTRL_REG(base) & ENC_CTRL_PH1_MASK) >> ENC_CTRL_PH1_SHIFT)
#define ENC_BRD_CTRL_PH1(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_PH1_SHIFT, ENC_CTRL_PH1_WIDTH))

/*! @brief Set the PH1 field to a new value. */
#define ENC_WR_CTRL_PH1(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_PH1_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_PH1(value)))
#define ENC_BWR_CTRL_PH1(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_PH1_SHIFT), ENC_CTRL_PH1_SHIFT, ENC_CTRL_PH1_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field REV[10] (RW)
 *
 * This read/write bit reverses the interpretation of the quadrature signal,
 * changing the direction of count.
 *
 * Values:
 * - 0b0 - Count normally
 * - 0b1 - Count in the reverse direction
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_REV field. */
#define ENC_RD_CTRL_REV(base) ((ENC_CTRL_REG(base) & ENC_CTRL_REV_MASK) >> ENC_CTRL_REV_SHIFT)
#define ENC_BRD_CTRL_REV(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_REV_SHIFT, ENC_CTRL_REV_WIDTH))

/*! @brief Set the REV field to a new value. */
#define ENC_WR_CTRL_REV(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_REV_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_REV(value)))
#define ENC_BWR_CTRL_REV(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_REV_SHIFT), ENC_CTRL_REV_SHIFT, ENC_CTRL_REV_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field SWIP[11] (WORZ)
 *
 * Writing a one to this bit will transfer the UINIT and LINIT contents to UPOS
 * and LPOS. This bit is always read as a zero.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - Initialize position counter
 */
/*@{*/
/*! @brief Set the SWIP field to a new value. */
#define ENC_WR_CTRL_SWIP(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_SWIP_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_SWIP(value)))
#define ENC_BWR_CTRL_SWIP(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_SWIP_SHIFT), ENC_CTRL_SWIP_SHIFT, ENC_CTRL_SWIP_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field HNE[12] (RW)
 *
 * This read/write bit determines whether to use the positive or negative edge
 * of the HOME input.
 *
 * Values:
 * - 0b0 - Use positive going edge-to-trigger initialization of position
 *     counters UPOS and LPOS
 * - 0b1 - Use negative going edge-to-trigger initialization of position
 *     counters UPOS and LPOS
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_HNE field. */
#define ENC_RD_CTRL_HNE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_HNE_MASK) >> ENC_CTRL_HNE_SHIFT)
#define ENC_BRD_CTRL_HNE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_HNE_SHIFT, ENC_CTRL_HNE_WIDTH))

/*! @brief Set the HNE field to a new value. */
#define ENC_WR_CTRL_HNE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_HNE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_HNE(value)))
#define ENC_BWR_CTRL_HNE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_HNE_SHIFT), ENC_CTRL_HNE_SHIFT, ENC_CTRL_HNE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field HIP[13] (RW)
 *
 * This read/write bit allows the position counter to be initialized by the HOME
 * signal.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - HOME signal initializes the position counter
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_HIP field. */
#define ENC_RD_CTRL_HIP(base) ((ENC_CTRL_REG(base) & ENC_CTRL_HIP_MASK) >> ENC_CTRL_HIP_SHIFT)
#define ENC_BRD_CTRL_HIP(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_HIP_SHIFT, ENC_CTRL_HIP_WIDTH))

/*! @brief Set the HIP field to a new value. */
#define ENC_WR_CTRL_HIP(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_HIP_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_HIP(value)))
#define ENC_BWR_CTRL_HIP(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_HIP_SHIFT), ENC_CTRL_HIP_SHIFT, ENC_CTRL_HIP_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field HIE[14] (RW)
 *
 * This read/write bit enables HOME signal interrupts.
 *
 * Values:
 * - 0b0 - Disable HOME interrupts
 * - 0b1 - Enable HOME interrupts
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_HIE field. */
#define ENC_RD_CTRL_HIE(base) ((ENC_CTRL_REG(base) & ENC_CTRL_HIE_MASK) >> ENC_CTRL_HIE_SHIFT)
#define ENC_BRD_CTRL_HIE(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_HIE_SHIFT, ENC_CTRL_HIE_WIDTH))

/*! @brief Set the HIE field to a new value. */
#define ENC_WR_CTRL_HIE(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_HIE_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK | ENC_CTRL_HIRQ_MASK), ENC_CTRL_HIE(value)))
#define ENC_BWR_CTRL_HIE(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_HIE_SHIFT), ENC_CTRL_HIE_SHIFT, ENC_CTRL_HIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL, field HIRQ[15] (W1C)
 *
 * This bit is set when a transition on the HOME signal occurs according to the
 * CTRL[HNE] bit. If this bit is set and CTRL[HIE] is set, a HOME interrupt
 * occurs. This bit will remain set until it is cleared by software. Write a one to
 * this bit to clear.
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - HOME signal transition interrupt request
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL_HIRQ field. */
#define ENC_RD_CTRL_HIRQ(base) ((ENC_CTRL_REG(base) & ENC_CTRL_HIRQ_MASK) >> ENC_CTRL_HIRQ_SHIFT)
#define ENC_BRD_CTRL_HIRQ(base) (BME_UBFX16(&ENC_CTRL_REG(base), ENC_CTRL_HIRQ_SHIFT, ENC_CTRL_HIRQ_WIDTH))

/*! @brief Set the HIRQ field to a new value. */
#define ENC_WR_CTRL_HIRQ(base, value) (ENC_RMW_CTRL(base, (ENC_CTRL_HIRQ_MASK | ENC_CTRL_CMPIRQ_MASK | ENC_CTRL_DIRQ_MASK | ENC_CTRL_XIRQ_MASK), ENC_CTRL_HIRQ(value)))
#define ENC_BWR_CTRL_HIRQ(base, value) (BME_BFI16(&ENC_CTRL_REG(base), ((uint16_t)(value) << ENC_CTRL_HIRQ_SHIFT), ENC_CTRL_HIRQ_SHIFT, ENC_CTRL_HIRQ_WIDTH))
/*@}*/

/*******************************************************************************
 * ENC_FILT - Input Filter Register
 ******************************************************************************/

/*!
 * @brief ENC_FILT - Input Filter Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register sets the values of the input filter sample period (FILT_PER)
 * and the input filter sample count (FILT_CNT). The FILT_PER value should be set
 * such that the sampling period is larger than the period of the expected noise.
 * This way a noise spike will only corrupt one sample. The FILT_CNT value should
 * be chosen to reduce the probablility of noisy samples causing an incorrect
 * transition to be recognized. The probability of an incorrect transition is
 * defined as the probability of an incorrect sample raised to the power of
 * FILT_CNT+3. The values of FILT_PER and FILT_CNT must also be traded off against the
 * desire for minimal latency in recognizing valid input transitions. Turning on the
 * input filter (setting FILT_PER to a non-zero value) introduces a latency of
 * ((FILT_CNT+3)*FILT_PER+2) IPBus clock periods. The filter latency can be
 * measured as follows: drive the quadrature decoder inputs, PHASEA, PHASEB, INDEX, and
 * HOME monitoring the filtered output in the input monitor register (IMR).
 * Determine how many IPBus clock cycles it takes before the output shows up, by using
 * the following equations, where f is FILT_PER and s is FILT_CNT. DELAY (IPBus
 * clock cycles) = f * (s+3) +1 (to read the filtered output) DELAY (IPBus clock
 * cycles) = f * (s+3) +2 (to monitor the output in the IMR) One more additional
 * IPBus clock cycle is needed to read the filtered output, and two more IPBus
 * clock cycles are needed to monitor the filtered output in the IMR. The sample
 * rate is set when it reaches the number f. The following examples employ the
 * preceding equations: Example: when f = 0, the filter is bypassed. Therefore, DELAY
 * = 1 or 2 clock cycles. Example: when f = 5 and s = 2, DELAY = 5 * (2+3) + (1
 * or 2) = 26 or 27 clock cycles.
 */
/*!
 * @name Constants and macros for entire ENC_FILT register
 */
/*@{*/
#define ENC_RD_FILT(base)        (ENC_FILT_REG(base))
#define ENC_WR_FILT(base, value) (ENC_FILT_REG(base) = (value))
#define ENC_RMW_FILT(base, mask, value) (ENC_WR_FILT(base, (ENC_RD_FILT(base) & ~(mask)) | (value)))
#define ENC_SET_FILT(base, value) (BME_OR16(&ENC_FILT_REG(base), (uint16_t)(value)))
#define ENC_CLR_FILT(base, value) (BME_AND16(&ENC_FILT_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_FILT(base, value) (BME_XOR16(&ENC_FILT_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENC_FILT bitfields
 */

/*!
 * @name Register ENC_FILT, field FILT_PER[7:0] (RW)
 *
 * These bits represent the sampling period (in IPBus clock cycles) of the
 * decoder input signals. Each input is sampled multiple times at the rate specified
 * by this field. If FILT_PER is 0x00 (default), then the input filter is
 * bypassed. Bypassing the digital filter enables the position/position difference
 * counters to operate with count rates up to the IPBus frequency. The value of
 * FILT_PER affects the input latency. When changing FILT_PER from one non-zero value to
 * another non-zero value, write a value of 0 first in order to clear the filter.
 */
/*@{*/
/*! @brief Read current value of the ENC_FILT_FILT_PER field. */
#define ENC_RD_FILT_FILT_PER(base) ((ENC_FILT_REG(base) & ENC_FILT_FILT_PER_MASK) >> ENC_FILT_FILT_PER_SHIFT)
#define ENC_BRD_FILT_FILT_PER(base) (BME_UBFX16(&ENC_FILT_REG(base), ENC_FILT_FILT_PER_SHIFT, ENC_FILT_FILT_PER_WIDTH))

/*! @brief Set the FILT_PER field to a new value. */
#define ENC_WR_FILT_FILT_PER(base, value) (ENC_RMW_FILT(base, ENC_FILT_FILT_PER_MASK, ENC_FILT_FILT_PER(value)))
#define ENC_BWR_FILT_FILT_PER(base, value) (BME_BFI16(&ENC_FILT_REG(base), ((uint16_t)(value) << ENC_FILT_FILT_PER_SHIFT), ENC_FILT_FILT_PER_SHIFT, ENC_FILT_FILT_PER_WIDTH))
/*@}*/

/*!
 * @name Register ENC_FILT, field FILT_CNT[10:8] (RW)
 *
 * These bits represent the number of consecutive samples that must agree prior
 * to the input filter accepting an input transition. A value of 0x0 represents 3
 * samples. A value of 0x7 represents 10 samples. The value of FILT_CNT affects
 * the input latency.
 */
/*@{*/
/*! @brief Read current value of the ENC_FILT_FILT_CNT field. */
#define ENC_RD_FILT_FILT_CNT(base) ((ENC_FILT_REG(base) & ENC_FILT_FILT_CNT_MASK) >> ENC_FILT_FILT_CNT_SHIFT)
#define ENC_BRD_FILT_FILT_CNT(base) (BME_UBFX16(&ENC_FILT_REG(base), ENC_FILT_FILT_CNT_SHIFT, ENC_FILT_FILT_CNT_WIDTH))

/*! @brief Set the FILT_CNT field to a new value. */
#define ENC_WR_FILT_FILT_CNT(base, value) (ENC_RMW_FILT(base, ENC_FILT_FILT_CNT_MASK, ENC_FILT_FILT_CNT(value)))
#define ENC_BWR_FILT_FILT_CNT(base, value) (BME_BFI16(&ENC_FILT_REG(base), ((uint16_t)(value) << ENC_FILT_FILT_CNT_SHIFT), ENC_FILT_FILT_CNT_SHIFT, ENC_FILT_FILT_CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * ENC_WTR - Watchdog Timeout Register
 ******************************************************************************/

/*!
 * @brief ENC_WTR - Watchdog Timeout Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This read/write register stores the timeout count for the quadrature decoder
 * module watchdog timer. This timer is separate from the watchdog timer in the
 * COP module.
 */
/*!
 * @name Constants and macros for entire ENC_WTR register
 */
/*@{*/
#define ENC_RD_WTR(base)         (ENC_WTR_REG(base))
#define ENC_WR_WTR(base, value)  (ENC_WTR_REG(base) = (value))
#define ENC_RMW_WTR(base, mask, value) (ENC_WR_WTR(base, (ENC_RD_WTR(base) & ~(mask)) | (value)))
#define ENC_SET_WTR(base, value) (BME_OR16(&ENC_WTR_REG(base), (uint16_t)(value)))
#define ENC_CLR_WTR(base, value) (BME_AND16(&ENC_WTR_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_WTR(base, value) (BME_XOR16(&ENC_WTR_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_POSD - Position Difference Counter Register
 ******************************************************************************/

/*!
 * @brief ENC_POSD - Position Difference Counter Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_POSD register
 */
/*@{*/
#define ENC_RD_POSD(base)        (ENC_POSD_REG(base))
#define ENC_WR_POSD(base, value) (ENC_POSD_REG(base) = (value))
#define ENC_RMW_POSD(base, mask, value) (ENC_WR_POSD(base, (ENC_RD_POSD(base) & ~(mask)) | (value)))
#define ENC_SET_POSD(base, value) (BME_OR16(&ENC_POSD_REG(base), (uint16_t)(value)))
#define ENC_CLR_POSD(base, value) (BME_AND16(&ENC_POSD_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_POSD(base, value) (BME_XOR16(&ENC_POSD_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_POSDH - Position Difference Hold Register
 ******************************************************************************/

/*!
 * @brief ENC_POSDH - Position Difference Hold Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_POSDH register
 */
/*@{*/
#define ENC_RD_POSDH(base)       (ENC_POSDH_REG(base))
/*@}*/

/*******************************************************************************
 * ENC_REV - Revolution Counter Register
 ******************************************************************************/

/*!
 * @brief ENC_REV - Revolution Counter Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_REV register
 */
/*@{*/
#define ENC_RD_REV(base)         (ENC_REV_REG(base))
#define ENC_WR_REV(base, value)  (ENC_REV_REG(base) = (value))
#define ENC_RMW_REV(base, mask, value) (ENC_WR_REV(base, (ENC_RD_REV(base) & ~(mask)) | (value)))
#define ENC_SET_REV(base, value) (BME_OR16(&ENC_REV_REG(base), (uint16_t)(value)))
#define ENC_CLR_REV(base, value) (BME_AND16(&ENC_REV_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_REV(base, value) (BME_XOR16(&ENC_REV_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_REVH - Revolution Hold Register
 ******************************************************************************/

/*!
 * @brief ENC_REVH - Revolution Hold Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_REVH register
 */
/*@{*/
#define ENC_RD_REVH(base)        (ENC_REVH_REG(base))
/*@}*/

/*******************************************************************************
 * ENC_UPOS - Upper Position Counter Register
 ******************************************************************************/

/*!
 * @brief ENC_UPOS - Upper Position Counter Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_UPOS register
 */
/*@{*/
#define ENC_RD_UPOS(base)        (ENC_UPOS_REG(base))
#define ENC_WR_UPOS(base, value) (ENC_UPOS_REG(base) = (value))
#define ENC_RMW_UPOS(base, mask, value) (ENC_WR_UPOS(base, (ENC_RD_UPOS(base) & ~(mask)) | (value)))
#define ENC_SET_UPOS(base, value) (BME_OR16(&ENC_UPOS_REG(base), (uint16_t)(value)))
#define ENC_CLR_UPOS(base, value) (BME_AND16(&ENC_UPOS_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_UPOS(base, value) (BME_XOR16(&ENC_UPOS_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_LPOS - Lower Position Counter Register
 ******************************************************************************/

/*!
 * @brief ENC_LPOS - Lower Position Counter Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_LPOS register
 */
/*@{*/
#define ENC_RD_LPOS(base)        (ENC_LPOS_REG(base))
#define ENC_WR_LPOS(base, value) (ENC_LPOS_REG(base) = (value))
#define ENC_RMW_LPOS(base, mask, value) (ENC_WR_LPOS(base, (ENC_RD_LPOS(base) & ~(mask)) | (value)))
#define ENC_SET_LPOS(base, value) (BME_OR16(&ENC_LPOS_REG(base), (uint16_t)(value)))
#define ENC_CLR_LPOS(base, value) (BME_AND16(&ENC_LPOS_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_LPOS(base, value) (BME_XOR16(&ENC_LPOS_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_UPOSH - Upper Position Hold Register
 ******************************************************************************/

/*!
 * @brief ENC_UPOSH - Upper Position Hold Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_UPOSH register
 */
/*@{*/
#define ENC_RD_UPOSH(base)       (ENC_UPOSH_REG(base))
/*@}*/

/*******************************************************************************
 * ENC_LPOSH - Lower Position Hold Register
 ******************************************************************************/

/*!
 * @brief ENC_LPOSH - Lower Position Hold Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_LPOSH register
 */
/*@{*/
#define ENC_RD_LPOSH(base)       (ENC_LPOSH_REG(base))
/*@}*/

/*******************************************************************************
 * ENC_UINIT - Upper Initialization Register
 ******************************************************************************/

/*!
 * @brief ENC_UINIT - Upper Initialization Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_UINIT register
 */
/*@{*/
#define ENC_RD_UINIT(base)       (ENC_UINIT_REG(base))
#define ENC_WR_UINIT(base, value) (ENC_UINIT_REG(base) = (value))
#define ENC_RMW_UINIT(base, mask, value) (ENC_WR_UINIT(base, (ENC_RD_UINIT(base) & ~(mask)) | (value)))
#define ENC_SET_UINIT(base, value) (BME_OR16(&ENC_UINIT_REG(base), (uint16_t)(value)))
#define ENC_CLR_UINIT(base, value) (BME_AND16(&ENC_UINIT_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_UINIT(base, value) (BME_XOR16(&ENC_UINIT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_LINIT - Lower Initialization Register
 ******************************************************************************/

/*!
 * @brief ENC_LINIT - Lower Initialization Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_LINIT register
 */
/*@{*/
#define ENC_RD_LINIT(base)       (ENC_LINIT_REG(base))
#define ENC_WR_LINIT(base, value) (ENC_LINIT_REG(base) = (value))
#define ENC_RMW_LINIT(base, mask, value) (ENC_WR_LINIT(base, (ENC_RD_LINIT(base) & ~(mask)) | (value)))
#define ENC_SET_LINIT(base, value) (BME_OR16(&ENC_LINIT_REG(base), (uint16_t)(value)))
#define ENC_CLR_LINIT(base, value) (BME_AND16(&ENC_LINIT_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_LINIT(base, value) (BME_XOR16(&ENC_LINIT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_IMR - Input Monitor Register
 ******************************************************************************/

/*!
 * @brief ENC_IMR - Input Monitor Register (RO)
 *
 * Reset value: 0x0000U
 *
 * This read-only register contains the values of the raw and filtered PHASEA,
 * PHASEB, INDEX, and HOME input signals. The reset value depends on the values of
 * the raw and filtered values of PHASEA, PHASEB, INDEX, and HOME. If these
 * input pins are connected to a pull-up, bits 0-7 of the IMR are all ones. If these
 * input pins are connected to a pull-down device, bits 0-7 are all zeros.
 */
/*!
 * @name Constants and macros for entire ENC_IMR register
 */
/*@{*/
#define ENC_RD_IMR(base)         (ENC_IMR_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENC_IMR bitfields
 */

/*!
 * @name Register ENC_IMR, field HOME[0] (RO)
 *
 * This is the raw HOME input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_HOME field. */
#define ENC_RD_IMR_HOME(base) ((ENC_IMR_REG(base) & ENC_IMR_HOME_MASK) >> ENC_IMR_HOME_SHIFT)
#define ENC_BRD_IMR_HOME(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_HOME_SHIFT, ENC_IMR_HOME_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field INDEX[1] (RO)
 *
 * This is the raw INDEX input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_INDEX field. */
#define ENC_RD_IMR_INDEX(base) ((ENC_IMR_REG(base) & ENC_IMR_INDEX_MASK) >> ENC_IMR_INDEX_SHIFT)
#define ENC_BRD_IMR_INDEX(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_INDEX_SHIFT, ENC_IMR_INDEX_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field PHB[2] (RO)
 *
 * This is the raw PHASEB input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_PHB field. */
#define ENC_RD_IMR_PHB(base) ((ENC_IMR_REG(base) & ENC_IMR_PHB_MASK) >> ENC_IMR_PHB_SHIFT)
#define ENC_BRD_IMR_PHB(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_PHB_SHIFT, ENC_IMR_PHB_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field PHA[3] (RO)
 *
 * This is the raw PHASEA input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_PHA field. */
#define ENC_RD_IMR_PHA(base) ((ENC_IMR_REG(base) & ENC_IMR_PHA_MASK) >> ENC_IMR_PHA_SHIFT)
#define ENC_BRD_IMR_PHA(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_PHA_SHIFT, ENC_IMR_PHA_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field FHOM[4] (RO)
 *
 * This is the filtered version of HOME input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_FHOM field. */
#define ENC_RD_IMR_FHOM(base) ((ENC_IMR_REG(base) & ENC_IMR_FHOM_MASK) >> ENC_IMR_FHOM_SHIFT)
#define ENC_BRD_IMR_FHOM(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_FHOM_SHIFT, ENC_IMR_FHOM_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field FIND[5] (RO)
 *
 * This is the filtered version of INDEX input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_FIND field. */
#define ENC_RD_IMR_FIND(base) ((ENC_IMR_REG(base) & ENC_IMR_FIND_MASK) >> ENC_IMR_FIND_SHIFT)
#define ENC_BRD_IMR_FIND(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_FIND_SHIFT, ENC_IMR_FIND_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field FPHB[6] (RO)
 *
 * This is the filtered version of PHASEB input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_FPHB field. */
#define ENC_RD_IMR_FPHB(base) ((ENC_IMR_REG(base) & ENC_IMR_FPHB_MASK) >> ENC_IMR_FPHB_SHIFT)
#define ENC_BRD_IMR_FPHB(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_FPHB_SHIFT, ENC_IMR_FPHB_WIDTH))
/*@}*/

/*!
 * @name Register ENC_IMR, field FPHA[7] (RO)
 *
 * This is the filtered version of PHASEA input.
 */
/*@{*/
/*! @brief Read current value of the ENC_IMR_FPHA field. */
#define ENC_RD_IMR_FPHA(base) ((ENC_IMR_REG(base) & ENC_IMR_FPHA_MASK) >> ENC_IMR_FPHA_SHIFT)
#define ENC_BRD_IMR_FPHA(base) (BME_UBFX16(&ENC_IMR_REG(base), ENC_IMR_FPHA_SHIFT, ENC_IMR_FPHA_WIDTH))
/*@}*/

/*******************************************************************************
 * ENC_TST - Test Register
 ******************************************************************************/

/*!
 * @brief ENC_TST - Test Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This read/write register controls and sets the frequency of a quadrature
 * signal generator. It provides a quadrature test signal to the inputs of the
 * quadrature decoder module. The TEST_COUNT value is counted down to zero when the
 * test module is enabled (TEN = 1) and the count is enabled (TCE = 1). Each count
 * value of one represents a single quadrature cycle interpreted as a count of one
 * by the position counter (UPOS and LPOS) if it is so enabled. Repeated writing
 * of new values to TEST_COUNT can cause an extra phase transition and therefore
 * an extra count by the position counter. The period field determines in IPBus
 * clock cycles the length of each quadrature cycle phase. This register is a
 * factory test feature; however, it may be useful to customers' software
 * development and testing.
 */
/*!
 * @name Constants and macros for entire ENC_TST register
 */
/*@{*/
#define ENC_RD_TST(base)         (ENC_TST_REG(base))
#define ENC_WR_TST(base, value)  (ENC_TST_REG(base) = (value))
#define ENC_RMW_TST(base, mask, value) (ENC_WR_TST(base, (ENC_RD_TST(base) & ~(mask)) | (value)))
#define ENC_SET_TST(base, value) (BME_OR16(&ENC_TST_REG(base), (uint16_t)(value)))
#define ENC_CLR_TST(base, value) (BME_AND16(&ENC_TST_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_TST(base, value) (BME_XOR16(&ENC_TST_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENC_TST bitfields
 */

/*!
 * @name Register ENC_TST, field TEST_COUNT[7:0] (RW)
 *
 * These bits hold the number of quadrature advances to generate.
 */
/*@{*/
/*! @brief Read current value of the ENC_TST_TEST_COUNT field. */
#define ENC_RD_TST_TEST_COUNT(base) ((ENC_TST_REG(base) & ENC_TST_TEST_COUNT_MASK) >> ENC_TST_TEST_COUNT_SHIFT)
#define ENC_BRD_TST_TEST_COUNT(base) (BME_UBFX16(&ENC_TST_REG(base), ENC_TST_TEST_COUNT_SHIFT, ENC_TST_TEST_COUNT_WIDTH))

/*! @brief Set the TEST_COUNT field to a new value. */
#define ENC_WR_TST_TEST_COUNT(base, value) (ENC_RMW_TST(base, ENC_TST_TEST_COUNT_MASK, ENC_TST_TEST_COUNT(value)))
#define ENC_BWR_TST_TEST_COUNT(base, value) (BME_BFI16(&ENC_TST_REG(base), ((uint16_t)(value) << ENC_TST_TEST_COUNT_SHIFT), ENC_TST_TEST_COUNT_SHIFT, ENC_TST_TEST_COUNT_WIDTH))
/*@}*/

/*!
 * @name Register ENC_TST, field TEST_PERIOD[12:8] (RW)
 *
 * These bits hold the period of quadrature phase in IPBus clock cycles.
 */
/*@{*/
/*! @brief Read current value of the ENC_TST_TEST_PERIOD field. */
#define ENC_RD_TST_TEST_PERIOD(base) ((ENC_TST_REG(base) & ENC_TST_TEST_PERIOD_MASK) >> ENC_TST_TEST_PERIOD_SHIFT)
#define ENC_BRD_TST_TEST_PERIOD(base) (BME_UBFX16(&ENC_TST_REG(base), ENC_TST_TEST_PERIOD_SHIFT, ENC_TST_TEST_PERIOD_WIDTH))

/*! @brief Set the TEST_PERIOD field to a new value. */
#define ENC_WR_TST_TEST_PERIOD(base, value) (ENC_RMW_TST(base, ENC_TST_TEST_PERIOD_MASK, ENC_TST_TEST_PERIOD(value)))
#define ENC_BWR_TST_TEST_PERIOD(base, value) (BME_BFI16(&ENC_TST_REG(base), ((uint16_t)(value) << ENC_TST_TEST_PERIOD_SHIFT), ENC_TST_TEST_PERIOD_SHIFT, ENC_TST_TEST_PERIOD_WIDTH))
/*@}*/

/*!
 * @name Register ENC_TST, field QDN[13] (RW)
 *
 * When set, this bit generates a negative quadrature signal. Otherwise the
 * signal is in a positive direction.
 *
 * Values:
 * - 0b0 - Leaves quadrature decoder signal in a positive direction
 * - 0b1 - Generates a negative quadrature decoder signal
 */
/*@{*/
/*! @brief Read current value of the ENC_TST_QDN field. */
#define ENC_RD_TST_QDN(base) ((ENC_TST_REG(base) & ENC_TST_QDN_MASK) >> ENC_TST_QDN_SHIFT)
#define ENC_BRD_TST_QDN(base) (BME_UBFX16(&ENC_TST_REG(base), ENC_TST_QDN_SHIFT, ENC_TST_QDN_WIDTH))

/*! @brief Set the QDN field to a new value. */
#define ENC_WR_TST_QDN(base, value) (ENC_RMW_TST(base, ENC_TST_QDN_MASK, ENC_TST_QDN(value)))
#define ENC_BWR_TST_QDN(base, value) (BME_BFI16(&ENC_TST_REG(base), ((uint16_t)(value) << ENC_TST_QDN_SHIFT), ENC_TST_QDN_SHIFT, ENC_TST_QDN_WIDTH))
/*@}*/

/*!
 * @name Register ENC_TST, field TCE[14] (RW)
 *
 * This bit connects the test counter to inputs of the quadrature decoder module.
 *
 * Values:
 * - 0b0 - Test count is not enabled
 * - 0b1 - Test count is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_TST_TCE field. */
#define ENC_RD_TST_TCE(base) ((ENC_TST_REG(base) & ENC_TST_TCE_MASK) >> ENC_TST_TCE_SHIFT)
#define ENC_BRD_TST_TCE(base) (BME_UBFX16(&ENC_TST_REG(base), ENC_TST_TCE_SHIFT, ENC_TST_TCE_WIDTH))

/*! @brief Set the TCE field to a new value. */
#define ENC_WR_TST_TCE(base, value) (ENC_RMW_TST(base, ENC_TST_TCE_MASK, ENC_TST_TCE(value)))
#define ENC_BWR_TST_TCE(base, value) (BME_BFI16(&ENC_TST_REG(base), ((uint16_t)(value) << ENC_TST_TCE_SHIFT), ENC_TST_TCE_SHIFT, ENC_TST_TCE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_TST, field TEN[15] (RW)
 *
 * This bit connects the test module to inputs of the quadrature decoder module.
 *
 * Values:
 * - 0b0 - Test module is not enabled
 * - 0b1 - Test module is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_TST_TEN field. */
#define ENC_RD_TST_TEN(base) ((ENC_TST_REG(base) & ENC_TST_TEN_MASK) >> ENC_TST_TEN_SHIFT)
#define ENC_BRD_TST_TEN(base) (BME_UBFX16(&ENC_TST_REG(base), ENC_TST_TEN_SHIFT, ENC_TST_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define ENC_WR_TST_TEN(base, value) (ENC_RMW_TST(base, ENC_TST_TEN_MASK, ENC_TST_TEN(value)))
#define ENC_BWR_TST_TEN(base, value) (BME_BFI16(&ENC_TST_REG(base), ((uint16_t)(value) << ENC_TST_TEN_SHIFT), ENC_TST_TEN_SHIFT, ENC_TST_TEN_WIDTH))
/*@}*/

/*******************************************************************************
 * ENC_CTRL2 - Control 2 Register
 ******************************************************************************/

/*!
 * @brief ENC_CTRL2 - Control 2 Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_CTRL2 register
 */
/*@{*/
#define ENC_RD_CTRL2(base)       (ENC_CTRL2_REG(base))
#define ENC_WR_CTRL2(base, value) (ENC_CTRL2_REG(base) = (value))
#define ENC_RMW_CTRL2(base, mask, value) (ENC_WR_CTRL2(base, (ENC_RD_CTRL2(base) & ~(mask)) | (value)))
#define ENC_SET_CTRL2(base, value) (BME_OR16(&ENC_CTRL2_REG(base), (uint16_t)(value)))
#define ENC_CLR_CTRL2(base, value) (BME_AND16(&ENC_CTRL2_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_CTRL2(base, value) (BME_XOR16(&ENC_CTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENC_CTRL2 bitfields
 */

/*!
 * @name Register ENC_CTRL2, field UPDHLD[0] (RW)
 *
 * When set, this bit allows the TRIGGER input to cause an update of the POSDH,
 * REVH, UPOSH, and LPOSH registers. When clear, the hold registers are not
 * updated by the TRIGGER input. Updating the POSDH register will also cause the POSD
 * register to be cleared.
 *
 * Values:
 * - 0b0 - Disable updates of hold registers on rising edge of TRIGGER
 * - 0b1 - Enable updates of hold registers on rising edge of TRIGGER
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_UPDHLD field. */
#define ENC_RD_CTRL2_UPDHLD(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_UPDHLD_MASK) >> ENC_CTRL2_UPDHLD_SHIFT)
#define ENC_BRD_CTRL2_UPDHLD(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_UPDHLD_SHIFT, ENC_CTRL2_UPDHLD_WIDTH))

/*! @brief Set the UPDHLD field to a new value. */
#define ENC_WR_CTRL2_UPDHLD(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_UPDHLD_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_UPDHLD(value)))
#define ENC_BWR_CTRL2_UPDHLD(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_UPDHLD_SHIFT), ENC_CTRL2_UPDHLD_SHIFT, ENC_CTRL2_UPDHLD_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field UPDPOS[1] (RW)
 *
 * When set, this bit allows the TRIGGER input to clear the POSD, REV, UPOS and
 * LPOS registers. When clear, the POSD, REV, UPOS and LPOS registers ignore the
 * TRIGGER input.
 *
 * Values:
 * - 0b0 - No action for POSD, REV, UPOS and LPOS on rising edge of TRIGGER
 * - 0b1 - Clear POSD, REV, UPOS and LPOS on rising edge of TRIGGER
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_UPDPOS field. */
#define ENC_RD_CTRL2_UPDPOS(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_UPDPOS_MASK) >> ENC_CTRL2_UPDPOS_SHIFT)
#define ENC_BRD_CTRL2_UPDPOS(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_UPDPOS_SHIFT, ENC_CTRL2_UPDPOS_WIDTH))

/*! @brief Set the UPDPOS field to a new value. */
#define ENC_WR_CTRL2_UPDPOS(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_UPDPOS_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_UPDPOS(value)))
#define ENC_BWR_CTRL2_UPDPOS(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_UPDPOS_SHIFT), ENC_CTRL2_UPDPOS_SHIFT, ENC_CTRL2_UPDPOS_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field MOD[2] (RW)
 *
 * When set, this bit allows the position counters (UPOS and LPOS) to count in a
 * modulo fashion using MOD and INIT as the upper and lower bounds of the
 * counting range. During modulo counting when a count up is indicated and the position
 * counter is equal to MOD, then the postion counter will be reloaded with the
 * value of INIT. When a count down is indicated and the position counter is equal
 * to INIT, then the position counter will be reloaded with the value of MOD.
 * When clear, then the values of MOD and INIT are ignored and the position counter
 * wraps to zero when counting up from 0xffffffff and wraps to 0xffffffff when
 * counting down from 0.
 *
 * Values:
 * - 0b0 - Disable modulo counting
 * - 0b1 - Enable modulo counting
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_MOD field. */
#define ENC_RD_CTRL2_MOD(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_MOD_MASK) >> ENC_CTRL2_MOD_SHIFT)
#define ENC_BRD_CTRL2_MOD(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_MOD_SHIFT, ENC_CTRL2_MOD_WIDTH))

/*! @brief Set the MOD field to a new value. */
#define ENC_WR_CTRL2_MOD(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_MOD_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_MOD(value)))
#define ENC_BWR_CTRL2_MOD(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_MOD_SHIFT), ENC_CTRL2_MOD_SHIFT, ENC_CTRL2_MOD_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field DIR[3] (RO)
 *
 * This read-only flag is used to indicate the direction of the last count.
 *
 * Values:
 * - 0b0 - Last count was in the down direction
 * - 0b1 - Last count was in the up direction
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_DIR field. */
#define ENC_RD_CTRL2_DIR(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_DIR_MASK) >> ENC_CTRL2_DIR_SHIFT)
#define ENC_BRD_CTRL2_DIR(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_DIR_SHIFT, ENC_CTRL2_DIR_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field RUIE[4] (RW)
 *
 * This read/write bit enables roll-under interrupts based on CTRL2[RUIRQ] being
 * set. This interrupt is combined with the index interrupt signal.
 *
 * Values:
 * - 0b0 - Roll-under interrupt is disabled
 * - 0b1 - Roll-under interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_RUIE field. */
#define ENC_RD_CTRL2_RUIE(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_RUIE_MASK) >> ENC_CTRL2_RUIE_SHIFT)
#define ENC_BRD_CTRL2_RUIE(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_RUIE_SHIFT, ENC_CTRL2_RUIE_WIDTH))

/*! @brief Set the RUIE field to a new value. */
#define ENC_WR_CTRL2_RUIE(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_RUIE_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_RUIE(value)))
#define ENC_BWR_CTRL2_RUIE(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_RUIE_SHIFT), ENC_CTRL2_RUIE_SHIFT, ENC_CTRL2_RUIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field RUIRQ[5] (W1C)
 *
 * This bit is set when the position counter (POS) rolls under from the INIT
 * value to the MOD value or from 0x00000000 to 0xffffffff. It will remain set until
 * cleared by software. Write a one to this bit to clear.
 *
 * Values:
 * - 0b0 - No roll-under has occurred
 * - 0b1 - Roll-under has occurred
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_RUIRQ field. */
#define ENC_RD_CTRL2_RUIRQ(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_RUIRQ_MASK) >> ENC_CTRL2_RUIRQ_SHIFT)
#define ENC_BRD_CTRL2_RUIRQ(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_RUIRQ_SHIFT, ENC_CTRL2_RUIRQ_WIDTH))

/*! @brief Set the RUIRQ field to a new value. */
#define ENC_WR_CTRL2_RUIRQ(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_RUIRQ(value)))
#define ENC_BWR_CTRL2_RUIRQ(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_RUIRQ_SHIFT), ENC_CTRL2_RUIRQ_SHIFT, ENC_CTRL2_RUIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field ROIE[6] (RW)
 *
 * This read/write bit enables roll-over interrupts based on CTRL2[ROIRQ] being
 * set. This interrupt is combined with the index interrupt signal.
 *
 * Values:
 * - 0b0 - Roll-over interrupt is disabled
 * - 0b1 - Roll-over interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_ROIE field. */
#define ENC_RD_CTRL2_ROIE(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_ROIE_MASK) >> ENC_CTRL2_ROIE_SHIFT)
#define ENC_BRD_CTRL2_ROIE(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_ROIE_SHIFT, ENC_CTRL2_ROIE_WIDTH))

/*! @brief Set the ROIE field to a new value. */
#define ENC_WR_CTRL2_ROIE(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_ROIE_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_ROIE(value)))
#define ENC_BWR_CTRL2_ROIE(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_ROIE_SHIFT), ENC_CTRL2_ROIE_SHIFT, ENC_CTRL2_ROIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field ROIRQ[7] (W1C)
 *
 * This bit is set when the position counter (POS) rolls over from the MOD value
 * to the INIT value or from 0xffffffff to 0x00000000. It will remain set until
 * cleared by software. Write a one to this bit to clear.
 *
 * Values:
 * - 0b0 - No roll-over has occurred
 * - 0b1 - Roll-over has occurred
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_ROIRQ field. */
#define ENC_RD_CTRL2_ROIRQ(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_ROIRQ_MASK) >> ENC_CTRL2_ROIRQ_SHIFT)
#define ENC_BRD_CTRL2_ROIRQ(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_ROIRQ_SHIFT, ENC_CTRL2_ROIRQ_WIDTH))

/*! @brief Set the ROIRQ field to a new value. */
#define ENC_WR_CTRL2_ROIRQ(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_ROIRQ(value)))
#define ENC_BWR_CTRL2_ROIRQ(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_ROIRQ_SHIFT), ENC_CTRL2_ROIRQ_SHIFT, ENC_CTRL2_ROIRQ_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field REVMOD[8] (RW)
 *
 * This bit is used to determine how the revolution counter (REV) is
 * incremented/decremented. By default REV is controlled based on the count direction and
 * the INDEX pulse. As an option, REV can be controlled using the roll-over/under
 * detection during modulo counting.
 *
 * Values:
 * - 0b0 - Use INDEX pulse to increment/decrement revolution counter (REV).
 * - 0b1 - Use modulus counting roll-over/under to increment/decrement
 *     revolution counter (REV).
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_REVMOD field. */
#define ENC_RD_CTRL2_REVMOD(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_REVMOD_MASK) >> ENC_CTRL2_REVMOD_SHIFT)
#define ENC_BRD_CTRL2_REVMOD(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_REVMOD_SHIFT, ENC_CTRL2_REVMOD_WIDTH))

/*! @brief Set the REVMOD field to a new value. */
#define ENC_WR_CTRL2_REVMOD(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_REVMOD_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_REVMOD(value)))
#define ENC_BWR_CTRL2_REVMOD(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_REVMOD_SHIFT), ENC_CTRL2_REVMOD_SHIFT, ENC_CTRL2_REVMOD_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field OUTCTL[9] (RW)
 *
 * This bit is used to control the behavior of the POSMATCH output signal. This
 * can control when a timer channel captures a time stamp.
 *
 * Values:
 * - 0b0 - POSMATCH pulses when a match occurs between the position counters
 *     (POS) and the compare value (COMP).
 * - 0b1 - POSMATCH pulses when the UPOS, LPOS, REV, or POSD registers are read.
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_OUTCTL field. */
#define ENC_RD_CTRL2_OUTCTL(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_OUTCTL_MASK) >> ENC_CTRL2_OUTCTL_SHIFT)
#define ENC_BRD_CTRL2_OUTCTL(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_OUTCTL_SHIFT, ENC_CTRL2_OUTCTL_WIDTH))

/*! @brief Set the OUTCTL field to a new value. */
#define ENC_WR_CTRL2_OUTCTL(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_OUTCTL_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_OUTCTL(value)))
#define ENC_BWR_CTRL2_OUTCTL(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_OUTCTL_SHIFT), ENC_CTRL2_OUTCTL_SHIFT, ENC_CTRL2_OUTCTL_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field SABIE[10] (RW)
 *
 * This read/write bit enables simultaneous PHASEA and PHASEB change interrupts
 * based on SABIRQ being set.
 *
 * Values:
 * - 0b0 - Simultaneous PHASEA and PHASEB change interrupt disabled.
 * - 0b1 - Simultaneous PHASEA and PHASEB change interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_SABIE field. */
#define ENC_RD_CTRL2_SABIE(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_SABIE_MASK) >> ENC_CTRL2_SABIE_SHIFT)
#define ENC_BRD_CTRL2_SABIE(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_SABIE_SHIFT, ENC_CTRL2_SABIE_WIDTH))

/*! @brief Set the SABIE field to a new value. */
#define ENC_WR_CTRL2_SABIE(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_SABIE_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK | ENC_CTRL2_SABIRQ_MASK), ENC_CTRL2_SABIE(value)))
#define ENC_BWR_CTRL2_SABIE(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_SABIE_SHIFT), ENC_CTRL2_SABIE_SHIFT, ENC_CTRL2_SABIE_WIDTH))
/*@}*/

/*!
 * @name Register ENC_CTRL2, field SABIRQ[11] (W1C)
 *
 * This bit indicates that the PHASEA and PHASEB inputs changed simultaneously
 * (within a single clock period). This event typically indicates an error
 * condition because quadrature coding requires only one of these inputs to change at a
 * time. The bit remains set until it is cleared by software or a reset. Write 1
 * to this bit to clear it.
 *
 * Values:
 * - 0b0 - No simultaneous change of PHASEA and PHASEB has occurred.
 * - 0b1 - A simultaneous change of PHASEA and PHASEB has occurred.
 */
/*@{*/
/*! @brief Read current value of the ENC_CTRL2_SABIRQ field. */
#define ENC_RD_CTRL2_SABIRQ(base) ((ENC_CTRL2_REG(base) & ENC_CTRL2_SABIRQ_MASK) >> ENC_CTRL2_SABIRQ_SHIFT)
#define ENC_BRD_CTRL2_SABIRQ(base) (BME_UBFX16(&ENC_CTRL2_REG(base), ENC_CTRL2_SABIRQ_SHIFT, ENC_CTRL2_SABIRQ_WIDTH))

/*! @brief Set the SABIRQ field to a new value. */
#define ENC_WR_CTRL2_SABIRQ(base, value) (ENC_RMW_CTRL2(base, (ENC_CTRL2_SABIRQ_MASK | ENC_CTRL2_RUIRQ_MASK | ENC_CTRL2_ROIRQ_MASK), ENC_CTRL2_SABIRQ(value)))
#define ENC_BWR_CTRL2_SABIRQ(base, value) (BME_BFI16(&ENC_CTRL2_REG(base), ((uint16_t)(value) << ENC_CTRL2_SABIRQ_SHIFT), ENC_CTRL2_SABIRQ_SHIFT, ENC_CTRL2_SABIRQ_WIDTH))
/*@}*/

/*******************************************************************************
 * ENC_UMOD - Upper Modulus Register
 ******************************************************************************/

/*!
 * @brief ENC_UMOD - Upper Modulus Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_UMOD register
 */
/*@{*/
#define ENC_RD_UMOD(base)        (ENC_UMOD_REG(base))
#define ENC_WR_UMOD(base, value) (ENC_UMOD_REG(base) = (value))
#define ENC_RMW_UMOD(base, mask, value) (ENC_WR_UMOD(base, (ENC_RD_UMOD(base) & ~(mask)) | (value)))
#define ENC_SET_UMOD(base, value) (BME_OR16(&ENC_UMOD_REG(base), (uint16_t)(value)))
#define ENC_CLR_UMOD(base, value) (BME_AND16(&ENC_UMOD_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_UMOD(base, value) (BME_XOR16(&ENC_UMOD_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_LMOD - Lower Modulus Register
 ******************************************************************************/

/*!
 * @brief ENC_LMOD - Lower Modulus Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire ENC_LMOD register
 */
/*@{*/
#define ENC_RD_LMOD(base)        (ENC_LMOD_REG(base))
#define ENC_WR_LMOD(base, value) (ENC_LMOD_REG(base) = (value))
#define ENC_RMW_LMOD(base, mask, value) (ENC_WR_LMOD(base, (ENC_RD_LMOD(base) & ~(mask)) | (value)))
#define ENC_SET_LMOD(base, value) (BME_OR16(&ENC_LMOD_REG(base), (uint16_t)(value)))
#define ENC_CLR_LMOD(base, value) (BME_AND16(&ENC_LMOD_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_LMOD(base, value) (BME_XOR16(&ENC_LMOD_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_UCOMP - Upper Position Compare Register
 ******************************************************************************/

/*!
 * @brief ENC_UCOMP - Upper Position Compare Register (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire ENC_UCOMP register
 */
/*@{*/
#define ENC_RD_UCOMP(base)       (ENC_UCOMP_REG(base))
#define ENC_WR_UCOMP(base, value) (ENC_UCOMP_REG(base) = (value))
#define ENC_RMW_UCOMP(base, mask, value) (ENC_WR_UCOMP(base, (ENC_RD_UCOMP(base) & ~(mask)) | (value)))
#define ENC_SET_UCOMP(base, value) (BME_OR16(&ENC_UCOMP_REG(base), (uint16_t)(value)))
#define ENC_CLR_UCOMP(base, value) (BME_AND16(&ENC_UCOMP_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_UCOMP(base, value) (BME_XOR16(&ENC_UCOMP_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * ENC_LCOMP - Lower Position Compare Register
 ******************************************************************************/

/*!
 * @brief ENC_LCOMP - Lower Position Compare Register (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire ENC_LCOMP register
 */
/*@{*/
#define ENC_RD_LCOMP(base)       (ENC_LCOMP_REG(base))
#define ENC_WR_LCOMP(base, value) (ENC_LCOMP_REG(base) = (value))
#define ENC_RMW_LCOMP(base, mask, value) (ENC_WR_LCOMP(base, (ENC_RD_LCOMP(base) & ~(mask)) | (value)))
#define ENC_SET_LCOMP(base, value) (BME_OR16(&ENC_LCOMP_REG(base), (uint16_t)(value)))
#define ENC_CLR_LCOMP(base, value) (BME_AND16(&ENC_LCOMP_REG(base), (uint16_t)(~(value))))
#define ENC_TOG_LCOMP(base, value) (BME_XOR16(&ENC_LCOMP_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * MKV58F24 ENET
 *
 * Ethernet MAC-NET Core
 *
 * Registers defined in this header file:
 * - ENET_EIR - Interrupt Event Register
 * - ENET_EIMR - Interrupt Mask Register
 * - ENET_RDAR - Receive Descriptor Active Register
 * - ENET_TDAR - Transmit Descriptor Active Register
 * - ENET_ECR - Ethernet Control Register
 * - ENET_MMFR - MII Management Frame Register
 * - ENET_MSCR - MII Speed Control Register
 * - ENET_MIBC - MIB Control Register
 * - ENET_RCR - Receive Control Register
 * - ENET_TCR - Transmit Control Register
 * - ENET_PALR - Physical Address Lower Register
 * - ENET_PAUR - Physical Address Upper Register
 * - ENET_OPD - Opcode/Pause Duration Register
 * - ENET_IAUR - Descriptor Individual Upper Address Register
 * - ENET_IALR - Descriptor Individual Lower Address Register
 * - ENET_GAUR - Descriptor Group Upper Address Register
 * - ENET_GALR - Descriptor Group Lower Address Register
 * - ENET_TFWR - Transmit FIFO Watermark Register
 * - ENET_RDSR - Receive Descriptor Ring Start Register
 * - ENET_TDSR - Transmit Buffer Descriptor Ring Start Register
 * - ENET_MRBR - Maximum Receive Buffer Size Register
 * - ENET_RSFL - Receive FIFO Section Full Threshold
 * - ENET_RSEM - Receive FIFO Section Empty Threshold
 * - ENET_RAEM - Receive FIFO Almost Empty Threshold
 * - ENET_RAFL - Receive FIFO Almost Full Threshold
 * - ENET_TSEM - Transmit FIFO Section Empty Threshold
 * - ENET_TAEM - Transmit FIFO Almost Empty Threshold
 * - ENET_TAFL - Transmit FIFO Almost Full Threshold
 * - ENET_TIPG - Transmit Inter-Packet Gap
 * - ENET_FTRL - Frame Truncation Length
 * - ENET_TACC - Transmit Accelerator Function Configuration
 * - ENET_RACC - Receive Accelerator Function Configuration
 * - ENET_RMON_T_DROP - Reserved Statistic Register
 * - ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register
 * - ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register
 * - ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register
 * - ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register
 * - ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register
 * - ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
 * - ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 * - ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
 * - ENET_RMON_T_COL - Tx Collision Count Statistic Register
 * - ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register
 * - ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register
 * - ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register
 * - ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register
 * - ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register
 * - ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register
 * - ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register
 * - ENET_RMON_T_OCTETS - Tx Octets Statistic Register
 * - ENET_IEEE_T_DROP - Reserved Statistic Register
 * - ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register
 * - ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register
 * - ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register
 * - ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register
 * - ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register
 * - ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register
 * - ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register
 * - ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register
 * - ENET_IEEE_T_SQE - Reserved Statistic Register
 * - ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register
 * - ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register
 * - ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register
 * - ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register
 * - ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register
 * - ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register
 * - ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
 * - ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
 * - ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 * - ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
 * - ENET_RMON_R_RESVD_0 - Reserved Statistic Register
 * - ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register
 * - ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register
 * - ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register
 * - ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register
 * - ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register
 * - ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register
 * - ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register
 * - ENET_RMON_R_OCTETS - Rx Octets Statistic Register
 * - ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register
 * - ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register
 * - ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register
 * - ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register
 * - ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register
 * - ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register
 * - ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register
 * - ENET_ATCR - Adjustable Timer Control Register
 * - ENET_ATVR - Timer Value Register
 * - ENET_ATOFF - Timer Offset Register
 * - ENET_ATPER - Timer Period Register
 * - ENET_ATCOR - Timer Correction Register
 * - ENET_ATINC - Time-Stamping Clock Period Register
 * - ENET_ATSTMP - Timestamp of Last Transmitted Frame
 * - ENET_TGSR - Timer Global Status Register
 * - ENET_TCSR - Timer Control Status Register
 * - ENET_TCCR - Timer Compare Capture Register
 */

#define ENET_INSTANCE_COUNT (1U) /*!< Number of instances of the ENET module. */
#define ENET_IDX (0U) /*!< Instance number for ENET. */

/*******************************************************************************
 * ENET_EIR - Interrupt Event Register
 ******************************************************************************/

/*!
 * @brief ENET_EIR - Interrupt Event Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * When an event occurs that sets a bit in EIR, an interrupt occurs if the
 * corresponding bit in the interrupt mask register (EIMR) is also set. Writing a 1 to
 * an EIR bit clears it; writing 0 has no effect. This register is cleared upon
 * hardware reset. TxBD[INT] and RxBD[INT] must be set to 1 to allow setting the
 * corresponding EIR register flags in enhanced mode, ENET_ECR[EN1588] = 1.
 * Legacy mode does not require these flags to be enabled.
 */
/*!
 * @name Constants and macros for entire ENET_EIR register
 */
/*@{*/
#define ENET_RD_EIR(base)        (ENET_EIR_REG(base))
#define ENET_WR_EIR(base, value) (ENET_EIR_REG(base) = (value))
#define ENET_RMW_EIR(base, mask, value) (ENET_WR_EIR(base, (ENET_RD_EIR(base) & ~(mask)) | (value)))
#define ENET_SET_EIR(base, value) (BME_OR32(&ENET_EIR_REG(base), (uint32_t)(value)))
#define ENET_CLR_EIR(base, value) (BME_AND32(&ENET_EIR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_EIR(base, value) (BME_XOR32(&ENET_EIR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_EIR bitfields
 */

/*!
 * @name Register ENET_EIR, field TS_TIMER[15] (W1C)
 *
 * The adjustable timer reached the period event. A period event interrupt can
 * be generated if ATCR[PEREN] is set and the timer wraps according to the
 * periodic setting in the ATPER register. Set the timer period value before setting
 * ATCR[PEREN].
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_TS_TIMER field. */
#define ENET_RD_EIR_TS_TIMER(base) ((ENET_EIR_REG(base) & ENET_EIR_TS_TIMER_MASK) >> ENET_EIR_TS_TIMER_SHIFT)
#define ENET_BRD_EIR_TS_TIMER(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_TS_TIMER_SHIFT, ENET_EIR_TS_TIMER_WIDTH))

/*! @brief Set the TS_TIMER field to a new value. */
#define ENET_WR_EIR_TS_TIMER(base, value) (ENET_RMW_EIR(base, (ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_TS_TIMER(value)))
#define ENET_BWR_EIR_TS_TIMER(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_TS_TIMER_SHIFT), ENET_EIR_TS_TIMER_SHIFT, ENET_EIR_TS_TIMER_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field TS_AVAIL[16] (W1C)
 *
 * Indicates that the timestamp of the last transmitted timing frame is
 * available in the ATSTMP register.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_TS_AVAIL field. */
#define ENET_RD_EIR_TS_AVAIL(base) ((ENET_EIR_REG(base) & ENET_EIR_TS_AVAIL_MASK) >> ENET_EIR_TS_AVAIL_SHIFT)
#define ENET_BRD_EIR_TS_AVAIL(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_TS_AVAIL_SHIFT, ENET_EIR_TS_AVAIL_WIDTH))

/*! @brief Set the TS_AVAIL field to a new value. */
#define ENET_WR_EIR_TS_AVAIL(base, value) (ENET_RMW_EIR(base, (ENET_EIR_TS_AVAIL_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_TS_AVAIL(value)))
#define ENET_BWR_EIR_TS_AVAIL(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_TS_AVAIL_SHIFT), ENET_EIR_TS_AVAIL_SHIFT, ENET_EIR_TS_AVAIL_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field WAKEUP[17] (W1C)
 *
 * Read-only status bit to indicate that a magic packet has been detected. Will
 * act only if ECR[MAGICEN] is set.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_WAKEUP field. */
#define ENET_RD_EIR_WAKEUP(base) ((ENET_EIR_REG(base) & ENET_EIR_WAKEUP_MASK) >> ENET_EIR_WAKEUP_SHIFT)
#define ENET_BRD_EIR_WAKEUP(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_WAKEUP_SHIFT, ENET_EIR_WAKEUP_WIDTH))

/*! @brief Set the WAKEUP field to a new value. */
#define ENET_WR_EIR_WAKEUP(base, value) (ENET_RMW_EIR(base, (ENET_EIR_WAKEUP_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_WAKEUP(value)))
#define ENET_BWR_EIR_WAKEUP(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_WAKEUP_SHIFT), ENET_EIR_WAKEUP_SHIFT, ENET_EIR_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field PLR[18] (W1C)
 *
 * Indicates a frame was received with a payload length error. See Frame
 * Length/Type Verification: Payload Length Check for more information.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_PLR field. */
#define ENET_RD_EIR_PLR(base) ((ENET_EIR_REG(base) & ENET_EIR_PLR_MASK) >> ENET_EIR_PLR_SHIFT)
#define ENET_BRD_EIR_PLR(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_PLR_SHIFT, ENET_EIR_PLR_WIDTH))

/*! @brief Set the PLR field to a new value. */
#define ENET_WR_EIR_PLR(base, value) (ENET_RMW_EIR(base, (ENET_EIR_PLR_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_PLR(value)))
#define ENET_BWR_EIR_PLR(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_PLR_SHIFT), ENET_EIR_PLR_SHIFT, ENET_EIR_PLR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field UN[19] (W1C)
 *
 * Indicates the transmit FIFO became empty before the complete frame was
 * transmitted. A bad CRC is appended to the frame fragment and the remainder of the
 * frame is discarded.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_UN field. */
#define ENET_RD_EIR_UN(base) ((ENET_EIR_REG(base) & ENET_EIR_UN_MASK) >> ENET_EIR_UN_SHIFT)
#define ENET_BRD_EIR_UN(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_UN_SHIFT, ENET_EIR_UN_WIDTH))

/*! @brief Set the UN field to a new value. */
#define ENET_WR_EIR_UN(base, value) (ENET_RMW_EIR(base, (ENET_EIR_UN_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_UN(value)))
#define ENET_BWR_EIR_UN(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_UN_SHIFT), ENET_EIR_UN_SHIFT, ENET_EIR_UN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field RL[20] (W1C)
 *
 * Indicates a collision occurred on each of 16 successive attempts to transmit
 * the frame. The frame is discarded without being transmitted and transmission
 * of the next frame commences. This error can only occur in half-duplex mode.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_RL field. */
#define ENET_RD_EIR_RL(base) ((ENET_EIR_REG(base) & ENET_EIR_RL_MASK) >> ENET_EIR_RL_SHIFT)
#define ENET_BRD_EIR_RL(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_RL_SHIFT, ENET_EIR_RL_WIDTH))

/*! @brief Set the RL field to a new value. */
#define ENET_WR_EIR_RL(base, value) (ENET_RMW_EIR(base, (ENET_EIR_RL_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_RL(value)))
#define ENET_BWR_EIR_RL(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_RL_SHIFT), ENET_EIR_RL_SHIFT, ENET_EIR_RL_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field LC[21] (W1C)
 *
 * Indicates a collision occurred beyond the collision window (slot time) in
 * half-duplex mode. The frame truncates with a bad CRC and the remainder of the
 * frame is discarded.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_LC field. */
#define ENET_RD_EIR_LC(base) ((ENET_EIR_REG(base) & ENET_EIR_LC_MASK) >> ENET_EIR_LC_SHIFT)
#define ENET_BRD_EIR_LC(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_LC_SHIFT, ENET_EIR_LC_WIDTH))

/*! @brief Set the LC field to a new value. */
#define ENET_WR_EIR_LC(base, value) (ENET_RMW_EIR(base, (ENET_EIR_LC_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_LC(value)))
#define ENET_BWR_EIR_LC(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_LC_SHIFT), ENET_EIR_LC_SHIFT, ENET_EIR_LC_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field EBERR[22] (W1C)
 *
 * Indicates a system bus error occurred when a uDMA transaction is underway.
 * When this bit is set, ECR[ETHEREN] is cleared, halting frame processing by the
 * MAC. When this occurs, software must ensure proper actions, possibly resetting
 * the system, to resume normal operation.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_EBERR field. */
#define ENET_RD_EIR_EBERR(base) ((ENET_EIR_REG(base) & ENET_EIR_EBERR_MASK) >> ENET_EIR_EBERR_SHIFT)
#define ENET_BRD_EIR_EBERR(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_EBERR_SHIFT, ENET_EIR_EBERR_WIDTH))

/*! @brief Set the EBERR field to a new value. */
#define ENET_WR_EIR_EBERR(base, value) (ENET_RMW_EIR(base, (ENET_EIR_EBERR_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_EBERR(value)))
#define ENET_BWR_EIR_EBERR(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_EBERR_SHIFT), ENET_EIR_EBERR_SHIFT, ENET_EIR_EBERR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field MII[23] (W1C)
 *
 * Indicates that the MII has completed the data transfer requested.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_MII field. */
#define ENET_RD_EIR_MII(base) ((ENET_EIR_REG(base) & ENET_EIR_MII_MASK) >> ENET_EIR_MII_SHIFT)
#define ENET_BRD_EIR_MII(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_MII_SHIFT, ENET_EIR_MII_WIDTH))

/*! @brief Set the MII field to a new value. */
#define ENET_WR_EIR_MII(base, value) (ENET_RMW_EIR(base, (ENET_EIR_MII_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_MII(value)))
#define ENET_BWR_EIR_MII(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_MII_SHIFT), ENET_EIR_MII_SHIFT, ENET_EIR_MII_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field RXB[24] (W1C)
 *
 * Indicates a receive buffer descriptor is not the last in the frame has been
 * updated.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_RXB field. */
#define ENET_RD_EIR_RXB(base) ((ENET_EIR_REG(base) & ENET_EIR_RXB_MASK) >> ENET_EIR_RXB_SHIFT)
#define ENET_BRD_EIR_RXB(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_RXB_SHIFT, ENET_EIR_RXB_WIDTH))

/*! @brief Set the RXB field to a new value. */
#define ENET_WR_EIR_RXB(base, value) (ENET_RMW_EIR(base, (ENET_EIR_RXB_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_RXB(value)))
#define ENET_BWR_EIR_RXB(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_RXB_SHIFT), ENET_EIR_RXB_SHIFT, ENET_EIR_RXB_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field RXF[25] (W1C)
 *
 * Indicates a frame has been received and the last corresponding buffer
 * descriptor has been updated.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_RXF field. */
#define ENET_RD_EIR_RXF(base) ((ENET_EIR_REG(base) & ENET_EIR_RXF_MASK) >> ENET_EIR_RXF_SHIFT)
#define ENET_BRD_EIR_RXF(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_RXF_SHIFT, ENET_EIR_RXF_WIDTH))

/*! @brief Set the RXF field to a new value. */
#define ENET_WR_EIR_RXF(base, value) (ENET_RMW_EIR(base, (ENET_EIR_RXF_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_RXF(value)))
#define ENET_BWR_EIR_RXF(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_RXF_SHIFT), ENET_EIR_RXF_SHIFT, ENET_EIR_RXF_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field TXB[26] (W1C)
 *
 * Indicates a transmit buffer descriptor has been updated.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_TXB field. */
#define ENET_RD_EIR_TXB(base) ((ENET_EIR_REG(base) & ENET_EIR_TXB_MASK) >> ENET_EIR_TXB_SHIFT)
#define ENET_BRD_EIR_TXB(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_TXB_SHIFT, ENET_EIR_TXB_WIDTH))

/*! @brief Set the TXB field to a new value. */
#define ENET_WR_EIR_TXB(base, value) (ENET_RMW_EIR(base, (ENET_EIR_TXB_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_TXB(value)))
#define ENET_BWR_EIR_TXB(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_TXB_SHIFT), ENET_EIR_TXB_SHIFT, ENET_EIR_TXB_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field TXF[27] (W1C)
 *
 * Indicates a frame has been transmitted and the last corresponding buffer
 * descriptor has been updated.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_TXF field. */
#define ENET_RD_EIR_TXF(base) ((ENET_EIR_REG(base) & ENET_EIR_TXF_MASK) >> ENET_EIR_TXF_SHIFT)
#define ENET_BRD_EIR_TXF(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_TXF_SHIFT, ENET_EIR_TXF_WIDTH))

/*! @brief Set the TXF field to a new value. */
#define ENET_WR_EIR_TXF(base, value) (ENET_RMW_EIR(base, (ENET_EIR_TXF_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_TXF(value)))
#define ENET_BWR_EIR_TXF(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_TXF_SHIFT), ENET_EIR_TXF_SHIFT, ENET_EIR_TXF_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field GRA[28] (W1C)
 *
 * This interrupt is asserted after the transmitter is put into a pause state
 * after completion of the frame currently being transmitted. See Graceful Transmit
 * Stop (GTS) for conditions that lead to graceful stop. The GRA interrupt is
 * asserted only when the TX transitions into the stopped state. If this bit is
 * cleared by writing 1 and the TX is still stopped, the bit is not set again.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_GRA field. */
#define ENET_RD_EIR_GRA(base) ((ENET_EIR_REG(base) & ENET_EIR_GRA_MASK) >> ENET_EIR_GRA_SHIFT)
#define ENET_BRD_EIR_GRA(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_GRA_SHIFT, ENET_EIR_GRA_WIDTH))

/*! @brief Set the GRA field to a new value. */
#define ENET_WR_EIR_GRA(base, value) (ENET_RMW_EIR(base, (ENET_EIR_GRA_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_BABT_MASK | ENET_EIR_BABR_MASK), ENET_EIR_GRA(value)))
#define ENET_BWR_EIR_GRA(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_GRA_SHIFT), ENET_EIR_GRA_SHIFT, ENET_EIR_GRA_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field BABT[29] (W1C)
 *
 * Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes. Usually
 * this condition is caused when a frame that is too long is placed into the
 * transmit data buffer(s). Truncation does not occur.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_BABT field. */
#define ENET_RD_EIR_BABT(base) ((ENET_EIR_REG(base) & ENET_EIR_BABT_MASK) >> ENET_EIR_BABT_SHIFT)
#define ENET_BRD_EIR_BABT(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_BABT_SHIFT, ENET_EIR_BABT_WIDTH))

/*! @brief Set the BABT field to a new value. */
#define ENET_WR_EIR_BABT(base, value) (ENET_RMW_EIR(base, (ENET_EIR_BABT_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABR_MASK), ENET_EIR_BABT(value)))
#define ENET_BWR_EIR_BABT(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_BABT_SHIFT), ENET_EIR_BABT_SHIFT, ENET_EIR_BABT_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIR, field BABR[30] (W1C)
 *
 * Indicates a frame was received with length in excess of RCR[MAX_FL] bytes.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIR_BABR field. */
#define ENET_RD_EIR_BABR(base) ((ENET_EIR_REG(base) & ENET_EIR_BABR_MASK) >> ENET_EIR_BABR_SHIFT)
#define ENET_BRD_EIR_BABR(base) (BME_UBFX32(&ENET_EIR_REG(base), ENET_EIR_BABR_SHIFT, ENET_EIR_BABR_WIDTH))

/*! @brief Set the BABR field to a new value. */
#define ENET_WR_EIR_BABR(base, value) (ENET_RMW_EIR(base, (ENET_EIR_BABR_MASK | ENET_EIR_TS_TIMER_MASK | ENET_EIR_TS_AVAIL_MASK | ENET_EIR_WAKEUP_MASK | ENET_EIR_PLR_MASK | ENET_EIR_UN_MASK | ENET_EIR_RL_MASK | ENET_EIR_LC_MASK | ENET_EIR_EBERR_MASK | ENET_EIR_MII_MASK | ENET_EIR_RXB_MASK | ENET_EIR_RXF_MASK | ENET_EIR_TXB_MASK | ENET_EIR_TXF_MASK | ENET_EIR_GRA_MASK | ENET_EIR_BABT_MASK), ENET_EIR_BABR(value)))
#define ENET_BWR_EIR_BABR(base, value) (BME_BFI32(&ENET_EIR_REG(base), ((uint32_t)(value) << ENET_EIR_BABR_SHIFT), ENET_EIR_BABR_SHIFT, ENET_EIR_BABR_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_EIMR - Interrupt Mask Register
 ******************************************************************************/

/*!
 * @brief ENET_EIMR - Interrupt Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * EIMR controls which interrupt events are allowed to generate actual
 * interrupts. A hardware reset clears this register. If the corresponding bits in the EIR
 * and EIMR registers are set, an interrupt is generated. The interrupt signal
 * remains asserted until a 1 is written to the EIR field (write 1 to clear) or a
 * 0 is written to the EIMR field.
 */
/*!
 * @name Constants and macros for entire ENET_EIMR register
 */
/*@{*/
#define ENET_RD_EIMR(base)       (ENET_EIMR_REG(base))
#define ENET_WR_EIMR(base, value) (ENET_EIMR_REG(base) = (value))
#define ENET_RMW_EIMR(base, mask, value) (ENET_WR_EIMR(base, (ENET_RD_EIMR(base) & ~(mask)) | (value)))
#define ENET_SET_EIMR(base, value) (BME_OR32(&ENET_EIMR_REG(base), (uint32_t)(value)))
#define ENET_CLR_EIMR(base, value) (BME_AND32(&ENET_EIMR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_EIMR(base, value) (BME_XOR32(&ENET_EIMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_EIMR bitfields
 */

/*!
 * @name Register ENET_EIMR, field TS_TIMER[15] (RW)
 *
 * Corresponds to interrupt source EIR[TS_TIMER] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR TS_TIMER field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_TS_TIMER field. */
#define ENET_RD_EIMR_TS_TIMER(base) ((ENET_EIMR_REG(base) & ENET_EIMR_TS_TIMER_MASK) >> ENET_EIMR_TS_TIMER_SHIFT)
#define ENET_BRD_EIMR_TS_TIMER(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_TS_TIMER_SHIFT, ENET_EIMR_TS_TIMER_WIDTH))

/*! @brief Set the TS_TIMER field to a new value. */
#define ENET_WR_EIMR_TS_TIMER(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_TS_TIMER_MASK, ENET_EIMR_TS_TIMER(value)))
#define ENET_BWR_EIMR_TS_TIMER(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_TS_TIMER_SHIFT), ENET_EIMR_TS_TIMER_SHIFT, ENET_EIMR_TS_TIMER_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TS_AVAIL[16] (RW)
 *
 * Corresponds to interrupt source EIR[TS_AVAIL] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR TS_AVAIL field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_TS_AVAIL field. */
#define ENET_RD_EIMR_TS_AVAIL(base) ((ENET_EIMR_REG(base) & ENET_EIMR_TS_AVAIL_MASK) >> ENET_EIMR_TS_AVAIL_SHIFT)
#define ENET_BRD_EIMR_TS_AVAIL(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_TS_AVAIL_SHIFT, ENET_EIMR_TS_AVAIL_WIDTH))

/*! @brief Set the TS_AVAIL field to a new value. */
#define ENET_WR_EIMR_TS_AVAIL(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_TS_AVAIL_MASK, ENET_EIMR_TS_AVAIL(value)))
#define ENET_BWR_EIMR_TS_AVAIL(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_TS_AVAIL_SHIFT), ENET_EIMR_TS_AVAIL_SHIFT, ENET_EIMR_TS_AVAIL_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field WAKEUP[17] (RW)
 *
 * Corresponds to interrupt source EIR[WAKEUP] register and determines whether
 * an interrupt condition can generate an interrupt. At every module clock, the
 * EIR samples the signal generated by the interrupting source. The corresponding
 * EIR WAKEUP field reflects the state of the interrupt signal even if the
 * corresponding EIMR field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_WAKEUP field. */
#define ENET_RD_EIMR_WAKEUP(base) ((ENET_EIMR_REG(base) & ENET_EIMR_WAKEUP_MASK) >> ENET_EIMR_WAKEUP_SHIFT)
#define ENET_BRD_EIMR_WAKEUP(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_WAKEUP_SHIFT, ENET_EIMR_WAKEUP_WIDTH))

/*! @brief Set the WAKEUP field to a new value. */
#define ENET_WR_EIMR_WAKEUP(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_WAKEUP_MASK, ENET_EIMR_WAKEUP(value)))
#define ENET_BWR_EIMR_WAKEUP(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_WAKEUP_SHIFT), ENET_EIMR_WAKEUP_SHIFT, ENET_EIMR_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field PLR[18] (RW)
 *
 * Corresponds to interrupt source EIR[PLR] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR PLR field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_PLR field. */
#define ENET_RD_EIMR_PLR(base) ((ENET_EIMR_REG(base) & ENET_EIMR_PLR_MASK) >> ENET_EIMR_PLR_SHIFT)
#define ENET_BRD_EIMR_PLR(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_PLR_SHIFT, ENET_EIMR_PLR_WIDTH))

/*! @brief Set the PLR field to a new value. */
#define ENET_WR_EIMR_PLR(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_PLR_MASK, ENET_EIMR_PLR(value)))
#define ENET_BWR_EIMR_PLR(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_PLR_SHIFT), ENET_EIMR_PLR_SHIFT, ENET_EIMR_PLR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field UN[19] (RW)
 *
 * Corresponds to interrupt source EIR[UN] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR UN field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_UN field. */
#define ENET_RD_EIMR_UN(base) ((ENET_EIMR_REG(base) & ENET_EIMR_UN_MASK) >> ENET_EIMR_UN_SHIFT)
#define ENET_BRD_EIMR_UN(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_UN_SHIFT, ENET_EIMR_UN_WIDTH))

/*! @brief Set the UN field to a new value. */
#define ENET_WR_EIMR_UN(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_UN_MASK, ENET_EIMR_UN(value)))
#define ENET_BWR_EIMR_UN(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_UN_SHIFT), ENET_EIMR_UN_SHIFT, ENET_EIMR_UN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RL[20] (RW)
 *
 * Corresponds to interrupt source EIR[RL] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR RL field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_RL field. */
#define ENET_RD_EIMR_RL(base) ((ENET_EIMR_REG(base) & ENET_EIMR_RL_MASK) >> ENET_EIMR_RL_SHIFT)
#define ENET_BRD_EIMR_RL(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_RL_SHIFT, ENET_EIMR_RL_WIDTH))

/*! @brief Set the RL field to a new value. */
#define ENET_WR_EIMR_RL(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_RL_MASK, ENET_EIMR_RL(value)))
#define ENET_BWR_EIMR_RL(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_RL_SHIFT), ENET_EIMR_RL_SHIFT, ENET_EIMR_RL_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field LC[21] (RW)
 *
 * Corresponds to interrupt source EIR[LC] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples the
 * signal generated by the interrupting source. The corresponding EIR LC field
 * reflects the state of the interrupt signal even if the corresponding EIMR field
 * is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_LC field. */
#define ENET_RD_EIMR_LC(base) ((ENET_EIMR_REG(base) & ENET_EIMR_LC_MASK) >> ENET_EIMR_LC_SHIFT)
#define ENET_BRD_EIMR_LC(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_LC_SHIFT, ENET_EIMR_LC_WIDTH))

/*! @brief Set the LC field to a new value. */
#define ENET_WR_EIMR_LC(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_LC_MASK, ENET_EIMR_LC(value)))
#define ENET_BWR_EIMR_LC(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_LC_SHIFT), ENET_EIMR_LC_SHIFT, ENET_EIMR_LC_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field EBERR[22] (RW)
 *
 * Corresponds to interrupt source EIR[EBERR] and determines whether an
 * interrupt condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR EBERR
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_EBERR field. */
#define ENET_RD_EIMR_EBERR(base) ((ENET_EIMR_REG(base) & ENET_EIMR_EBERR_MASK) >> ENET_EIMR_EBERR_SHIFT)
#define ENET_BRD_EIMR_EBERR(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_EBERR_SHIFT, ENET_EIMR_EBERR_WIDTH))

/*! @brief Set the EBERR field to a new value. */
#define ENET_WR_EIMR_EBERR(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_EBERR_MASK, ENET_EIMR_EBERR(value)))
#define ENET_BWR_EIMR_EBERR(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_EBERR_SHIFT), ENET_EIMR_EBERR_SHIFT, ENET_EIMR_EBERR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field MII[23] (RW)
 *
 * Corresponds to interrupt source EIR[MII] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR MII field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_MII field. */
#define ENET_RD_EIMR_MII(base) ((ENET_EIMR_REG(base) & ENET_EIMR_MII_MASK) >> ENET_EIMR_MII_SHIFT)
#define ENET_BRD_EIMR_MII(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_MII_SHIFT, ENET_EIMR_MII_WIDTH))

/*! @brief Set the MII field to a new value. */
#define ENET_WR_EIMR_MII(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_MII_MASK, ENET_EIMR_MII(value)))
#define ENET_BWR_EIMR_MII(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_MII_SHIFT), ENET_EIMR_MII_SHIFT, ENET_EIMR_MII_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RXB[24] (RW)
 *
 * Corresponds to interrupt source EIR[RXB] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR RXB field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_RXB field. */
#define ENET_RD_EIMR_RXB(base) ((ENET_EIMR_REG(base) & ENET_EIMR_RXB_MASK) >> ENET_EIMR_RXB_SHIFT)
#define ENET_BRD_EIMR_RXB(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_RXB_SHIFT, ENET_EIMR_RXB_WIDTH))

/*! @brief Set the RXB field to a new value. */
#define ENET_WR_EIMR_RXB(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_RXB_MASK, ENET_EIMR_RXB(value)))
#define ENET_BWR_EIMR_RXB(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_RXB_SHIFT), ENET_EIMR_RXB_SHIFT, ENET_EIMR_RXB_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field RXF[25] (RW)
 *
 * Corresponds to interrupt source EIR[RXF] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR RXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_RXF field. */
#define ENET_RD_EIMR_RXF(base) ((ENET_EIMR_REG(base) & ENET_EIMR_RXF_MASK) >> ENET_EIMR_RXF_SHIFT)
#define ENET_BRD_EIMR_RXF(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_RXF_SHIFT, ENET_EIMR_RXF_WIDTH))

/*! @brief Set the RXF field to a new value. */
#define ENET_WR_EIMR_RXF(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_RXF_MASK, ENET_EIMR_RXF(value)))
#define ENET_BWR_EIMR_RXF(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_RXF_SHIFT), ENET_EIMR_RXF_SHIFT, ENET_EIMR_RXF_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TXB[26] (RW)
 *
 * Corresponds to interrupt source EIR[TXB] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR TXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0b0 - The corresponding interrupt source is masked.
 * - 0b1 - The corresponding interrupt source is not masked.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_TXB field. */
#define ENET_RD_EIMR_TXB(base) ((ENET_EIMR_REG(base) & ENET_EIMR_TXB_MASK) >> ENET_EIMR_TXB_SHIFT)
#define ENET_BRD_EIMR_TXB(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_TXB_SHIFT, ENET_EIMR_TXB_WIDTH))

/*! @brief Set the TXB field to a new value. */
#define ENET_WR_EIMR_TXB(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_TXB_MASK, ENET_EIMR_TXB(value)))
#define ENET_BWR_EIMR_TXB(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_TXB_SHIFT), ENET_EIMR_TXB_SHIFT, ENET_EIMR_TXB_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field TXF[27] (RW)
 *
 * Corresponds to interrupt source EIR[TXF] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR TXF field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0b0 - The corresponding interrupt source is masked.
 * - 0b1 - The corresponding interrupt source is not masked.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_TXF field. */
#define ENET_RD_EIMR_TXF(base) ((ENET_EIMR_REG(base) & ENET_EIMR_TXF_MASK) >> ENET_EIMR_TXF_SHIFT)
#define ENET_BRD_EIMR_TXF(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_TXF_SHIFT, ENET_EIMR_TXF_WIDTH))

/*! @brief Set the TXF field to a new value. */
#define ENET_WR_EIMR_TXF(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_TXF_MASK, ENET_EIMR_TXF(value)))
#define ENET_BWR_EIMR_TXF(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_TXF_SHIFT), ENET_EIMR_TXF_SHIFT, ENET_EIMR_TXF_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field GRA[28] (RW)
 *
 * Corresponds to interrupt source EIR[GRA] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR GRA field
 * reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0b0 - The corresponding interrupt source is masked.
 * - 0b1 - The corresponding interrupt source is not masked.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_GRA field. */
#define ENET_RD_EIMR_GRA(base) ((ENET_EIMR_REG(base) & ENET_EIMR_GRA_MASK) >> ENET_EIMR_GRA_SHIFT)
#define ENET_BRD_EIMR_GRA(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_GRA_SHIFT, ENET_EIMR_GRA_WIDTH))

/*! @brief Set the GRA field to a new value. */
#define ENET_WR_EIMR_GRA(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_GRA_MASK, ENET_EIMR_GRA(value)))
#define ENET_BWR_EIMR_GRA(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_GRA_SHIFT), ENET_EIMR_GRA_SHIFT, ENET_EIMR_GRA_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field BABT[29] (RW)
 *
 * Corresponds to interrupt source EIR[BABT] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR BABT
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0b0 - The corresponding interrupt source is masked.
 * - 0b1 - The corresponding interrupt source is not masked.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_BABT field. */
#define ENET_RD_EIMR_BABT(base) ((ENET_EIMR_REG(base) & ENET_EIMR_BABT_MASK) >> ENET_EIMR_BABT_SHIFT)
#define ENET_BRD_EIMR_BABT(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_BABT_SHIFT, ENET_EIMR_BABT_WIDTH))

/*! @brief Set the BABT field to a new value. */
#define ENET_WR_EIMR_BABT(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_BABT_MASK, ENET_EIMR_BABT(value)))
#define ENET_BWR_EIMR_BABT(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_BABT_SHIFT), ENET_EIMR_BABT_SHIFT, ENET_EIMR_BABT_WIDTH))
/*@}*/

/*!
 * @name Register ENET_EIMR, field BABR[30] (RW)
 *
 * Corresponds to interrupt source EIR[BABR] and determines whether an interrupt
 * condition can generate an interrupt. At every module clock, the EIR samples
 * the signal generated by the interrupting source. The corresponding EIR BABR
 * field reflects the state of the interrupt signal even if the corresponding EIMR
 * field is cleared.
 *
 * Values:
 * - 0b0 - The corresponding interrupt source is masked.
 * - 0b1 - The corresponding interrupt source is not masked.
 */
/*@{*/
/*! @brief Read current value of the ENET_EIMR_BABR field. */
#define ENET_RD_EIMR_BABR(base) ((ENET_EIMR_REG(base) & ENET_EIMR_BABR_MASK) >> ENET_EIMR_BABR_SHIFT)
#define ENET_BRD_EIMR_BABR(base) (BME_UBFX32(&ENET_EIMR_REG(base), ENET_EIMR_BABR_SHIFT, ENET_EIMR_BABR_WIDTH))

/*! @brief Set the BABR field to a new value. */
#define ENET_WR_EIMR_BABR(base, value) (ENET_RMW_EIMR(base, ENET_EIMR_BABR_MASK, ENET_EIMR_BABR(value)))
#define ENET_BWR_EIMR_BABR(base, value) (BME_BFI32(&ENET_EIMR_REG(base), ((uint32_t)(value) << ENET_EIMR_BABR_SHIFT), ENET_EIMR_BABR_SHIFT, ENET_EIMR_BABR_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RDAR - Receive Descriptor Active Register
 ******************************************************************************/

/*!
 * @brief ENET_RDAR - Receive Descriptor Active Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RDAR is a command register, written by the user, to indicate that the receive
 * descriptor ring has been updated, that is, that the driver produced empty
 * receive buffers with the empty bit set.
 */
/*!
 * @name Constants and macros for entire ENET_RDAR register
 */
/*@{*/
#define ENET_RD_RDAR(base)       (ENET_RDAR_REG(base))
#define ENET_WR_RDAR(base, value) (ENET_RDAR_REG(base) = (value))
#define ENET_RMW_RDAR(base, mask, value) (ENET_WR_RDAR(base, (ENET_RD_RDAR(base) & ~(mask)) | (value)))
#define ENET_SET_RDAR(base, value) (BME_OR32(&ENET_RDAR_REG(base), (uint32_t)(value)))
#define ENET_CLR_RDAR(base, value) (BME_AND32(&ENET_RDAR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RDAR(base, value) (BME_XOR32(&ENET_RDAR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RDAR bitfields
 */

/*!
 * @name Register ENET_RDAR, field RDAR[24] (RW)
 *
 * Always set to 1 when this register is written, regardless of the value
 * written. This field is cleared by the MAC device when no additional empty
 * descriptors remain in the receive ring. It is also cleared when ECR[ETHEREN] transitions
 * from set to cleared or when ECR[RESET] is set.
 */
/*@{*/
/*! @brief Read current value of the ENET_RDAR_RDAR field. */
#define ENET_RD_RDAR_RDAR(base) ((ENET_RDAR_REG(base) & ENET_RDAR_RDAR_MASK) >> ENET_RDAR_RDAR_SHIFT)
#define ENET_BRD_RDAR_RDAR(base) (BME_UBFX32(&ENET_RDAR_REG(base), ENET_RDAR_RDAR_SHIFT, ENET_RDAR_RDAR_WIDTH))

/*! @brief Set the RDAR field to a new value. */
#define ENET_WR_RDAR_RDAR(base, value) (ENET_RMW_RDAR(base, ENET_RDAR_RDAR_MASK, ENET_RDAR_RDAR(value)))
#define ENET_BWR_RDAR_RDAR(base, value) (BME_BFI32(&ENET_RDAR_REG(base), ((uint32_t)(value) << ENET_RDAR_RDAR_SHIFT), ENET_RDAR_RDAR_SHIFT, ENET_RDAR_RDAR_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TDAR - Transmit Descriptor Active Register
 ******************************************************************************/

/*!
 * @brief ENET_TDAR - Transmit Descriptor Active Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The TDAR is a command register that the user writes to indicate that the
 * transmit descriptor ring has been updated, that is, that transmit buffers have
 * been produced by the driver with the ready bit set in the buffer descriptor. The
 * TDAR register is cleared at reset, when ECR[ETHEREN] transitions from set to
 * cleared, or when ECR[RESET] is set.
 */
/*!
 * @name Constants and macros for entire ENET_TDAR register
 */
/*@{*/
#define ENET_RD_TDAR(base)       (ENET_TDAR_REG(base))
#define ENET_WR_TDAR(base, value) (ENET_TDAR_REG(base) = (value))
#define ENET_RMW_TDAR(base, mask, value) (ENET_WR_TDAR(base, (ENET_RD_TDAR(base) & ~(mask)) | (value)))
#define ENET_SET_TDAR(base, value) (BME_OR32(&ENET_TDAR_REG(base), (uint32_t)(value)))
#define ENET_CLR_TDAR(base, value) (BME_AND32(&ENET_TDAR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TDAR(base, value) (BME_XOR32(&ENET_TDAR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TDAR bitfields
 */

/*!
 * @name Register ENET_TDAR, field TDAR[24] (RW)
 *
 * Always set to 1 when this register is written, regardless of the value
 * written. This bit is cleared by the MAC device when no additional ready descriptors
 * remain in the transmit ring. Also cleared when ECR[ETHEREN] transitions from
 * set to cleared or when ECR[RESET] is set.
 */
/*@{*/
/*! @brief Read current value of the ENET_TDAR_TDAR field. */
#define ENET_RD_TDAR_TDAR(base) ((ENET_TDAR_REG(base) & ENET_TDAR_TDAR_MASK) >> ENET_TDAR_TDAR_SHIFT)
#define ENET_BRD_TDAR_TDAR(base) (BME_UBFX32(&ENET_TDAR_REG(base), ENET_TDAR_TDAR_SHIFT, ENET_TDAR_TDAR_WIDTH))

/*! @brief Set the TDAR field to a new value. */
#define ENET_WR_TDAR_TDAR(base, value) (ENET_RMW_TDAR(base, ENET_TDAR_TDAR_MASK, ENET_TDAR_TDAR(value)))
#define ENET_BWR_TDAR_TDAR(base, value) (BME_BFI32(&ENET_TDAR_REG(base), ((uint32_t)(value) << ENET_TDAR_TDAR_SHIFT), ENET_TDAR_TDAR_SHIFT, ENET_TDAR_TDAR_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_ECR - Ethernet Control Register
 ******************************************************************************/

/*!
 * @brief ENET_ECR - Ethernet Control Register (RW)
 *
 * Reset value: 0xF0000000U
 *
 * ECR is a read/write user register, though hardware may also alter fields in
 * this register. It controls many of the high level features of the Ethernet MAC,
 * including legacy FEC support through the EN1588 field.
 */
/*!
 * @name Constants and macros for entire ENET_ECR register
 */
/*@{*/
#define ENET_RD_ECR(base)        (ENET_ECR_REG(base))
#define ENET_WR_ECR(base, value) (ENET_ECR_REG(base) = (value))
#define ENET_RMW_ECR(base, mask, value) (ENET_WR_ECR(base, (ENET_RD_ECR(base) & ~(mask)) | (value)))
#define ENET_SET_ECR(base, value) (BME_OR32(&ENET_ECR_REG(base), (uint32_t)(value)))
#define ENET_CLR_ECR(base, value) (BME_AND32(&ENET_ECR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ECR(base, value) (BME_XOR32(&ENET_ECR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_ECR bitfields
 */

/*!
 * @name Register ENET_ECR, field RESET[0] (RW)
 *
 * When this field is set, it clears the ETHEREN field.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_RESET field. */
#define ENET_RD_ECR_RESET(base) ((ENET_ECR_REG(base) & ENET_ECR_RESET_MASK) >> ENET_ECR_RESET_SHIFT)
#define ENET_BRD_ECR_RESET(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_RESET_SHIFT, ENET_ECR_RESET_WIDTH))

/*! @brief Set the RESET field to a new value. */
#define ENET_WR_ECR_RESET(base, value) (ENET_RMW_ECR(base, ENET_ECR_RESET_MASK, ENET_ECR_RESET(value)))
#define ENET_BWR_ECR_RESET(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_RESET_SHIFT), ENET_ECR_RESET_SHIFT, ENET_ECR_RESET_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field ETHEREN[1] (RW)
 *
 * Enables/disables the Ethernet MAC. When the MAC is disabled, the buffer
 * descriptors for an aborted transmit frame are not updated. The uDMA, buffer
 * descriptor, and FIFO control logic are reset, including the buffer descriptor and
 * FIFO pointers. Hardware clears this field under the following conditions: RESET
 * is set by software An error condition causes the EBERR field to set. ETHEREN
 * must be set at the very last step during ENET
 * configuration/setup/initialization, only after all other ENET-related registers have been configured. If ETHEREN
 * is cleared to 0 by software then next time ETHEREN is set, the EIR interrupts
 * must cleared to 0 due to previous pending interrupts.
 *
 * Values:
 * - 0b0 - Reception immediately stops and transmission stops after a bad CRC is
 *     appended to any currently transmitted frame.
 * - 0b1 - MAC is enabled, and reception and transmission are possible.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_ETHEREN field. */
#define ENET_RD_ECR_ETHEREN(base) ((ENET_ECR_REG(base) & ENET_ECR_ETHEREN_MASK) >> ENET_ECR_ETHEREN_SHIFT)
#define ENET_BRD_ECR_ETHEREN(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_ETHEREN_SHIFT, ENET_ECR_ETHEREN_WIDTH))

/*! @brief Set the ETHEREN field to a new value. */
#define ENET_WR_ECR_ETHEREN(base, value) (ENET_RMW_ECR(base, ENET_ECR_ETHEREN_MASK, ENET_ECR_ETHEREN(value)))
#define ENET_BWR_ECR_ETHEREN(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_ETHEREN_SHIFT), ENET_ECR_ETHEREN_SHIFT, ENET_ECR_ETHEREN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field MAGICEN[2] (RW)
 *
 * Enables/disables magic packet detection. MAGICEN is relevant only if the
 * SLEEP field is set. If MAGICEN is set, changing the SLEEP field enables/disables
 * sleep mode and magic packet detection.
 *
 * Values:
 * - 0b0 - Magic detection logic disabled.
 * - 0b1 - The MAC core detects magic packets and asserts EIR[WAKEUP] when a
 *     frame is detected.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_MAGICEN field. */
#define ENET_RD_ECR_MAGICEN(base) ((ENET_ECR_REG(base) & ENET_ECR_MAGICEN_MASK) >> ENET_ECR_MAGICEN_SHIFT)
#define ENET_BRD_ECR_MAGICEN(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_MAGICEN_SHIFT, ENET_ECR_MAGICEN_WIDTH))

/*! @brief Set the MAGICEN field to a new value. */
#define ENET_WR_ECR_MAGICEN(base, value) (ENET_RMW_ECR(base, ENET_ECR_MAGICEN_MASK, ENET_ECR_MAGICEN(value)))
#define ENET_BWR_ECR_MAGICEN(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_MAGICEN_SHIFT), ENET_ECR_MAGICEN_SHIFT, ENET_ECR_MAGICEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field SLEEP[3] (RW)
 *
 * Values:
 * - 0b0 - Normal operating mode.
 * - 0b1 - Sleep mode.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_SLEEP field. */
#define ENET_RD_ECR_SLEEP(base) ((ENET_ECR_REG(base) & ENET_ECR_SLEEP_MASK) >> ENET_ECR_SLEEP_SHIFT)
#define ENET_BRD_ECR_SLEEP(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_SLEEP_SHIFT, ENET_ECR_SLEEP_WIDTH))

/*! @brief Set the SLEEP field to a new value. */
#define ENET_WR_ECR_SLEEP(base, value) (ENET_RMW_ECR(base, ENET_ECR_SLEEP_MASK, ENET_ECR_SLEEP(value)))
#define ENET_BWR_ECR_SLEEP(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_SLEEP_SHIFT), ENET_ECR_SLEEP_SHIFT, ENET_ECR_SLEEP_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field EN1588[4] (RW)
 *
 * Enables enhanced functionality of the MAC.
 *
 * Values:
 * - 0b0 - Legacy FEC buffer descriptors and functions enabled.
 * - 0b1 - Enhanced frame time-stamping functions enabled.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_EN1588 field. */
#define ENET_RD_ECR_EN1588(base) ((ENET_ECR_REG(base) & ENET_ECR_EN1588_MASK) >> ENET_ECR_EN1588_SHIFT)
#define ENET_BRD_ECR_EN1588(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_EN1588_SHIFT, ENET_ECR_EN1588_WIDTH))

/*! @brief Set the EN1588 field to a new value. */
#define ENET_WR_ECR_EN1588(base, value) (ENET_RMW_ECR(base, ENET_ECR_EN1588_MASK, ENET_ECR_EN1588(value)))
#define ENET_BWR_ECR_EN1588(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_EN1588_SHIFT), ENET_ECR_EN1588_SHIFT, ENET_ECR_EN1588_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field DBGEN[6] (RW)
 *
 * Enables the MAC to enter hardware freeze mode when the device enters debug
 * mode.
 *
 * Values:
 * - 0b0 - MAC continues operation in debug mode.
 * - 0b1 - MAC enters hardware freeze mode when the processor is in debug mode.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_DBGEN field. */
#define ENET_RD_ECR_DBGEN(base) ((ENET_ECR_REG(base) & ENET_ECR_DBGEN_MASK) >> ENET_ECR_DBGEN_SHIFT)
#define ENET_BRD_ECR_DBGEN(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_DBGEN_SHIFT, ENET_ECR_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define ENET_WR_ECR_DBGEN(base, value) (ENET_RMW_ECR(base, ENET_ECR_DBGEN_MASK, ENET_ECR_DBGEN(value)))
#define ENET_BWR_ECR_DBGEN(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_DBGEN_SHIFT), ENET_ECR_DBGEN_SHIFT, ENET_ECR_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field STOPEN[7] (RW)
 *
 * Controls device behavior in doze mode. In doze mode, if this field is set
 * then all the clocks of the ENET assembly are disabled, except the RMII /MII
 * clock. Doze mode is similar to a conditional stop mode entry for the ENET assembly
 * depending on ECR[STOPEN]. If module clocks are gated in this mode, the module
 * can still wake the system after receiving a magic packet in stop mode. MAGICEN
 * must be set prior to entering sleep/stop mode.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_STOPEN field. */
#define ENET_RD_ECR_STOPEN(base) ((ENET_ECR_REG(base) & ENET_ECR_STOPEN_MASK) >> ENET_ECR_STOPEN_SHIFT)
#define ENET_BRD_ECR_STOPEN(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_STOPEN_SHIFT, ENET_ECR_STOPEN_WIDTH))

/*! @brief Set the STOPEN field to a new value. */
#define ENET_WR_ECR_STOPEN(base, value) (ENET_RMW_ECR(base, ENET_ECR_STOPEN_MASK, ENET_ECR_STOPEN(value)))
#define ENET_BWR_ECR_STOPEN(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_STOPEN_SHIFT), ENET_ECR_STOPEN_SHIFT, ENET_ECR_STOPEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ECR, field DBSWP[8] (RW)
 *
 * Swaps the byte locations of the buffer descriptors. This field must be
 * written to 1 after reset.
 *
 * Values:
 * - 0b0 - The buffer descriptor bytes are not swapped to support big-endian
 *     devices.
 * - 0b1 - The buffer descriptor bytes are swapped to support little-endian
 *     devices.
 */
/*@{*/
/*! @brief Read current value of the ENET_ECR_DBSWP field. */
#define ENET_RD_ECR_DBSWP(base) ((ENET_ECR_REG(base) & ENET_ECR_DBSWP_MASK) >> ENET_ECR_DBSWP_SHIFT)
#define ENET_BRD_ECR_DBSWP(base) (BME_UBFX32(&ENET_ECR_REG(base), ENET_ECR_DBSWP_SHIFT, ENET_ECR_DBSWP_WIDTH))

/*! @brief Set the DBSWP field to a new value. */
#define ENET_WR_ECR_DBSWP(base, value) (ENET_RMW_ECR(base, ENET_ECR_DBSWP_MASK, ENET_ECR_DBSWP(value)))
#define ENET_BWR_ECR_DBSWP(base, value) (BME_BFI32(&ENET_ECR_REG(base), ((uint32_t)(value) << ENET_ECR_DBSWP_SHIFT), ENET_ECR_DBSWP_SHIFT, ENET_ECR_DBSWP_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_MMFR - MII Management Frame Register
 ******************************************************************************/

/*!
 * @brief ENET_MMFR - MII Management Frame Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Writing to MMFR triggers a management frame transaction to the PHY device
 * unless MSCR is programmed to zero. If MSCR is changed from zero to non-zero
 * during a write to MMFR, an MII frame is generated with the data previously written
 * to the MMFR. This allows MMFR and MSCR to be programmed in either order if
 * MSCR is currently zero. If the MMFR register is written while frame generation is
 * in progress, the frame contents are altered. Software must use the EIR[MII]
 * interrupt indication to avoid writing to the MMFR register while frame
 * generation is in progress.
 */
/*!
 * @name Constants and macros for entire ENET_MMFR register
 */
/*@{*/
#define ENET_RD_MMFR(base)       (ENET_MMFR_REG(base))
#define ENET_WR_MMFR(base, value) (ENET_MMFR_REG(base) = (value))
#define ENET_RMW_MMFR(base, mask, value) (ENET_WR_MMFR(base, (ENET_RD_MMFR(base) & ~(mask)) | (value)))
#define ENET_SET_MMFR(base, value) (BME_OR32(&ENET_MMFR_REG(base), (uint32_t)(value)))
#define ENET_CLR_MMFR(base, value) (BME_AND32(&ENET_MMFR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_MMFR(base, value) (BME_XOR32(&ENET_MMFR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_MMFR bitfields
 */

/*!
 * @name Register ENET_MMFR, field DATA[15:0] (RW)
 *
 * This is the field for data to be written to or read from the PHY register.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_DATA field. */
#define ENET_RD_MMFR_DATA(base) ((ENET_MMFR_REG(base) & ENET_MMFR_DATA_MASK) >> ENET_MMFR_DATA_SHIFT)
#define ENET_BRD_MMFR_DATA(base) (ENET_RD_MMFR_DATA(base))

/*! @brief Set the DATA field to a new value. */
#define ENET_WR_MMFR_DATA(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_DATA_MASK, ENET_MMFR_DATA(value)))
#define ENET_BWR_MMFR_DATA(base, value) (ENET_WR_MMFR_DATA(base, value))
/*@}*/

/*!
 * @name Register ENET_MMFR, field TA[17:16] (RW)
 *
 * This field must be programmed to 10 to generate a valid MII management frame.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_TA field. */
#define ENET_RD_MMFR_TA(base) ((ENET_MMFR_REG(base) & ENET_MMFR_TA_MASK) >> ENET_MMFR_TA_SHIFT)
#define ENET_BRD_MMFR_TA(base) (BME_UBFX32(&ENET_MMFR_REG(base), ENET_MMFR_TA_SHIFT, ENET_MMFR_TA_WIDTH))

/*! @brief Set the TA field to a new value. */
#define ENET_WR_MMFR_TA(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_TA_MASK, ENET_MMFR_TA(value)))
#define ENET_BWR_MMFR_TA(base, value) (BME_BFI32(&ENET_MMFR_REG(base), ((uint32_t)(value) << ENET_MMFR_TA_SHIFT), ENET_MMFR_TA_SHIFT, ENET_MMFR_TA_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MMFR, field RA[22:18] (RW)
 *
 * See (Clause 22) or (Clause 45) for correct value.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_RA field. */
#define ENET_RD_MMFR_RA(base) ((ENET_MMFR_REG(base) & ENET_MMFR_RA_MASK) >> ENET_MMFR_RA_SHIFT)
#define ENET_BRD_MMFR_RA(base) (BME_UBFX32(&ENET_MMFR_REG(base), ENET_MMFR_RA_SHIFT, ENET_MMFR_RA_WIDTH))

/*! @brief Set the RA field to a new value. */
#define ENET_WR_MMFR_RA(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_RA_MASK, ENET_MMFR_RA(value)))
#define ENET_BWR_MMFR_RA(base, value) (BME_BFI32(&ENET_MMFR_REG(base), ((uint32_t)(value) << ENET_MMFR_RA_SHIFT), ENET_MMFR_RA_SHIFT, ENET_MMFR_RA_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MMFR, field PA[27:23] (RW)
 *
 * See (Clause 22) or (Clause 45) for correct value.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_PA field. */
#define ENET_RD_MMFR_PA(base) ((ENET_MMFR_REG(base) & ENET_MMFR_PA_MASK) >> ENET_MMFR_PA_SHIFT)
#define ENET_BRD_MMFR_PA(base) (BME_UBFX32(&ENET_MMFR_REG(base), ENET_MMFR_PA_SHIFT, ENET_MMFR_PA_WIDTH))

/*! @brief Set the PA field to a new value. */
#define ENET_WR_MMFR_PA(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_PA_MASK, ENET_MMFR_PA(value)))
#define ENET_BWR_MMFR_PA(base, value) (BME_BFI32(&ENET_MMFR_REG(base), ((uint32_t)(value) << ENET_MMFR_PA_SHIFT), ENET_MMFR_PA_SHIFT, ENET_MMFR_PA_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MMFR, field OP[29:28] (RW)
 *
 * See (Clause 22) or (Clause 45) for correct value.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_OP field. */
#define ENET_RD_MMFR_OP(base) ((ENET_MMFR_REG(base) & ENET_MMFR_OP_MASK) >> ENET_MMFR_OP_SHIFT)
#define ENET_BRD_MMFR_OP(base) (BME_UBFX32(&ENET_MMFR_REG(base), ENET_MMFR_OP_SHIFT, ENET_MMFR_OP_WIDTH))

/*! @brief Set the OP field to a new value. */
#define ENET_WR_MMFR_OP(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_OP_MASK, ENET_MMFR_OP(value)))
#define ENET_BWR_MMFR_OP(base, value) (BME_BFI32(&ENET_MMFR_REG(base), ((uint32_t)(value) << ENET_MMFR_OP_SHIFT), ENET_MMFR_OP_SHIFT, ENET_MMFR_OP_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MMFR, field ST[31:30] (RW)
 *
 * See (Clause 22) or (Clause 45) for correct value.
 */
/*@{*/
/*! @brief Read current value of the ENET_MMFR_ST field. */
#define ENET_RD_MMFR_ST(base) ((ENET_MMFR_REG(base) & ENET_MMFR_ST_MASK) >> ENET_MMFR_ST_SHIFT)
#define ENET_BRD_MMFR_ST(base) (BME_UBFX32(&ENET_MMFR_REG(base), ENET_MMFR_ST_SHIFT, ENET_MMFR_ST_WIDTH))

/*! @brief Set the ST field to a new value. */
#define ENET_WR_MMFR_ST(base, value) (ENET_RMW_MMFR(base, ENET_MMFR_ST_MASK, ENET_MMFR_ST(value)))
#define ENET_BWR_MMFR_ST(base, value) (BME_BFI32(&ENET_MMFR_REG(base), ((uint32_t)(value) << ENET_MMFR_ST_SHIFT), ENET_MMFR_ST_SHIFT, ENET_MMFR_ST_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_MSCR - MII Speed Control Register
 ******************************************************************************/

/*!
 * @brief ENET_MSCR - MII Speed Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * MSCR provides control of the MII clock (MDC pin) frequency and allows a
 * preamble drop on the MII management frame. The MII_SPEED field must be programmed
 * with a value to provide an MDC frequency of less than or equal to 2.5 MHz to be
 * compliant with the IEEE 802.3 MII specification. The MII_SPEED must be set to
 * a non-zero value to source a read or write management frame. After the
 * management frame is complete, the MSCR register may optionally be cleared to turn
 * off MDC. The MDC signal generated has a 50% duty cycle except when MII_SPEED
 * changes during operation. This change takes effect following a rising or falling
 * edge of MDC. For example, if the internal module clock (i.e., IPS bus clock)
 * is 25 MHz, programming MII_SPEED to 0x4 results in an MDC as given in the
 * following equation: MII clock frequency = 25 MHz / ((4 + 1) x 2) = 2.5 MHz The
 * following table shows the optimum values for MII_SPEED as a function of IPS bus
 * clock frequency. Programming Examples for MSCR Internal module clock frequency
 * MSCR [MII_SPEED] MDC frequency 25 MHz 0x4 2.50 MHz 33 MHz 0x6 2.36 MHz 40 MHz
 * 0x7 2.50 MHz 50 MHz 0x9 2.50 MHz 66 MHz 0xD 2.36 MHz
 */
/*!
 * @name Constants and macros for entire ENET_MSCR register
 */
/*@{*/
#define ENET_RD_MSCR(base)       (ENET_MSCR_REG(base))
#define ENET_WR_MSCR(base, value) (ENET_MSCR_REG(base) = (value))
#define ENET_RMW_MSCR(base, mask, value) (ENET_WR_MSCR(base, (ENET_RD_MSCR(base) & ~(mask)) | (value)))
#define ENET_SET_MSCR(base, value) (BME_OR32(&ENET_MSCR_REG(base), (uint32_t)(value)))
#define ENET_CLR_MSCR(base, value) (BME_AND32(&ENET_MSCR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_MSCR(base, value) (BME_XOR32(&ENET_MSCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_MSCR bitfields
 */

/*!
 * @name Register ENET_MSCR, field MII_SPEED[6:1] (RW)
 *
 * Controls the frequency of the MII management interface clock (MDC) relative
 * to the internal module clock. A value of 0 in this field turns off MDC and
 * leaves it in low voltage state. Any non-zero value results in the MDC frequency
 * of: 1/((MII_SPEED + 1) x 2) of the internal module clock frequency
 */
/*@{*/
/*! @brief Read current value of the ENET_MSCR_MII_SPEED field. */
#define ENET_RD_MSCR_MII_SPEED(base) ((ENET_MSCR_REG(base) & ENET_MSCR_MII_SPEED_MASK) >> ENET_MSCR_MII_SPEED_SHIFT)
#define ENET_BRD_MSCR_MII_SPEED(base) (BME_UBFX32(&ENET_MSCR_REG(base), ENET_MSCR_MII_SPEED_SHIFT, ENET_MSCR_MII_SPEED_WIDTH))

/*! @brief Set the MII_SPEED field to a new value. */
#define ENET_WR_MSCR_MII_SPEED(base, value) (ENET_RMW_MSCR(base, ENET_MSCR_MII_SPEED_MASK, ENET_MSCR_MII_SPEED(value)))
#define ENET_BWR_MSCR_MII_SPEED(base, value) (BME_BFI32(&ENET_MSCR_REG(base), ((uint32_t)(value) << ENET_MSCR_MII_SPEED_SHIFT), ENET_MSCR_MII_SPEED_SHIFT, ENET_MSCR_MII_SPEED_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MSCR, field DIS_PRE[7] (RW)
 *
 * Enables/disables prepending a preamble to the MII management frame. The MII
 * standard allows the preamble to be dropped if the attached PHY devices do not
 * require it.
 *
 * Values:
 * - 0b0 - Preamble enabled.
 * - 0b1 - Preamble (32 ones) is not prepended to the MII management frame.
 */
/*@{*/
/*! @brief Read current value of the ENET_MSCR_DIS_PRE field. */
#define ENET_RD_MSCR_DIS_PRE(base) ((ENET_MSCR_REG(base) & ENET_MSCR_DIS_PRE_MASK) >> ENET_MSCR_DIS_PRE_SHIFT)
#define ENET_BRD_MSCR_DIS_PRE(base) (BME_UBFX32(&ENET_MSCR_REG(base), ENET_MSCR_DIS_PRE_SHIFT, ENET_MSCR_DIS_PRE_WIDTH))

/*! @brief Set the DIS_PRE field to a new value. */
#define ENET_WR_MSCR_DIS_PRE(base, value) (ENET_RMW_MSCR(base, ENET_MSCR_DIS_PRE_MASK, ENET_MSCR_DIS_PRE(value)))
#define ENET_BWR_MSCR_DIS_PRE(base, value) (BME_BFI32(&ENET_MSCR_REG(base), ((uint32_t)(value) << ENET_MSCR_DIS_PRE_SHIFT), ENET_MSCR_DIS_PRE_SHIFT, ENET_MSCR_DIS_PRE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MSCR, field HOLDTIME[10:8] (RW)
 *
 * IEEE802.3 clause 22 defines a minimum of 10 ns for the hold time on the MDIO
 * output. Depending on the host bus frequency, the setting may need to be
 * increased.
 *
 * Values:
 * - 0b000 - 1 internal module clock cycle
 * - 0b001 - 2 internal module clock cycles
 * - 0b010 - 3 internal module clock cycles
 * - 0b111 - 8 internal module clock cycles
 */
/*@{*/
/*! @brief Read current value of the ENET_MSCR_HOLDTIME field. */
#define ENET_RD_MSCR_HOLDTIME(base) ((ENET_MSCR_REG(base) & ENET_MSCR_HOLDTIME_MASK) >> ENET_MSCR_HOLDTIME_SHIFT)
#define ENET_BRD_MSCR_HOLDTIME(base) (BME_UBFX32(&ENET_MSCR_REG(base), ENET_MSCR_HOLDTIME_SHIFT, ENET_MSCR_HOLDTIME_WIDTH))

/*! @brief Set the HOLDTIME field to a new value. */
#define ENET_WR_MSCR_HOLDTIME(base, value) (ENET_RMW_MSCR(base, ENET_MSCR_HOLDTIME_MASK, ENET_MSCR_HOLDTIME(value)))
#define ENET_BWR_MSCR_HOLDTIME(base, value) (BME_BFI32(&ENET_MSCR_REG(base), ((uint32_t)(value) << ENET_MSCR_HOLDTIME_SHIFT), ENET_MSCR_HOLDTIME_SHIFT, ENET_MSCR_HOLDTIME_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_MIBC - MIB Control Register
 ******************************************************************************/

/*!
 * @brief ENET_MIBC - MIB Control Register (RW)
 *
 * Reset value: 0xC0000000U
 *
 * MIBC is a read/write register controlling and observing the state of the MIB
 * block. Access this register to disable the MIB block operation or clear the
 * MIB counters. The MIB_DIS field resets to 1.
 */
/*!
 * @name Constants and macros for entire ENET_MIBC register
 */
/*@{*/
#define ENET_RD_MIBC(base)       (ENET_MIBC_REG(base))
#define ENET_WR_MIBC(base, value) (ENET_MIBC_REG(base) = (value))
#define ENET_RMW_MIBC(base, mask, value) (ENET_WR_MIBC(base, (ENET_RD_MIBC(base) & ~(mask)) | (value)))
#define ENET_SET_MIBC(base, value) (BME_OR32(&ENET_MIBC_REG(base), (uint32_t)(value)))
#define ENET_CLR_MIBC(base, value) (BME_AND32(&ENET_MIBC_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_MIBC(base, value) (BME_XOR32(&ENET_MIBC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_MIBC bitfields
 */

/*!
 * @name Register ENET_MIBC, field MIB_CLEAR[29] (RW)
 *
 * This field is not self-clearing. To clear the MIB counters set and then clear
 * this field.
 *
 * Values:
 * - 0b0 - See note above.
 * - 0b1 - All statistics counters are reset to 0.
 */
/*@{*/
/*! @brief Read current value of the ENET_MIBC_MIB_CLEAR field. */
#define ENET_RD_MIBC_MIB_CLEAR(base) ((ENET_MIBC_REG(base) & ENET_MIBC_MIB_CLEAR_MASK) >> ENET_MIBC_MIB_CLEAR_SHIFT)
#define ENET_BRD_MIBC_MIB_CLEAR(base) (BME_UBFX32(&ENET_MIBC_REG(base), ENET_MIBC_MIB_CLEAR_SHIFT, ENET_MIBC_MIB_CLEAR_WIDTH))

/*! @brief Set the MIB_CLEAR field to a new value. */
#define ENET_WR_MIBC_MIB_CLEAR(base, value) (ENET_RMW_MIBC(base, ENET_MIBC_MIB_CLEAR_MASK, ENET_MIBC_MIB_CLEAR(value)))
#define ENET_BWR_MIBC_MIB_CLEAR(base, value) (BME_BFI32(&ENET_MIBC_REG(base), ((uint32_t)(value) << ENET_MIBC_MIB_CLEAR_SHIFT), ENET_MIBC_MIB_CLEAR_SHIFT, ENET_MIBC_MIB_CLEAR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MIBC, field MIB_IDLE[30] (RO)
 *
 * Values:
 * - 0b0 - The MIB block is updating MIB counters.
 * - 0b1 - The MIB block is not currently updating any MIB counters.
 */
/*@{*/
/*! @brief Read current value of the ENET_MIBC_MIB_IDLE field. */
#define ENET_RD_MIBC_MIB_IDLE(base) ((ENET_MIBC_REG(base) & ENET_MIBC_MIB_IDLE_MASK) >> ENET_MIBC_MIB_IDLE_SHIFT)
#define ENET_BRD_MIBC_MIB_IDLE(base) (BME_UBFX32(&ENET_MIBC_REG(base), ENET_MIBC_MIB_IDLE_SHIFT, ENET_MIBC_MIB_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_MIBC, field MIB_DIS[31] (RW)
 *
 * If this control field is set,
 *
 * Values:
 * - 0b0 - MIB logic is enabled.
 * - 0b1 - MIB logic is disabled. The MIB logic halts and does not update any
 *     MIB counters.
 */
/*@{*/
/*! @brief Read current value of the ENET_MIBC_MIB_DIS field. */
#define ENET_RD_MIBC_MIB_DIS(base) ((ENET_MIBC_REG(base) & ENET_MIBC_MIB_DIS_MASK) >> ENET_MIBC_MIB_DIS_SHIFT)
#define ENET_BRD_MIBC_MIB_DIS(base) (BME_UBFX32(&ENET_MIBC_REG(base), ENET_MIBC_MIB_DIS_SHIFT, ENET_MIBC_MIB_DIS_WIDTH))

/*! @brief Set the MIB_DIS field to a new value. */
#define ENET_WR_MIBC_MIB_DIS(base, value) (ENET_RMW_MIBC(base, ENET_MIBC_MIB_DIS_MASK, ENET_MIBC_MIB_DIS(value)))
#define ENET_BWR_MIBC_MIB_DIS(base, value) (BME_BFI32(&ENET_MIBC_REG(base), ((uint32_t)(value) << ENET_MIBC_MIB_DIS_SHIFT), ENET_MIBC_MIB_DIS_SHIFT, ENET_MIBC_MIB_DIS_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RCR - Receive Control Register
 ******************************************************************************/

/*!
 * @brief ENET_RCR - Receive Control Register (RW)
 *
 * Reset value: 0x05EE0001U
 */
/*!
 * @name Constants and macros for entire ENET_RCR register
 */
/*@{*/
#define ENET_RD_RCR(base)        (ENET_RCR_REG(base))
#define ENET_WR_RCR(base, value) (ENET_RCR_REG(base) = (value))
#define ENET_RMW_RCR(base, mask, value) (ENET_WR_RCR(base, (ENET_RD_RCR(base) & ~(mask)) | (value)))
#define ENET_SET_RCR(base, value) (BME_OR32(&ENET_RCR_REG(base), (uint32_t)(value)))
#define ENET_CLR_RCR(base, value) (BME_AND32(&ENET_RCR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RCR(base, value) (BME_XOR32(&ENET_RCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RCR bitfields
 */

/*!
 * @name Register ENET_RCR, field LOOP[0] (RW)
 *
 * This is an MII internal loopback, therefore MII_MODE must be written to 1 and
 * RMII_MODE must be written to 0.
 *
 * Values:
 * - 0b0 - Loopback disabled.
 * - 0b1 - Transmitted frames are looped back internal to the device and
 *     transmit MII output signals are not asserted. DRT must be cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_LOOP field. */
#define ENET_RD_RCR_LOOP(base) ((ENET_RCR_REG(base) & ENET_RCR_LOOP_MASK) >> ENET_RCR_LOOP_SHIFT)
#define ENET_BRD_RCR_LOOP(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_LOOP_SHIFT, ENET_RCR_LOOP_WIDTH))

/*! @brief Set the LOOP field to a new value. */
#define ENET_WR_RCR_LOOP(base, value) (ENET_RMW_RCR(base, ENET_RCR_LOOP_MASK, ENET_RCR_LOOP(value)))
#define ENET_BWR_RCR_LOOP(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_LOOP_SHIFT), ENET_RCR_LOOP_SHIFT, ENET_RCR_LOOP_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field DRT[1] (RW)
 *
 * Values:
 * - 0b0 - Receive path operates independently of transmit (i.e., full-duplex
 *     mode). Can also be used to monitor transmit activity in half-duplex mode.
 * - 0b1 - Disable reception of frames while transmitting. (Normally used for
 *     half-duplex mode.)
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_DRT field. */
#define ENET_RD_RCR_DRT(base) ((ENET_RCR_REG(base) & ENET_RCR_DRT_MASK) >> ENET_RCR_DRT_SHIFT)
#define ENET_BRD_RCR_DRT(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_DRT_SHIFT, ENET_RCR_DRT_WIDTH))

/*! @brief Set the DRT field to a new value. */
#define ENET_WR_RCR_DRT(base, value) (ENET_RMW_RCR(base, ENET_RCR_DRT_MASK, ENET_RCR_DRT(value)))
#define ENET_BWR_RCR_DRT(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_DRT_SHIFT), ENET_RCR_DRT_SHIFT, ENET_RCR_DRT_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field MII_MODE[2] (RW)
 *
 * This field must always be set.
 *
 * Values:
 * - 0b0 - Reserved.
 * - 0b1 - MII or RMII mode, as indicated by the RMII_MODE field.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_MII_MODE field. */
#define ENET_RD_RCR_MII_MODE(base) ((ENET_RCR_REG(base) & ENET_RCR_MII_MODE_MASK) >> ENET_RCR_MII_MODE_SHIFT)
#define ENET_BRD_RCR_MII_MODE(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_MII_MODE_SHIFT, ENET_RCR_MII_MODE_WIDTH))

/*! @brief Set the MII_MODE field to a new value. */
#define ENET_WR_RCR_MII_MODE(base, value) (ENET_RMW_RCR(base, ENET_RCR_MII_MODE_MASK, ENET_RCR_MII_MODE(value)))
#define ENET_BWR_RCR_MII_MODE(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_MII_MODE_SHIFT), ENET_RCR_MII_MODE_SHIFT, ENET_RCR_MII_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field PROM[3] (RW)
 *
 * All frames are accepted regardless of address matching.
 *
 * Values:
 * - 0b0 - Disabled.
 * - 0b1 - Enabled.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_PROM field. */
#define ENET_RD_RCR_PROM(base) ((ENET_RCR_REG(base) & ENET_RCR_PROM_MASK) >> ENET_RCR_PROM_SHIFT)
#define ENET_BRD_RCR_PROM(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_PROM_SHIFT, ENET_RCR_PROM_WIDTH))

/*! @brief Set the PROM field to a new value. */
#define ENET_WR_RCR_PROM(base, value) (ENET_RMW_RCR(base, ENET_RCR_PROM_MASK, ENET_RCR_PROM(value)))
#define ENET_BWR_RCR_PROM(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_PROM_SHIFT), ENET_RCR_PROM_SHIFT, ENET_RCR_PROM_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field BC_REJ[4] (RW)
 *
 * If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF are
 * rejected unless the PROM field is set. If BC_REJ and PROM are set, frames with
 * broadcast DA are accepted and the MISS (M) is set in the receive buffer
 * descriptor.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_BC_REJ field. */
#define ENET_RD_RCR_BC_REJ(base) ((ENET_RCR_REG(base) & ENET_RCR_BC_REJ_MASK) >> ENET_RCR_BC_REJ_SHIFT)
#define ENET_BRD_RCR_BC_REJ(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_BC_REJ_SHIFT, ENET_RCR_BC_REJ_WIDTH))

/*! @brief Set the BC_REJ field to a new value. */
#define ENET_WR_RCR_BC_REJ(base, value) (ENET_RMW_RCR(base, ENET_RCR_BC_REJ_MASK, ENET_RCR_BC_REJ(value)))
#define ENET_BWR_RCR_BC_REJ(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_BC_REJ_SHIFT), ENET_RCR_BC_REJ_SHIFT, ENET_RCR_BC_REJ_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field FCE[5] (RW)
 *
 * If set, the receiver detects PAUSE frames. Upon PAUSE frame detection, the
 * transmitter stops transmitting data frames for a given duration.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_FCE field. */
#define ENET_RD_RCR_FCE(base) ((ENET_RCR_REG(base) & ENET_RCR_FCE_MASK) >> ENET_RCR_FCE_SHIFT)
#define ENET_BRD_RCR_FCE(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_FCE_SHIFT, ENET_RCR_FCE_WIDTH))

/*! @brief Set the FCE field to a new value. */
#define ENET_WR_RCR_FCE(base, value) (ENET_RMW_RCR(base, ENET_RCR_FCE_MASK, ENET_RCR_FCE(value)))
#define ENET_BWR_RCR_FCE(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_FCE_SHIFT), ENET_RCR_FCE_SHIFT, ENET_RCR_FCE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field RMII_MODE[8] (RW)
 *
 * Specifies whether the MAC is configured for MII mode or RMII operation .
 *
 * Values:
 * - 0b0 - MAC configured for MII mode.
 * - 0b1 - MAC configured for RMII operation.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_RMII_MODE field. */
#define ENET_RD_RCR_RMII_MODE(base) ((ENET_RCR_REG(base) & ENET_RCR_RMII_MODE_MASK) >> ENET_RCR_RMII_MODE_SHIFT)
#define ENET_BRD_RCR_RMII_MODE(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_RMII_MODE_SHIFT, ENET_RCR_RMII_MODE_WIDTH))

/*! @brief Set the RMII_MODE field to a new value. */
#define ENET_WR_RCR_RMII_MODE(base, value) (ENET_RMW_RCR(base, ENET_RCR_RMII_MODE_MASK, ENET_RCR_RMII_MODE(value)))
#define ENET_BWR_RCR_RMII_MODE(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_RMII_MODE_SHIFT), ENET_RCR_RMII_MODE_SHIFT, ENET_RCR_RMII_MODE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field RMII_10T[9] (RW)
 *
 * Enables 10-Mbit/s mode of the RMII .
 *
 * Values:
 * - 0b0 - 100-Mbit/s operation.
 * - 0b1 - 10-Mbit/s operation.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_RMII_10T field. */
#define ENET_RD_RCR_RMII_10T(base) ((ENET_RCR_REG(base) & ENET_RCR_RMII_10T_MASK) >> ENET_RCR_RMII_10T_SHIFT)
#define ENET_BRD_RCR_RMII_10T(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_RMII_10T_SHIFT, ENET_RCR_RMII_10T_WIDTH))

/*! @brief Set the RMII_10T field to a new value. */
#define ENET_WR_RCR_RMII_10T(base, value) (ENET_RMW_RCR(base, ENET_RCR_RMII_10T_MASK, ENET_RCR_RMII_10T(value)))
#define ENET_BWR_RCR_RMII_10T(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_RMII_10T_SHIFT), ENET_RCR_RMII_10T_SHIFT, ENET_RCR_RMII_10T_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field PADEN[12] (RW)
 *
 * Specifies whether the MAC removes padding from received frames.
 *
 * Values:
 * - 0b0 - No padding is removed on receive by the MAC.
 * - 0b1 - Padding is removed from received frames.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_PADEN field. */
#define ENET_RD_RCR_PADEN(base) ((ENET_RCR_REG(base) & ENET_RCR_PADEN_MASK) >> ENET_RCR_PADEN_SHIFT)
#define ENET_BRD_RCR_PADEN(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_PADEN_SHIFT, ENET_RCR_PADEN_WIDTH))

/*! @brief Set the PADEN field to a new value. */
#define ENET_WR_RCR_PADEN(base, value) (ENET_RMW_RCR(base, ENET_RCR_PADEN_MASK, ENET_RCR_PADEN(value)))
#define ENET_BWR_RCR_PADEN(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_PADEN_SHIFT), ENET_RCR_PADEN_SHIFT, ENET_RCR_PADEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field PAUFWD[13] (RW)
 *
 * Specifies whether pause frames are terminated or forwarded.
 *
 * Values:
 * - 0b0 - Pause frames are terminated and discarded in the MAC.
 * - 0b1 - Pause frames are forwarded to the user application.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_PAUFWD field. */
#define ENET_RD_RCR_PAUFWD(base) ((ENET_RCR_REG(base) & ENET_RCR_PAUFWD_MASK) >> ENET_RCR_PAUFWD_SHIFT)
#define ENET_BRD_RCR_PAUFWD(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_PAUFWD_SHIFT, ENET_RCR_PAUFWD_WIDTH))

/*! @brief Set the PAUFWD field to a new value. */
#define ENET_WR_RCR_PAUFWD(base, value) (ENET_RMW_RCR(base, ENET_RCR_PAUFWD_MASK, ENET_RCR_PAUFWD(value)))
#define ENET_BWR_RCR_PAUFWD(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_PAUFWD_SHIFT), ENET_RCR_PAUFWD_SHIFT, ENET_RCR_PAUFWD_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field CRCFWD[14] (RW)
 *
 * Specifies whether the CRC field of received frames is transmitted or
 * stripped. If padding function is enabled (PADEN = 1), CRCFWD is ignored and the CRC
 * field is checked and always terminated and removed.
 *
 * Values:
 * - 0b0 - The CRC field of received frames is transmitted to the user
 *     application.
 * - 0b1 - The CRC field is stripped from the frame.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_CRCFWD field. */
#define ENET_RD_RCR_CRCFWD(base) ((ENET_RCR_REG(base) & ENET_RCR_CRCFWD_MASK) >> ENET_RCR_CRCFWD_SHIFT)
#define ENET_BRD_RCR_CRCFWD(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_CRCFWD_SHIFT, ENET_RCR_CRCFWD_WIDTH))

/*! @brief Set the CRCFWD field to a new value. */
#define ENET_WR_RCR_CRCFWD(base, value) (ENET_RMW_RCR(base, ENET_RCR_CRCFWD_MASK, ENET_RCR_CRCFWD(value)))
#define ENET_BWR_RCR_CRCFWD(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_CRCFWD_SHIFT), ENET_RCR_CRCFWD_SHIFT, ENET_RCR_CRCFWD_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field CFEN[15] (RW)
 *
 * Enables/disables the MAC control frame.
 *
 * Values:
 * - 0b0 - MAC control frames with any opcode other than 0x0001 (pause frame)
 *     are accepted and forwarded to the client interface.
 * - 0b1 - MAC control frames with any opcode other than 0x0001 (pause frame)
 *     are silently discarded.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_CFEN field. */
#define ENET_RD_RCR_CFEN(base) ((ENET_RCR_REG(base) & ENET_RCR_CFEN_MASK) >> ENET_RCR_CFEN_SHIFT)
#define ENET_BRD_RCR_CFEN(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_CFEN_SHIFT, ENET_RCR_CFEN_WIDTH))

/*! @brief Set the CFEN field to a new value. */
#define ENET_WR_RCR_CFEN(base, value) (ENET_RMW_RCR(base, ENET_RCR_CFEN_MASK, ENET_RCR_CFEN(value)))
#define ENET_BWR_RCR_CFEN(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_CFEN_SHIFT), ENET_RCR_CFEN_SHIFT, ENET_RCR_CFEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field MAX_FL[29:16] (RW)
 *
 * Resets to decimal 1518. Length is measured starting at DA and includes the
 * CRC at the end of the frame. Transmit frames longer than MAX_FL cause the BABT
 * interrupt to occur. Receive frames longer than MAX_FL cause the BABR interrupt
 * to occur and set the LG field in the end of frame receive buffer descriptor.
 * The recommended default value to be programmed is 1518 or 1522 if VLAN tags are
 * supported.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_MAX_FL field. */
#define ENET_RD_RCR_MAX_FL(base) ((ENET_RCR_REG(base) & ENET_RCR_MAX_FL_MASK) >> ENET_RCR_MAX_FL_SHIFT)
#define ENET_BRD_RCR_MAX_FL(base) (ENET_RD_RCR_MAX_FL(base))

/*! @brief Set the MAX_FL field to a new value. */
#define ENET_WR_RCR_MAX_FL(base, value) (ENET_RMW_RCR(base, ENET_RCR_MAX_FL_MASK, ENET_RCR_MAX_FL(value)))
#define ENET_BWR_RCR_MAX_FL(base, value) (ENET_WR_RCR_MAX_FL(base, value))
/*@}*/

/*!
 * @name Register ENET_RCR, field NLC[30] (RW)
 *
 * Enables/disables a payload length check.
 *
 * Values:
 * - 0b0 - The payload length check is disabled.
 * - 0b1 - The core checks the frame's payload length with the frame length/type
 *     field. Errors are indicated in the EIR[PLC] field.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_NLC field. */
#define ENET_RD_RCR_NLC(base) ((ENET_RCR_REG(base) & ENET_RCR_NLC_MASK) >> ENET_RCR_NLC_SHIFT)
#define ENET_BRD_RCR_NLC(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_NLC_SHIFT, ENET_RCR_NLC_WIDTH))

/*! @brief Set the NLC field to a new value. */
#define ENET_WR_RCR_NLC(base, value) (ENET_RMW_RCR(base, ENET_RCR_NLC_MASK, ENET_RCR_NLC(value)))
#define ENET_BWR_RCR_NLC(base, value) (BME_BFI32(&ENET_RCR_REG(base), ((uint32_t)(value) << ENET_RCR_NLC_SHIFT), ENET_RCR_NLC_SHIFT, ENET_RCR_NLC_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RCR, field GRS[31] (RO)
 *
 * Read-only status indicating that the MAC receive datapath is stopped.
 */
/*@{*/
/*! @brief Read current value of the ENET_RCR_GRS field. */
#define ENET_RD_RCR_GRS(base) ((ENET_RCR_REG(base) & ENET_RCR_GRS_MASK) >> ENET_RCR_GRS_SHIFT)
#define ENET_BRD_RCR_GRS(base) (BME_UBFX32(&ENET_RCR_REG(base), ENET_RCR_GRS_SHIFT, ENET_RCR_GRS_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TCR - Transmit Control Register
 ******************************************************************************/

/*!
 * @brief ENET_TCR - Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR is read/write and configures the transmit block. This register is cleared
 * at system reset. FDEN can only be modified when ECR[ETHEREN] is cleared.
 */
/*!
 * @name Constants and macros for entire ENET_TCR register
 */
/*@{*/
#define ENET_RD_TCR(base)        (ENET_TCR_REG(base))
#define ENET_WR_TCR(base, value) (ENET_TCR_REG(base) = (value))
#define ENET_RMW_TCR(base, mask, value) (ENET_WR_TCR(base, (ENET_RD_TCR(base) & ~(mask)) | (value)))
#define ENET_SET_TCR(base, value) (BME_OR32(&ENET_TCR_REG(base), (uint32_t)(value)))
#define ENET_CLR_TCR(base, value) (BME_AND32(&ENET_TCR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TCR(base, value) (BME_XOR32(&ENET_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TCR bitfields
 */

/*!
 * @name Register ENET_TCR, field GTS[0] (RW)
 *
 * When this field is set, MAC stops transmission after any frame currently
 * transmitted is complete and EIR[GRA] is set. If frame transmission is not
 * currently underway, the GRA interrupt is asserted immediately. After transmission
 * finishes, clear GTS to restart. The next frame in the transmit FIFO is then
 * transmitted. If an early collision occurs during transmission when GTS is set,
 * transmission stops after the collision. The frame is transmitted again after GTS is
 * cleared. There may be old frames in the transmit FIFO that transmit when GTS
 * is reasserted. To avoid this, clear ECR[ETHEREN] following the GRA interrupt.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_GTS field. */
#define ENET_RD_TCR_GTS(base) ((ENET_TCR_REG(base) & ENET_TCR_GTS_MASK) >> ENET_TCR_GTS_SHIFT)
#define ENET_BRD_TCR_GTS(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_GTS_SHIFT, ENET_TCR_GTS_WIDTH))

/*! @brief Set the GTS field to a new value. */
#define ENET_WR_TCR_GTS(base, value) (ENET_RMW_TCR(base, ENET_TCR_GTS_MASK, ENET_TCR_GTS(value)))
#define ENET_BWR_TCR_GTS(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_GTS_SHIFT), ENET_TCR_GTS_SHIFT, ENET_TCR_GTS_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field FDEN[2] (RW)
 *
 * If this field is set, frames transmit independent of carrier sense and
 * collision inputs. Only modify this bit when ECR[ETHEREN] is cleared.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_FDEN field. */
#define ENET_RD_TCR_FDEN(base) ((ENET_TCR_REG(base) & ENET_TCR_FDEN_MASK) >> ENET_TCR_FDEN_SHIFT)
#define ENET_BRD_TCR_FDEN(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_FDEN_SHIFT, ENET_TCR_FDEN_WIDTH))

/*! @brief Set the FDEN field to a new value. */
#define ENET_WR_TCR_FDEN(base, value) (ENET_RMW_TCR(base, ENET_TCR_FDEN_MASK, ENET_TCR_FDEN(value)))
#define ENET_BWR_TCR_FDEN(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_FDEN_SHIFT), ENET_TCR_FDEN_SHIFT, ENET_TCR_FDEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field TFC_PAUSE[3] (RW)
 *
 * Pauses frame transmission. When this field is set, EIR[GRA] is set. With
 * transmission of data frames stopped, the MAC transmits a MAC control PAUSE frame.
 * Next, the MAC clears TFC_PAUSE and resumes transmitting data frames. If the
 * transmitter pauses due to user assertion of GTS or reception of a PAUSE frame,
 * the MAC may continue transmitting a MAC control PAUSE frame.
 *
 * Values:
 * - 0b0 - No PAUSE frame transmitted.
 * - 0b1 - The MAC stops transmission of data frames after the current
 *     transmission is complete.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_TFC_PAUSE field. */
#define ENET_RD_TCR_TFC_PAUSE(base) ((ENET_TCR_REG(base) & ENET_TCR_TFC_PAUSE_MASK) >> ENET_TCR_TFC_PAUSE_SHIFT)
#define ENET_BRD_TCR_TFC_PAUSE(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_TFC_PAUSE_SHIFT, ENET_TCR_TFC_PAUSE_WIDTH))

/*! @brief Set the TFC_PAUSE field to a new value. */
#define ENET_WR_TCR_TFC_PAUSE(base, value) (ENET_RMW_TCR(base, ENET_TCR_TFC_PAUSE_MASK, ENET_TCR_TFC_PAUSE(value)))
#define ENET_BWR_TCR_TFC_PAUSE(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_TFC_PAUSE_SHIFT), ENET_TCR_TFC_PAUSE_SHIFT, ENET_TCR_TFC_PAUSE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field RFC_PAUSE[4] (RO)
 *
 * This status field is set when a full-duplex flow control pause frame is
 * received and the transmitter pauses for the duration defined in this pause frame.
 * This field automatically clears when the pause duration is complete.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_RFC_PAUSE field. */
#define ENET_RD_TCR_RFC_PAUSE(base) ((ENET_TCR_REG(base) & ENET_TCR_RFC_PAUSE_MASK) >> ENET_TCR_RFC_PAUSE_SHIFT)
#define ENET_BRD_TCR_RFC_PAUSE(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_RFC_PAUSE_SHIFT, ENET_TCR_RFC_PAUSE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field ADDSEL[7:5] (RW)
 *
 * If ADDINS is set, indicates the MAC address that overwrites the source MAC
 * address.
 *
 * Values:
 * - 0b000 - Node MAC address programmed on PADDR1/2 registers.
 * - 0b100 - Reserved.
 * - 0b101 - Reserved.
 * - 0b110 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_ADDSEL field. */
#define ENET_RD_TCR_ADDSEL(base) ((ENET_TCR_REG(base) & ENET_TCR_ADDSEL_MASK) >> ENET_TCR_ADDSEL_SHIFT)
#define ENET_BRD_TCR_ADDSEL(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_ADDSEL_SHIFT, ENET_TCR_ADDSEL_WIDTH))

/*! @brief Set the ADDSEL field to a new value. */
#define ENET_WR_TCR_ADDSEL(base, value) (ENET_RMW_TCR(base, ENET_TCR_ADDSEL_MASK, ENET_TCR_ADDSEL(value)))
#define ENET_BWR_TCR_ADDSEL(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_ADDSEL_SHIFT), ENET_TCR_ADDSEL_SHIFT, ENET_TCR_ADDSEL_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field ADDINS[8] (RW)
 *
 * Values:
 * - 0b0 - The source MAC address is not modified by the MAC.
 * - 0b1 - The MAC overwrites the source MAC address with the programmed MAC
 *     address according to ADDSEL.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_ADDINS field. */
#define ENET_RD_TCR_ADDINS(base) ((ENET_TCR_REG(base) & ENET_TCR_ADDINS_MASK) >> ENET_TCR_ADDINS_SHIFT)
#define ENET_BRD_TCR_ADDINS(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_ADDINS_SHIFT, ENET_TCR_ADDINS_WIDTH))

/*! @brief Set the ADDINS field to a new value. */
#define ENET_WR_TCR_ADDINS(base, value) (ENET_RMW_TCR(base, ENET_TCR_ADDINS_MASK, ENET_TCR_ADDINS(value)))
#define ENET_BWR_TCR_ADDINS(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_ADDINS_SHIFT), ENET_TCR_ADDINS_SHIFT, ENET_TCR_ADDINS_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCR, field CRCFWD[9] (RW)
 *
 * Values:
 * - 0b0 - TxBD[TC] controls whether the frame has a CRC from the application.
 * - 0b1 - The transmitter does not append any CRC to transmitted frames, as it
 *     is expecting a frame with CRC from the application.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCR_CRCFWD field. */
#define ENET_RD_TCR_CRCFWD(base) ((ENET_TCR_REG(base) & ENET_TCR_CRCFWD_MASK) >> ENET_TCR_CRCFWD_SHIFT)
#define ENET_BRD_TCR_CRCFWD(base) (BME_UBFX32(&ENET_TCR_REG(base), ENET_TCR_CRCFWD_SHIFT, ENET_TCR_CRCFWD_WIDTH))

/*! @brief Set the CRCFWD field to a new value. */
#define ENET_WR_TCR_CRCFWD(base, value) (ENET_RMW_TCR(base, ENET_TCR_CRCFWD_MASK, ENET_TCR_CRCFWD(value)))
#define ENET_BWR_TCR_CRCFWD(base, value) (BME_BFI32(&ENET_TCR_REG(base), ((uint32_t)(value) << ENET_TCR_CRCFWD_SHIFT), ENET_TCR_CRCFWD_SHIFT, ENET_TCR_CRCFWD_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_PALR - Physical Address Lower Register
 ******************************************************************************/

/*!
 * @brief ENET_PALR - Physical Address Lower Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * PALR contains the lower 32 bits (bytes 0, 1, 2, 3) of the 48-bit address used
 * in the address recognition process to compare with the destination address
 * (DA) field of receive frames with an individual DA. In addition, this register
 * is used in bytes 0 through 3 of the six-byte source address field when
 * transmitting PAUSE frames.
 */
/*!
 * @name Constants and macros for entire ENET_PALR register
 */
/*@{*/
#define ENET_RD_PALR(base)       (ENET_PALR_REG(base))
#define ENET_WR_PALR(base, value) (ENET_PALR_REG(base) = (value))
#define ENET_RMW_PALR(base, mask, value) (ENET_WR_PALR(base, (ENET_RD_PALR(base) & ~(mask)) | (value)))
#define ENET_SET_PALR(base, value) (BME_OR32(&ENET_PALR_REG(base), (uint32_t)(value)))
#define ENET_CLR_PALR(base, value) (BME_AND32(&ENET_PALR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_PALR(base, value) (BME_XOR32(&ENET_PALR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_PAUR - Physical Address Upper Register
 ******************************************************************************/

/*!
 * @brief ENET_PAUR - Physical Address Upper Register (RW)
 *
 * Reset value: 0x00008808U
 *
 * PAUR contains the upper 16 bits (bytes 4 and 5) of the 48-bit address used in
 * the address recognition process to compare with the destination address (DA)
 * field of receive frames with an individual DA. In addition, this register is
 * used in bytes 4 and 5 of the six-byte source address field when transmitting
 * PAUSE frames. Bits 15:0 of PAUR contain a constant type field (0x8808) for
 * transmission of PAUSE frames.
 */
/*!
 * @name Constants and macros for entire ENET_PAUR register
 */
/*@{*/
#define ENET_RD_PAUR(base)       (ENET_PAUR_REG(base))
#define ENET_WR_PAUR(base, value) (ENET_PAUR_REG(base) = (value))
#define ENET_RMW_PAUR(base, mask, value) (ENET_WR_PAUR(base, (ENET_RD_PAUR(base) & ~(mask)) | (value)))
#define ENET_SET_PAUR(base, value) (BME_OR32(&ENET_PAUR_REG(base), (uint32_t)(value)))
#define ENET_CLR_PAUR(base, value) (BME_AND32(&ENET_PAUR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_PAUR(base, value) (BME_XOR32(&ENET_PAUR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_PAUR bitfields
 */

/*!
 * @name Register ENET_PAUR, field TYPE[15:0] (RO)
 *
 * These fields have a constant value of 0x8808.
 */
/*@{*/
/*! @brief Read current value of the ENET_PAUR_TYPE field. */
#define ENET_RD_PAUR_TYPE(base) ((ENET_PAUR_REG(base) & ENET_PAUR_TYPE_MASK) >> ENET_PAUR_TYPE_SHIFT)
#define ENET_BRD_PAUR_TYPE(base) (ENET_RD_PAUR_TYPE(base))
/*@}*/

/*!
 * @name Register ENET_PAUR, field PADDR2[31:16] (RW)
 *
 * Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual address used
 * for exact match, and the source address field in PAUSE frames.
 */
/*@{*/
/*! @brief Read current value of the ENET_PAUR_PADDR2 field. */
#define ENET_RD_PAUR_PADDR2(base) ((ENET_PAUR_REG(base) & ENET_PAUR_PADDR2_MASK) >> ENET_PAUR_PADDR2_SHIFT)
#define ENET_BRD_PAUR_PADDR2(base) (ENET_RD_PAUR_PADDR2(base))

/*! @brief Set the PADDR2 field to a new value. */
#define ENET_WR_PAUR_PADDR2(base, value) (ENET_RMW_PAUR(base, ENET_PAUR_PADDR2_MASK, ENET_PAUR_PADDR2(value)))
#define ENET_BWR_PAUR_PADDR2(base, value) (ENET_WR_PAUR_PADDR2(base, value))
/*@}*/

/*******************************************************************************
 * ENET_OPD - Opcode/Pause Duration Register
 ******************************************************************************/

/*!
 * @brief ENET_OPD - Opcode/Pause Duration Register (RW)
 *
 * Reset value: 0x00010000U
 *
 * OPD is read/write accessible. This register contains the 16-bit opcode and
 * 16-bit pause duration fields used in transmission of a PAUSE frame. The opcode
 * field is a constant value, 0x0001. When another node detects a PAUSE frame,
 * that node pauses transmission for the duration specified in the pause duration
 * field. The lower 16 bits of this register are not reset and you must initialize
 * it.
 */
/*!
 * @name Constants and macros for entire ENET_OPD register
 */
/*@{*/
#define ENET_RD_OPD(base)        (ENET_OPD_REG(base))
#define ENET_WR_OPD(base, value) (ENET_OPD_REG(base) = (value))
#define ENET_RMW_OPD(base, mask, value) (ENET_WR_OPD(base, (ENET_RD_OPD(base) & ~(mask)) | (value)))
#define ENET_SET_OPD(base, value) (BME_OR32(&ENET_OPD_REG(base), (uint32_t)(value)))
#define ENET_CLR_OPD(base, value) (BME_AND32(&ENET_OPD_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_OPD(base, value) (BME_XOR32(&ENET_OPD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_OPD bitfields
 */

/*!
 * @name Register ENET_OPD, field PAUSE_DUR[15:0] (RW)
 *
 * Pause duration field used in PAUSE frames.
 */
/*@{*/
/*! @brief Read current value of the ENET_OPD_PAUSE_DUR field. */
#define ENET_RD_OPD_PAUSE_DUR(base) ((ENET_OPD_REG(base) & ENET_OPD_PAUSE_DUR_MASK) >> ENET_OPD_PAUSE_DUR_SHIFT)
#define ENET_BRD_OPD_PAUSE_DUR(base) (ENET_RD_OPD_PAUSE_DUR(base))

/*! @brief Set the PAUSE_DUR field to a new value. */
#define ENET_WR_OPD_PAUSE_DUR(base, value) (ENET_RMW_OPD(base, ENET_OPD_PAUSE_DUR_MASK, ENET_OPD_PAUSE_DUR(value)))
#define ENET_BWR_OPD_PAUSE_DUR(base, value) (ENET_WR_OPD_PAUSE_DUR(base, value))
/*@}*/

/*!
 * @name Register ENET_OPD, field OPCODE[31:16] (RO)
 *
 * These fields have a constant value of 0x0001.
 */
/*@{*/
/*! @brief Read current value of the ENET_OPD_OPCODE field. */
#define ENET_RD_OPD_OPCODE(base) ((ENET_OPD_REG(base) & ENET_OPD_OPCODE_MASK) >> ENET_OPD_OPCODE_SHIFT)
#define ENET_BRD_OPD_OPCODE(base) (ENET_RD_OPD_OPCODE(base))
/*@}*/

/*******************************************************************************
 * ENET_IAUR - Descriptor Individual Upper Address Register
 ******************************************************************************/

/*!
 * @brief ENET_IAUR - Descriptor Individual Upper Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * IAUR contains the upper 32 bits of the 64-bit individual address hash table.
 * The address recognition process uses this table to check for a possible match
 * with the destination address (DA) field of receive frames with an individual
 * DA. This register is not reset and you must initialize it.
 */
/*!
 * @name Constants and macros for entire ENET_IAUR register
 */
/*@{*/
#define ENET_RD_IAUR(base)       (ENET_IAUR_REG(base))
#define ENET_WR_IAUR(base, value) (ENET_IAUR_REG(base) = (value))
#define ENET_RMW_IAUR(base, mask, value) (ENET_WR_IAUR(base, (ENET_RD_IAUR(base) & ~(mask)) | (value)))
#define ENET_SET_IAUR(base, value) (BME_OR32(&ENET_IAUR_REG(base), (uint32_t)(value)))
#define ENET_CLR_IAUR(base, value) (BME_AND32(&ENET_IAUR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_IAUR(base, value) (BME_XOR32(&ENET_IAUR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_IALR - Descriptor Individual Lower Address Register
 ******************************************************************************/

/*!
 * @brief ENET_IALR - Descriptor Individual Lower Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * IALR contains the lower 32 bits of the 64-bit individual address hash table.
 * The address recognition process uses this table to check for a possible match
 * with the DA field of receive frames with an individual DA. This register is
 * not reset and you must initialize it.
 */
/*!
 * @name Constants and macros for entire ENET_IALR register
 */
/*@{*/
#define ENET_RD_IALR(base)       (ENET_IALR_REG(base))
#define ENET_WR_IALR(base, value) (ENET_IALR_REG(base) = (value))
#define ENET_RMW_IALR(base, mask, value) (ENET_WR_IALR(base, (ENET_RD_IALR(base) & ~(mask)) | (value)))
#define ENET_SET_IALR(base, value) (BME_OR32(&ENET_IALR_REG(base), (uint32_t)(value)))
#define ENET_CLR_IALR(base, value) (BME_AND32(&ENET_IALR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_IALR(base, value) (BME_XOR32(&ENET_IALR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_GAUR - Descriptor Group Upper Address Register
 ******************************************************************************/

/*!
 * @brief ENET_GAUR - Descriptor Group Upper Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * GAUR contains the upper 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. You must
 * initialize this register.
 */
/*!
 * @name Constants and macros for entire ENET_GAUR register
 */
/*@{*/
#define ENET_RD_GAUR(base)       (ENET_GAUR_REG(base))
#define ENET_WR_GAUR(base, value) (ENET_GAUR_REG(base) = (value))
#define ENET_RMW_GAUR(base, mask, value) (ENET_WR_GAUR(base, (ENET_RD_GAUR(base) & ~(mask)) | (value)))
#define ENET_SET_GAUR(base, value) (BME_OR32(&ENET_GAUR_REG(base), (uint32_t)(value)))
#define ENET_CLR_GAUR(base, value) (BME_AND32(&ENET_GAUR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_GAUR(base, value) (BME_XOR32(&ENET_GAUR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_GALR - Descriptor Group Lower Address Register
 ******************************************************************************/

/*!
 * @brief ENET_GALR - Descriptor Group Lower Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * GALR contains the lower 32 bits of the 64-bit hash table used in the address
 * recognition process for receive frames with a multicast address. You must
 * initialize this register.
 */
/*!
 * @name Constants and macros for entire ENET_GALR register
 */
/*@{*/
#define ENET_RD_GALR(base)       (ENET_GALR_REG(base))
#define ENET_WR_GALR(base, value) (ENET_GALR_REG(base) = (value))
#define ENET_RMW_GALR(base, mask, value) (ENET_WR_GALR(base, (ENET_RD_GALR(base) & ~(mask)) | (value)))
#define ENET_SET_GALR(base, value) (BME_OR32(&ENET_GALR_REG(base), (uint32_t)(value)))
#define ENET_CLR_GALR(base, value) (BME_AND32(&ENET_GALR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_GALR(base, value) (BME_XOR32(&ENET_GALR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_TFWR - Transmit FIFO Watermark Register
 ******************************************************************************/

/*!
 * @brief ENET_TFWR - Transmit FIFO Watermark Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * If TFWR[STRFWD] is cleared, TFWR[TFWR] controls the amount of data required
 * in the transmit FIFO before transmission of a frame can begin. This allows you
 * to minimize transmit latency (TFWR = 00 or 01) or allow for larger bus access
 * latency (TFWR = 11) due to contention for the system bus. Setting the
 * watermark to a high value minimizes the risk of transmit FIFO underrun due to
 * contention for the system bus. The byte counts associated with the TFWR field may need
 * to be modified to match a given system requirement, for example, worst-case
 * bus access latency by the transmit data uDMA channel. When the FIFO level
 * reaches the value the TFWR field and when the STR_FWD is set to '0', the MAC
 * transmit control logic starts frame transmission even before the end-of-frame is
 * available in the FIFO (cut-through operation). If a complete frame has a size
 * smaller than the threshold programmed with TFWR, the MAC also transmits the Frame
 * to the line. To enable store and forward on the Transmit path, set STR_FWD to
 * '1'. In this case, the MAC starts to transmit data only when a complete frame
 * is stored in the Transmit FIFO.
 */
/*!
 * @name Constants and macros for entire ENET_TFWR register
 */
/*@{*/
#define ENET_RD_TFWR(base)       (ENET_TFWR_REG(base))
#define ENET_WR_TFWR(base, value) (ENET_TFWR_REG(base) = (value))
#define ENET_RMW_TFWR(base, mask, value) (ENET_WR_TFWR(base, (ENET_RD_TFWR(base) & ~(mask)) | (value)))
#define ENET_SET_TFWR(base, value) (BME_OR32(&ENET_TFWR_REG(base), (uint32_t)(value)))
#define ENET_CLR_TFWR(base, value) (BME_AND32(&ENET_TFWR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TFWR(base, value) (BME_XOR32(&ENET_TFWR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TFWR bitfields
 */

/*!
 * @name Register ENET_TFWR, field TFWR[5:0] (RW)
 *
 * If TFWR[STRFWD] is cleared, this field indicates the number of bytes, in
 * steps of 64 bytes, written to the transmit FIFO before transmission of a frame
 * begins. If a frame with less than the threshold is written, it is still sent
 * independently of this threshold setting. The threshold is relevant only if the
 * frame is larger than the threshold given.
 *
 * Values:
 * - 0b000000 - 64 bytes written.
 * - 0b000001 - 64 bytes written.
 * - 0b000010 - 128 bytes written.
 * - 0b000011 - 192 bytes written.
 * - 0b011111 - 1984 bytes written.
 */
/*@{*/
/*! @brief Read current value of the ENET_TFWR_TFWR field. */
#define ENET_RD_TFWR_TFWR(base) ((ENET_TFWR_REG(base) & ENET_TFWR_TFWR_MASK) >> ENET_TFWR_TFWR_SHIFT)
#define ENET_BRD_TFWR_TFWR(base) (BME_UBFX32(&ENET_TFWR_REG(base), ENET_TFWR_TFWR_SHIFT, ENET_TFWR_TFWR_WIDTH))

/*! @brief Set the TFWR field to a new value. */
#define ENET_WR_TFWR_TFWR(base, value) (ENET_RMW_TFWR(base, ENET_TFWR_TFWR_MASK, ENET_TFWR_TFWR(value)))
#define ENET_BWR_TFWR_TFWR(base, value) (BME_BFI32(&ENET_TFWR_REG(base), ((uint32_t)(value) << ENET_TFWR_TFWR_SHIFT), ENET_TFWR_TFWR_SHIFT, ENET_TFWR_TFWR_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TFWR, field STRFWD[8] (RW)
 *
 * Values:
 * - 0b0 - Reset. The transmission start threshold is programmed in TFWR[TFWR].
 * - 0b1 - Enabled.
 */
/*@{*/
/*! @brief Read current value of the ENET_TFWR_STRFWD field. */
#define ENET_RD_TFWR_STRFWD(base) ((ENET_TFWR_REG(base) & ENET_TFWR_STRFWD_MASK) >> ENET_TFWR_STRFWD_SHIFT)
#define ENET_BRD_TFWR_STRFWD(base) (BME_UBFX32(&ENET_TFWR_REG(base), ENET_TFWR_STRFWD_SHIFT, ENET_TFWR_STRFWD_WIDTH))

/*! @brief Set the STRFWD field to a new value. */
#define ENET_WR_TFWR_STRFWD(base, value) (ENET_RMW_TFWR(base, ENET_TFWR_STRFWD_MASK, ENET_TFWR_STRFWD(value)))
#define ENET_BWR_TFWR_STRFWD(base, value) (BME_BFI32(&ENET_TFWR_REG(base), ((uint32_t)(value) << ENET_TFWR_STRFWD_SHIFT), ENET_TFWR_STRFWD_SHIFT, ENET_TFWR_STRFWD_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RDSR - Receive Descriptor Ring Start Register
 ******************************************************************************/

/*!
 * @brief ENET_RDSR - Receive Descriptor Ring Start Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RDSR points to the beginning of the circular receive buffer descriptor queue
 * in external memory. This pointer must be 64-bit aligned (bits 2-0 must be
 * zero); however, it is recommended to be 128-bit aligned, that is, evenly divisible
 * by 16. This register must be initialized prior to operation
 */
/*!
 * @name Constants and macros for entire ENET_RDSR register
 */
/*@{*/
#define ENET_RD_RDSR(base)       (ENET_RDSR_REG(base))
#define ENET_WR_RDSR(base, value) (ENET_RDSR_REG(base) = (value))
#define ENET_RMW_RDSR(base, mask, value) (ENET_WR_RDSR(base, (ENET_RD_RDSR(base) & ~(mask)) | (value)))
#define ENET_SET_RDSR(base, value) (BME_OR32(&ENET_RDSR_REG(base), (uint32_t)(value)))
#define ENET_CLR_RDSR(base, value) (BME_AND32(&ENET_RDSR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RDSR(base, value) (BME_XOR32(&ENET_RDSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RDSR bitfields
 */

/*!
 * @name Register ENET_RDSR, field R_DES_START[31:3] (RW)
 *
 * Pointer to the beginning of the receive buffer descriptor queue.
 */
/*@{*/
/*! @brief Read current value of the ENET_RDSR_R_DES_START field. */
#define ENET_RD_RDSR_R_DES_START(base) ((ENET_RDSR_REG(base) & ENET_RDSR_R_DES_START_MASK) >> ENET_RDSR_R_DES_START_SHIFT)
#define ENET_BRD_RDSR_R_DES_START(base) (ENET_RD_RDSR_R_DES_START(base))

/*! @brief Set the R_DES_START field to a new value. */
#define ENET_WR_RDSR_R_DES_START(base, value) (ENET_RMW_RDSR(base, ENET_RDSR_R_DES_START_MASK, ENET_RDSR_R_DES_START(value)))
#define ENET_BWR_RDSR_R_DES_START(base, value) (ENET_WR_RDSR_R_DES_START(base, value))
/*@}*/

/*******************************************************************************
 * ENET_TDSR - Transmit Buffer Descriptor Ring Start Register
 ******************************************************************************/

/*!
 * @brief ENET_TDSR - Transmit Buffer Descriptor Ring Start Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TDSR provides a pointer to the beginning of the circular transmit buffer
 * descriptor queue in external memory. This pointer must be 64-bit aligned (bits 2-0
 * must be zero); however, it is recommended to be 128-bit aligned, that is,
 * evenly divisible by 16. This register must be initialized prior to operation.
 */
/*!
 * @name Constants and macros for entire ENET_TDSR register
 */
/*@{*/
#define ENET_RD_TDSR(base)       (ENET_TDSR_REG(base))
#define ENET_WR_TDSR(base, value) (ENET_TDSR_REG(base) = (value))
#define ENET_RMW_TDSR(base, mask, value) (ENET_WR_TDSR(base, (ENET_RD_TDSR(base) & ~(mask)) | (value)))
#define ENET_SET_TDSR(base, value) (BME_OR32(&ENET_TDSR_REG(base), (uint32_t)(value)))
#define ENET_CLR_TDSR(base, value) (BME_AND32(&ENET_TDSR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TDSR(base, value) (BME_XOR32(&ENET_TDSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TDSR bitfields
 */

/*!
 * @name Register ENET_TDSR, field X_DES_START[31:3] (RW)
 *
 * Pointer to the beginning of the transmit buffer descriptor queue.
 */
/*@{*/
/*! @brief Read current value of the ENET_TDSR_X_DES_START field. */
#define ENET_RD_TDSR_X_DES_START(base) ((ENET_TDSR_REG(base) & ENET_TDSR_X_DES_START_MASK) >> ENET_TDSR_X_DES_START_SHIFT)
#define ENET_BRD_TDSR_X_DES_START(base) (ENET_RD_TDSR_X_DES_START(base))

/*! @brief Set the X_DES_START field to a new value. */
#define ENET_WR_TDSR_X_DES_START(base, value) (ENET_RMW_TDSR(base, ENET_TDSR_X_DES_START_MASK, ENET_TDSR_X_DES_START(value)))
#define ENET_BWR_TDSR_X_DES_START(base, value) (ENET_WR_TDSR_X_DES_START(base, value))
/*@}*/

/*******************************************************************************
 * ENET_MRBR - Maximum Receive Buffer Size Register
 ******************************************************************************/

/*!
 * @brief ENET_MRBR - Maximum Receive Buffer Size Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MRBR is a user-programmable register that dictates the maximum size of
 * all receive buffers. This value should take into consideration that the receive
 * CRC is always written into the last receive buffer. R_BUF_SIZE is
 * concatentated with the four least-significant bits of this register and are used as the
 * maximum receive buffer size. To allow one maximum size frame per buffer, MRBR
 * must be set to RCR[MAX_FL] or larger. To properly align the buffer, MRBR must be
 * evenly divisible by 16. To ensure this, the lower four bits are set to zero
 * by the device. To minimize bus usage (descriptor fetches), set MRBR greater
 * than or equal to 256 bytes. This register must be initialized before operation.
 */
/*!
 * @name Constants and macros for entire ENET_MRBR register
 */
/*@{*/
#define ENET_RD_MRBR(base)       (ENET_MRBR_REG(base))
#define ENET_WR_MRBR(base, value) (ENET_MRBR_REG(base) = (value))
#define ENET_RMW_MRBR(base, mask, value) (ENET_WR_MRBR(base, (ENET_RD_MRBR(base) & ~(mask)) | (value)))
#define ENET_SET_MRBR(base, value) (BME_OR32(&ENET_MRBR_REG(base), (uint32_t)(value)))
#define ENET_CLR_MRBR(base, value) (BME_AND32(&ENET_MRBR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_MRBR(base, value) (BME_XOR32(&ENET_MRBR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_MRBR bitfields
 */

/*!
 * @name Register ENET_MRBR, field R_BUF_SIZE[10:4] (RW)
 *
 * Receive buffer size in bytes. This value, concatenated with the four
 * least-significant bits of this register (which are always zero), is the effective
 * maximum receive buffer size.
 */
/*@{*/
/*! @brief Read current value of the ENET_MRBR_R_BUF_SIZE field. */
#define ENET_RD_MRBR_R_BUF_SIZE(base) ((ENET_MRBR_REG(base) & ENET_MRBR_R_BUF_SIZE_MASK) >> ENET_MRBR_R_BUF_SIZE_SHIFT)
#define ENET_BRD_MRBR_R_BUF_SIZE(base) (BME_UBFX32(&ENET_MRBR_REG(base), ENET_MRBR_R_BUF_SIZE_SHIFT, ENET_MRBR_R_BUF_SIZE_WIDTH))

/*! @brief Set the R_BUF_SIZE field to a new value. */
#define ENET_WR_MRBR_R_BUF_SIZE(base, value) (ENET_RMW_MRBR(base, ENET_MRBR_R_BUF_SIZE_MASK, ENET_MRBR_R_BUF_SIZE(value)))
#define ENET_BWR_MRBR_R_BUF_SIZE(base, value) (BME_BFI32(&ENET_MRBR_REG(base), ((uint32_t)(value) << ENET_MRBR_R_BUF_SIZE_SHIFT), ENET_MRBR_R_BUF_SIZE_SHIFT, ENET_MRBR_R_BUF_SIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RSFL - Receive FIFO Section Full Threshold
 ******************************************************************************/

/*!
 * @brief ENET_RSFL - Receive FIFO Section Full Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RSFL register
 */
/*@{*/
#define ENET_RD_RSFL(base)       (ENET_RSFL_REG(base))
#define ENET_WR_RSFL(base, value) (ENET_RSFL_REG(base) = (value))
#define ENET_RMW_RSFL(base, mask, value) (ENET_WR_RSFL(base, (ENET_RD_RSFL(base) & ~(mask)) | (value)))
#define ENET_SET_RSFL(base, value) (BME_OR32(&ENET_RSFL_REG(base), (uint32_t)(value)))
#define ENET_CLR_RSFL(base, value) (BME_AND32(&ENET_RSFL_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RSFL(base, value) (BME_XOR32(&ENET_RSFL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RSFL bitfields
 */

/*!
 * @name Register ENET_RSFL, field RX_SECTION_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO section full threshold. Clear
 * this field to enable store and forward on the RX FIFO. When programming a value
 * greater than 0 (cut-through operation), it must be greater than
 * RAEM[RX_ALMOST_EMPTY]. When the FIFO level reaches the value in this field, data is available
 * in the Receive FIFO (cut-through operation).
 */
/*@{*/
/*! @brief Read current value of the ENET_RSFL_RX_SECTION_FULL field. */
#define ENET_RD_RSFL_RX_SECTION_FULL(base) ((ENET_RSFL_REG(base) & ENET_RSFL_RX_SECTION_FULL_MASK) >> ENET_RSFL_RX_SECTION_FULL_SHIFT)
#define ENET_BRD_RSFL_RX_SECTION_FULL(base) (BME_UBFX32(&ENET_RSFL_REG(base), ENET_RSFL_RX_SECTION_FULL_SHIFT, ENET_RSFL_RX_SECTION_FULL_WIDTH))

/*! @brief Set the RX_SECTION_FULL field to a new value. */
#define ENET_WR_RSFL_RX_SECTION_FULL(base, value) (ENET_RMW_RSFL(base, ENET_RSFL_RX_SECTION_FULL_MASK, ENET_RSFL_RX_SECTION_FULL(value)))
#define ENET_BWR_RSFL_RX_SECTION_FULL(base, value) (BME_BFI32(&ENET_RSFL_REG(base), ((uint32_t)(value) << ENET_RSFL_RX_SECTION_FULL_SHIFT), ENET_RSFL_RX_SECTION_FULL_SHIFT, ENET_RSFL_RX_SECTION_FULL_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RSEM - Receive FIFO Section Empty Threshold
 ******************************************************************************/

/*!
 * @brief ENET_RSEM - Receive FIFO Section Empty Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RSEM register
 */
/*@{*/
#define ENET_RD_RSEM(base)       (ENET_RSEM_REG(base))
#define ENET_WR_RSEM(base, value) (ENET_RSEM_REG(base) = (value))
#define ENET_RMW_RSEM(base, mask, value) (ENET_WR_RSEM(base, (ENET_RD_RSEM(base) & ~(mask)) | (value)))
#define ENET_SET_RSEM(base, value) (BME_OR32(&ENET_RSEM_REG(base), (uint32_t)(value)))
#define ENET_CLR_RSEM(base, value) (BME_AND32(&ENET_RSEM_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RSEM(base, value) (BME_XOR32(&ENET_RSEM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RSEM bitfields
 */

/*!
 * @name Register ENET_RSEM, field RX_SECTION_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO section empty threshold. When the
 * FIFO has reached this level, a pause frame will be issued. A value of 0
 * disables automatic pause frame generation. When the FIFO level goes below the value
 * programmed in this field, an XON pause frame is issued to indicate the FIFO
 * congestion is cleared to the remote Ethernet client. The section-empty
 * threshold indications from both FIFOs are OR'ed to cause XOFF pause frame generation.
 */
/*@{*/
/*! @brief Read current value of the ENET_RSEM_RX_SECTION_EMPTY field. */
#define ENET_RD_RSEM_RX_SECTION_EMPTY(base) ((ENET_RSEM_REG(base) & ENET_RSEM_RX_SECTION_EMPTY_MASK) >> ENET_RSEM_RX_SECTION_EMPTY_SHIFT)
#define ENET_BRD_RSEM_RX_SECTION_EMPTY(base) (BME_UBFX32(&ENET_RSEM_REG(base), ENET_RSEM_RX_SECTION_EMPTY_SHIFT, ENET_RSEM_RX_SECTION_EMPTY_WIDTH))

/*! @brief Set the RX_SECTION_EMPTY field to a new value. */
#define ENET_WR_RSEM_RX_SECTION_EMPTY(base, value) (ENET_RMW_RSEM(base, ENET_RSEM_RX_SECTION_EMPTY_MASK, ENET_RSEM_RX_SECTION_EMPTY(value)))
#define ENET_BWR_RSEM_RX_SECTION_EMPTY(base, value) (BME_BFI32(&ENET_RSEM_REG(base), ((uint32_t)(value) << ENET_RSEM_RX_SECTION_EMPTY_SHIFT), ENET_RSEM_RX_SECTION_EMPTY_SHIFT, ENET_RSEM_RX_SECTION_EMPTY_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RSEM, field STAT_SECTION_EMPTY[20:16] (RW)
 *
 * Defines number of frames in the receive FIFO, independent of its size, that
 * can be accepted. If the limit is reached, reception will continue normally,
 * however a pause frame will be triggered to indicate a possible congestion to the
 * remote device to avoid FIFO overflow. A value of 0 disables automatic pause
 * frame generation
 */
/*@{*/
/*! @brief Read current value of the ENET_RSEM_STAT_SECTION_EMPTY field. */
#define ENET_RD_RSEM_STAT_SECTION_EMPTY(base) ((ENET_RSEM_REG(base) & ENET_RSEM_STAT_SECTION_EMPTY_MASK) >> ENET_RSEM_STAT_SECTION_EMPTY_SHIFT)
#define ENET_BRD_RSEM_STAT_SECTION_EMPTY(base) (BME_UBFX32(&ENET_RSEM_REG(base), ENET_RSEM_STAT_SECTION_EMPTY_SHIFT, ENET_RSEM_STAT_SECTION_EMPTY_WIDTH))

/*! @brief Set the STAT_SECTION_EMPTY field to a new value. */
#define ENET_WR_RSEM_STAT_SECTION_EMPTY(base, value) (ENET_RMW_RSEM(base, ENET_RSEM_STAT_SECTION_EMPTY_MASK, ENET_RSEM_STAT_SECTION_EMPTY(value)))
#define ENET_BWR_RSEM_STAT_SECTION_EMPTY(base, value) (BME_BFI32(&ENET_RSEM_REG(base), ((uint32_t)(value) << ENET_RSEM_STAT_SECTION_EMPTY_SHIFT), ENET_RSEM_STAT_SECTION_EMPTY_SHIFT, ENET_RSEM_STAT_SECTION_EMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RAEM - Receive FIFO Almost Empty Threshold
 ******************************************************************************/

/*!
 * @brief ENET_RAEM - Receive FIFO Almost Empty Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
/*!
 * @name Constants and macros for entire ENET_RAEM register
 */
/*@{*/
#define ENET_RD_RAEM(base)       (ENET_RAEM_REG(base))
#define ENET_WR_RAEM(base, value) (ENET_RAEM_REG(base) = (value))
#define ENET_RMW_RAEM(base, mask, value) (ENET_WR_RAEM(base, (ENET_RD_RAEM(base) & ~(mask)) | (value)))
#define ENET_SET_RAEM(base, value) (BME_OR32(&ENET_RAEM_REG(base), (uint32_t)(value)))
#define ENET_CLR_RAEM(base, value) (BME_AND32(&ENET_RAEM_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RAEM(base, value) (BME_XOR32(&ENET_RAEM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RAEM bitfields
 */

/*!
 * @name Register ENET_RAEM, field RX_ALMOST_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO almost empty threshold. When the
 * FIFO level reaches the value programmed in this field and the end-of-frame has
 * not been received for the frame yet, the core receive read control stops FIFO
 * read (and subsequently stops transferring data to the MAC client
 * application). It continues to deliver the frame, if again more data than the threshold or
 * the end-of-frame is available in the FIFO. A minimum value of 4 should be set.
 */
/*@{*/
/*! @brief Read current value of the ENET_RAEM_RX_ALMOST_EMPTY field. */
#define ENET_RD_RAEM_RX_ALMOST_EMPTY(base) ((ENET_RAEM_REG(base) & ENET_RAEM_RX_ALMOST_EMPTY_MASK) >> ENET_RAEM_RX_ALMOST_EMPTY_SHIFT)
#define ENET_BRD_RAEM_RX_ALMOST_EMPTY(base) (BME_UBFX32(&ENET_RAEM_REG(base), ENET_RAEM_RX_ALMOST_EMPTY_SHIFT, ENET_RAEM_RX_ALMOST_EMPTY_WIDTH))

/*! @brief Set the RX_ALMOST_EMPTY field to a new value. */
#define ENET_WR_RAEM_RX_ALMOST_EMPTY(base, value) (ENET_RMW_RAEM(base, ENET_RAEM_RX_ALMOST_EMPTY_MASK, ENET_RAEM_RX_ALMOST_EMPTY(value)))
#define ENET_BWR_RAEM_RX_ALMOST_EMPTY(base, value) (BME_BFI32(&ENET_RAEM_REG(base), ((uint32_t)(value) << ENET_RAEM_RX_ALMOST_EMPTY_SHIFT), ENET_RAEM_RX_ALMOST_EMPTY_SHIFT, ENET_RAEM_RX_ALMOST_EMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RAFL - Receive FIFO Almost Full Threshold
 ******************************************************************************/

/*!
 * @brief ENET_RAFL - Receive FIFO Almost Full Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
/*!
 * @name Constants and macros for entire ENET_RAFL register
 */
/*@{*/
#define ENET_RD_RAFL(base)       (ENET_RAFL_REG(base))
#define ENET_WR_RAFL(base, value) (ENET_RAFL_REG(base) = (value))
#define ENET_RMW_RAFL(base, mask, value) (ENET_WR_RAFL(base, (ENET_RD_RAFL(base) & ~(mask)) | (value)))
#define ENET_SET_RAFL(base, value) (BME_OR32(&ENET_RAFL_REG(base), (uint32_t)(value)))
#define ENET_CLR_RAFL(base, value) (BME_AND32(&ENET_RAFL_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RAFL(base, value) (BME_XOR32(&ENET_RAFL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RAFL bitfields
 */

/*!
 * @name Register ENET_RAFL, field RX_ALMOST_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the receive FIFO almost full threshold. When the
 * FIFO level comes close to the maximum, so that there is no more space for at
 * least RX_ALMOST_FULL number of words, the MAC stops writing data in the FIFO and
 * truncates the received frame to avoid FIFO overflow. The corresponding error
 * status will be set when the frame is delivered to the application. A minimum
 * value of 4 should be set.
 */
/*@{*/
/*! @brief Read current value of the ENET_RAFL_RX_ALMOST_FULL field. */
#define ENET_RD_RAFL_RX_ALMOST_FULL(base) ((ENET_RAFL_REG(base) & ENET_RAFL_RX_ALMOST_FULL_MASK) >> ENET_RAFL_RX_ALMOST_FULL_SHIFT)
#define ENET_BRD_RAFL_RX_ALMOST_FULL(base) (BME_UBFX32(&ENET_RAFL_REG(base), ENET_RAFL_RX_ALMOST_FULL_SHIFT, ENET_RAFL_RX_ALMOST_FULL_WIDTH))

/*! @brief Set the RX_ALMOST_FULL field to a new value. */
#define ENET_WR_RAFL_RX_ALMOST_FULL(base, value) (ENET_RMW_RAFL(base, ENET_RAFL_RX_ALMOST_FULL_MASK, ENET_RAFL_RX_ALMOST_FULL(value)))
#define ENET_BWR_RAFL_RX_ALMOST_FULL(base, value) (BME_BFI32(&ENET_RAFL_REG(base), ((uint32_t)(value) << ENET_RAFL_RX_ALMOST_FULL_SHIFT), ENET_RAFL_RX_ALMOST_FULL_SHIFT, ENET_RAFL_RX_ALMOST_FULL_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TSEM - Transmit FIFO Section Empty Threshold
 ******************************************************************************/

/*!
 * @brief ENET_TSEM - Transmit FIFO Section Empty Threshold (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_TSEM register
 */
/*@{*/
#define ENET_RD_TSEM(base)       (ENET_TSEM_REG(base))
#define ENET_WR_TSEM(base, value) (ENET_TSEM_REG(base) = (value))
#define ENET_RMW_TSEM(base, mask, value) (ENET_WR_TSEM(base, (ENET_RD_TSEM(base) & ~(mask)) | (value)))
#define ENET_SET_TSEM(base, value) (BME_OR32(&ENET_TSEM_REG(base), (uint32_t)(value)))
#define ENET_CLR_TSEM(base, value) (BME_AND32(&ENET_TSEM_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TSEM(base, value) (BME_XOR32(&ENET_TSEM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TSEM bitfields
 */

/*!
 * @name Register ENET_TSEM, field TX_SECTION_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO section empty threshold. See
 * Transmit FIFO for more information.
 */
/*@{*/
/*! @brief Read current value of the ENET_TSEM_TX_SECTION_EMPTY field. */
#define ENET_RD_TSEM_TX_SECTION_EMPTY(base) ((ENET_TSEM_REG(base) & ENET_TSEM_TX_SECTION_EMPTY_MASK) >> ENET_TSEM_TX_SECTION_EMPTY_SHIFT)
#define ENET_BRD_TSEM_TX_SECTION_EMPTY(base) (BME_UBFX32(&ENET_TSEM_REG(base), ENET_TSEM_TX_SECTION_EMPTY_SHIFT, ENET_TSEM_TX_SECTION_EMPTY_WIDTH))

/*! @brief Set the TX_SECTION_EMPTY field to a new value. */
#define ENET_WR_TSEM_TX_SECTION_EMPTY(base, value) (ENET_RMW_TSEM(base, ENET_TSEM_TX_SECTION_EMPTY_MASK, ENET_TSEM_TX_SECTION_EMPTY(value)))
#define ENET_BWR_TSEM_TX_SECTION_EMPTY(base, value) (BME_BFI32(&ENET_TSEM_REG(base), ((uint32_t)(value) << ENET_TSEM_TX_SECTION_EMPTY_SHIFT), ENET_TSEM_TX_SECTION_EMPTY_SHIFT, ENET_TSEM_TX_SECTION_EMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TAEM - Transmit FIFO Almost Empty Threshold
 ******************************************************************************/

/*!
 * @brief ENET_TAEM - Transmit FIFO Almost Empty Threshold (RW)
 *
 * Reset value: 0x00000004U
 */
/*!
 * @name Constants and macros for entire ENET_TAEM register
 */
/*@{*/
#define ENET_RD_TAEM(base)       (ENET_TAEM_REG(base))
#define ENET_WR_TAEM(base, value) (ENET_TAEM_REG(base) = (value))
#define ENET_RMW_TAEM(base, mask, value) (ENET_WR_TAEM(base, (ENET_RD_TAEM(base) & ~(mask)) | (value)))
#define ENET_SET_TAEM(base, value) (BME_OR32(&ENET_TAEM_REG(base), (uint32_t)(value)))
#define ENET_CLR_TAEM(base, value) (BME_AND32(&ENET_TAEM_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TAEM(base, value) (BME_XOR32(&ENET_TAEM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TAEM bitfields
 */

/*!
 * @name Register ENET_TAEM, field TX_ALMOST_EMPTY[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO almost empty threshold. When the
 * FIFO level reaches the value programmed in this field, and no end-of-frame is
 * available for the frame, the MAC transmit logic, to avoid FIFO underflow,
 * stops reading the FIFO and transmits a frame with an MII error indication. See
 * Transmit FIFO for more information. A minimum value of 4 should be set.
 */
/*@{*/
/*! @brief Read current value of the ENET_TAEM_TX_ALMOST_EMPTY field. */
#define ENET_RD_TAEM_TX_ALMOST_EMPTY(base) ((ENET_TAEM_REG(base) & ENET_TAEM_TX_ALMOST_EMPTY_MASK) >> ENET_TAEM_TX_ALMOST_EMPTY_SHIFT)
#define ENET_BRD_TAEM_TX_ALMOST_EMPTY(base) (BME_UBFX32(&ENET_TAEM_REG(base), ENET_TAEM_TX_ALMOST_EMPTY_SHIFT, ENET_TAEM_TX_ALMOST_EMPTY_WIDTH))

/*! @brief Set the TX_ALMOST_EMPTY field to a new value. */
#define ENET_WR_TAEM_TX_ALMOST_EMPTY(base, value) (ENET_RMW_TAEM(base, ENET_TAEM_TX_ALMOST_EMPTY_MASK, ENET_TAEM_TX_ALMOST_EMPTY(value)))
#define ENET_BWR_TAEM_TX_ALMOST_EMPTY(base, value) (BME_BFI32(&ENET_TAEM_REG(base), ((uint32_t)(value) << ENET_TAEM_TX_ALMOST_EMPTY_SHIFT), ENET_TAEM_TX_ALMOST_EMPTY_SHIFT, ENET_TAEM_TX_ALMOST_EMPTY_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TAFL - Transmit FIFO Almost Full Threshold
 ******************************************************************************/

/*!
 * @brief ENET_TAFL - Transmit FIFO Almost Full Threshold (RW)
 *
 * Reset value: 0x00000008U
 */
/*!
 * @name Constants and macros for entire ENET_TAFL register
 */
/*@{*/
#define ENET_RD_TAFL(base)       (ENET_TAFL_REG(base))
#define ENET_WR_TAFL(base, value) (ENET_TAFL_REG(base) = (value))
#define ENET_RMW_TAFL(base, mask, value) (ENET_WR_TAFL(base, (ENET_RD_TAFL(base) & ~(mask)) | (value)))
#define ENET_SET_TAFL(base, value) (BME_OR32(&ENET_TAFL_REG(base), (uint32_t)(value)))
#define ENET_CLR_TAFL(base, value) (BME_AND32(&ENET_TAFL_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TAFL(base, value) (BME_XOR32(&ENET_TAFL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TAFL bitfields
 */

/*!
 * @name Register ENET_TAFL, field TX_ALMOST_FULL[7:0] (RW)
 *
 * Value, in 64-bit words, of the transmit FIFO almost full threshold. A minimum
 * value of six is required . A recommended value of at least 8 should be set
 * allowing a latency of two clock cycles to the application. If more latency is
 * required the value can be increased as necessary (latency = TAFL - 5). When the
 * FIFO level comes close to the maximum, so that there is no more space for at
 * least TX_ALMOST_FULL number of words, the pin ff_tx_rdy is deasserted. If the
 * application does not react on this signal, the FIFO write control logic, to
 * avoid FIFO overflow, truncates the current frame and sets the error status. As a
 * result, the frame will be transmitted with an GMII/MII error indication. See
 * Transmit FIFO for more information. A FIFO overflow is a fatal error and
 * requires a global reset on the transmit datapath or at least deassertion of ETHEREN.
 */
/*@{*/
/*! @brief Read current value of the ENET_TAFL_TX_ALMOST_FULL field. */
#define ENET_RD_TAFL_TX_ALMOST_FULL(base) ((ENET_TAFL_REG(base) & ENET_TAFL_TX_ALMOST_FULL_MASK) >> ENET_TAFL_TX_ALMOST_FULL_SHIFT)
#define ENET_BRD_TAFL_TX_ALMOST_FULL(base) (BME_UBFX32(&ENET_TAFL_REG(base), ENET_TAFL_TX_ALMOST_FULL_SHIFT, ENET_TAFL_TX_ALMOST_FULL_WIDTH))

/*! @brief Set the TX_ALMOST_FULL field to a new value. */
#define ENET_WR_TAFL_TX_ALMOST_FULL(base, value) (ENET_RMW_TAFL(base, ENET_TAFL_TX_ALMOST_FULL_MASK, ENET_TAFL_TX_ALMOST_FULL(value)))
#define ENET_BWR_TAFL_TX_ALMOST_FULL(base, value) (BME_BFI32(&ENET_TAFL_REG(base), ((uint32_t)(value) << ENET_TAFL_TX_ALMOST_FULL_SHIFT), ENET_TAFL_TX_ALMOST_FULL_SHIFT, ENET_TAFL_TX_ALMOST_FULL_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TIPG - Transmit Inter-Packet Gap
 ******************************************************************************/

/*!
 * @brief ENET_TIPG - Transmit Inter-Packet Gap (RW)
 *
 * Reset value: 0x0000000CU
 */
/*!
 * @name Constants and macros for entire ENET_TIPG register
 */
/*@{*/
#define ENET_RD_TIPG(base)       (ENET_TIPG_REG(base))
#define ENET_WR_TIPG(base, value) (ENET_TIPG_REG(base) = (value))
#define ENET_RMW_TIPG(base, mask, value) (ENET_WR_TIPG(base, (ENET_RD_TIPG(base) & ~(mask)) | (value)))
#define ENET_SET_TIPG(base, value) (BME_OR32(&ENET_TIPG_REG(base), (uint32_t)(value)))
#define ENET_CLR_TIPG(base, value) (BME_AND32(&ENET_TIPG_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TIPG(base, value) (BME_XOR32(&ENET_TIPG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TIPG bitfields
 */

/*!
 * @name Register ENET_TIPG, field IPG[4:0] (RW)
 *
 * Indicates the IPG, in bytes, between transmitted frames. Valid values range
 * from 8 to 26. If the written value is less than 8 or greater than 26, the
 * internal (effective) IPG is 12. The IPG value read will be the value that was
 * written, even if it is out of range.
 */
/*@{*/
/*! @brief Read current value of the ENET_TIPG_IPG field. */
#define ENET_RD_TIPG_IPG(base) ((ENET_TIPG_REG(base) & ENET_TIPG_IPG_MASK) >> ENET_TIPG_IPG_SHIFT)
#define ENET_BRD_TIPG_IPG(base) (BME_UBFX32(&ENET_TIPG_REG(base), ENET_TIPG_IPG_SHIFT, ENET_TIPG_IPG_WIDTH))

/*! @brief Set the IPG field to a new value. */
#define ENET_WR_TIPG_IPG(base, value) (ENET_RMW_TIPG(base, ENET_TIPG_IPG_MASK, ENET_TIPG_IPG(value)))
#define ENET_BWR_TIPG_IPG(base, value) (BME_BFI32(&ENET_TIPG_REG(base), ((uint32_t)(value) << ENET_TIPG_IPG_SHIFT), ENET_TIPG_IPG_SHIFT, ENET_TIPG_IPG_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_FTRL - Frame Truncation Length
 ******************************************************************************/

/*!
 * @brief ENET_FTRL - Frame Truncation Length (RW)
 *
 * Reset value: 0x000007FFU
 */
/*!
 * @name Constants and macros for entire ENET_FTRL register
 */
/*@{*/
#define ENET_RD_FTRL(base)       (ENET_FTRL_REG(base))
#define ENET_WR_FTRL(base, value) (ENET_FTRL_REG(base) = (value))
#define ENET_RMW_FTRL(base, mask, value) (ENET_WR_FTRL(base, (ENET_RD_FTRL(base) & ~(mask)) | (value)))
#define ENET_SET_FTRL(base, value) (BME_OR32(&ENET_FTRL_REG(base), (uint32_t)(value)))
#define ENET_CLR_FTRL(base, value) (BME_AND32(&ENET_FTRL_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_FTRL(base, value) (BME_XOR32(&ENET_FTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_FTRL bitfields
 */

/*!
 * @name Register ENET_FTRL, field TRUNC_FL[13:0] (RW)
 *
 * Indicates the value a receive frame is truncated, if it is greater than this
 * value. Must be greater than or equal to RCR[MAX_FL]. Truncation happens at
 * TRUNC_FL. However, when truncation occurs, the application (FIFO) may receive
 * less data, guaranteeing that it never receives more than the set limit.
 */
/*@{*/
/*! @brief Read current value of the ENET_FTRL_TRUNC_FL field. */
#define ENET_RD_FTRL_TRUNC_FL(base) ((ENET_FTRL_REG(base) & ENET_FTRL_TRUNC_FL_MASK) >> ENET_FTRL_TRUNC_FL_SHIFT)
#define ENET_BRD_FTRL_TRUNC_FL(base) (ENET_RD_FTRL_TRUNC_FL(base))

/*! @brief Set the TRUNC_FL field to a new value. */
#define ENET_WR_FTRL_TRUNC_FL(base, value) (ENET_RMW_FTRL(base, ENET_FTRL_TRUNC_FL_MASK, ENET_FTRL_TRUNC_FL(value)))
#define ENET_BWR_FTRL_TRUNC_FL(base, value) (ENET_WR_FTRL_TRUNC_FL(base, value))
/*@}*/

/*******************************************************************************
 * ENET_TACC - Transmit Accelerator Function Configuration
 ******************************************************************************/

/*!
 * @brief ENET_TACC - Transmit Accelerator Function Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * TACC controls accelerator actions when sending frames. The register can be
 * changed before or after each frame, but it must remain unmodified during frame
 * writes into the transmit FIFO. The TFWR[STRFWD] field must be set to use the
 * checksum feature.
 */
/*!
 * @name Constants and macros for entire ENET_TACC register
 */
/*@{*/
#define ENET_RD_TACC(base)       (ENET_TACC_REG(base))
#define ENET_WR_TACC(base, value) (ENET_TACC_REG(base) = (value))
#define ENET_RMW_TACC(base, mask, value) (ENET_WR_TACC(base, (ENET_RD_TACC(base) & ~(mask)) | (value)))
#define ENET_SET_TACC(base, value) (BME_OR32(&ENET_TACC_REG(base), (uint32_t)(value)))
#define ENET_CLR_TACC(base, value) (BME_AND32(&ENET_TACC_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TACC(base, value) (BME_XOR32(&ENET_TACC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TACC bitfields
 */

/*!
 * @name Register ENET_TACC, field SHIFT16[0] (RW)
 *
 * Values:
 * - 0b0 - Disabled.
 * - 0b1 - Indicates to the transmit data FIFO that the written frames contain
 *     two additional octets before the frame data. This means the actual frame
 *     begins at bit 16 of the first word written into the FIFO. This function
 *     allows putting the frame payload on a 32-bit boundary in memory, as the
 *     14-byte Ethernet header is extended to a 16-byte header.
 */
/*@{*/
/*! @brief Read current value of the ENET_TACC_SHIFT16 field. */
#define ENET_RD_TACC_SHIFT16(base) ((ENET_TACC_REG(base) & ENET_TACC_SHIFT16_MASK) >> ENET_TACC_SHIFT16_SHIFT)
#define ENET_BRD_TACC_SHIFT16(base) (BME_UBFX32(&ENET_TACC_REG(base), ENET_TACC_SHIFT16_SHIFT, ENET_TACC_SHIFT16_WIDTH))

/*! @brief Set the SHIFT16 field to a new value. */
#define ENET_WR_TACC_SHIFT16(base, value) (ENET_RMW_TACC(base, ENET_TACC_SHIFT16_MASK, ENET_TACC_SHIFT16(value)))
#define ENET_BWR_TACC_SHIFT16(base, value) (BME_BFI32(&ENET_TACC_REG(base), ((uint32_t)(value) << ENET_TACC_SHIFT16_SHIFT), ENET_TACC_SHIFT16_SHIFT, ENET_TACC_SHIFT16_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TACC, field IPCHK[3] (RW)
 *
 * Enables insertion of IP header checksum.
 *
 * Values:
 * - 0b0 - Checksum is not inserted.
 * - 0b1 - If an IP frame is transmitted, the checksum is inserted
 *     automatically. The IP header checksum field must be cleared. If a non-IP frame is
 *     transmitted the frame is not modified.
 */
/*@{*/
/*! @brief Read current value of the ENET_TACC_IPCHK field. */
#define ENET_RD_TACC_IPCHK(base) ((ENET_TACC_REG(base) & ENET_TACC_IPCHK_MASK) >> ENET_TACC_IPCHK_SHIFT)
#define ENET_BRD_TACC_IPCHK(base) (BME_UBFX32(&ENET_TACC_REG(base), ENET_TACC_IPCHK_SHIFT, ENET_TACC_IPCHK_WIDTH))

/*! @brief Set the IPCHK field to a new value. */
#define ENET_WR_TACC_IPCHK(base, value) (ENET_RMW_TACC(base, ENET_TACC_IPCHK_MASK, ENET_TACC_IPCHK(value)))
#define ENET_BWR_TACC_IPCHK(base, value) (BME_BFI32(&ENET_TACC_REG(base), ((uint32_t)(value) << ENET_TACC_IPCHK_SHIFT), ENET_TACC_IPCHK_SHIFT, ENET_TACC_IPCHK_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TACC, field PROCHK[4] (RW)
 *
 * Enables insertion of protocol checksum.
 *
 * Values:
 * - 0b0 - Checksum not inserted.
 * - 0b1 - If an IP frame with a known protocol is transmitted, the checksum is
 *     inserted automatically into the frame. The checksum field must be cleared.
 *     The other frames are not modified.
 */
/*@{*/
/*! @brief Read current value of the ENET_TACC_PROCHK field. */
#define ENET_RD_TACC_PROCHK(base) ((ENET_TACC_REG(base) & ENET_TACC_PROCHK_MASK) >> ENET_TACC_PROCHK_SHIFT)
#define ENET_BRD_TACC_PROCHK(base) (BME_UBFX32(&ENET_TACC_REG(base), ENET_TACC_PROCHK_SHIFT, ENET_TACC_PROCHK_WIDTH))

/*! @brief Set the PROCHK field to a new value. */
#define ENET_WR_TACC_PROCHK(base, value) (ENET_RMW_TACC(base, ENET_TACC_PROCHK_MASK, ENET_TACC_PROCHK(value)))
#define ENET_BWR_TACC_PROCHK(base, value) (BME_BFI32(&ENET_TACC_REG(base), ((uint32_t)(value) << ENET_TACC_PROCHK_SHIFT), ENET_TACC_PROCHK_SHIFT, ENET_TACC_PROCHK_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RACC - Receive Accelerator Function Configuration
 ******************************************************************************/

/*!
 * @brief ENET_RACC - Receive Accelerator Function Configuration (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RACC register
 */
/*@{*/
#define ENET_RD_RACC(base)       (ENET_RACC_REG(base))
#define ENET_WR_RACC(base, value) (ENET_RACC_REG(base) = (value))
#define ENET_RMW_RACC(base, mask, value) (ENET_WR_RACC(base, (ENET_RD_RACC(base) & ~(mask)) | (value)))
#define ENET_SET_RACC(base, value) (BME_OR32(&ENET_RACC_REG(base), (uint32_t)(value)))
#define ENET_CLR_RACC(base, value) (BME_AND32(&ENET_RACC_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_RACC(base, value) (BME_XOR32(&ENET_RACC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_RACC bitfields
 */

/*!
 * @name Register ENET_RACC, field PADREM[0] (RW)
 *
 * Values:
 * - 0b0 - Padding not removed.
 * - 0b1 - Any bytes following the IP payload section of the frame are removed
 *     from the frame.
 */
/*@{*/
/*! @brief Read current value of the ENET_RACC_PADREM field. */
#define ENET_RD_RACC_PADREM(base) ((ENET_RACC_REG(base) & ENET_RACC_PADREM_MASK) >> ENET_RACC_PADREM_SHIFT)
#define ENET_BRD_RACC_PADREM(base) (BME_UBFX32(&ENET_RACC_REG(base), ENET_RACC_PADREM_SHIFT, ENET_RACC_PADREM_WIDTH))

/*! @brief Set the PADREM field to a new value. */
#define ENET_WR_RACC_PADREM(base, value) (ENET_RMW_RACC(base, ENET_RACC_PADREM_MASK, ENET_RACC_PADREM(value)))
#define ENET_BWR_RACC_PADREM(base, value) (BME_BFI32(&ENET_RACC_REG(base), ((uint32_t)(value) << ENET_RACC_PADREM_SHIFT), ENET_RACC_PADREM_SHIFT, ENET_RACC_PADREM_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RACC, field IPDIS[1] (RW)
 *
 * Values:
 * - 0b0 - Frames with wrong IPv4 header checksum are not discarded.
 * - 0b1 - If an IPv4 frame is received with a mismatching header checksum, the
 *     frame is discarded. IPv6 has no header checksum and is not affected by
 *     this setting. Discarding is only available when the RX FIFO operates in store
 *     and forward mode (RSFL cleared).
 */
/*@{*/
/*! @brief Read current value of the ENET_RACC_IPDIS field. */
#define ENET_RD_RACC_IPDIS(base) ((ENET_RACC_REG(base) & ENET_RACC_IPDIS_MASK) >> ENET_RACC_IPDIS_SHIFT)
#define ENET_BRD_RACC_IPDIS(base) (BME_UBFX32(&ENET_RACC_REG(base), ENET_RACC_IPDIS_SHIFT, ENET_RACC_IPDIS_WIDTH))

/*! @brief Set the IPDIS field to a new value. */
#define ENET_WR_RACC_IPDIS(base, value) (ENET_RMW_RACC(base, ENET_RACC_IPDIS_MASK, ENET_RACC_IPDIS(value)))
#define ENET_BWR_RACC_IPDIS(base, value) (BME_BFI32(&ENET_RACC_REG(base), ((uint32_t)(value) << ENET_RACC_IPDIS_SHIFT), ENET_RACC_IPDIS_SHIFT, ENET_RACC_IPDIS_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RACC, field PRODIS[2] (RW)
 *
 * Values:
 * - 0b0 - Frames with wrong checksum are not discarded.
 * - 0b1 - If a TCP/IP, UDP/IP, or ICMP/IP frame is received that has a wrong
 *     TCP, UDP, or ICMP checksum, the frame is discarded. Discarding is only
 *     available when the RX FIFO operates in store and forward mode (RSFL cleared).
 */
/*@{*/
/*! @brief Read current value of the ENET_RACC_PRODIS field. */
#define ENET_RD_RACC_PRODIS(base) ((ENET_RACC_REG(base) & ENET_RACC_PRODIS_MASK) >> ENET_RACC_PRODIS_SHIFT)
#define ENET_BRD_RACC_PRODIS(base) (BME_UBFX32(&ENET_RACC_REG(base), ENET_RACC_PRODIS_SHIFT, ENET_RACC_PRODIS_WIDTH))

/*! @brief Set the PRODIS field to a new value. */
#define ENET_WR_RACC_PRODIS(base, value) (ENET_RMW_RACC(base, ENET_RACC_PRODIS_MASK, ENET_RACC_PRODIS(value)))
#define ENET_BWR_RACC_PRODIS(base, value) (BME_BFI32(&ENET_RACC_REG(base), ((uint32_t)(value) << ENET_RACC_PRODIS_SHIFT), ENET_RACC_PRODIS_SHIFT, ENET_RACC_PRODIS_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RACC, field LINEDIS[6] (RW)
 *
 * Values:
 * - 0b0 - Frames with errors are not discarded.
 * - 0b1 - Any frame received with a CRC, length, or PHY error is automatically
 *     discarded and not forwarded to the user application interface.
 */
/*@{*/
/*! @brief Read current value of the ENET_RACC_LINEDIS field. */
#define ENET_RD_RACC_LINEDIS(base) ((ENET_RACC_REG(base) & ENET_RACC_LINEDIS_MASK) >> ENET_RACC_LINEDIS_SHIFT)
#define ENET_BRD_RACC_LINEDIS(base) (BME_UBFX32(&ENET_RACC_REG(base), ENET_RACC_LINEDIS_SHIFT, ENET_RACC_LINEDIS_WIDTH))

/*! @brief Set the LINEDIS field to a new value. */
#define ENET_WR_RACC_LINEDIS(base, value) (ENET_RMW_RACC(base, ENET_RACC_LINEDIS_MASK, ENET_RACC_LINEDIS(value)))
#define ENET_BWR_RACC_LINEDIS(base, value) (BME_BFI32(&ENET_RACC_REG(base), ((uint32_t)(value) << ENET_RACC_LINEDIS_SHIFT), ENET_RACC_LINEDIS_SHIFT, ENET_RACC_LINEDIS_WIDTH))
/*@}*/

/*!
 * @name Register ENET_RACC, field SHIFT16[7] (RW)
 *
 * When this field is set, the actual frame data starts at bit 16 of the first
 * word read from the RX FIFO aligning the Ethernet payload on a 32-bit boundary.
 * This function only affects the FIFO storage and has no influence on the
 * statistics, which use the actual length of the frame received.
 *
 * Values:
 * - 0b0 - Disabled.
 * - 0b1 - Instructs the MAC to write two additional bytes in front of each
 *     frame received into the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the ENET_RACC_SHIFT16 field. */
#define ENET_RD_RACC_SHIFT16(base) ((ENET_RACC_REG(base) & ENET_RACC_SHIFT16_MASK) >> ENET_RACC_SHIFT16_SHIFT)
#define ENET_BRD_RACC_SHIFT16(base) (BME_UBFX32(&ENET_RACC_REG(base), ENET_RACC_SHIFT16_SHIFT, ENET_RACC_SHIFT16_WIDTH))

/*! @brief Set the SHIFT16 field to a new value. */
#define ENET_WR_RACC_SHIFT16(base, value) (ENET_RMW_RACC(base, ENET_RACC_SHIFT16_MASK, ENET_RACC_SHIFT16(value)))
#define ENET_BWR_RACC_SHIFT16(base, value) (BME_BFI32(&ENET_RACC_REG(base), ((uint32_t)(value) << ENET_RACC_SHIFT16_SHIFT), ENET_RACC_SHIFT16_SHIFT, ENET_RACC_SHIFT16_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_DROP - Reserved Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_DROP - Reserved Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_DROP register
 */
/*@{*/
#define ENET_RD_RMON_T_DROP(base) (ENET_RMON_T_DROP_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_PACKETS - Tx Packet Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_PACKETS register
 */
/*@{*/
#define ENET_RD_RMON_T_PACKETS(base) (ENET_RMON_T_PACKETS_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_PACKETS bitfields
 */

/*!
 * @name Register ENET_RMON_T_PACKETS, field TXPKTS[15:0] (RO)
 *
 * Transmit packet count
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_PACKETS_TXPKTS field. */
#define ENET_RD_RMON_T_PACKETS_TXPKTS(base) ((ENET_RMON_T_PACKETS_REG(base) & ENET_RMON_T_PACKETS_TXPKTS_MASK) >> ENET_RMON_T_PACKETS_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_PACKETS_TXPKTS(base) (ENET_RD_RMON_T_PACKETS_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_BC_PKT - Tx Broadcast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RMON Tx Broadcast Packets
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_BC_PKT register
 */
/*@{*/
#define ENET_RD_RMON_T_BC_PKT(base) (ENET_RMON_T_BC_PKT_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_BC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_T_BC_PKT, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_BC_PKT_TXPKTS field. */
#define ENET_RD_RMON_T_BC_PKT_TXPKTS(base) ((ENET_RMON_T_BC_PKT_REG(base) & ENET_RMON_T_BC_PKT_TXPKTS_MASK) >> ENET_RMON_T_BC_PKT_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_BC_PKT_TXPKTS(base) (ENET_RD_RMON_T_BC_PKT_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_MC_PKT - Tx Multicast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_MC_PKT register
 */
/*@{*/
#define ENET_RD_RMON_T_MC_PKT(base) (ENET_RMON_T_MC_PKT_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_MC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_T_MC_PKT, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_MC_PKT_TXPKTS field. */
#define ENET_RD_RMON_T_MC_PKT_TXPKTS(base) ((ENET_RMON_T_MC_PKT_REG(base) & ENET_RMON_T_MC_PKT_TXPKTS_MASK) >> ENET_RMON_T_MC_PKT_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_MC_PKT_TXPKTS(base) (ENET_RD_RMON_T_MC_PKT_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_CRC_ALIGN - Tx Packets with CRC/Align Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_CRC_ALIGN register
 */
/*@{*/
#define ENET_RD_RMON_T_CRC_ALIGN(base) (ENET_RMON_T_CRC_ALIGN_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_CRC_ALIGN bitfields
 */

/*!
 * @name Register ENET_RMON_T_CRC_ALIGN, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_CRC_ALIGN_TXPKTS field. */
#define ENET_RD_RMON_T_CRC_ALIGN_TXPKTS(base) ((ENET_RMON_T_CRC_ALIGN_REG(base) & ENET_RMON_T_CRC_ALIGN_TXPKTS_MASK) >> ENET_RMON_T_CRC_ALIGN_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_CRC_ALIGN_TXPKTS(base) (ENET_RD_RMON_T_CRC_ALIGN_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_UNDERSIZE - Tx Packets Less Than Bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_UNDERSIZE register
 */
/*@{*/
#define ENET_RD_RMON_T_UNDERSIZE(base) (ENET_RMON_T_UNDERSIZE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_UNDERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_T_UNDERSIZE, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_UNDERSIZE_TXPKTS field. */
#define ENET_RD_RMON_T_UNDERSIZE_TXPKTS(base) ((ENET_RMON_T_UNDERSIZE_REG(base) & ENET_RMON_T_UNDERSIZE_TXPKTS_MASK) >> ENET_RMON_T_UNDERSIZE_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_UNDERSIZE_TXPKTS(base) (ENET_RD_RMON_T_UNDERSIZE_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_OVERSIZE - Tx Packets GT MAX_FL bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_OVERSIZE register
 */
/*@{*/
#define ENET_RD_RMON_T_OVERSIZE(base) (ENET_RMON_T_OVERSIZE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_OVERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_T_OVERSIZE, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_OVERSIZE_TXPKTS field. */
#define ENET_RD_RMON_T_OVERSIZE_TXPKTS(base) ((ENET_RMON_T_OVERSIZE_REG(base) & ENET_RMON_T_OVERSIZE_TXPKTS_MASK) >> ENET_RMON_T_OVERSIZE_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_OVERSIZE_TXPKTS(base) (ENET_RD_RMON_T_OVERSIZE_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_FRAG - Tx Packets Less Than 64 Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_FRAG register
 */
/*@{*/
#define ENET_RD_RMON_T_FRAG(base) (ENET_RMON_T_FRAG_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_FRAG bitfields
 */

/*!
 * @name Register ENET_RMON_T_FRAG, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_FRAG_TXPKTS field. */
#define ENET_RD_RMON_T_FRAG_TXPKTS(base) ((ENET_RMON_T_FRAG_REG(base) & ENET_RMON_T_FRAG_TXPKTS_MASK) >> ENET_RMON_T_FRAG_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_FRAG_TXPKTS(base) (ENET_RD_RMON_T_FRAG_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_JAB - Tx Packets Greater Than MAX_FL bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_JAB register
 */
/*@{*/
#define ENET_RD_RMON_T_JAB(base) (ENET_RMON_T_JAB_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_JAB bitfields
 */

/*!
 * @name Register ENET_RMON_T_JAB, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_JAB_TXPKTS field. */
#define ENET_RD_RMON_T_JAB_TXPKTS(base) ((ENET_RMON_T_JAB_REG(base) & ENET_RMON_T_JAB_TXPKTS_MASK) >> ENET_RMON_T_JAB_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_JAB_TXPKTS(base) (ENET_RD_RMON_T_JAB_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_COL - Tx Collision Count Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_COL - Tx Collision Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_COL register
 */
/*@{*/
#define ENET_RD_RMON_T_COL(base) (ENET_RMON_T_COL_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_COL bitfields
 */

/*!
 * @name Register ENET_RMON_T_COL, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_COL_TXPKTS field. */
#define ENET_RD_RMON_T_COL_TXPKTS(base) ((ENET_RMON_T_COL_REG(base) & ENET_RMON_T_COL_TXPKTS_MASK) >> ENET_RMON_T_COL_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_COL_TXPKTS(base) (ENET_RD_RMON_T_COL_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P64 - Tx 64-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P64 register
 */
/*@{*/
#define ENET_RD_RMON_T_P64(base) (ENET_RMON_T_P64_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P64 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P64, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P64_TXPKTS field. */
#define ENET_RD_RMON_T_P64_TXPKTS(base) ((ENET_RMON_T_P64_REG(base) & ENET_RMON_T_P64_TXPKTS_MASK) >> ENET_RMON_T_P64_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P64_TXPKTS(base) (ENET_RD_RMON_T_P64_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P65TO127 - Tx 65- to 127-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P65TO127 register
 */
/*@{*/
#define ENET_RD_RMON_T_P65TO127(base) (ENET_RMON_T_P65TO127_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P65TO127 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P65TO127, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P65TO127_TXPKTS field. */
#define ENET_RD_RMON_T_P65TO127_TXPKTS(base) ((ENET_RMON_T_P65TO127_REG(base) & ENET_RMON_T_P65TO127_TXPKTS_MASK) >> ENET_RMON_T_P65TO127_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P65TO127_TXPKTS(base) (ENET_RD_RMON_T_P65TO127_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P128TO255 - Tx 128- to 255-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P128TO255 register
 */
/*@{*/
#define ENET_RD_RMON_T_P128TO255(base) (ENET_RMON_T_P128TO255_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P128TO255 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P128TO255, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P128TO255_TXPKTS field. */
#define ENET_RD_RMON_T_P128TO255_TXPKTS(base) ((ENET_RMON_T_P128TO255_REG(base) & ENET_RMON_T_P128TO255_TXPKTS_MASK) >> ENET_RMON_T_P128TO255_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P128TO255_TXPKTS(base) (ENET_RD_RMON_T_P128TO255_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P256TO511 - Tx 256- to 511-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P256TO511 register
 */
/*@{*/
#define ENET_RD_RMON_T_P256TO511(base) (ENET_RMON_T_P256TO511_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P256TO511 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P256TO511, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P256TO511_TXPKTS field. */
#define ENET_RD_RMON_T_P256TO511_TXPKTS(base) ((ENET_RMON_T_P256TO511_REG(base) & ENET_RMON_T_P256TO511_TXPKTS_MASK) >> ENET_RMON_T_P256TO511_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P256TO511_TXPKTS(base) (ENET_RD_RMON_T_P256TO511_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P512TO1023 - Tx 512- to 1023-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P512TO1023 register
 */
/*@{*/
#define ENET_RD_RMON_T_P512TO1023(base) (ENET_RMON_T_P512TO1023_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P512TO1023 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P512TO1023, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P512TO1023_TXPKTS field. */
#define ENET_RD_RMON_T_P512TO1023_TXPKTS(base) ((ENET_RMON_T_P512TO1023_REG(base) & ENET_RMON_T_P512TO1023_TXPKTS_MASK) >> ENET_RMON_T_P512TO1023_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P512TO1023_TXPKTS(base) (ENET_RD_RMON_T_P512TO1023_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P1024TO2047 - Tx 1024- to 2047-byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P1024TO2047 register
 */
/*@{*/
#define ENET_RD_RMON_T_P1024TO2047(base) (ENET_RMON_T_P1024TO2047_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P1024TO2047 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P1024TO2047, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P1024TO2047_TXPKTS field. */
#define ENET_RD_RMON_T_P1024TO2047_TXPKTS(base) ((ENET_RMON_T_P1024TO2047_REG(base) & ENET_RMON_T_P1024TO2047_TXPKTS_MASK) >> ENET_RMON_T_P1024TO2047_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P1024TO2047_TXPKTS(base) (ENET_RD_RMON_T_P1024TO2047_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_P_GTE2048 - Tx Packets Greater Than 2048 Bytes Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_P_GTE2048 register
 */
/*@{*/
#define ENET_RD_RMON_T_P_GTE2048(base) (ENET_RMON_T_P_GTE2048_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_T_P_GTE2048 bitfields
 */

/*!
 * @name Register ENET_RMON_T_P_GTE2048, field TXPKTS[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_T_P_GTE2048_TXPKTS field. */
#define ENET_RD_RMON_T_P_GTE2048_TXPKTS(base) ((ENET_RMON_T_P_GTE2048_REG(base) & ENET_RMON_T_P_GTE2048_TXPKTS_MASK) >> ENET_RMON_T_P_GTE2048_TXPKTS_SHIFT)
#define ENET_BRD_RMON_T_P_GTE2048_TXPKTS(base) (ENET_RD_RMON_T_P_GTE2048_TXPKTS(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_T_OCTETS - Tx Octets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_T_OCTETS - Tx Octets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_T_OCTETS register
 */
/*@{*/
#define ENET_RD_RMON_T_OCTETS(base) (ENET_RMON_T_OCTETS_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_DROP - Reserved Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_DROP - Reserved Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_DROP register
 */
/*@{*/
#define ENET_RD_IEEE_T_DROP(base) (ENET_IEEE_T_DROP_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_FRAME_OK - Frames Transmitted OK Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_FRAME_OK register
 */
/*@{*/
#define ENET_RD_IEEE_T_FRAME_OK(base) (ENET_IEEE_T_FRAME_OK_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_FRAME_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_T_FRAME_OK, field COUNT[15:0] (RO)
 *
 * Does not increment for the broadcast frames when broadcast reject is enabled
 * and promiscuous mode is disabled within the receive control register (RCR).
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_FRAME_OK_COUNT field. */
#define ENET_RD_IEEE_T_FRAME_OK_COUNT(base) ((ENET_IEEE_T_FRAME_OK_REG(base) & ENET_IEEE_T_FRAME_OK_COUNT_MASK) >> ENET_IEEE_T_FRAME_OK_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_FRAME_OK_COUNT(base) (ENET_RD_IEEE_T_FRAME_OK_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_1COL - Frames Transmitted with Single Collision Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_1COL register
 */
/*@{*/
#define ENET_RD_IEEE_T_1COL(base) (ENET_IEEE_T_1COL_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_1COL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_1COL, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_1COL_COUNT field. */
#define ENET_RD_IEEE_T_1COL_COUNT(base) ((ENET_IEEE_T_1COL_REG(base) & ENET_IEEE_T_1COL_COUNT_MASK) >> ENET_IEEE_T_1COL_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_1COL_COUNT(base) (ENET_RD_IEEE_T_1COL_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_MCOL - Frames Transmitted with Multiple Collisions Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_MCOL register
 */
/*@{*/
#define ENET_RD_IEEE_T_MCOL(base) (ENET_IEEE_T_MCOL_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_MCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_MCOL, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_MCOL_COUNT field. */
#define ENET_RD_IEEE_T_MCOL_COUNT(base) ((ENET_IEEE_T_MCOL_REG(base) & ENET_IEEE_T_MCOL_COUNT_MASK) >> ENET_IEEE_T_MCOL_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_MCOL_COUNT(base) (ENET_RD_IEEE_T_MCOL_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_DEF - Frames Transmitted after Deferral Delay Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_DEF register
 */
/*@{*/
#define ENET_RD_IEEE_T_DEF(base) (ENET_IEEE_T_DEF_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_DEF bitfields
 */

/*!
 * @name Register ENET_IEEE_T_DEF, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_DEF_COUNT field. */
#define ENET_RD_IEEE_T_DEF_COUNT(base) ((ENET_IEEE_T_DEF_REG(base) & ENET_IEEE_T_DEF_COUNT_MASK) >> ENET_IEEE_T_DEF_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_DEF_COUNT(base) (ENET_RD_IEEE_T_DEF_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_LCOL - Frames Transmitted with Late Collision Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_LCOL register
 */
/*@{*/
#define ENET_RD_IEEE_T_LCOL(base) (ENET_IEEE_T_LCOL_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_LCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_LCOL, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_LCOL_COUNT field. */
#define ENET_RD_IEEE_T_LCOL_COUNT(base) ((ENET_IEEE_T_LCOL_REG(base) & ENET_IEEE_T_LCOL_COUNT_MASK) >> ENET_IEEE_T_LCOL_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_LCOL_COUNT(base) (ENET_RD_IEEE_T_LCOL_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_EXCOL - Frames Transmitted with Excessive Collisions Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_EXCOL register
 */
/*@{*/
#define ENET_RD_IEEE_T_EXCOL(base) (ENET_IEEE_T_EXCOL_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_EXCOL bitfields
 */

/*!
 * @name Register ENET_IEEE_T_EXCOL, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_EXCOL_COUNT field. */
#define ENET_RD_IEEE_T_EXCOL_COUNT(base) ((ENET_IEEE_T_EXCOL_REG(base) & ENET_IEEE_T_EXCOL_COUNT_MASK) >> ENET_IEEE_T_EXCOL_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_EXCOL_COUNT(base) (ENET_RD_IEEE_T_EXCOL_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_MACERR - Frames Transmitted with Tx FIFO Underrun Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_MACERR register
 */
/*@{*/
#define ENET_RD_IEEE_T_MACERR(base) (ENET_IEEE_T_MACERR_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_MACERR bitfields
 */

/*!
 * @name Register ENET_IEEE_T_MACERR, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_MACERR_COUNT field. */
#define ENET_RD_IEEE_T_MACERR_COUNT(base) ((ENET_IEEE_T_MACERR_REG(base) & ENET_IEEE_T_MACERR_COUNT_MASK) >> ENET_IEEE_T_MACERR_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_MACERR_COUNT(base) (ENET_RD_IEEE_T_MACERR_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_CSERR - Frames Transmitted with Carrier Sense Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_CSERR register
 */
/*@{*/
#define ENET_RD_IEEE_T_CSERR(base) (ENET_IEEE_T_CSERR_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_CSERR bitfields
 */

/*!
 * @name Register ENET_IEEE_T_CSERR, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_CSERR_COUNT field. */
#define ENET_RD_IEEE_T_CSERR_COUNT(base) ((ENET_IEEE_T_CSERR_REG(base) & ENET_IEEE_T_CSERR_COUNT_MASK) >> ENET_IEEE_T_CSERR_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_CSERR_COUNT(base) (ENET_RD_IEEE_T_CSERR_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_SQE - Reserved Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_SQE - Reserved Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_SQE register
 */
/*@{*/
#define ENET_RD_IEEE_T_SQE(base) (ENET_IEEE_T_SQE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_SQE bitfields
 */

/*!
 * @name Register ENET_IEEE_T_SQE, field COUNT[15:0] (RO)
 *
 * This read-only field is reserved and always has the value 0. Counter not
 * implemented as no SQE information is available.
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_SQE_COUNT field. */
#define ENET_RD_IEEE_T_SQE_COUNT(base) ((ENET_IEEE_T_SQE_REG(base) & ENET_IEEE_T_SQE_COUNT_MASK) >> ENET_IEEE_T_SQE_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_SQE_COUNT(base) (ENET_RD_IEEE_T_SQE_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_FDXFC - Flow Control Pause Frames Transmitted Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_FDXFC register
 */
/*@{*/
#define ENET_RD_IEEE_T_FDXFC(base) (ENET_IEEE_T_FDXFC_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_T_FDXFC bitfields
 */

/*!
 * @name Register ENET_IEEE_T_FDXFC, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_T_FDXFC_COUNT field. */
#define ENET_RD_IEEE_T_FDXFC_COUNT(base) ((ENET_IEEE_T_FDXFC_REG(base) & ENET_IEEE_T_FDXFC_COUNT_MASK) >> ENET_IEEE_T_FDXFC_COUNT_SHIFT)
#define ENET_BRD_IEEE_T_FDXFC_COUNT(base) (ENET_RD_IEEE_T_FDXFC_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_T_OCTETS_OK - Octet Count for Frames Transmitted w/o Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_T_OCTETS_OK register
 */
/*@{*/
#define ENET_RD_IEEE_T_OCTETS_OK(base) (ENET_IEEE_T_OCTETS_OK_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_PACKETS - Rx Packet Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_PACKETS register
 */
/*@{*/
#define ENET_RD_RMON_R_PACKETS(base) (ENET_RMON_R_PACKETS_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_PACKETS bitfields
 */

/*!
 * @name Register ENET_RMON_R_PACKETS, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_PACKETS_COUNT field. */
#define ENET_RD_RMON_R_PACKETS_COUNT(base) ((ENET_RMON_R_PACKETS_REG(base) & ENET_RMON_R_PACKETS_COUNT_MASK) >> ENET_RMON_R_PACKETS_COUNT_SHIFT)
#define ENET_BRD_RMON_R_PACKETS_COUNT(base) (ENET_RD_RMON_R_PACKETS_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_BC_PKT - Rx Broadcast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_BC_PKT register
 */
/*@{*/
#define ENET_RD_RMON_R_BC_PKT(base) (ENET_RMON_R_BC_PKT_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_BC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_R_BC_PKT, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_BC_PKT_COUNT field. */
#define ENET_RD_RMON_R_BC_PKT_COUNT(base) ((ENET_RMON_R_BC_PKT_REG(base) & ENET_RMON_R_BC_PKT_COUNT_MASK) >> ENET_RMON_R_BC_PKT_COUNT_SHIFT)
#define ENET_BRD_RMON_R_BC_PKT_COUNT(base) (ENET_RD_RMON_R_BC_PKT_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_MC_PKT - Rx Multicast Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_MC_PKT register
 */
/*@{*/
#define ENET_RD_RMON_R_MC_PKT(base) (ENET_RMON_R_MC_PKT_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_MC_PKT bitfields
 */

/*!
 * @name Register ENET_RMON_R_MC_PKT, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_MC_PKT_COUNT field. */
#define ENET_RD_RMON_R_MC_PKT_COUNT(base) ((ENET_RMON_R_MC_PKT_REG(base) & ENET_RMON_R_MC_PKT_COUNT_MASK) >> ENET_RMON_R_MC_PKT_COUNT_SHIFT)
#define ENET_BRD_RMON_R_MC_PKT_COUNT(base) (ENET_RD_RMON_R_MC_PKT_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_CRC_ALIGN - Rx Packets with CRC/Align Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_CRC_ALIGN register
 */
/*@{*/
#define ENET_RD_RMON_R_CRC_ALIGN(base) (ENET_RMON_R_CRC_ALIGN_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_CRC_ALIGN bitfields
 */

/*!
 * @name Register ENET_RMON_R_CRC_ALIGN, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_CRC_ALIGN_COUNT field. */
#define ENET_RD_RMON_R_CRC_ALIGN_COUNT(base) ((ENET_RMON_R_CRC_ALIGN_REG(base) & ENET_RMON_R_CRC_ALIGN_COUNT_MASK) >> ENET_RMON_R_CRC_ALIGN_COUNT_SHIFT)
#define ENET_BRD_RMON_R_CRC_ALIGN_COUNT(base) (ENET_RD_RMON_R_CRC_ALIGN_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_UNDERSIZE - Rx Packets with Less Than 64 Bytes and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_UNDERSIZE register
 */
/*@{*/
#define ENET_RD_RMON_R_UNDERSIZE(base) (ENET_RMON_R_UNDERSIZE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_UNDERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_R_UNDERSIZE, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_UNDERSIZE_COUNT field. */
#define ENET_RD_RMON_R_UNDERSIZE_COUNT(base) ((ENET_RMON_R_UNDERSIZE_REG(base) & ENET_RMON_R_UNDERSIZE_COUNT_MASK) >> ENET_RMON_R_UNDERSIZE_COUNT_SHIFT)
#define ENET_BRD_RMON_R_UNDERSIZE_COUNT(base) (ENET_RD_RMON_R_UNDERSIZE_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_OVERSIZE - Rx Packets Greater Than MAX_FL and Good CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_OVERSIZE register
 */
/*@{*/
#define ENET_RD_RMON_R_OVERSIZE(base) (ENET_RMON_R_OVERSIZE_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_OVERSIZE bitfields
 */

/*!
 * @name Register ENET_RMON_R_OVERSIZE, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_OVERSIZE_COUNT field. */
#define ENET_RD_RMON_R_OVERSIZE_COUNT(base) ((ENET_RMON_R_OVERSIZE_REG(base) & ENET_RMON_R_OVERSIZE_COUNT_MASK) >> ENET_RMON_R_OVERSIZE_COUNT_SHIFT)
#define ENET_BRD_RMON_R_OVERSIZE_COUNT(base) (ENET_RD_RMON_R_OVERSIZE_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_FRAG - Rx Packets Less Than 64 Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_FRAG register
 */
/*@{*/
#define ENET_RD_RMON_R_FRAG(base) (ENET_RMON_R_FRAG_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_FRAG bitfields
 */

/*!
 * @name Register ENET_RMON_R_FRAG, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_FRAG_COUNT field. */
#define ENET_RD_RMON_R_FRAG_COUNT(base) ((ENET_RMON_R_FRAG_REG(base) & ENET_RMON_R_FRAG_COUNT_MASK) >> ENET_RMON_R_FRAG_COUNT_SHIFT)
#define ENET_BRD_RMON_R_FRAG_COUNT(base) (ENET_RD_RMON_R_FRAG_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_JAB - Rx Packets Greater Than MAX_FL Bytes and Bad CRC Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_JAB register
 */
/*@{*/
#define ENET_RD_RMON_R_JAB(base) (ENET_RMON_R_JAB_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_JAB bitfields
 */

/*!
 * @name Register ENET_RMON_R_JAB, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_JAB_COUNT field. */
#define ENET_RD_RMON_R_JAB_COUNT(base) ((ENET_RMON_R_JAB_REG(base) & ENET_RMON_R_JAB_COUNT_MASK) >> ENET_RMON_R_JAB_COUNT_SHIFT)
#define ENET_BRD_RMON_R_JAB_COUNT(base) (ENET_RD_RMON_R_JAB_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_RESVD_0 - Reserved Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_RESVD_0 - Reserved Statistic Register (ROZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_RESVD_0 register
 */
/*@{*/
#define ENET_RD_RMON_R_RESVD_0(base) (ENET_RMON_R_RESVD_0_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P64 - Rx 64-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P64 register
 */
/*@{*/
#define ENET_RD_RMON_R_P64(base) (ENET_RMON_R_P64_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P64 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P64, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P64_COUNT field. */
#define ENET_RD_RMON_R_P64_COUNT(base) ((ENET_RMON_R_P64_REG(base) & ENET_RMON_R_P64_COUNT_MASK) >> ENET_RMON_R_P64_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P64_COUNT(base) (ENET_RD_RMON_R_P64_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P65TO127 - Rx 65- to 127-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P65TO127 register
 */
/*@{*/
#define ENET_RD_RMON_R_P65TO127(base) (ENET_RMON_R_P65TO127_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P65TO127 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P65TO127, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P65TO127_COUNT field. */
#define ENET_RD_RMON_R_P65TO127_COUNT(base) ((ENET_RMON_R_P65TO127_REG(base) & ENET_RMON_R_P65TO127_COUNT_MASK) >> ENET_RMON_R_P65TO127_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P65TO127_COUNT(base) (ENET_RD_RMON_R_P65TO127_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P128TO255 - Rx 128- to 255-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P128TO255 register
 */
/*@{*/
#define ENET_RD_RMON_R_P128TO255(base) (ENET_RMON_R_P128TO255_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P128TO255 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P128TO255, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P128TO255_COUNT field. */
#define ENET_RD_RMON_R_P128TO255_COUNT(base) ((ENET_RMON_R_P128TO255_REG(base) & ENET_RMON_R_P128TO255_COUNT_MASK) >> ENET_RMON_R_P128TO255_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P128TO255_COUNT(base) (ENET_RD_RMON_R_P128TO255_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P256TO511 - Rx 256- to 511-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P256TO511 register
 */
/*@{*/
#define ENET_RD_RMON_R_P256TO511(base) (ENET_RMON_R_P256TO511_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P256TO511 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P256TO511, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P256TO511_COUNT field. */
#define ENET_RD_RMON_R_P256TO511_COUNT(base) ((ENET_RMON_R_P256TO511_REG(base) & ENET_RMON_R_P256TO511_COUNT_MASK) >> ENET_RMON_R_P256TO511_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P256TO511_COUNT(base) (ENET_RD_RMON_R_P256TO511_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P512TO1023 - Rx 512- to 1023-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P512TO1023 register
 */
/*@{*/
#define ENET_RD_RMON_R_P512TO1023(base) (ENET_RMON_R_P512TO1023_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P512TO1023 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P512TO1023, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P512TO1023_COUNT field. */
#define ENET_RD_RMON_R_P512TO1023_COUNT(base) ((ENET_RMON_R_P512TO1023_REG(base) & ENET_RMON_R_P512TO1023_COUNT_MASK) >> ENET_RMON_R_P512TO1023_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P512TO1023_COUNT(base) (ENET_RD_RMON_R_P512TO1023_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P1024TO2047 - Rx 1024- to 2047-Byte Packets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P1024TO2047 register
 */
/*@{*/
#define ENET_RD_RMON_R_P1024TO2047(base) (ENET_RMON_R_P1024TO2047_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P1024TO2047 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P1024TO2047, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P1024TO2047_COUNT field. */
#define ENET_RD_RMON_R_P1024TO2047_COUNT(base) ((ENET_RMON_R_P1024TO2047_REG(base) & ENET_RMON_R_P1024TO2047_COUNT_MASK) >> ENET_RMON_R_P1024TO2047_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P1024TO2047_COUNT(base) (ENET_RD_RMON_R_P1024TO2047_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_P_GTE2048 - Rx Packets Greater than 2048 Bytes Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_P_GTE2048 register
 */
/*@{*/
#define ENET_RD_RMON_R_P_GTE2048(base) (ENET_RMON_R_P_GTE2048_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_RMON_R_P_GTE2048 bitfields
 */

/*!
 * @name Register ENET_RMON_R_P_GTE2048, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_RMON_R_P_GTE2048_COUNT field. */
#define ENET_RD_RMON_R_P_GTE2048_COUNT(base) ((ENET_RMON_R_P_GTE2048_REG(base) & ENET_RMON_R_P_GTE2048_COUNT_MASK) >> ENET_RMON_R_P_GTE2048_COUNT_SHIFT)
#define ENET_BRD_RMON_R_P_GTE2048_COUNT(base) (ENET_RD_RMON_R_P_GTE2048_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_RMON_R_OCTETS - Rx Octets Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_RMON_R_OCTETS - Rx Octets Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_RMON_R_OCTETS register
 */
/*@{*/
#define ENET_RD_RMON_R_OCTETS(base) (ENET_RMON_R_OCTETS_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_DROP - Frames not Counted Correctly Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Counter increments if a frame with invalid or missing SFD character is
 * detected and has been dropped. None of the other counters increments if this counter
 * increments.
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_DROP register
 */
/*@{*/
#define ENET_RD_IEEE_R_DROP(base) (ENET_IEEE_R_DROP_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_DROP bitfields
 */

/*!
 * @name Register ENET_IEEE_R_DROP, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_DROP_COUNT field. */
#define ENET_RD_IEEE_R_DROP_COUNT(base) ((ENET_IEEE_R_DROP_REG(base) & ENET_IEEE_R_DROP_COUNT_MASK) >> ENET_IEEE_R_DROP_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_DROP_COUNT(base) (ENET_RD_IEEE_R_DROP_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_FRAME_OK - Frames Received OK Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_FRAME_OK register
 */
/*@{*/
#define ENET_RD_IEEE_R_FRAME_OK(base) (ENET_IEEE_R_FRAME_OK_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_FRAME_OK bitfields
 */

/*!
 * @name Register ENET_IEEE_R_FRAME_OK, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_FRAME_OK_COUNT field. */
#define ENET_RD_IEEE_R_FRAME_OK_COUNT(base) ((ENET_IEEE_R_FRAME_OK_REG(base) & ENET_IEEE_R_FRAME_OK_COUNT_MASK) >> ENET_IEEE_R_FRAME_OK_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_FRAME_OK_COUNT(base) (ENET_RD_IEEE_R_FRAME_OK_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_CRC - Frames Received with CRC Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_CRC register
 */
/*@{*/
#define ENET_RD_IEEE_R_CRC(base) (ENET_IEEE_R_CRC_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_CRC bitfields
 */

/*!
 * @name Register ENET_IEEE_R_CRC, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_CRC_COUNT field. */
#define ENET_RD_IEEE_R_CRC_COUNT(base) ((ENET_IEEE_R_CRC_REG(base) & ENET_IEEE_R_CRC_COUNT_MASK) >> ENET_IEEE_R_CRC_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_CRC_COUNT(base) (ENET_RD_IEEE_R_CRC_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_ALIGN - Frames Received with Alignment Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_ALIGN register
 */
/*@{*/
#define ENET_RD_IEEE_R_ALIGN(base) (ENET_IEEE_R_ALIGN_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_ALIGN bitfields
 */

/*!
 * @name Register ENET_IEEE_R_ALIGN, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_ALIGN_COUNT field. */
#define ENET_RD_IEEE_R_ALIGN_COUNT(base) ((ENET_IEEE_R_ALIGN_REG(base) & ENET_IEEE_R_ALIGN_COUNT_MASK) >> ENET_IEEE_R_ALIGN_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_ALIGN_COUNT(base) (ENET_RD_IEEE_R_ALIGN_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_MACERR - Receive FIFO Overflow Count Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_MACERR register
 */
/*@{*/
#define ENET_RD_IEEE_R_MACERR(base) (ENET_IEEE_R_MACERR_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_MACERR bitfields
 */

/*!
 * @name Register ENET_IEEE_R_MACERR, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_MACERR_COUNT field. */
#define ENET_RD_IEEE_R_MACERR_COUNT(base) ((ENET_IEEE_R_MACERR_REG(base) & ENET_IEEE_R_MACERR_COUNT_MASK) >> ENET_IEEE_R_MACERR_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_MACERR_COUNT(base) (ENET_RD_IEEE_R_MACERR_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_FDXFC - Flow Control Pause Frames Received Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_FDXFC register
 */
/*@{*/
#define ENET_RD_IEEE_R_FDXFC(base) (ENET_IEEE_R_FDXFC_REG(base))
/*@}*/

/*
 * Constants & macros for individual ENET_IEEE_R_FDXFC bitfields
 */

/*!
 * @name Register ENET_IEEE_R_FDXFC, field COUNT[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ENET_IEEE_R_FDXFC_COUNT field. */
#define ENET_RD_IEEE_R_FDXFC_COUNT(base) ((ENET_IEEE_R_FDXFC_REG(base) & ENET_IEEE_R_FDXFC_COUNT_MASK) >> ENET_IEEE_R_FDXFC_COUNT_SHIFT)
#define ENET_BRD_IEEE_R_FDXFC_COUNT(base) (ENET_RD_IEEE_R_FDXFC_COUNT(base))
/*@}*/

/*******************************************************************************
 * ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register
 ******************************************************************************/

/*!
 * @brief ENET_IEEE_R_OCTETS_OK - Octet Count for Frames Received without Error Statistic Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_IEEE_R_OCTETS_OK register
 */
/*@{*/
#define ENET_RD_IEEE_R_OCTETS_OK(base) (ENET_IEEE_R_OCTETS_OK_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_ATCR - Adjustable Timer Control Register
 ******************************************************************************/

/*!
 * @brief ENET_ATCR - Adjustable Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * ATCR command fields can trigger the corresponding events directly. It is not
 * necessary to preserve any of the configuration fields when a command field is
 * set in the register, that is, no read-modify-write is required.
 */
/*!
 * @name Constants and macros for entire ENET_ATCR register
 */
/*@{*/
#define ENET_RD_ATCR(base)       (ENET_ATCR_REG(base))
#define ENET_WR_ATCR(base, value) (ENET_ATCR_REG(base) = (value))
#define ENET_RMW_ATCR(base, mask, value) (ENET_WR_ATCR(base, (ENET_RD_ATCR(base) & ~(mask)) | (value)))
#define ENET_SET_ATCR(base, value) (BME_OR32(&ENET_ATCR_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATCR(base, value) (BME_AND32(&ENET_ATCR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATCR(base, value) (BME_XOR32(&ENET_ATCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATCR bitfields
 */

/*!
 * @name Register ENET_ATCR, field EN[0] (RW)
 *
 * Values:
 * - 0b0 - The timer stops at the current value.
 * - 0b1 - The timer starts incrementing.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_EN field. */
#define ENET_RD_ATCR_EN(base) ((ENET_ATCR_REG(base) & ENET_ATCR_EN_MASK) >> ENET_ATCR_EN_SHIFT)
#define ENET_BRD_ATCR_EN(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_EN_SHIFT, ENET_ATCR_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define ENET_WR_ATCR_EN(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_EN_MASK, ENET_ATCR_EN(value)))
#define ENET_BWR_ATCR_EN(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_EN_SHIFT), ENET_ATCR_EN_SHIFT, ENET_ATCR_EN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field OFFEN[2] (RW)
 *
 * Values:
 * - 0b0 - Disable.
 * - 0b1 - The timer can be reset to zero when the given offset time is reached
 *     (offset event). The field is cleared when the offset event is reached, so
 *     no further event occurs until the field is set again. The timer offset
 *     value must be set before setting this field.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_OFFEN field. */
#define ENET_RD_ATCR_OFFEN(base) ((ENET_ATCR_REG(base) & ENET_ATCR_OFFEN_MASK) >> ENET_ATCR_OFFEN_SHIFT)
#define ENET_BRD_ATCR_OFFEN(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_OFFEN_SHIFT, ENET_ATCR_OFFEN_WIDTH))

/*! @brief Set the OFFEN field to a new value. */
#define ENET_WR_ATCR_OFFEN(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_OFFEN_MASK, ENET_ATCR_OFFEN(value)))
#define ENET_BWR_ATCR_OFFEN(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_OFFEN_SHIFT), ENET_ATCR_OFFEN_SHIFT, ENET_ATCR_OFFEN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field OFFRST[3] (RW)
 *
 * Values:
 * - 0b0 - The timer is not affected and no action occurs, besides clearing
 *     OFFEN, when the offset is reached.
 * - 0b1 - If OFFEN is set, the timer resets to zero when the offset setting is
 *     reached. The offset event does not cause a timer interrupt.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_OFFRST field. */
#define ENET_RD_ATCR_OFFRST(base) ((ENET_ATCR_REG(base) & ENET_ATCR_OFFRST_MASK) >> ENET_ATCR_OFFRST_SHIFT)
#define ENET_BRD_ATCR_OFFRST(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_OFFRST_SHIFT, ENET_ATCR_OFFRST_WIDTH))

/*! @brief Set the OFFRST field to a new value. */
#define ENET_WR_ATCR_OFFRST(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_OFFRST_MASK, ENET_ATCR_OFFRST(value)))
#define ENET_BWR_ATCR_OFFRST(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_OFFRST_SHIFT), ENET_ATCR_OFFRST_SHIFT, ENET_ATCR_OFFRST_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field PEREN[4] (RW)
 *
 * Values:
 * - 0b0 - Disable.
 * - 0b1 - A period event interrupt can be generated (EIR[TS_TIMER]) and the
 *     event signal output is asserted when the timer wraps around according to the
 *     periodic setting ATPER. The timer period value must be set before setting
 *     this bit. Not all devices contain the event signal output. See the chip
 *     configuration details.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_PEREN field. */
#define ENET_RD_ATCR_PEREN(base) ((ENET_ATCR_REG(base) & ENET_ATCR_PEREN_MASK) >> ENET_ATCR_PEREN_SHIFT)
#define ENET_BRD_ATCR_PEREN(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_PEREN_SHIFT, ENET_ATCR_PEREN_WIDTH))

/*! @brief Set the PEREN field to a new value. */
#define ENET_WR_ATCR_PEREN(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_PEREN_MASK, ENET_ATCR_PEREN(value)))
#define ENET_BWR_ATCR_PEREN(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_PEREN_SHIFT), ENET_ATCR_PEREN_SHIFT, ENET_ATCR_PEREN_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field PINPER[7] (RW)
 *
 * Enables event signal output assertion on period event. Not all devices
 * contain the event signal output. See the chip configuration details.
 *
 * Values:
 * - 0b0 - Disable.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_PINPER field. */
#define ENET_RD_ATCR_PINPER(base) ((ENET_ATCR_REG(base) & ENET_ATCR_PINPER_MASK) >> ENET_ATCR_PINPER_SHIFT)
#define ENET_BRD_ATCR_PINPER(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_PINPER_SHIFT, ENET_ATCR_PINPER_WIDTH))

/*! @brief Set the PINPER field to a new value. */
#define ENET_WR_ATCR_PINPER(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_PINPER_MASK, ENET_ATCR_PINPER(value)))
#define ENET_BWR_ATCR_PINPER(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_PINPER_SHIFT), ENET_ATCR_PINPER_SHIFT, ENET_ATCR_PINPER_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field RESTART[9] (RW)
 *
 * Resets the timer to zero. This has no effect on the counter enable. If the
 * counter is enabled when this field is set, the timer is reset to zero and starts
 * counting from there. When set, all other fields are ignored during a write.
 * This field automatically clears to 0 after the command completes. The Reset
 * Timer command requires at least 6 clock cycles of either the register clock or
 * the 1588/timestamp clock, whichever is greater, to complete.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_RESTART field. */
#define ENET_RD_ATCR_RESTART(base) ((ENET_ATCR_REG(base) & ENET_ATCR_RESTART_MASK) >> ENET_ATCR_RESTART_SHIFT)
#define ENET_BRD_ATCR_RESTART(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_RESTART_SHIFT, ENET_ATCR_RESTART_WIDTH))

/*! @brief Set the RESTART field to a new value. */
#define ENET_WR_ATCR_RESTART(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_RESTART_MASK, ENET_ATCR_RESTART(value)))
#define ENET_BWR_ATCR_RESTART(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_RESTART_SHIFT), ENET_ATCR_RESTART_SHIFT, ENET_ATCR_RESTART_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field CAPTURE[11] (RW)
 *
 * When this field is set, all other fields are ignored during a write. This
 * field automatically clears to 0 after the command completes. To ensure that the
 * correct time value is read from the ATVR register, a minimum amount of time
 * must elapse from issuing this command to reading the ATVR register. This minimum
 * time is defined by the greater of either six register clock cycles or six
 * 1588/timestamp clock cycles.
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - The current time is captured and can be read from the ATVR register.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_CAPTURE field. */
#define ENET_RD_ATCR_CAPTURE(base) ((ENET_ATCR_REG(base) & ENET_ATCR_CAPTURE_MASK) >> ENET_ATCR_CAPTURE_SHIFT)
#define ENET_BRD_ATCR_CAPTURE(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_CAPTURE_SHIFT, ENET_ATCR_CAPTURE_WIDTH))

/*! @brief Set the CAPTURE field to a new value. */
#define ENET_WR_ATCR_CAPTURE(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_CAPTURE_MASK, ENET_ATCR_CAPTURE(value)))
#define ENET_BWR_ATCR_CAPTURE(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_CAPTURE_SHIFT), ENET_ATCR_CAPTURE_SHIFT, ENET_ATCR_CAPTURE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATCR, field SLAVE[13] (RW)
 *
 * Values:
 * - 0b0 - The timer is active and all configuration fields in this register are
 *     relevant.
 * - 0b1 - The internal timer is disabled and the externally provided timer
 *     value is used. All other fields, except CAPTURE, in this register have no
 *     effect. CAPTURE can still be used to capture the current timer value.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCR_SLAVE field. */
#define ENET_RD_ATCR_SLAVE(base) ((ENET_ATCR_REG(base) & ENET_ATCR_SLAVE_MASK) >> ENET_ATCR_SLAVE_SHIFT)
#define ENET_BRD_ATCR_SLAVE(base) (BME_UBFX32(&ENET_ATCR_REG(base), ENET_ATCR_SLAVE_SHIFT, ENET_ATCR_SLAVE_WIDTH))

/*! @brief Set the SLAVE field to a new value. */
#define ENET_WR_ATCR_SLAVE(base, value) (ENET_RMW_ATCR(base, ENET_ATCR_SLAVE_MASK, ENET_ATCR_SLAVE(value)))
#define ENET_BWR_ATCR_SLAVE(base, value) (BME_BFI32(&ENET_ATCR_REG(base), ((uint32_t)(value) << ENET_ATCR_SLAVE_SHIFT), ENET_ATCR_SLAVE_SHIFT, ENET_ATCR_SLAVE_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_ATVR - Timer Value Register
 ******************************************************************************/

/*!
 * @brief ENET_ATVR - Timer Value Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_ATVR register
 */
/*@{*/
#define ENET_RD_ATVR(base)       (ENET_ATVR_REG(base))
#define ENET_WR_ATVR(base, value) (ENET_ATVR_REG(base) = (value))
#define ENET_RMW_ATVR(base, mask, value) (ENET_WR_ATVR(base, (ENET_RD_ATVR(base) & ~(mask)) | (value)))
#define ENET_SET_ATVR(base, value) (BME_OR32(&ENET_ATVR_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATVR(base, value) (BME_AND32(&ENET_ATVR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATVR(base, value) (BME_XOR32(&ENET_ATVR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_ATOFF - Timer Offset Register
 ******************************************************************************/

/*!
 * @brief ENET_ATOFF - Timer Offset Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_ATOFF register
 */
/*@{*/
#define ENET_RD_ATOFF(base)      (ENET_ATOFF_REG(base))
#define ENET_WR_ATOFF(base, value) (ENET_ATOFF_REG(base) = (value))
#define ENET_RMW_ATOFF(base, mask, value) (ENET_WR_ATOFF(base, (ENET_RD_ATOFF(base) & ~(mask)) | (value)))
#define ENET_SET_ATOFF(base, value) (BME_OR32(&ENET_ATOFF_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATOFF(base, value) (BME_AND32(&ENET_ATOFF_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATOFF(base, value) (BME_XOR32(&ENET_ATOFF_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_ATPER - Timer Period Register
 ******************************************************************************/

/*!
 * @brief ENET_ATPER - Timer Period Register (RW)
 *
 * Reset value: 0x3B9ACA00U
 */
/*!
 * @name Constants and macros for entire ENET_ATPER register
 */
/*@{*/
#define ENET_RD_ATPER(base)      (ENET_ATPER_REG(base))
#define ENET_WR_ATPER(base, value) (ENET_ATPER_REG(base) = (value))
#define ENET_RMW_ATPER(base, mask, value) (ENET_WR_ATPER(base, (ENET_RD_ATPER(base) & ~(mask)) | (value)))
#define ENET_SET_ATPER(base, value) (BME_OR32(&ENET_ATPER_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATPER(base, value) (BME_AND32(&ENET_ATPER_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATPER(base, value) (BME_XOR32(&ENET_ATPER_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * ENET_ATCOR - Timer Correction Register
 ******************************************************************************/

/*!
 * @brief ENET_ATCOR - Timer Correction Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_ATCOR register
 */
/*@{*/
#define ENET_RD_ATCOR(base)      (ENET_ATCOR_REG(base))
#define ENET_WR_ATCOR(base, value) (ENET_ATCOR_REG(base) = (value))
#define ENET_RMW_ATCOR(base, mask, value) (ENET_WR_ATCOR(base, (ENET_RD_ATCOR(base) & ~(mask)) | (value)))
#define ENET_SET_ATCOR(base, value) (BME_OR32(&ENET_ATCOR_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATCOR(base, value) (BME_AND32(&ENET_ATCOR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATCOR(base, value) (BME_XOR32(&ENET_ATCOR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATCOR bitfields
 */

/*!
 * @name Register ENET_ATCOR, field COR[30:0] (RW)
 *
 * Defines after how many timer clock cycles (ts_clk) the correction counter
 * should be reset and trigger a correction increment on the timer. The amount of
 * correction is defined in ATINC[INC_CORR]. A value of 0 disables the correction
 * counter and no corrections occur. This value is given in clock cycles, not in
 * nanoseconds as all other values.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATCOR_COR field. */
#define ENET_RD_ATCOR_COR(base) ((ENET_ATCOR_REG(base) & ENET_ATCOR_COR_MASK) >> ENET_ATCOR_COR_SHIFT)
#define ENET_BRD_ATCOR_COR(base) (ENET_RD_ATCOR_COR(base))

/*! @brief Set the COR field to a new value. */
#define ENET_WR_ATCOR_COR(base, value) (ENET_RMW_ATCOR(base, ENET_ATCOR_COR_MASK, ENET_ATCOR_COR(value)))
#define ENET_BWR_ATCOR_COR(base, value) (ENET_WR_ATCOR_COR(base, value))
/*@}*/

/*******************************************************************************
 * ENET_ATINC - Time-Stamping Clock Period Register
 ******************************************************************************/

/*!
 * @brief ENET_ATINC - Time-Stamping Clock Period Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_ATINC register
 */
/*@{*/
#define ENET_RD_ATINC(base)      (ENET_ATINC_REG(base))
#define ENET_WR_ATINC(base, value) (ENET_ATINC_REG(base) = (value))
#define ENET_RMW_ATINC(base, mask, value) (ENET_WR_ATINC(base, (ENET_RD_ATINC(base) & ~(mask)) | (value)))
#define ENET_SET_ATINC(base, value) (BME_OR32(&ENET_ATINC_REG(base), (uint32_t)(value)))
#define ENET_CLR_ATINC(base, value) (BME_AND32(&ENET_ATINC_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_ATINC(base, value) (BME_XOR32(&ENET_ATINC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_ATINC bitfields
 */

/*!
 * @name Register ENET_ATINC, field INC[6:0] (RW)
 *
 * The timer increments by this amount each clock cycle. For example, set to 10
 * for 100 MHz, 8 for 125 MHz, 5 for 200 MHz. For highest precision, use a value
 * that is an integer fraction of the period set in ATPER.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATINC_INC field. */
#define ENET_RD_ATINC_INC(base) ((ENET_ATINC_REG(base) & ENET_ATINC_INC_MASK) >> ENET_ATINC_INC_SHIFT)
#define ENET_BRD_ATINC_INC(base) (BME_UBFX32(&ENET_ATINC_REG(base), ENET_ATINC_INC_SHIFT, ENET_ATINC_INC_WIDTH))

/*! @brief Set the INC field to a new value. */
#define ENET_WR_ATINC_INC(base, value) (ENET_RMW_ATINC(base, ENET_ATINC_INC_MASK, ENET_ATINC_INC(value)))
#define ENET_BWR_ATINC_INC(base, value) (BME_BFI32(&ENET_ATINC_REG(base), ((uint32_t)(value) << ENET_ATINC_INC_SHIFT), ENET_ATINC_INC_SHIFT, ENET_ATINC_INC_WIDTH))
/*@}*/

/*!
 * @name Register ENET_ATINC, field INC_CORR[14:8] (RW)
 *
 * This value is added every time the correction timer expires (every clock
 * cycle given in ATCOR). A value less than INC slows down the timer. A value greater
 * than INC speeds up the timer.
 */
/*@{*/
/*! @brief Read current value of the ENET_ATINC_INC_CORR field. */
#define ENET_RD_ATINC_INC_CORR(base) ((ENET_ATINC_REG(base) & ENET_ATINC_INC_CORR_MASK) >> ENET_ATINC_INC_CORR_SHIFT)
#define ENET_BRD_ATINC_INC_CORR(base) (BME_UBFX32(&ENET_ATINC_REG(base), ENET_ATINC_INC_CORR_SHIFT, ENET_ATINC_INC_CORR_WIDTH))

/*! @brief Set the INC_CORR field to a new value. */
#define ENET_WR_ATINC_INC_CORR(base, value) (ENET_RMW_ATINC(base, ENET_ATINC_INC_CORR_MASK, ENET_ATINC_INC_CORR(value)))
#define ENET_BWR_ATINC_INC_CORR(base, value) (BME_BFI32(&ENET_ATINC_REG(base), ((uint32_t)(value) << ENET_ATINC_INC_CORR_SHIFT), ENET_ATINC_INC_CORR_SHIFT, ENET_ATINC_INC_CORR_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_ATSTMP - Timestamp of Last Transmitted Frame
 ******************************************************************************/

/*!
 * @brief ENET_ATSTMP - Timestamp of Last Transmitted Frame (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_ATSTMP register
 */
/*@{*/
#define ENET_RD_ATSTMP(base)     (ENET_ATSTMP_REG(base))
/*@}*/

/*******************************************************************************
 * ENET_TGSR - Timer Global Status Register
 ******************************************************************************/

/*!
 * @brief ENET_TGSR - Timer Global Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_TGSR register
 */
/*@{*/
#define ENET_RD_TGSR(base)       (ENET_TGSR_REG(base))
#define ENET_WR_TGSR(base, value) (ENET_TGSR_REG(base) = (value))
#define ENET_RMW_TGSR(base, mask, value) (ENET_WR_TGSR(base, (ENET_RD_TGSR(base) & ~(mask)) | (value)))
#define ENET_SET_TGSR(base, value) (BME_OR32(&ENET_TGSR_REG(base), (uint32_t)(value)))
#define ENET_CLR_TGSR(base, value) (BME_AND32(&ENET_TGSR_REG(base), (uint32_t)(~(value))))
#define ENET_TOG_TGSR(base, value) (BME_XOR32(&ENET_TGSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TGSR bitfields
 */

/*!
 * @name Register ENET_TGSR, field TF0[0] (W1C)
 *
 * Values:
 * - 0b0 - Timer Flag for Channel 0 is clear
 * - 0b1 - Timer Flag for Channel 0 is set
 */
/*@{*/
/*! @brief Read current value of the ENET_TGSR_TF0 field. */
#define ENET_RD_TGSR_TF0(base) ((ENET_TGSR_REG(base) & ENET_TGSR_TF0_MASK) >> ENET_TGSR_TF0_SHIFT)
#define ENET_BRD_TGSR_TF0(base) (BME_UBFX32(&ENET_TGSR_REG(base), ENET_TGSR_TF0_SHIFT, ENET_TGSR_TF0_WIDTH))

/*! @brief Set the TF0 field to a new value. */
#define ENET_WR_TGSR_TF0(base, value) (ENET_RMW_TGSR(base, (ENET_TGSR_TF0_MASK | ENET_TGSR_TF1_MASK | ENET_TGSR_TF2_MASK | ENET_TGSR_TF3_MASK), ENET_TGSR_TF0(value)))
#define ENET_BWR_TGSR_TF0(base, value) (BME_BFI32(&ENET_TGSR_REG(base), ((uint32_t)(value) << ENET_TGSR_TF0_SHIFT), ENET_TGSR_TF0_SHIFT, ENET_TGSR_TF0_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF1[1] (W1C)
 *
 * Values:
 * - 0b0 - Timer Flag for Channel 1 is clear
 * - 0b1 - Timer Flag for Channel 1 is set
 */
/*@{*/
/*! @brief Read current value of the ENET_TGSR_TF1 field. */
#define ENET_RD_TGSR_TF1(base) ((ENET_TGSR_REG(base) & ENET_TGSR_TF1_MASK) >> ENET_TGSR_TF1_SHIFT)
#define ENET_BRD_TGSR_TF1(base) (BME_UBFX32(&ENET_TGSR_REG(base), ENET_TGSR_TF1_SHIFT, ENET_TGSR_TF1_WIDTH))

/*! @brief Set the TF1 field to a new value. */
#define ENET_WR_TGSR_TF1(base, value) (ENET_RMW_TGSR(base, (ENET_TGSR_TF1_MASK | ENET_TGSR_TF0_MASK | ENET_TGSR_TF2_MASK | ENET_TGSR_TF3_MASK), ENET_TGSR_TF1(value)))
#define ENET_BWR_TGSR_TF1(base, value) (BME_BFI32(&ENET_TGSR_REG(base), ((uint32_t)(value) << ENET_TGSR_TF1_SHIFT), ENET_TGSR_TF1_SHIFT, ENET_TGSR_TF1_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF2[2] (W1C)
 *
 * Values:
 * - 0b0 - Timer Flag for Channel 2 is clear
 * - 0b1 - Timer Flag for Channel 2 is set
 */
/*@{*/
/*! @brief Read current value of the ENET_TGSR_TF2 field. */
#define ENET_RD_TGSR_TF2(base) ((ENET_TGSR_REG(base) & ENET_TGSR_TF2_MASK) >> ENET_TGSR_TF2_SHIFT)
#define ENET_BRD_TGSR_TF2(base) (BME_UBFX32(&ENET_TGSR_REG(base), ENET_TGSR_TF2_SHIFT, ENET_TGSR_TF2_WIDTH))

/*! @brief Set the TF2 field to a new value. */
#define ENET_WR_TGSR_TF2(base, value) (ENET_RMW_TGSR(base, (ENET_TGSR_TF2_MASK | ENET_TGSR_TF0_MASK | ENET_TGSR_TF1_MASK | ENET_TGSR_TF3_MASK), ENET_TGSR_TF2(value)))
#define ENET_BWR_TGSR_TF2(base, value) (BME_BFI32(&ENET_TGSR_REG(base), ((uint32_t)(value) << ENET_TGSR_TF2_SHIFT), ENET_TGSR_TF2_SHIFT, ENET_TGSR_TF2_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TGSR, field TF3[3] (W1C)
 *
 * Values:
 * - 0b0 - Timer Flag for Channel 3 is clear
 * - 0b1 - Timer Flag for Channel 3 is set
 */
/*@{*/
/*! @brief Read current value of the ENET_TGSR_TF3 field. */
#define ENET_RD_TGSR_TF3(base) ((ENET_TGSR_REG(base) & ENET_TGSR_TF3_MASK) >> ENET_TGSR_TF3_SHIFT)
#define ENET_BRD_TGSR_TF3(base) (BME_UBFX32(&ENET_TGSR_REG(base), ENET_TGSR_TF3_SHIFT, ENET_TGSR_TF3_WIDTH))

/*! @brief Set the TF3 field to a new value. */
#define ENET_WR_TGSR_TF3(base, value) (ENET_RMW_TGSR(base, (ENET_TGSR_TF3_MASK | ENET_TGSR_TF0_MASK | ENET_TGSR_TF1_MASK | ENET_TGSR_TF2_MASK), ENET_TGSR_TF3(value)))
#define ENET_BWR_TGSR_TF3(base, value) (BME_BFI32(&ENET_TGSR_REG(base), ((uint32_t)(value) << ENET_TGSR_TF3_SHIFT), ENET_TGSR_TF3_SHIFT, ENET_TGSR_TF3_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TCSR - Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief ENET_TCSR - Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_TCSR register
 */
/*@{*/
#define ENET_RD_TCSR(base, index) (ENET_TCSR_REG(base, index))
#define ENET_WR_TCSR(base, index, value) (ENET_TCSR_REG(base, index) = (value))
#define ENET_RMW_TCSR(base, index, mask, value) (ENET_WR_TCSR(base, index, (ENET_RD_TCSR(base, index) & ~(mask)) | (value)))
#define ENET_SET_TCSR(base, index, value) (BME_OR32(&ENET_TCSR_REG(base, index), (uint32_t)(value)))
#define ENET_CLR_TCSR(base, index, value) (BME_AND32(&ENET_TCSR_REG(base, index), (uint32_t)(~(value))))
#define ENET_TOG_TCSR(base, index, value) (BME_XOR32(&ENET_TCSR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual ENET_TCSR bitfields
 */

/*!
 * @name Register ENET_TCSR, field TDRE[0] (RW)
 *
 * Values:
 * - 0b0 - DMA request is disabled
 * - 0b1 - DMA request is enabled
 */
/*@{*/
/*! @brief Read current value of the ENET_TCSR_TDRE field. */
#define ENET_RD_TCSR_TDRE(base, index) ((ENET_TCSR_REG(base, index) & ENET_TCSR_TDRE_MASK) >> ENET_TCSR_TDRE_SHIFT)
#define ENET_BRD_TCSR_TDRE(base, index) (BME_UBFX32(&ENET_TCSR_REG(base, index), ENET_TCSR_TDRE_SHIFT, ENET_TCSR_TDRE_WIDTH))

/*! @brief Set the TDRE field to a new value. */
#define ENET_WR_TCSR_TDRE(base, index, value) (ENET_RMW_TCSR(base, index, (ENET_TCSR_TDRE_MASK | ENET_TCSR_TF_MASK), ENET_TCSR_TDRE(value)))
#define ENET_BWR_TCSR_TDRE(base, index, value) (BME_BFI32(&ENET_TCSR_REG(base, index), ((uint32_t)(value) << ENET_TCSR_TDRE_SHIFT), ENET_TCSR_TDRE_SHIFT, ENET_TCSR_TDRE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCSR, field TMODE[5:2] (RW)
 *
 * Updating the Timer Mode field takes a few cycles to register because it is
 * synchronized to the 1588 clock. The version of Timer Mode returned on a read is
 * from the 1588 clock domain. When changing Timer Mode, always disable the
 * channel and read this register to verify the channel is disabled first.
 *
 * Values:
 * - 0b0000 - Timer Channel is disabled.
 * - 0b0001 - Timer Channel is configured for Input Capture on rising edge.
 * - 0b0010 - Timer Channel is configured for Input Capture on falling edge.
 * - 0b0011 - Timer Channel is configured for Input Capture on both edges.
 * - 0b0100 - Timer Channel is configured for Output Compare - software only.
 * - 0b0101 - Timer Channel is configured for Output Compare - toggle output on
 *     compare.
 * - 0b0110 - Timer Channel is configured for Output Compare - clear output on
 *     compare.
 * - 0b0111 - Timer Channel is configured for Output Compare - set output on
 *     compare.
 * - 0b1000 - Reserved
 * - 0b1010 - Timer Channel is configured for Output Compare - clear output on
 *     compare, set output on overflow.
 * - 0b10x1 - Timer Channel is configured for Output Compare - set output on
 *     compare, clear output on overflow.
 * - 0b110x - Reserved
 * - 0b1110 - Timer Channel is configured for Output Compare - pulse output low
 *     on compare for one 1588-clock cycle.
 * - 0b1111 - Timer Channel is configured for Output Compare - pulse output high
 *     on compare for one 1588-clock cycle.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCSR_TMODE field. */
#define ENET_RD_TCSR_TMODE(base, index) ((ENET_TCSR_REG(base, index) & ENET_TCSR_TMODE_MASK) >> ENET_TCSR_TMODE_SHIFT)
#define ENET_BRD_TCSR_TMODE(base, index) (BME_UBFX32(&ENET_TCSR_REG(base, index), ENET_TCSR_TMODE_SHIFT, ENET_TCSR_TMODE_WIDTH))

/*! @brief Set the TMODE field to a new value. */
#define ENET_WR_TCSR_TMODE(base, index, value) (ENET_RMW_TCSR(base, index, (ENET_TCSR_TMODE_MASK | ENET_TCSR_TF_MASK), ENET_TCSR_TMODE(value)))
#define ENET_BWR_TCSR_TMODE(base, index, value) (BME_BFI32(&ENET_TCSR_REG(base, index), ((uint32_t)(value) << ENET_TCSR_TMODE_SHIFT), ENET_TCSR_TMODE_SHIFT, ENET_TCSR_TMODE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCSR, field TIE[6] (RW)
 *
 * Values:
 * - 0b0 - Interrupt is disabled
 * - 0b1 - Interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the ENET_TCSR_TIE field. */
#define ENET_RD_TCSR_TIE(base, index) ((ENET_TCSR_REG(base, index) & ENET_TCSR_TIE_MASK) >> ENET_TCSR_TIE_SHIFT)
#define ENET_BRD_TCSR_TIE(base, index) (BME_UBFX32(&ENET_TCSR_REG(base, index), ENET_TCSR_TIE_SHIFT, ENET_TCSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define ENET_WR_TCSR_TIE(base, index, value) (ENET_RMW_TCSR(base, index, (ENET_TCSR_TIE_MASK | ENET_TCSR_TF_MASK), ENET_TCSR_TIE(value)))
#define ENET_BWR_TCSR_TIE(base, index, value) (BME_BFI32(&ENET_TCSR_REG(base, index), ((uint32_t)(value) << ENET_TCSR_TIE_SHIFT), ENET_TCSR_TIE_SHIFT, ENET_TCSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register ENET_TCSR, field TF[7] (W1C)
 *
 * Sets when input capture or output compare occurs. This flag is double
 * buffered between the module clock and 1588 clock domains. When this field is 1, it
 * can be cleared to 0 by writing 1 to it.
 *
 * Values:
 * - 0b0 - Input Capture or Output Compare has not occurred.
 * - 0b1 - Input Capture or Output Compare has occurred.
 */
/*@{*/
/*! @brief Read current value of the ENET_TCSR_TF field. */
#define ENET_RD_TCSR_TF(base, index) ((ENET_TCSR_REG(base, index) & ENET_TCSR_TF_MASK) >> ENET_TCSR_TF_SHIFT)
#define ENET_BRD_TCSR_TF(base, index) (BME_UBFX32(&ENET_TCSR_REG(base, index), ENET_TCSR_TF_SHIFT, ENET_TCSR_TF_WIDTH))

/*! @brief Set the TF field to a new value. */
#define ENET_WR_TCSR_TF(base, index, value) (ENET_RMW_TCSR(base, index, ENET_TCSR_TF_MASK, ENET_TCSR_TF(value)))
#define ENET_BWR_TCSR_TF(base, index, value) (BME_BFI32(&ENET_TCSR_REG(base, index), ((uint32_t)(value) << ENET_TCSR_TF_SHIFT), ENET_TCSR_TF_SHIFT, ENET_TCSR_TF_WIDTH))
/*@}*/

/*******************************************************************************
 * ENET_TCCR - Timer Compare Capture Register
 ******************************************************************************/

/*!
 * @brief ENET_TCCR - Timer Compare Capture Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire ENET_TCCR register
 */
/*@{*/
#define ENET_RD_TCCR(base, index) (ENET_TCCR_REG(base, index))
#define ENET_WR_TCCR(base, index, value) (ENET_TCCR_REG(base, index) = (value))
#define ENET_RMW_TCCR(base, index, mask, value) (ENET_WR_TCCR(base, index, (ENET_RD_TCCR(base, index) & ~(mask)) | (value)))
#define ENET_SET_TCCR(base, index, value) (BME_OR32(&ENET_TCCR_REG(base, index), (uint32_t)(value)))
#define ENET_CLR_TCCR(base, index, value) (BME_AND32(&ENET_TCCR_REG(base, index), (uint32_t)(~(value))))
#define ENET_TOG_TCCR(base, index, value) (BME_XOR32(&ENET_TCCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * MKV58F24 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 * - EWM_CLKCTRL - Clock Control Register
 * - EWM_CLKPRESCALER - Clock Prescaler Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (BME_OR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CTRL(base, value) (BME_AND8(&EWM_CTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CTRL(base, value) (BME_XOR8(&EWM_CTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. This bit when unset, keeps the EWM module
 * disabled. It cannot be re-enabled until a next reset, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_EWMEN_SHIFT), EWM_CTRL_EWMEN_SHIFT, EWM_CTRL_EWMEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting the ASSIN
 * bit inverts the assert state of EWM_in signal to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_ASSIN_SHIFT), EWM_CTRL_ASSIN_SHIFT, EWM_CTRL_ASSIN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INEN_SHIFT), EWM_CTRL_INEN_SHIFT, EWM_CTRL_INEN_WIDTH))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BME_UBFX8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BME_BFI8(&EWM_CTRL_REG(base), ((uint8_t)(value) << EWM_CTRL_INTEN_SHIFT), EWM_CTRL_INTEN_SHIFT, EWM_CTRL_INTEN_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to refresh the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (BME_OR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPL(base, value) (BME_AND8(&EWM_CMPL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPL(base, value) (BME_XOR8(&EWM_CMPL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to refresh the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (BME_OR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
#define EWM_CLR_CMPH(base, value) (BME_AND8(&EWM_CMPH_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CMPH(base, value) (BME_XOR8(&EWM_CMPH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * EWM_CLKCTRL - Clock Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKCTRL - Clock Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKCTRL register is reset to 0x00 after a CPU reset. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. User should select the required low power clock
 * before enabling the EWM.
 */
/*!
 * @name Constants and macros for entire EWM_CLKCTRL register
 */
/*@{*/
#define EWM_RD_CLKCTRL(base)     (EWM_CLKCTRL_REG(base))
#define EWM_WR_CLKCTRL(base, value) (EWM_CLKCTRL_REG(base) = (value))
#define EWM_RMW_CLKCTRL(base, mask, value) (EWM_WR_CLKCTRL(base, (EWM_RD_CLKCTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CLKCTRL(base, value) (BME_OR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKCTRL(base, value) (BME_AND8(&EWM_CLKCTRL_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKCTRL(base, value) (BME_XOR8(&EWM_CLKCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CLKCTRL bitfields
 */

/*!
 * @name Register EWM_CLKCTRL, field CLKSEL[1:0] (RW)
 *
 * EWM has 4 possible low power clock sources for running EWM counter. One of
 * the clock source can be selected by writing into this field. 00 - lpo_clk[0]
 * will be selected for running EWM counter. 01 - lpo_clk[1] will be selected for
 * running EWM counter. 10 - lpo_clk[2] will be selected for running EWM counter.
 * 11 - lpo_clk[3] will be selected for running EWM counter.
 */
/*@{*/
/*! @brief Read current value of the EWM_CLKCTRL_CLKSEL field. */
#define EWM_RD_CLKCTRL_CLKSEL(base) ((EWM_CLKCTRL_REG(base) & EWM_CLKCTRL_CLKSEL_MASK) >> EWM_CLKCTRL_CLKSEL_SHIFT)
#define EWM_BRD_CLKCTRL_CLKSEL(base) (BME_UBFX8(&EWM_CLKCTRL_REG(base), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))

/*! @brief Set the CLKSEL field to a new value. */
#define EWM_WR_CLKCTRL_CLKSEL(base, value) (EWM_RMW_CLKCTRL(base, EWM_CLKCTRL_CLKSEL_MASK, EWM_CLKCTRL_CLKSEL(value)))
#define EWM_BWR_CLKCTRL_CLKSEL(base, value) (BME_BFI8(&EWM_CLKCTRL_REG(base), ((uint8_t)(value) << EWM_CLKCTRL_CLKSEL_SHIFT), EWM_CLKCTRL_CLKSEL_SHIFT, EWM_CLKCTRL_CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * EWM_CLKPRESCALER - Clock Prescaler Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKPRESCALER - Clock Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKPRESCALER register is reset to 0x00 after a CPU reset. This register
 * can be written only once after a CPU reset. Writing this register more than
 * once generates a bus transfer error. Write the required prescaler value before
 * enabling the EWM. The implementation of this register is chip-specific. See the
 * Chip Configuration details.
 */
/*!
 * @name Constants and macros for entire EWM_CLKPRESCALER register
 */
/*@{*/
#define EWM_RD_CLKPRESCALER(base) (EWM_CLKPRESCALER_REG(base))
#define EWM_WR_CLKPRESCALER(base, value) (EWM_CLKPRESCALER_REG(base) = (value))
#define EWM_RMW_CLKPRESCALER(base, mask, value) (EWM_WR_CLKPRESCALER(base, (EWM_RD_CLKPRESCALER(base) & ~(mask)) | (value)))
#define EWM_SET_CLKPRESCALER(base, value) (BME_OR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
#define EWM_CLR_CLKPRESCALER(base, value) (BME_AND8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(~(value))))
#define EWM_TOG_CLKPRESCALER(base, value) (BME_XOR8(&EWM_CLKPRESCALER_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV58F24 FB
 *
 * FlexBus external bus interface
 *
 * Registers defined in this header file:
 * - FB_CSAR - Chip Select Address Register
 * - FB_CSMR - Chip Select Mask Register
 * - FB_CSCR - Chip Select Control Register
 * - FB_CSPMCR - Chip Select port Multiplexing Control Register
 */

#define FB_INSTANCE_COUNT (1U) /*!< Number of instances of the FB module. */
#define FB_IDX (0U) /*!< Instance number for FB. */

/*******************************************************************************
 * FB_CSAR - Chip Select Address Register
 ******************************************************************************/

/*!
 * @brief FB_CSAR - Chip Select Address Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies the associated chip-select's base address.
 */
/*!
 * @name Constants and macros for entire FB_CSAR register
 */
/*@{*/
#define FB_RD_CSAR(base, index)  (FB_CSAR_REG(base, index))
#define FB_WR_CSAR(base, index, value) (FB_CSAR_REG(base, index) = (value))
#define FB_RMW_CSAR(base, index, mask, value) (FB_WR_CSAR(base, index, (FB_RD_CSAR(base, index) & ~(mask)) | (value)))
#define FB_SET_CSAR(base, index, value) (BME_OR32(&FB_CSAR_REG(base, index), (uint32_t)(value)))
#define FB_CLR_CSAR(base, index, value) (BME_AND32(&FB_CSAR_REG(base, index), (uint32_t)(~(value))))
#define FB_TOG_CSAR(base, index, value) (BME_XOR32(&FB_CSAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FB_CSAR bitfields
 */

/*!
 * @name Register FB_CSAR, field BA[31:16] (RW)
 *
 * Defines the base address for memory dedicated to the associated chip-select.
 * BA is compared to bits 31-16 on the internal address bus to determine if the
 * associated chip-select's memory is being accessed. Because the FlexBus module
 * is one of the slaves connected to the crossbar switch, it is only accessible
 * within a certain memory range. See the chip memory map for the applicable
 * FlexBus "expansion" address range for which the chip-selects can be active. Set the
 * CSARn and CSMRn registers appropriately before accessing this region.
 */
/*@{*/
/*! @brief Read current value of the FB_CSAR_BA field. */
#define FB_RD_CSAR_BA(base, index) ((FB_CSAR_REG(base, index) & FB_CSAR_BA_MASK) >> FB_CSAR_BA_SHIFT)
#define FB_BRD_CSAR_BA(base, index) (FB_RD_CSAR_BA(base, index))

/*! @brief Set the BA field to a new value. */
#define FB_WR_CSAR_BA(base, index, value) (FB_RMW_CSAR(base, index, FB_CSAR_BA_MASK, FB_CSAR_BA(value)))
#define FB_BWR_CSAR_BA(base, index, value) (FB_WR_CSAR_BA(base, index, value))
/*@}*/

/*******************************************************************************
 * FB_CSMR - Chip Select Mask Register
 ******************************************************************************/

/*!
 * @brief FB_CSMR - Chip Select Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies the address mask and allowable access types for the associated
 * chip-select.
 */
/*!
 * @name Constants and macros for entire FB_CSMR register
 */
/*@{*/
#define FB_RD_CSMR(base, index)  (FB_CSMR_REG(base, index))
#define FB_WR_CSMR(base, index, value) (FB_CSMR_REG(base, index) = (value))
#define FB_RMW_CSMR(base, index, mask, value) (FB_WR_CSMR(base, index, (FB_RD_CSMR(base, index) & ~(mask)) | (value)))
#define FB_SET_CSMR(base, index, value) (BME_OR32(&FB_CSMR_REG(base, index), (uint32_t)(value)))
#define FB_CLR_CSMR(base, index, value) (BME_AND32(&FB_CSMR_REG(base, index), (uint32_t)(~(value))))
#define FB_TOG_CSMR(base, index, value) (BME_XOR32(&FB_CSMR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FB_CSMR bitfields
 */

/*!
 * @name Register FB_CSMR, field V[0] (RW)
 *
 * Specifies whether the corresponding CSAR, CSMR, and CSCR contents are valid.
 * Programmed chip-selects do not assert until the V bit is 1b (except for
 * FB_CS0, which acts as the global chip-select). At reset, FB_CS0 will fire for any
 * access to the FlexBus memory region. CSMR0[V] must be set as part of the chip
 * select initialization sequence to allow other chip selects to function as
 * programmed.
 *
 * Values:
 * - 0b0 - Chip-select is invalid.
 * - 0b1 - Chip-select is valid.
 */
/*@{*/
/*! @brief Read current value of the FB_CSMR_V field. */
#define FB_RD_CSMR_V(base, index) ((FB_CSMR_REG(base, index) & FB_CSMR_V_MASK) >> FB_CSMR_V_SHIFT)
#define FB_BRD_CSMR_V(base, index) (BME_UBFX32(&FB_CSMR_REG(base, index), FB_CSMR_V_SHIFT, FB_CSMR_V_WIDTH))

/*! @brief Set the V field to a new value. */
#define FB_WR_CSMR_V(base, index, value) (FB_RMW_CSMR(base, index, FB_CSMR_V_MASK, FB_CSMR_V(value)))
#define FB_BWR_CSMR_V(base, index, value) (BME_BFI32(&FB_CSMR_REG(base, index), ((uint32_t)(value) << FB_CSMR_V_SHIFT), FB_CSMR_V_SHIFT, FB_CSMR_V_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSMR, field WP[8] (RW)
 *
 * Controls write accesses to the address range in the corresponding CSAR.
 *
 * Values:
 * - 0b0 - Write accesses are allowed.
 * - 0b1 - Write accesses are not allowed. Attempting to write to the range of
 *     addresses for which the WP bit is set results in a bus error termination of
 *     the internal cycle and no external cycle.
 */
/*@{*/
/*! @brief Read current value of the FB_CSMR_WP field. */
#define FB_RD_CSMR_WP(base, index) ((FB_CSMR_REG(base, index) & FB_CSMR_WP_MASK) >> FB_CSMR_WP_SHIFT)
#define FB_BRD_CSMR_WP(base, index) (BME_UBFX32(&FB_CSMR_REG(base, index), FB_CSMR_WP_SHIFT, FB_CSMR_WP_WIDTH))

/*! @brief Set the WP field to a new value. */
#define FB_WR_CSMR_WP(base, index, value) (FB_RMW_CSMR(base, index, FB_CSMR_WP_MASK, FB_CSMR_WP(value)))
#define FB_BWR_CSMR_WP(base, index, value) (BME_BFI32(&FB_CSMR_REG(base, index), ((uint32_t)(value) << FB_CSMR_WP_SHIFT), FB_CSMR_WP_SHIFT, FB_CSMR_WP_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSMR, field BAM[31:16] (RW)
 *
 * Defines the associated chip-select's block size by masking address bits.
 *
 * Values:
 * - 0b0000000000000000 - The corresponding address bit in CSAR is used in the
 *     chip-select decode.
 * - 0b0000000000000001 - The corresponding address bit in CSAR is a don't care
 *     in the chip-select decode.
 */
/*@{*/
/*! @brief Read current value of the FB_CSMR_BAM field. */
#define FB_RD_CSMR_BAM(base, index) ((FB_CSMR_REG(base, index) & FB_CSMR_BAM_MASK) >> FB_CSMR_BAM_SHIFT)
#define FB_BRD_CSMR_BAM(base, index) (FB_RD_CSMR_BAM(base, index))

/*! @brief Set the BAM field to a new value. */
#define FB_WR_CSMR_BAM(base, index, value) (FB_RMW_CSMR(base, index, FB_CSMR_BAM_MASK, FB_CSMR_BAM(value)))
#define FB_BWR_CSMR_BAM(base, index, value) (FB_WR_CSMR_BAM(base, index, value))
/*@}*/

/*******************************************************************************
 * FB_CSCR - Chip Select Control Register
 ******************************************************************************/

/*!
 * @brief FB_CSCR - Chip Select Control Register (RW)
 *
 * Reset value: 0x003FFC00U
 *
 * Controls the auto-acknowledge, address setup and hold times, port size, burst
 * capability, and number of wait states for the associated chip select. To
 * support the global chip-select (FB_CS0), the CSCR0 reset values differ from the
 * other CSCRs. The reset value of CSCR0 is as follows: Bits 31-24 are 0b Bit 23-3
 * are chip-dependent Bits 3-0 are 0b See the chip configuration details for your
 * particular chip for information on the exact CSCR0 reset value.
 */
/*!
 * @name Constants and macros for entire FB_CSCR register
 */
/*@{*/
#define FB_RD_CSCR(base, index)  (FB_CSCR_REG(base, index))
#define FB_WR_CSCR(base, index, value) (FB_CSCR_REG(base, index) = (value))
#define FB_RMW_CSCR(base, index, mask, value) (FB_WR_CSCR(base, index, (FB_RD_CSCR(base, index) & ~(mask)) | (value)))
#define FB_SET_CSCR(base, index, value) (BME_OR32(&FB_CSCR_REG(base, index), (uint32_t)(value)))
#define FB_CLR_CSCR(base, index, value) (BME_AND32(&FB_CSCR_REG(base, index), (uint32_t)(~(value))))
#define FB_TOG_CSCR(base, index, value) (BME_XOR32(&FB_CSCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FB_CSCR bitfields
 */

/*!
 * @name Register FB_CSCR, field BSTW[3] (RW)
 *
 * Specifies whether burst writes are enabled for memory associated with each
 * chip select.
 *
 * Values:
 * - 0b0 - Disabled. Data exceeding the specified port size is broken into
 *     individual, port-sized, non-burst writes. For example, a 32-bit write to an
 *     8-bit port takes four byte writes.
 * - 0b1 - Enabled. Enables burst write of data larger than the specified port
 *     size, including 32-bit writes to 8- and 16-bit ports, 16-bit writes to
 *     8-bit ports, and line writes to 8-, 16-, and 32-bit ports.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_BSTW field. */
#define FB_RD_CSCR_BSTW(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_BSTW_MASK) >> FB_CSCR_BSTW_SHIFT)
#define FB_BRD_CSCR_BSTW(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_BSTW_SHIFT, FB_CSCR_BSTW_WIDTH))

/*! @brief Set the BSTW field to a new value. */
#define FB_WR_CSCR_BSTW(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_BSTW_MASK, FB_CSCR_BSTW(value)))
#define FB_BWR_CSCR_BSTW(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_BSTW_SHIFT), FB_CSCR_BSTW_SHIFT, FB_CSCR_BSTW_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field BSTR[4] (RW)
 *
 * Specifies whether burst reads are enabled for memory associated with each
 * chip select.
 *
 * Values:
 * - 0b0 - Disabled. Data exceeding the specified port size is broken into
 *     individual, port-sized, non-burst reads. For example, a 32-bit read from an
 *     8-bit port is broken into four 8-bit reads.
 * - 0b1 - Enabled. Enables data burst reads larger than the specified port
 *     size, including 32-bit reads from 8- and 16-bit ports, 16-bit reads from 8-bit
 *     ports, and line reads from 8-, 16-, and 32-bit ports.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_BSTR field. */
#define FB_RD_CSCR_BSTR(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_BSTR_MASK) >> FB_CSCR_BSTR_SHIFT)
#define FB_BRD_CSCR_BSTR(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_BSTR_SHIFT, FB_CSCR_BSTR_WIDTH))

/*! @brief Set the BSTR field to a new value. */
#define FB_WR_CSCR_BSTR(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_BSTR_MASK, FB_CSCR_BSTR(value)))
#define FB_BWR_CSCR_BSTR(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_BSTR_SHIFT), FB_CSCR_BSTR_SHIFT, FB_CSCR_BSTR_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field BEM[5] (RW)
 *
 * Specifies whether the corresponding FB_BE is asserted for read accesses.
 * Certain memories have byte enables that must be asserted during reads and writes.
 * Write 1b to the BEM bit in the relevant CSCR to provide the appropriate mode
 * of byte enable support for these SRAMs.
 *
 * Values:
 * - 0b0 - FB_BE is asserted for data write only.
 * - 0b1 - FB_BE is asserted for data read and write accesses.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_BEM field. */
#define FB_RD_CSCR_BEM(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_BEM_MASK) >> FB_CSCR_BEM_SHIFT)
#define FB_BRD_CSCR_BEM(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_BEM_SHIFT, FB_CSCR_BEM_WIDTH))

/*! @brief Set the BEM field to a new value. */
#define FB_WR_CSCR_BEM(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_BEM_MASK, FB_CSCR_BEM(value)))
#define FB_BWR_CSCR_BEM(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_BEM_SHIFT), FB_CSCR_BEM_SHIFT, FB_CSCR_BEM_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field PS[7:6] (RW)
 *
 * Specifies the data port width of the associated chip-select, and determines
 * where data is driven during write cycles and where data is sampled during read
 * cycles.
 *
 * Values:
 * - 0b00 - 32-bit port size. Valid data is sampled and driven on FB_D[31:0].
 * - 0b01 - 8-bit port size. Valid data is sampled and driven on FB_D[31:24]
 *     when BLS is 0b, or FB_D[7:0] when BLS is 1b.
 * - 0b1x - 16-bit port size. Valid data is sampled and driven on FB_D[31:16]
 *     when BLS is 0b, or FB_D[15:0] when BLS is 1b.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_PS field. */
#define FB_RD_CSCR_PS(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_PS_MASK) >> FB_CSCR_PS_SHIFT)
#define FB_BRD_CSCR_PS(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_PS_SHIFT, FB_CSCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define FB_WR_CSCR_PS(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_PS_MASK, FB_CSCR_PS(value)))
#define FB_BWR_CSCR_PS(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_PS_SHIFT), FB_CSCR_PS_SHIFT, FB_CSCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field AA[8] (RW)
 *
 * Asserts the internal transfer acknowledge for accesses specified by the
 * chip-select address. If AA is 1b for a corresponding FB_CSn and the external system
 * asserts an external FB_TA before the wait-state countdown asserts the
 * internal FB_TA, the cycle is terminated. Burst cycles increment the address bus
 * between each internal termination. This field must be 1b if CSPMCR disables FB_TA.
 *
 * Values:
 * - 0b0 - Disabled. No internal transfer acknowledge is asserted and the cycle
 *     is terminated externally.
 * - 0b1 - Enabled. Internal transfer acknowledge is asserted as specified by WS.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_AA field. */
#define FB_RD_CSCR_AA(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_AA_MASK) >> FB_CSCR_AA_SHIFT)
#define FB_BRD_CSCR_AA(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_AA_SHIFT, FB_CSCR_AA_WIDTH))

/*! @brief Set the AA field to a new value. */
#define FB_WR_CSCR_AA(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_AA_MASK, FB_CSCR_AA(value)))
#define FB_BWR_CSCR_AA(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_AA_SHIFT), FB_CSCR_AA_SHIFT, FB_CSCR_AA_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field BLS[9] (RW)
 *
 * Specifies if data on FB_AD appears left-aligned or right-aligned during the
 * data phase of a FlexBus access.
 *
 * Values:
 * - 0b0 - Not shifted. Data is left-aligned on FB_AD.
 * - 0b1 - Shifted. Data is right-aligned on FB_AD.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_BLS field. */
#define FB_RD_CSCR_BLS(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_BLS_MASK) >> FB_CSCR_BLS_SHIFT)
#define FB_BRD_CSCR_BLS(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_BLS_SHIFT, FB_CSCR_BLS_WIDTH))

/*! @brief Set the BLS field to a new value. */
#define FB_WR_CSCR_BLS(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_BLS_MASK, FB_CSCR_BLS(value)))
#define FB_BWR_CSCR_BLS(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_BLS_SHIFT), FB_CSCR_BLS_SHIFT, FB_CSCR_BLS_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field WS[15:10] (RW)
 *
 * Specifies the number of wait states inserted after FlexBus asserts the
 * associated chip-select and before an internal transfer acknowledge is generated (WS
 * = 00h inserts 0 wait states, ..., WS = 3Fh inserts 63 wait states).
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_WS field. */
#define FB_RD_CSCR_WS(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_WS_MASK) >> FB_CSCR_WS_SHIFT)
#define FB_BRD_CSCR_WS(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_WS_SHIFT, FB_CSCR_WS_WIDTH))

/*! @brief Set the WS field to a new value. */
#define FB_WR_CSCR_WS(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_WS_MASK, FB_CSCR_WS(value)))
#define FB_BWR_CSCR_WS(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_WS_SHIFT), FB_CSCR_WS_SHIFT, FB_CSCR_WS_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field WRAH[17:16] (RW)
 *
 * Controls the address, data, and attribute hold time after the termination of
 * a write cycle that hits in the associated chip-select's address space. The
 * hold time applies only at the end of a transfer. Therefore, during a burst
 * transfer or a transfer to a port size smaller than the transfer size, the hold time
 * is only added after the last bus cycle.
 *
 * Values:
 * - 0b00 - 1 cycle (default for all but FB_CS0 )
 * - 0b01 - 2 cycles
 * - 0b10 - 3 cycles
 * - 0b11 - 4 cycles (default for FB_CS0 )
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_WRAH field. */
#define FB_RD_CSCR_WRAH(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_WRAH_MASK) >> FB_CSCR_WRAH_SHIFT)
#define FB_BRD_CSCR_WRAH(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_WRAH_SHIFT, FB_CSCR_WRAH_WIDTH))

/*! @brief Set the WRAH field to a new value. */
#define FB_WR_CSCR_WRAH(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_WRAH_MASK, FB_CSCR_WRAH(value)))
#define FB_BWR_CSCR_WRAH(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_WRAH_SHIFT), FB_CSCR_WRAH_SHIFT, FB_CSCR_WRAH_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field RDAH[19:18] (RW)
 *
 * Controls the address and attribute hold time after the termination during a
 * read cycle that hits in the associated chip-select's address space. The hold
 * time applies only at the end of a transfer. Therefore, during a burst transfer
 * or a transfer to a port size smaller than the transfer size, the hold time is
 * only added after the last bus cycle. The number of cycles the address and
 * attributes are held after FB_CSn deassertion depends on the value of the AA bit.
 *
 * Values:
 * - 0b00 - When AA is 1b, 1 cycle. When AA is 0b, 0 cycles.
 * - 0b01 - When AA is 1b, 2 cycles. When AA is 0b, 1 cycle.
 * - 0b10 - When AA is 1b, 3 cycles. When AA is 0b, 2 cycles.
 * - 0b11 - When AA is 1b, 4 cycles. When AA is 0b, 3 cycles.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_RDAH field. */
#define FB_RD_CSCR_RDAH(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_RDAH_MASK) >> FB_CSCR_RDAH_SHIFT)
#define FB_BRD_CSCR_RDAH(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_RDAH_SHIFT, FB_CSCR_RDAH_WIDTH))

/*! @brief Set the RDAH field to a new value. */
#define FB_WR_CSCR_RDAH(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_RDAH_MASK, FB_CSCR_RDAH(value)))
#define FB_BWR_CSCR_RDAH(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_RDAH_SHIFT), FB_CSCR_RDAH_SHIFT, FB_CSCR_RDAH_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field ASET[21:20] (RW)
 *
 * Controls when the chip-select is asserted with respect to assertion of a
 * valid address and attributes.
 *
 * Values:
 * - 0b00 - Assert FB_CSn on the first rising clock edge after the address is
 *     asserted (default for all but FB_CS0 ).
 * - 0b01 - Assert FB_CSn on the second rising clock edge after the address is
 *     asserted.
 * - 0b10 - Assert FB_CSn on the third rising clock edge after the address is
 *     asserted.
 * - 0b11 - Assert FB_CSn on the fourth rising clock edge after the address is
 *     asserted (default for FB_CS0 ).
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_ASET field. */
#define FB_RD_CSCR_ASET(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_ASET_MASK) >> FB_CSCR_ASET_SHIFT)
#define FB_BRD_CSCR_ASET(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_ASET_SHIFT, FB_CSCR_ASET_WIDTH))

/*! @brief Set the ASET field to a new value. */
#define FB_WR_CSCR_ASET(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_ASET_MASK, FB_CSCR_ASET(value)))
#define FB_BWR_CSCR_ASET(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_ASET_SHIFT), FB_CSCR_ASET_SHIFT, FB_CSCR_ASET_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field EXTS[22] (RW)
 *
 * Extended Transfer Start/Extended Address Latch Enable Controls how long FB_TS
 * /FB_ALE is asserted.
 *
 * Values:
 * - 0b0 - Disabled. FB_TS /FB_ALE asserts for one bus clock cycle.
 * - 0b1 - Enabled. FB_TS /FB_ALE remains asserted until the first positive
 *     clock edge after FB_CSn asserts.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_EXTS field. */
#define FB_RD_CSCR_EXTS(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_EXTS_MASK) >> FB_CSCR_EXTS_SHIFT)
#define FB_BRD_CSCR_EXTS(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_EXTS_SHIFT, FB_CSCR_EXTS_WIDTH))

/*! @brief Set the EXTS field to a new value. */
#define FB_WR_CSCR_EXTS(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_EXTS_MASK, FB_CSCR_EXTS(value)))
#define FB_BWR_CSCR_EXTS(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_EXTS_SHIFT), FB_CSCR_EXTS_SHIFT, FB_CSCR_EXTS_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field SWSEN[23] (RW)
 *
 * Values:
 * - 0b0 - Disabled. A number of wait states (specified by WS) are inserted
 *     before an internal transfer acknowledge is generated for all transfers.
 * - 0b1 - Enabled. A number of wait states (specified by SWS) are inserted
 *     before an internal transfer acknowledge is generated for burst transfer
 *     secondary terminations.
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_SWSEN field. */
#define FB_RD_CSCR_SWSEN(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_SWSEN_MASK) >> FB_CSCR_SWSEN_SHIFT)
#define FB_BRD_CSCR_SWSEN(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_SWSEN_SHIFT, FB_CSCR_SWSEN_WIDTH))

/*! @brief Set the SWSEN field to a new value. */
#define FB_WR_CSCR_SWSEN(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_SWSEN_MASK, FB_CSCR_SWSEN(value)))
#define FB_BWR_CSCR_SWSEN(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_SWSEN_SHIFT), FB_CSCR_SWSEN_SHIFT, FB_CSCR_SWSEN_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSCR, field SWS[31:26] (RW)
 *
 * Used only when the SWSEN bit is 1b. Specifies the number of wait states
 * inserted before an internal transfer acknowledge is generated for a burst transfer
 * (except for the first termination, which is controlled by WS).
 */
/*@{*/
/*! @brief Read current value of the FB_CSCR_SWS field. */
#define FB_RD_CSCR_SWS(base, index) ((FB_CSCR_REG(base, index) & FB_CSCR_SWS_MASK) >> FB_CSCR_SWS_SHIFT)
#define FB_BRD_CSCR_SWS(base, index) (BME_UBFX32(&FB_CSCR_REG(base, index), FB_CSCR_SWS_SHIFT, FB_CSCR_SWS_WIDTH))

/*! @brief Set the SWS field to a new value. */
#define FB_WR_CSCR_SWS(base, index, value) (FB_RMW_CSCR(base, index, FB_CSCR_SWS_MASK, FB_CSCR_SWS(value)))
#define FB_BWR_CSCR_SWS(base, index, value) (BME_BFI32(&FB_CSCR_REG(base, index), ((uint32_t)(value) << FB_CSCR_SWS_SHIFT), FB_CSCR_SWS_SHIFT, FB_CSCR_SWS_WIDTH))
/*@}*/

/*******************************************************************************
 * FB_CSPMCR - Chip Select port Multiplexing Control Register
 ******************************************************************************/

/*!
 * @brief FB_CSPMCR - Chip Select port Multiplexing Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Controls the multiplexing of the FlexBus signals. A bus error occurs when you
 * do any of the following: Write to a reserved address Write to a reserved
 * field in this register, or Access this register using a size other than 32 bits.
 */
/*!
 * @name Constants and macros for entire FB_CSPMCR register
 */
/*@{*/
#define FB_RD_CSPMCR(base)       (FB_CSPMCR_REG(base))
#define FB_WR_CSPMCR(base, value) (FB_CSPMCR_REG(base) = (value))
#define FB_RMW_CSPMCR(base, mask, value) (FB_WR_CSPMCR(base, (FB_RD_CSPMCR(base) & ~(mask)) | (value)))
#define FB_SET_CSPMCR(base, value) (BME_OR32(&FB_CSPMCR_REG(base), (uint32_t)(value)))
#define FB_CLR_CSPMCR(base, value) (BME_AND32(&FB_CSPMCR_REG(base), (uint32_t)(~(value))))
#define FB_TOG_CSPMCR(base, value) (BME_XOR32(&FB_CSPMCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FB_CSPMCR bitfields
 */

/*!
 * @name Register FB_CSPMCR, field GROUP5[15:12] (RW)
 *
 * Controls the multiplexing of the FB_TA , FB_CS3 , and FB_BE_7_0 signals. When
 * GROUP5 is not 0000b, you must write 1b to the CSCR[AA] bit. Otherwise, the
 * bus hangs during a transfer.
 *
 * Values:
 * - 0b0000 - FB_TA
 * - 0b0001 - FB_CS3 . You must also write 1b to CSCR[AA].
 * - 0b0010 - FB_BE_7_0 . You must also write 1b to CSCR[AA].
 */
/*@{*/
/*! @brief Read current value of the FB_CSPMCR_GROUP5 field. */
#define FB_RD_CSPMCR_GROUP5(base) ((FB_CSPMCR_REG(base) & FB_CSPMCR_GROUP5_MASK) >> FB_CSPMCR_GROUP5_SHIFT)
#define FB_BRD_CSPMCR_GROUP5(base) (BME_UBFX32(&FB_CSPMCR_REG(base), FB_CSPMCR_GROUP5_SHIFT, FB_CSPMCR_GROUP5_WIDTH))

/*! @brief Set the GROUP5 field to a new value. */
#define FB_WR_CSPMCR_GROUP5(base, value) (FB_RMW_CSPMCR(base, FB_CSPMCR_GROUP5_MASK, FB_CSPMCR_GROUP5(value)))
#define FB_BWR_CSPMCR_GROUP5(base, value) (BME_BFI32(&FB_CSPMCR_REG(base), ((uint32_t)(value) << FB_CSPMCR_GROUP5_SHIFT), FB_CSPMCR_GROUP5_SHIFT, FB_CSPMCR_GROUP5_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP4[19:16] (RW)
 *
 * Controls the multiplexing of the FB_TBST , FB_CS2 , and FB_BE_15_8 signals.
 *
 * Values:
 * - 0b0000 - FB_TBST
 * - 0b0001 - FB_CS2
 * - 0b0010 - FB_BE_15_8
 */
/*@{*/
/*! @brief Read current value of the FB_CSPMCR_GROUP4 field. */
#define FB_RD_CSPMCR_GROUP4(base) ((FB_CSPMCR_REG(base) & FB_CSPMCR_GROUP4_MASK) >> FB_CSPMCR_GROUP4_SHIFT)
#define FB_BRD_CSPMCR_GROUP4(base) (BME_UBFX32(&FB_CSPMCR_REG(base), FB_CSPMCR_GROUP4_SHIFT, FB_CSPMCR_GROUP4_WIDTH))

/*! @brief Set the GROUP4 field to a new value. */
#define FB_WR_CSPMCR_GROUP4(base, value) (FB_RMW_CSPMCR(base, FB_CSPMCR_GROUP4_MASK, FB_CSPMCR_GROUP4(value)))
#define FB_BWR_CSPMCR_GROUP4(base, value) (BME_BFI32(&FB_CSPMCR_REG(base), ((uint32_t)(value) << FB_CSPMCR_GROUP4_SHIFT), FB_CSPMCR_GROUP4_SHIFT, FB_CSPMCR_GROUP4_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP3[23:20] (RW)
 *
 * Controls the multiplexing of the FB_CS5 , FB_TSIZ1, and FB_BE_23_16 signals.
 *
 * Values:
 * - 0b0000 - FB_CS5
 * - 0b0001 - FB_TSIZ1
 * - 0b0010 - FB_BE_23_16
 */
/*@{*/
/*! @brief Read current value of the FB_CSPMCR_GROUP3 field. */
#define FB_RD_CSPMCR_GROUP3(base) ((FB_CSPMCR_REG(base) & FB_CSPMCR_GROUP3_MASK) >> FB_CSPMCR_GROUP3_SHIFT)
#define FB_BRD_CSPMCR_GROUP3(base) (BME_UBFX32(&FB_CSPMCR_REG(base), FB_CSPMCR_GROUP3_SHIFT, FB_CSPMCR_GROUP3_WIDTH))

/*! @brief Set the GROUP3 field to a new value. */
#define FB_WR_CSPMCR_GROUP3(base, value) (FB_RMW_CSPMCR(base, FB_CSPMCR_GROUP3_MASK, FB_CSPMCR_GROUP3(value)))
#define FB_BWR_CSPMCR_GROUP3(base, value) (BME_BFI32(&FB_CSPMCR_REG(base), ((uint32_t)(value) << FB_CSPMCR_GROUP3_SHIFT), FB_CSPMCR_GROUP3_SHIFT, FB_CSPMCR_GROUP3_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP2[27:24] (RW)
 *
 * Controls the multiplexing of the FB_CS4, FB_TSIZ0, and FB_BE_31_24 signals.
 *
 * Values:
 * - 0b0000 - FB_CS4
 * - 0b0001 - FB_TSIZ0
 * - 0b0010 - FB_BE_31_24
 */
/*@{*/
/*! @brief Read current value of the FB_CSPMCR_GROUP2 field. */
#define FB_RD_CSPMCR_GROUP2(base) ((FB_CSPMCR_REG(base) & FB_CSPMCR_GROUP2_MASK) >> FB_CSPMCR_GROUP2_SHIFT)
#define FB_BRD_CSPMCR_GROUP2(base) (BME_UBFX32(&FB_CSPMCR_REG(base), FB_CSPMCR_GROUP2_SHIFT, FB_CSPMCR_GROUP2_WIDTH))

/*! @brief Set the GROUP2 field to a new value. */
#define FB_WR_CSPMCR_GROUP2(base, value) (FB_RMW_CSPMCR(base, FB_CSPMCR_GROUP2_MASK, FB_CSPMCR_GROUP2(value)))
#define FB_BWR_CSPMCR_GROUP2(base, value) (BME_BFI32(&FB_CSPMCR_REG(base), ((uint32_t)(value) << FB_CSPMCR_GROUP2_SHIFT), FB_CSPMCR_GROUP2_SHIFT, FB_CSPMCR_GROUP2_WIDTH))
/*@}*/

/*!
 * @name Register FB_CSPMCR, field GROUP1[31:28] (RW)
 *
 * Controls the multiplexing of the FB_ALE, FB_CS1 , and FB_TS signals.
 *
 * Values:
 * - 0b0000 - FB_ALE
 * - 0b0001 - FB_CS1
 * - 0b0010 - FB_TS
 */
/*@{*/
/*! @brief Read current value of the FB_CSPMCR_GROUP1 field. */
#define FB_RD_CSPMCR_GROUP1(base) ((FB_CSPMCR_REG(base) & FB_CSPMCR_GROUP1_MASK) >> FB_CSPMCR_GROUP1_SHIFT)
#define FB_BRD_CSPMCR_GROUP1(base) (BME_UBFX32(&FB_CSPMCR_REG(base), FB_CSPMCR_GROUP1_SHIFT, FB_CSPMCR_GROUP1_WIDTH))

/*! @brief Set the GROUP1 field to a new value. */
#define FB_WR_CSPMCR_GROUP1(base, value) (FB_RMW_CSPMCR(base, FB_CSPMCR_GROUP1_MASK, FB_CSPMCR_GROUP1(value)))
#define FB_BWR_CSPMCR_GROUP1(base, value) (BME_BFI32(&FB_CSPMCR_REG(base), ((uint32_t)(value) << FB_CSPMCR_GROUP1_SHIFT), FB_CSPMCR_GROUP1_SHIFT, FB_CSPMCR_GROUP1_WIDTH))
/*@}*/

/*
 * MKV58F24 FMC
 *
 * Flash Memory Controller
 *
 * Registers defined in this header file:
 * - FMC_PFAPR - Flash Access Protection Register
 * - FMC_PFB0CR - Flash Bank 0 Control Register
 */

#define FMC_INSTANCE_COUNT (1U) /*!< Number of instances of the FMC module. */
#define FMC_IDX (0U) /*!< Instance number for FMC. */

/*******************************************************************************
 * FMC_PFAPR - Flash Access Protection Register
 ******************************************************************************/

/*!
 * @brief FMC_PFAPR - Flash Access Protection Register (RW)
 *
 * Reset value: 0x00F8003FU
 */
/*!
 * @name Constants and macros for entire FMC_PFAPR register
 */
/*@{*/
#define FMC_RD_PFAPR(base)       (FMC_PFAPR_REG(base))
#define FMC_WR_PFAPR(base, value) (FMC_PFAPR_REG(base) = (value))
#define FMC_RMW_PFAPR(base, mask, value) (FMC_WR_PFAPR(base, (FMC_RD_PFAPR(base) & ~(mask)) | (value)))
#define FMC_SET_PFAPR(base, value) (BME_OR32(&FMC_PFAPR_REG(base), (uint32_t)(value)))
#define FMC_CLR_PFAPR(base, value) (BME_AND32(&FMC_PFAPR_REG(base), (uint32_t)(~(value))))
#define FMC_TOG_PFAPR(base, value) (BME_XOR32(&FMC_PFAPR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFAPR bitfields
 */

/*!
 * @name Register FMC_PFAPR, field M0AP[1:0] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 0b00 - No access may be performed by this master
 * - 0b01 - Only read accesses may be performed by this master
 * - 0b10 - Only write accesses may be performed by this master
 * - 0b11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0AP field. */
#define FMC_RD_PFAPR_M0AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0AP_MASK) >> FMC_PFAPR_M0AP_SHIFT)
#define FMC_BRD_PFAPR_M0AP(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0AP_SHIFT, FMC_PFAPR_M0AP_WIDTH))

/*! @brief Set the M0AP field to a new value. */
#define FMC_WR_PFAPR_M0AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0AP_MASK, FMC_PFAPR_M0AP(value)))
#define FMC_BWR_PFAPR_M0AP(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M0AP_SHIFT), FMC_PFAPR_M0AP_SHIFT, FMC_PFAPR_M0AP_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1AP[3:2] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 0b00 - No access may be performed by this master
 * - 0b01 - Only read accesses may be performed by this master
 * - 0b10 - Only write accesses may be performed by this master
 * - 0b11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1AP field. */
#define FMC_RD_PFAPR_M1AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1AP_MASK) >> FMC_PFAPR_M1AP_SHIFT)
#define FMC_BRD_PFAPR_M1AP(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1AP_SHIFT, FMC_PFAPR_M1AP_WIDTH))

/*! @brief Set the M1AP field to a new value. */
#define FMC_WR_PFAPR_M1AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1AP_MASK, FMC_PFAPR_M1AP(value)))
#define FMC_BWR_PFAPR_M1AP(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M1AP_SHIFT), FMC_PFAPR_M1AP_SHIFT, FMC_PFAPR_M1AP_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2AP[5:4] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 0b00 - No access may be performed by this master
 * - 0b01 - Only read accesses may be performed by this master
 * - 0b10 - Only write accesses may be performed by this master
 * - 0b11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2AP field. */
#define FMC_RD_PFAPR_M2AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2AP_MASK) >> FMC_PFAPR_M2AP_SHIFT)
#define FMC_BRD_PFAPR_M2AP(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2AP_SHIFT, FMC_PFAPR_M2AP_WIDTH))

/*! @brief Set the M2AP field to a new value. */
#define FMC_WR_PFAPR_M2AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2AP_MASK, FMC_PFAPR_M2AP(value)))
#define FMC_BWR_PFAPR_M2AP(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M2AP_SHIFT), FMC_PFAPR_M2AP_SHIFT, FMC_PFAPR_M2AP_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3AP[7:6] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 0b00 - No access may be performed by this master
 * - 0b01 - Only read accesses may be performed by this master
 * - 0b10 - Only write accesses may be performed by this master
 * - 0b11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3AP field. */
#define FMC_RD_PFAPR_M3AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3AP_MASK) >> FMC_PFAPR_M3AP_SHIFT)
#define FMC_BRD_PFAPR_M3AP(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3AP_SHIFT, FMC_PFAPR_M3AP_WIDTH))

/*! @brief Set the M3AP field to a new value. */
#define FMC_WR_PFAPR_M3AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3AP_MASK, FMC_PFAPR_M3AP(value)))
#define FMC_BWR_PFAPR_M3AP(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M3AP_SHIFT), FMC_PFAPR_M3AP_SHIFT, FMC_PFAPR_M3AP_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M0PFD[16] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0b0 - Prefetching for this master is enabled.
 * - 0b1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0PFD field. */
#define FMC_RD_PFAPR_M0PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0PFD_MASK) >> FMC_PFAPR_M0PFD_SHIFT)
#define FMC_BRD_PFAPR_M0PFD(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0PFD_SHIFT, FMC_PFAPR_M0PFD_WIDTH))

/*! @brief Set the M0PFD field to a new value. */
#define FMC_WR_PFAPR_M0PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0PFD_MASK, FMC_PFAPR_M0PFD(value)))
#define FMC_BWR_PFAPR_M0PFD(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M0PFD_SHIFT), FMC_PFAPR_M0PFD_SHIFT, FMC_PFAPR_M0PFD_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1PFD[17] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0b0 - Prefetching for this master is enabled.
 * - 0b1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1PFD field. */
#define FMC_RD_PFAPR_M1PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1PFD_MASK) >> FMC_PFAPR_M1PFD_SHIFT)
#define FMC_BRD_PFAPR_M1PFD(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1PFD_SHIFT, FMC_PFAPR_M1PFD_WIDTH))

/*! @brief Set the M1PFD field to a new value. */
#define FMC_WR_PFAPR_M1PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1PFD_MASK, FMC_PFAPR_M1PFD(value)))
#define FMC_BWR_PFAPR_M1PFD(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M1PFD_SHIFT), FMC_PFAPR_M1PFD_SHIFT, FMC_PFAPR_M1PFD_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2PFD[18] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0b0 - Prefetching for this master is enabled.
 * - 0b1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2PFD field. */
#define FMC_RD_PFAPR_M2PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2PFD_MASK) >> FMC_PFAPR_M2PFD_SHIFT)
#define FMC_BRD_PFAPR_M2PFD(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2PFD_SHIFT, FMC_PFAPR_M2PFD_WIDTH))

/*! @brief Set the M2PFD field to a new value. */
#define FMC_WR_PFAPR_M2PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2PFD_MASK, FMC_PFAPR_M2PFD(value)))
#define FMC_BWR_PFAPR_M2PFD(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M2PFD_SHIFT), FMC_PFAPR_M2PFD_SHIFT, FMC_PFAPR_M2PFD_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3PFD[19] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0b0 - Prefetching for this master is enabled.
 * - 0b1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3PFD field. */
#define FMC_RD_PFAPR_M3PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3PFD_MASK) >> FMC_PFAPR_M3PFD_SHIFT)
#define FMC_BRD_PFAPR_M3PFD(base) (BME_UBFX32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3PFD_SHIFT, FMC_PFAPR_M3PFD_WIDTH))

/*! @brief Set the M3PFD field to a new value. */
#define FMC_WR_PFAPR_M3PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3PFD_MASK, FMC_PFAPR_M3PFD(value)))
#define FMC_BWR_PFAPR_M3PFD(base, value) (BME_BFI32(&FMC_PFAPR_REG(base), ((uint32_t)(value) << FMC_PFAPR_M3PFD_SHIFT), FMC_PFAPR_M3PFD_SHIFT, FMC_PFAPR_M3PFD_WIDTH))
/*@}*/

/*******************************************************************************
 * FMC_PFB0CR - Flash Bank 0 Control Register
 ******************************************************************************/

/*!
 * @brief FMC_PFB0CR - Flash Bank 0 Control Register (RW)
 *
 * Reset value: 0x30060006U
 */
/*!
 * @name Constants and macros for entire FMC_PFB0CR register
 */
/*@{*/
#define FMC_RD_PFB0CR(base)      (FMC_PFB0CR_REG(base))
#define FMC_WR_PFB0CR(base, value) (FMC_PFB0CR_REG(base) = (value))
#define FMC_RMW_PFB0CR(base, mask, value) (FMC_WR_PFB0CR(base, (FMC_RD_PFB0CR(base) & ~(mask)) | (value)))
#define FMC_SET_PFB0CR(base, value) (BME_OR32(&FMC_PFB0CR_REG(base), (uint32_t)(value)))
#define FMC_CLR_PFB0CR(base, value) (BME_AND32(&FMC_PFB0CR_REG(base), (uint32_t)(~(value))))
#define FMC_TOG_PFB0CR(base, value) (BME_XOR32(&FMC_PFB0CR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB0CR bitfields
 */

/*!
 * @name Register FMC_PFB0CR, field B0IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0b0 - Do not prefetch in response to instruction fetches.
 * - 0b1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0IPE field. */
#define FMC_RD_PFB0CR_B0IPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0IPE_MASK) >> FMC_PFB0CR_B0IPE_SHIFT)
#define FMC_BRD_PFB0CR_B0IPE(base) (BME_UBFX32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0IPE_SHIFT, FMC_PFB0CR_B0IPE_WIDTH))

/*! @brief Set the B0IPE field to a new value. */
#define FMC_WR_PFB0CR_B0IPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0IPE_MASK, FMC_PFB0CR_B0IPE(value)))
#define FMC_BWR_PFB0CR_B0IPE(base, value) (BME_BFI32(&FMC_PFB0CR_REG(base), ((uint32_t)(value) << FMC_PFB0CR_B0IPE_SHIFT), FMC_PFB0CR_B0IPE_SHIFT, FMC_PFB0CR_B0IPE_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0b0 - Do not prefetch in response to data references.
 * - 0b1 - Enable prefetches in response to data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0DPE field. */
#define FMC_RD_PFB0CR_B0DPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0DPE_MASK) >> FMC_PFB0CR_B0DPE_SHIFT)
#define FMC_BRD_PFB0CR_B0DPE(base) (BME_UBFX32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DPE_SHIFT, FMC_PFB0CR_B0DPE_WIDTH))

/*! @brief Set the B0DPE field to a new value. */
#define FMC_WR_PFB0CR_B0DPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0DPE_MASK, FMC_PFB0CR_B0DPE(value)))
#define FMC_BWR_PFB0CR_B0DPE(base, value) (BME_BFI32(&FMC_PFB0CR_REG(base), ((uint32_t)(value) << FMC_PFB0CR_B0DPE_SHIFT), FMC_PFB0CR_B0DPE_SHIFT, FMC_PFB0CR_B0DPE_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0MW[18:17] (RO)
 *
 * This read-only field defines the width of the bank 0 memory.
 *
 * Values:
 * - 0b00 - 32 bits
 * - 0b01 - 64 bits
 * - 0b10 - 128 bits
 * - 0b11 - 256 bits
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0MW field. */
#define FMC_RD_PFB0CR_B0MW(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0MW_MASK) >> FMC_PFB0CR_B0MW_SHIFT)
#define FMC_BRD_PFB0CR_B0MW(base) (BME_UBFX32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0MW_SHIFT, FMC_PFB0CR_B0MW_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field S_INV[19] (WORZ)
 *
 * S_INV bit determines if the FMC's prefetch speculation buffer is to be
 * invalidated (cleared). When S_INV bit is written, the prefetch speculation buffer is
 * immediately cleared. Whenever flash memory is modified, the prefetch
 * speculation buffer should be cleared. S_INV bit always reads as zero.
 *
 * Values:
 * - 0b0 - Speculation buffer is not affected.
 * - 0b1 - Invalidate (clear) the speculation buffer.
 */
/*@{*/
/*! @brief Set the S_INV field to a new value. */
#define FMC_WR_PFB0CR_S_INV(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_S_INV_MASK, FMC_PFB0CR_S_INV(value)))
#define FMC_BWR_PFB0CR_S_INV(base, value) (BME_BFI32(&FMC_PFB0CR_REG(base), ((uint32_t)(value) << FMC_PFB0CR_S_INV_SHIFT), FMC_PFB0CR_S_INV_SHIFT, FMC_PFB0CR_S_INV_WIDTH))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * bank 0 flash memory. The relationship between the read access time of the
 * flash array (expressed in system clock cycles) and RWSC is defined as: Access
 * time of flash array [system clocks] = RWSC + 1 The FMC automatically calculates
 * this value based on the ratio of the system clock speed to the flash clock
 * speed. For example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0RWSC field. */
#define FMC_RD_PFB0CR_B0RWSC(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0RWSC_MASK) >> FMC_PFB0CR_B0RWSC_SHIFT)
#define FMC_BRD_PFB0CR_B0RWSC(base) (BME_UBFX32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0RWSC_SHIFT, FMC_PFB0CR_B0RWSC_WIDTH))
/*@}*/

/*
 * MKV58F24 FTFE
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFE_FSTAT - Flash Status Register
 * - FTFE_FCNFG - Flash Configuration Register
 * - FTFE_FSEC - Flash Security Register
 * - FTFE_FOPT - Flash Option Register
 * - FTFE_FCCOB3 - Flash Common Command Object Registers
 * - FTFE_FCCOB2 - Flash Common Command Object Registers
 * - FTFE_FCCOB1 - Flash Common Command Object Registers
 * - FTFE_FCCOB0 - Flash Common Command Object Registers
 * - FTFE_FCCOB7 - Flash Common Command Object Registers
 * - FTFE_FCCOB6 - Flash Common Command Object Registers
 * - FTFE_FCCOB5 - Flash Common Command Object Registers
 * - FTFE_FCCOB4 - Flash Common Command Object Registers
 * - FTFE_FCCOBB - Flash Common Command Object Registers
 * - FTFE_FCCOBA - Flash Common Command Object Registers
 * - FTFE_FCCOB9 - Flash Common Command Object Registers
 * - FTFE_FCCOB8 - Flash Common Command Object Registers
 * - FTFE_FPROT3 - Program Flash Protection Registers
 * - FTFE_FPROT2 - Program Flash Protection Registers
 * - FTFE_FPROT1 - Program Flash Protection Registers
 * - FTFE_FPROT0 - Program Flash Protection Registers
 */

#define FTFE_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFE module. */
#define FTFE_IDX (0U) /*!< Instance number for FTFE. */

/*******************************************************************************
 * FTFE_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFE_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the FTFE module. The
 * CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The MGSTAT0
 * bit is read only. The unassigned bits read 0 and are not writable. When set, the
 * Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in this
 * register prevent the launch of any more commands until the flag is cleared (by
 * writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFE_FSTAT register
 */
/*@{*/
#define FTFE_RD_FSTAT(base)      (FTFE_FSTAT_REG(base))
#define FTFE_WR_FSTAT(base, value) (FTFE_FSTAT_REG(base) = (value))
#define FTFE_RMW_FSTAT(base, mask, value) (FTFE_WR_FSTAT(base, (FTFE_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFE_SET_FSTAT(base, value) (BME_OR8(&FTFE_FSTAT_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FSTAT(base, value) (BME_AND8(&FTFE_FSTAT_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FSTAT(base, value) (BME_XOR8(&FTFE_FSTAT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FSTAT bitfields
 */

/*!
 * @name Register FTFE_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of an
 * FTFE command or during the flash reset sequence. As a status flag, this bit
 * cannot (and need not) be cleared by the user like the other error flags in this
 * register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the previous
 * result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_MGSTAT0 field. */
#define FTFE_RD_FSTAT_MGSTAT0(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_MGSTAT0_MASK) >> FTFE_FSTAT_MGSTAT0_SHIFT)
#define FTFE_BRD_FSTAT_MGSTAT0(base) (BME_UBFX8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_MGSTAT0_SHIFT, FTFE_FSTAT_MGSTAT0_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field FPVIOL[4] (W1C)
 *
 * The FPVIOL error bit indicates an attempt was made to program or erase an
 * address in a protected area of program flash memory during a command write
 * sequence. While FPVIOL is set, the CCIF flag cannot be cleared to launch a command.
 * The FPVIOL bit is cleared by writing a 1 to FPVIOL while CCIF is set. Writing
 * a 0 to the FPVIOL bit has no effect.
 *
 * Values:
 * - 0b0 - No protection violation detected
 * - 0b1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_FPVIOL field. */
#define FTFE_RD_FSTAT_FPVIOL(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_FPVIOL_MASK) >> FTFE_FSTAT_FPVIOL_SHIFT)
#define FTFE_BRD_FSTAT_FPVIOL(base) (BME_UBFX8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_FPVIOL_SHIFT, FTFE_FSTAT_FPVIOL_WIDTH))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFE_WR_FSTAT_FPVIOL(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_FPVIOL(value)))
#define FTFE_BWR_FSTAT_FPVIOL(base, value) (BME_BFI8(&FTFE_FSTAT_REG(base), ((uint8_t)(value) << FTFE_FSTAT_FPVIOL_SHIFT), FTFE_FSTAT_FPVIOL_SHIFT, FTFE_FSTAT_FPVIOL_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field ACCERR[5] (W1C)
 *
 * The ACCERR error bit indicates an illegal access has occurred to an FTFE
 * resource caused by a violation of the command write sequence or issuing an illegal
 * FTFE command. While ACCERR is set, the CCIF flag cannot be cleared to launch
 * a command. The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is
 * set. Writing a 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0b0 - No access error detected
 * - 0b1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_ACCERR field. */
#define FTFE_RD_FSTAT_ACCERR(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_ACCERR_MASK) >> FTFE_FSTAT_ACCERR_SHIFT)
#define FTFE_BRD_FSTAT_ACCERR(base) (BME_UBFX8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_ACCERR_SHIFT, FTFE_FSTAT_ACCERR_WIDTH))

/*! @brief Set the ACCERR field to a new value. */
#define FTFE_WR_FSTAT_ACCERR(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_ACCERR(value)))
#define FTFE_BWR_FSTAT_ACCERR(base, value) (BME_BFI8(&FTFE_FSTAT_REG(base), ((uint8_t)(value) << FTFE_FSTAT_ACCERR_SHIFT), FTFE_FSTAT_ACCERR_SHIFT, FTFE_FSTAT_ACCERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field RDCOLERR[6] (W1C)
 *
 * The RDCOLERR error bit indicates that the MCU attempted a read from an FTFE
 * resource that was being manipulated by an FTFE command (CCIF=0). Any
 * simultaneous access is detected as a collision error by the block arbitration logic. The
 * read data in this case cannot be guaranteed. The RDCOLERR bit is cleared by
 * writing a 1 to it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0b0 - No collision error detected
 * - 0b1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_RDCOLERR field. */
#define FTFE_RD_FSTAT_RDCOLERR(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_RDCOLERR_MASK) >> FTFE_FSTAT_RDCOLERR_SHIFT)
#define FTFE_BRD_FSTAT_RDCOLERR(base) (BME_UBFX8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_RDCOLERR_SHIFT, FTFE_FSTAT_RDCOLERR_WIDTH))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFE_WR_FSTAT_RDCOLERR(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_RDCOLERR_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_CCIF_MASK), FTFE_FSTAT_RDCOLERR(value)))
#define FTFE_BWR_FSTAT_RDCOLERR(base, value) (BME_BFI8(&FTFE_FSTAT_REG(base), ((uint8_t)(value) << FTFE_FSTAT_RDCOLERR_SHIFT), FTFE_FSTAT_RDCOLERR_SHIFT, FTFE_FSTAT_RDCOLERR_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSTAT, field CCIF[7] (W1C)
 *
 * The CCIF flag indicates that a FTFE command has completed. The CCIF flag is
 * cleared by writing a 1 to CCIF to launch a command, and CCIF stays low until
 * command completion or command violation. The CCIF bit is reset to 0 but is set
 * to 1 by the memory controller at the end of the reset initialization sequence.
 * Depending on how quickly the read occurs after reset release, the user may or
 * may not see the 0 hardware reset value.
 *
 * Values:
 * - 0b0 - FTFE command in progress
 * - 0b1 - FTFE command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSTAT_CCIF field. */
#define FTFE_RD_FSTAT_CCIF(base) ((FTFE_FSTAT_REG(base) & FTFE_FSTAT_CCIF_MASK) >> FTFE_FSTAT_CCIF_SHIFT)
#define FTFE_BRD_FSTAT_CCIF(base) (BME_UBFX8(&FTFE_FSTAT_REG(base), FTFE_FSTAT_CCIF_SHIFT, FTFE_FSTAT_CCIF_WIDTH))

/*! @brief Set the CCIF field to a new value. */
#define FTFE_WR_FSTAT_CCIF(base, value) (FTFE_RMW_FSTAT(base, (FTFE_FSTAT_CCIF_MASK | FTFE_FSTAT_FPVIOL_MASK | FTFE_FSTAT_ACCERR_MASK | FTFE_FSTAT_RDCOLERR_MASK), FTFE_FSTAT_CCIF(value)))
#define FTFE_BWR_FSTAT_CCIF(base, value) (BME_BFI8(&FTFE_FSTAT_REG(base), ((uint8_t)(value) << FTFE_FSTAT_CCIF_SHIFT), FTFE_FSTAT_CCIF_SHIFT, FTFE_FSTAT_CCIF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFE_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFE_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x02U
 *
 * This register provides information on the current functional state of the
 * FTFE module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. RAMRDY is a read-only status bit while PFLSH and EEERDY are reserved bits.
 */
/*!
 * @name Constants and macros for entire FTFE_FCNFG register
 */
/*@{*/
#define FTFE_RD_FCNFG(base)      (FTFE_FCNFG_REG(base))
#define FTFE_WR_FCNFG(base, value) (FTFE_FCNFG_REG(base) = (value))
#define FTFE_RMW_FCNFG(base, mask, value) (FTFE_WR_FCNFG(base, (FTFE_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFE_SET_FCNFG(base, value) (BME_OR8(&FTFE_FCNFG_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCNFG(base, value) (BME_AND8(&FTFE_FCNFG_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCNFG(base, value) (BME_XOR8(&FTFE_FCNFG_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTFE_FCNFG bitfields
 */

/*!
 * @name Register FTFE_FCNFG, field EEERDY[0] (RO)
 *
 * This bit is reserved and always has the value 0.
 *
 * Values:
 * - 0b0 - See RAMRDY for availability of programming acceleration RAM
 * - 0b1 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_EEERDY field. */
#define FTFE_RD_FCNFG_EEERDY(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_EEERDY_MASK) >> FTFE_FCNFG_EEERDY_SHIFT)
#define FTFE_BRD_FCNFG_EEERDY(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_EEERDY_SHIFT, FTFE_FCNFG_EEERDY_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RAMRDY[1] (RO)
 *
 * This flag indicates the current status of the programming acceleration RAM.
 * This bit should always be set.
 *
 * Values:
 * - 0b0 - Programming acceleration RAM is not available
 * - 0b1 - Programming acceleration RAM is available
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_RAMRDY field. */
#define FTFE_RD_FCNFG_RAMRDY(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_RAMRDY_MASK) >> FTFE_FCNFG_RAMRDY_SHIFT)
#define FTFE_BRD_FCNFG_RAMRDY(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_RAMRDY_SHIFT, FTFE_FCNFG_RAMRDY_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field PFLSH[2] (RO)
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_PFLSH field. */
#define FTFE_RD_FCNFG_PFLSH(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_PFLSH_MASK) >> FTFE_FCNFG_PFLSH_SHIFT)
#define FTFE_BRD_FCNFG_PFLSH(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_PFLSH_SHIFT, FTFE_FCNFG_PFLSH_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSSUSP[4] (RW)
 *
 * The ERSSUSP bit allows the user to suspend (interrupt) the Erase Flash Sector
 * command while it is executing.
 *
 * Values:
 * - 0b0 - No suspend requested
 * - 0b1 - Suspend the current Erase Flash Sector command execution
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_ERSSUSP field. */
#define FTFE_RD_FCNFG_ERSSUSP(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_ERSSUSP_MASK) >> FTFE_FCNFG_ERSSUSP_SHIFT)
#define FTFE_BRD_FCNFG_ERSSUSP(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_ERSSUSP_SHIFT, FTFE_FCNFG_ERSSUSP_WIDTH))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFE_WR_FCNFG_ERSSUSP(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_ERSSUSP_MASK, FTFE_FCNFG_ERSSUSP(value)))
#define FTFE_BWR_FCNFG_ERSSUSP(base, value) (BME_BFI8(&FTFE_FCNFG_REG(base), ((uint8_t)(value) << FTFE_FCNFG_ERSSUSP_SHIFT), FTFE_FCNFG_ERSSUSP_SHIFT, FTFE_FCNFG_ERSSUSP_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field ERSAREQ[5] (RO)
 *
 * This bit issues a request to the memory controller to execute the Erase All
 * Blocks command and release security. ERSAREQ is not directly writable but is
 * under indirect user control. Refer to the device's Chip Configuration details on
 * how to request this command. The ERSAREQ bit sets when an erase all request
 * is triggered external to the FTFE and CCIF is set (no command is currently
 * being executed). ERSAREQ is cleared by the FTFE when the operation completes.
 *
 * Values:
 * - 0b0 - No request or request complete
 * - 0b1 - Request to: run the Erase All Blocks command, verify the erased
 *     state, program the security byte in the Flash Configuration Field to the
 *     unsecure state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_ERSAREQ field. */
#define FTFE_RD_FCNFG_ERSAREQ(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_ERSAREQ_MASK) >> FTFE_FCNFG_ERSAREQ_SHIFT)
#define FTFE_BRD_FCNFG_ERSAREQ(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_ERSAREQ_SHIFT, FTFE_FCNFG_ERSAREQ_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field RDCOLLIE[6] (RW)
 *
 * The RDCOLLIE bit controls interrupt generation when an FTFE read collision
 * error occurs.
 *
 * Values:
 * - 0b0 - Read collision error interrupt disabled
 * - 0b1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever an FTFE read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_RDCOLLIE field. */
#define FTFE_RD_FCNFG_RDCOLLIE(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_RDCOLLIE_MASK) >> FTFE_FCNFG_RDCOLLIE_SHIFT)
#define FTFE_BRD_FCNFG_RDCOLLIE(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_RDCOLLIE_SHIFT, FTFE_FCNFG_RDCOLLIE_WIDTH))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFE_WR_FCNFG_RDCOLLIE(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_RDCOLLIE_MASK, FTFE_FCNFG_RDCOLLIE(value)))
#define FTFE_BWR_FCNFG_RDCOLLIE(base, value) (BME_BFI8(&FTFE_FCNFG_REG(base), ((uint8_t)(value) << FTFE_FCNFG_RDCOLLIE_SHIFT), FTFE_FCNFG_RDCOLLIE_SHIFT, FTFE_FCNFG_RDCOLLIE_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FCNFG, field CCIE[7] (RW)
 *
 * The CCIE bit controls interrupt generation when an FTFE command completes.
 *
 * Values:
 * - 0b0 - Command complete interrupt disabled
 * - 0b1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFE_FCNFG_CCIE field. */
#define FTFE_RD_FCNFG_CCIE(base) ((FTFE_FCNFG_REG(base) & FTFE_FCNFG_CCIE_MASK) >> FTFE_FCNFG_CCIE_SHIFT)
#define FTFE_BRD_FCNFG_CCIE(base) (BME_UBFX8(&FTFE_FCNFG_REG(base), FTFE_FCNFG_CCIE_SHIFT, FTFE_FCNFG_CCIE_WIDTH))

/*! @brief Set the CCIE field to a new value. */
#define FTFE_WR_FCNFG_CCIE(base, value) (FTFE_RMW_FCNFG(base, FTFE_FCNFG_CCIE_MASK, FTFE_FCNFG_CCIE(value)))
#define FTFE_BWR_FCNFG_CCIE(base, value) (BME_BFI8(&FTFE_FCNFG_REG(base), ((uint8_t)(value) << FTFE_FCNFG_CCIE_SHIFT), FTFE_FCNFG_CCIE_SHIFT, FTFE_FCNFG_CCIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFE_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFE_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and FTFE module. During the reset sequence, the register is loaded with the
 * contents of the flash security byte in the Flash Configuration Field located
 * in program flash memory. The Flash basis for the values is signified by X in
 * the reset value.
 */
/*!
 * @name Constants and macros for entire FTFE_FSEC register
 */
/*@{*/
#define FTFE_RD_FSEC(base)       (FTFE_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFE_FSEC bitfields
 */

/*!
 * @name Register FTFE_FSEC, field SEC[1:0] (RO)
 *
 * These bits define the security state of the MCU. In the secure state, the MCU
 * limits access to FTFE module resources. The limitations are defined per
 * device and are detailed in the Chip Configuration details. If the FTFE module is
 * unsecured using backdoor key access, the SEC bits are forced to 10b.
 *
 * Values:
 * - 0b00 - MCU security status is secure
 * - 0b01 - MCU security status is secure
 * - 0b10 - MCU security status is unsecure (The standard shipping condition of
 *     the FTFE is unsecure.)
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_SEC field. */
#define FTFE_RD_FSEC_SEC(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_SEC_MASK) >> FTFE_FSEC_SEC_SHIFT)
#define FTFE_BRD_FSEC_SEC(base) (BME_UBFX8(&FTFE_FSEC_REG(base), FTFE_FSEC_SEC_SHIFT, FTFE_FSEC_SEC_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field FSLACC[3:2] (RO)
 *
 * These bits enable or disable access to the flash memory contents during
 * returned part failure analysis at NXP. When SEC is secure and FSLACC is denied,
 * access to the program flash contents is denied and any failure analysis performed
 * by NXP factory test must begin with a full erase to unsecure the part. When
 * access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * NXP factory testing has visibility of the current flash contents. The state of
 * the FSLACC bits is only relevant when the SEC bits are set to secure. When the
 * SEC field is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 0b00 - Factory access granted
 * - 0b01 - Factory access denied
 * - 0b10 - Factory access denied
 * - 0b11 - Factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_FSLACC field. */
#define FTFE_RD_FSEC_FSLACC(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_FSLACC_MASK) >> FTFE_FSEC_FSLACC_SHIFT)
#define FTFE_BRD_FSEC_FSLACC(base) (BME_UBFX8(&FTFE_FSEC_REG(base), FTFE_FSEC_FSLACC_SHIFT, FTFE_FSEC_FSLACC_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the FTFE module. The state of
 * the MEEN bits is only relevant when the SEC bits are set to secure. When the
 * SEC field is set to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 0b00 - Mass erase is enabled
 * - 0b01 - Mass erase is enabled
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_MEEN field. */
#define FTFE_RD_FSEC_MEEN(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_MEEN_MASK) >> FTFE_FSEC_MEEN_SHIFT)
#define FTFE_BRD_FSEC_MEEN(base) (BME_UBFX8(&FTFE_FSEC_REG(base), FTFE_FSEC_MEEN_SHIFT, FTFE_FSEC_MEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTFE_FSEC, field KEYEN[7:6] (RO)
 *
 * These bits enable and disable backdoor key access to the FTFE module.
 *
 * Values:
 * - 0b00 - Backdoor key access disabled
 * - 0b01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFE_FSEC_KEYEN field. */
#define FTFE_RD_FSEC_KEYEN(base) ((FTFE_FSEC_REG(base) & FTFE_FSEC_KEYEN_MASK) >> FTFE_FSEC_KEYEN_SHIFT)
#define FTFE_BRD_FSEC_KEYEN(base) (BME_UBFX8(&FTFE_FSEC_REG(base), FTFE_FSEC_KEYEN_SHIFT, FTFE_FSEC_KEYEN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTFE_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFE_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only. During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFE_FOPT register
 */
/*@{*/
#define FTFE_RD_FOPT(base)       (FTFE_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB3 register
 */
/*@{*/
#define FTFE_RD_FCCOB3(base)     (FTFE_FCCOB3_REG(base))
#define FTFE_WR_FCCOB3(base, value) (FTFE_FCCOB3_REG(base) = (value))
#define FTFE_RMW_FCCOB3(base, mask, value) (FTFE_WR_FCCOB3(base, (FTFE_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB3(base, value) (BME_OR8(&FTFE_FCCOB3_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB3(base, value) (BME_AND8(&FTFE_FCCOB3_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB3(base, value) (BME_XOR8(&FTFE_FCCOB3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB2 register
 */
/*@{*/
#define FTFE_RD_FCCOB2(base)     (FTFE_FCCOB2_REG(base))
#define FTFE_WR_FCCOB2(base, value) (FTFE_FCCOB2_REG(base) = (value))
#define FTFE_RMW_FCCOB2(base, mask, value) (FTFE_WR_FCCOB2(base, (FTFE_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB2(base, value) (BME_OR8(&FTFE_FCCOB2_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB2(base, value) (BME_AND8(&FTFE_FCCOB2_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB2(base, value) (BME_XOR8(&FTFE_FCCOB2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB1 register
 */
/*@{*/
#define FTFE_RD_FCCOB1(base)     (FTFE_FCCOB1_REG(base))
#define FTFE_WR_FCCOB1(base, value) (FTFE_FCCOB1_REG(base) = (value))
#define FTFE_RMW_FCCOB1(base, mask, value) (FTFE_WR_FCCOB1(base, (FTFE_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB1(base, value) (BME_OR8(&FTFE_FCCOB1_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB1(base, value) (BME_AND8(&FTFE_FCCOB1_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB1(base, value) (BME_XOR8(&FTFE_FCCOB1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB0 register
 */
/*@{*/
#define FTFE_RD_FCCOB0(base)     (FTFE_FCCOB0_REG(base))
#define FTFE_WR_FCCOB0(base, value) (FTFE_FCCOB0_REG(base) = (value))
#define FTFE_RMW_FCCOB0(base, mask, value) (FTFE_WR_FCCOB0(base, (FTFE_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB0(base, value) (BME_OR8(&FTFE_FCCOB0_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB0(base, value) (BME_AND8(&FTFE_FCCOB0_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB0(base, value) (BME_XOR8(&FTFE_FCCOB0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB7 register
 */
/*@{*/
#define FTFE_RD_FCCOB7(base)     (FTFE_FCCOB7_REG(base))
#define FTFE_WR_FCCOB7(base, value) (FTFE_FCCOB7_REG(base) = (value))
#define FTFE_RMW_FCCOB7(base, mask, value) (FTFE_WR_FCCOB7(base, (FTFE_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB7(base, value) (BME_OR8(&FTFE_FCCOB7_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB7(base, value) (BME_AND8(&FTFE_FCCOB7_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB7(base, value) (BME_XOR8(&FTFE_FCCOB7_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB6 register
 */
/*@{*/
#define FTFE_RD_FCCOB6(base)     (FTFE_FCCOB6_REG(base))
#define FTFE_WR_FCCOB6(base, value) (FTFE_FCCOB6_REG(base) = (value))
#define FTFE_RMW_FCCOB6(base, mask, value) (FTFE_WR_FCCOB6(base, (FTFE_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB6(base, value) (BME_OR8(&FTFE_FCCOB6_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB6(base, value) (BME_AND8(&FTFE_FCCOB6_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB6(base, value) (BME_XOR8(&FTFE_FCCOB6_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB5 register
 */
/*@{*/
#define FTFE_RD_FCCOB5(base)     (FTFE_FCCOB5_REG(base))
#define FTFE_WR_FCCOB5(base, value) (FTFE_FCCOB5_REG(base) = (value))
#define FTFE_RMW_FCCOB5(base, mask, value) (FTFE_WR_FCCOB5(base, (FTFE_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB5(base, value) (BME_OR8(&FTFE_FCCOB5_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB5(base, value) (BME_AND8(&FTFE_FCCOB5_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB5(base, value) (BME_XOR8(&FTFE_FCCOB5_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB4 register
 */
/*@{*/
#define FTFE_RD_FCCOB4(base)     (FTFE_FCCOB4_REG(base))
#define FTFE_WR_FCCOB4(base, value) (FTFE_FCCOB4_REG(base) = (value))
#define FTFE_RMW_FCCOB4(base, mask, value) (FTFE_WR_FCCOB4(base, (FTFE_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB4(base, value) (BME_OR8(&FTFE_FCCOB4_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB4(base, value) (BME_AND8(&FTFE_FCCOB4_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB4(base, value) (BME_XOR8(&FTFE_FCCOB4_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOBB register
 */
/*@{*/
#define FTFE_RD_FCCOBB(base)     (FTFE_FCCOBB_REG(base))
#define FTFE_WR_FCCOBB(base, value) (FTFE_FCCOBB_REG(base) = (value))
#define FTFE_RMW_FCCOBB(base, mask, value) (FTFE_WR_FCCOBB(base, (FTFE_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOBB(base, value) (BME_OR8(&FTFE_FCCOBB_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOBB(base, value) (BME_AND8(&FTFE_FCCOBB_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOBB(base, value) (BME_XOR8(&FTFE_FCCOBB_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOBA register
 */
/*@{*/
#define FTFE_RD_FCCOBA(base)     (FTFE_FCCOBA_REG(base))
#define FTFE_WR_FCCOBA(base, value) (FTFE_FCCOBA_REG(base) = (value))
#define FTFE_RMW_FCCOBA(base, mask, value) (FTFE_WR_FCCOBA(base, (FTFE_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOBA(base, value) (BME_OR8(&FTFE_FCCOBA_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOBA(base, value) (BME_AND8(&FTFE_FCCOBA_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOBA(base, value) (BME_XOR8(&FTFE_FCCOBA_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB9 register
 */
/*@{*/
#define FTFE_RD_FCCOB9(base)     (FTFE_FCCOB9_REG(base))
#define FTFE_WR_FCCOB9(base, value) (FTFE_FCCOB9_REG(base) = (value))
#define FTFE_RMW_FCCOB9(base, mask, value) (FTFE_WR_FCCOB9(base, (FTFE_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB9(base, value) (BME_OR8(&FTFE_FCCOB9_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB9(base, value) (BME_AND8(&FTFE_FCCOB9_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB9(base, value) (BME_XOR8(&FTFE_FCCOB9_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFE_FCCOB8 register
 */
/*@{*/
#define FTFE_RD_FCCOB8(base)     (FTFE_FCCOB8_REG(base))
#define FTFE_WR_FCCOB8(base, value) (FTFE_FCCOB8_REG(base) = (value))
#define FTFE_RMW_FCCOB8(base, mask, value) (FTFE_WR_FCCOB8(base, (FTFE_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFE_SET_FCCOB8(base, value) (BME_OR8(&FTFE_FCCOB8_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FCCOB8(base, value) (BME_AND8(&FTFE_FCCOB8_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FCCOB8(base, value) (BME_XOR8(&FTFE_FCCOB8_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFE_FPROT3 register
 */
/*@{*/
#define FTFE_RD_FPROT3(base)     (FTFE_FPROT3_REG(base))
#define FTFE_WR_FPROT3(base, value) (FTFE_FPROT3_REG(base) = (value))
#define FTFE_RMW_FPROT3(base, mask, value) (FTFE_WR_FPROT3(base, (FTFE_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFE_SET_FPROT3(base, value) (BME_OR8(&FTFE_FPROT3_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FPROT3(base, value) (BME_AND8(&FTFE_FPROT3_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FPROT3(base, value) (BME_XOR8(&FTFE_FPROT3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFE_FPROT2 register
 */
/*@{*/
#define FTFE_RD_FPROT2(base)     (FTFE_FPROT2_REG(base))
#define FTFE_WR_FPROT2(base, value) (FTFE_FPROT2_REG(base) = (value))
#define FTFE_RMW_FPROT2(base, mask, value) (FTFE_WR_FPROT2(base, (FTFE_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFE_SET_FPROT2(base, value) (BME_OR8(&FTFE_FPROT2_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FPROT2(base, value) (BME_AND8(&FTFE_FPROT2_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FPROT2(base, value) (BME_XOR8(&FTFE_FPROT2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFE_FPROT1 register
 */
/*@{*/
#define FTFE_RD_FPROT1(base)     (FTFE_FPROT1_REG(base))
#define FTFE_WR_FPROT1(base, value) (FTFE_FPROT1_REG(base) = (value))
#define FTFE_RMW_FPROT1(base, mask, value) (FTFE_WR_FPROT1(base, (FTFE_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFE_SET_FPROT1(base, value) (BME_OR8(&FTFE_FPROT1_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FPROT1(base, value) (BME_AND8(&FTFE_FPROT1_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FPROT1(base, value) (BME_XOR8(&FTFE_FPROT1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * FTFE_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFE_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any FTFE command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions of equal
 * memory size. Program flash protection register Program flash protection bits
 * FPROT0 PROT[31:24] FPROT1 PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During
 * the reset sequence, the FPROT registers are loaded with the contents of the
 * program flash protection bytes in the Flash Configuration Field as indicated in
 * the following table. Program flash protection register Flash Configuration Field
 * offset address FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To
 * change the program flash protection that is loaded during the reset sequence,
 * unprotect the sector of program flash memory that contains the Flash
 * Configuration Field. Then, reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFE_FPROT0 register
 */
/*@{*/
#define FTFE_RD_FPROT0(base)     (FTFE_FPROT0_REG(base))
#define FTFE_WR_FPROT0(base, value) (FTFE_FPROT0_REG(base) = (value))
#define FTFE_RMW_FPROT0(base, mask, value) (FTFE_WR_FPROT0(base, (FTFE_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFE_SET_FPROT0(base, value) (BME_OR8(&FTFE_FPROT0_REG(base), (uint8_t)(value)))
#define FTFE_CLR_FPROT0(base, value) (BME_AND8(&FTFE_FPROT0_REG(base), (uint8_t)(~(value))))
#define FTFE_TOG_FPROT0(base, value) (BME_XOR8(&FTFE_FPROT0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV58F24 FTM
 *
 * FlexTimer Module
 *
 * Registers defined in this header file:
 * - FTM_SC - Status And Control
 * - FTM_CNT - Counter
 * - FTM_MOD - Modulo
 * - FTM_CnSC - Channel (n) Status And Control
 * - FTM_CnV - Channel (n) Value
 * - FTM_CNTIN - Counter Initial Value
 * - FTM_STATUS - Capture And Compare Status
 * - FTM_MODE - Features Mode Selection
 * - FTM_SYNC - Synchronization
 * - FTM_OUTINIT - Initial State For Channels Output
 * - FTM_OUTMASK - Output Mask
 * - FTM_COMBINE - Function For Linked Channels
 * - FTM_DEADTIME - Deadtime Insertion Control
 * - FTM_EXTTRIG - FTM External Trigger
 * - FTM_POL - Channels Polarity
 * - FTM_FMS - Fault Mode Status
 * - FTM_FILTER - Input Capture Filter Control
 * - FTM_FLTCTRL - Fault Control
 * - FTM_QDCTRL - Quadrature Decoder Control And Status
 * - FTM_CONF - Configuration
 * - FTM_FLTPOL - FTM Fault Input Polarity
 * - FTM_SYNCONF - Synchronization Configuration
 * - FTM_INVCTRL - FTM Inverting Control
 * - FTM_SWOCTRL - FTM Software Output Control
 * - FTM_PWMLOAD - FTM PWM Load
 */

#define FTM_INSTANCE_COUNT (4U) /*!< Number of instances of the FTM module. */
#define FTM0_IDX (0U) /*!< Instance number for FTM0. */
#define FTM1_IDX (1U) /*!< Instance number for FTM1. */
#define FTM2_IDX (2U) /*!< Instance number for FTM2. */
#define FTM3_IDX (3U) /*!< Instance number for FTM3. */

/*******************************************************************************
 * FTM_SC - Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_SC - Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, FTM configuration, clock source, and prescaler factor. These
 * controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_SC register
 */
/*@{*/
#define FTM_RD_SC(base)          (FTM_SC_REG(base))
#define FTM_WR_SC(base, value)   (FTM_SC_REG(base) = (value))
#define FTM_RMW_SC(base, mask, value) (FTM_WR_SC(base, (FTM_RD_SC(base) & ~(mask)) | (value)))
#define FTM_SET_SC(base, value)  (BME_OR32(&FTM_SC_REG(base), (uint32_t)(value)))
#define FTM_CLR_SC(base, value)  (BME_AND32(&FTM_SC_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SC(base, value)  (BME_XOR32(&FTM_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SC bitfields
 */

/*!
 * @name Register FTM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock source selected by CLKS. The
 * new prescaler factor affects the clock source on the next system clock cycle
 * after the new value is updated into the register bits. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b000 - Divide by 1
 * - 0b001 - Divide by 2
 * - 0b010 - Divide by 4
 * - 0b011 - Divide by 8
 * - 0b100 - Divide by 16
 * - 0b101 - Divide by 32
 * - 0b110 - Divide by 64
 * - 0b111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_PS field. */
#define FTM_RD_SC_PS(base)   ((FTM_SC_REG(base) & FTM_SC_PS_MASK) >> FTM_SC_PS_SHIFT)
#define FTM_BRD_SC_PS(base)  (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_PS_SHIFT, FTM_SC_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define FTM_WR_SC_PS(base, value) (FTM_RMW_SC(base, FTM_SC_PS_MASK, FTM_SC_PS(value)))
#define FTM_BWR_SC_PS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_PS_SHIFT), FTM_SC_PS_SHIFT, FTM_SC_PS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field CLKS[4:3] (RW)
 *
 * Selects FTM counter clock sources. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b00 - No clock selected. This in effect disables the FTM counter.
 * - 0b01 - System clock
 * - 0b10 - Fixed frequency clock
 * - 0b11 - External clock
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CLKS field. */
#define FTM_RD_SC_CLKS(base) ((FTM_SC_REG(base) & FTM_SC_CLKS_MASK) >> FTM_SC_CLKS_SHIFT)
#define FTM_BRD_SC_CLKS(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_CLKS_SHIFT, FTM_SC_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define FTM_WR_SC_CLKS(base, value) (FTM_RMW_SC(base, FTM_SC_CLKS_MASK, FTM_SC_CLKS(value)))
#define FTM_BWR_SC_CLKS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_CLKS_SHIFT), FTM_SC_CLKS_SHIFT, FTM_SC_CLKS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the FTM to operate in Up-Down
 * Counting mode. This field is write protected. It can be written only when MODE[WPDIS]
 * = 1.
 *
 * Values:
 * - 0b0 - FTM counter operates in Up Counting mode.
 * - 0b1 - FTM counter operates in Up-Down Counting mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_CPWMS field. */
#define FTM_RD_SC_CPWMS(base) ((FTM_SC_REG(base) & FTM_SC_CPWMS_MASK) >> FTM_SC_CPWMS_SHIFT)
#define FTM_BRD_SC_CPWMS(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_CPWMS_SHIFT, FTM_SC_CPWMS_WIDTH))

/*! @brief Set the CPWMS field to a new value. */
#define FTM_WR_SC_CPWMS(base, value) (FTM_RMW_SC(base, FTM_SC_CPWMS_MASK, FTM_SC_CPWMS(value)))
#define FTM_BWR_SC_CPWMS(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_CPWMS_SHIFT), FTM_SC_CPWMS_SHIFT, FTM_SC_CPWMS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field TOIE[6] (RW)
 *
 * Enables FTM overflow interrupts.
 *
 * Values:
 * - 0b0 - Disable TOF interrupts. Use software polling.
 * - 0b1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOIE field. */
#define FTM_RD_SC_TOIE(base) ((FTM_SC_REG(base) & FTM_SC_TOIE_MASK) >> FTM_SC_TOIE_SHIFT)
#define FTM_BRD_SC_TOIE(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_TOIE_SHIFT, FTM_SC_TOIE_WIDTH))

/*! @brief Set the TOIE field to a new value. */
#define FTM_WR_SC_TOIE(base, value) (FTM_RMW_SC(base, FTM_SC_TOIE_MASK, FTM_SC_TOIE(value)))
#define FTM_BWR_SC_TOIE(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_TOIE_SHIFT), FTM_SC_TOIE_SHIFT, FTM_SC_TOIE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SC, field TOF[7] (ROWZ)
 *
 * Set by hardware when the FTM counter passes the value in the MOD register.
 * The TOF bit is cleared by reading the SC register while TOF is set and then
 * writing a 0 to TOF bit. Writing a 1 to TOF has no effect. If another FTM overflow
 * occurs between the read and write operations, the write operation has no
 * effect; therefore, TOF remains set indicating an overflow has occurred. In this
 * case, a TOF interrupt request is not lost due to the clearing sequence for a
 * previous TOF.
 *
 * Values:
 * - 0b0 - FTM counter has not overflowed.
 * - 0b1 - FTM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the FTM_SC_TOF field. */
#define FTM_RD_SC_TOF(base)  ((FTM_SC_REG(base) & FTM_SC_TOF_MASK) >> FTM_SC_TOF_SHIFT)
#define FTM_BRD_SC_TOF(base) (BME_UBFX32(&FTM_SC_REG(base), FTM_SC_TOF_SHIFT, FTM_SC_TOF_WIDTH))

/*! @brief Set the TOF field to a new value. */
#define FTM_WR_SC_TOF(base, value) (FTM_RMW_SC(base, FTM_SC_TOF_MASK, FTM_SC_TOF(value)))
#define FTM_BWR_SC_TOF(base, value) (BME_BFI32(&FTM_SC_REG(base), ((uint32_t)(value) << FTM_SC_TOF_SHIFT), FTM_SC_TOF_SHIFT, FTM_SC_TOF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief FTM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the FTM counter value. Reset clears the CNT
 * register. Writing any value to COUNT updates the counter with its initial value,
 * CNTIN. When BDM is active, the FTM counter is frozen. This is the value that you
 * may read.
 */
/*!
 * @name Constants and macros for entire FTM_CNT register
 */
/*@{*/
#define FTM_RD_CNT(base)         (FTM_CNT_REG(base))
#define FTM_WR_CNT(base, value)  (FTM_CNT_REG(base) = (value))
#define FTM_RMW_CNT(base, mask, value) (FTM_WR_CNT(base, (FTM_RD_CNT(base) & ~(mask)) | (value)))
#define FTM_SET_CNT(base, value) (BME_OR32(&FTM_CNT_REG(base), (uint32_t)(value)))
#define FTM_CLR_CNT(base, value) (BME_AND32(&FTM_CNT_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CNT(base, value) (BME_XOR32(&FTM_CNT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNT bitfields
 */

/*!
 * @name Register FTM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FTM_CNT_COUNT field. */
#define FTM_RD_CNT_COUNT(base) ((FTM_CNT_REG(base) & FTM_CNT_COUNT_MASK) >> FTM_CNT_COUNT_SHIFT)
#define FTM_BRD_CNT_COUNT(base) (FTM_RD_CNT_COUNT(base))

/*! @brief Set the COUNT field to a new value. */
#define FTM_WR_CNT_COUNT(base, value) (FTM_RMW_CNT(base, FTM_CNT_COUNT_MASK, FTM_CNT_COUNT(value)))
#define FTM_BWR_CNT_COUNT(base, value) (FTM_WR_CNT_COUNT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief FTM_MOD - Modulo (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Modulo register contains the modulo value for the FTM counter. After the
 * FTM counter reaches the modulo value, the overflow flag (TOF) becomes set at
 * the next clock, and the next value of FTM counter depends on the selected
 * counting method; see Counter. Writing to the MOD register latches the value into a
 * buffer. The MOD register is updated with the value of its write buffer
 * according to Registers updated from write buffers. If FTMEN = 0, this write coherency
 * mechanism may be manually reset by writing to the SC register whether BDM is
 * active or not. Initialize the FTM counter, by writing to CNT, before writing
 * to the MOD register to avoid confusion about when the first counter overflow
 * will occur.
 */
/*!
 * @name Constants and macros for entire FTM_MOD register
 */
/*@{*/
#define FTM_RD_MOD(base)         (FTM_MOD_REG(base))
#define FTM_WR_MOD(base, value)  (FTM_MOD_REG(base) = (value))
#define FTM_RMW_MOD(base, mask, value) (FTM_WR_MOD(base, (FTM_RD_MOD(base) & ~(mask)) | (value)))
#define FTM_SET_MOD(base, value) (BME_OR32(&FTM_MOD_REG(base), (uint32_t)(value)))
#define FTM_CLR_MOD(base, value) (BME_AND32(&FTM_MOD_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_MOD(base, value) (BME_XOR32(&FTM_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MOD bitfields
 */

/*!
 * @name Register FTM_MOD, field MOD[15:0] (RW)
 *
 * Modulo Value
 */
/*@{*/
/*! @brief Read current value of the FTM_MOD_MOD field. */
#define FTM_RD_MOD_MOD(base) ((FTM_MOD_REG(base) & FTM_MOD_MOD_MASK) >> FTM_MOD_MOD_SHIFT)
#define FTM_BRD_MOD_MOD(base) (FTM_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define FTM_WR_MOD_MOD(base, value) (FTM_RMW_MOD(base, FTM_MOD_MOD_MASK, FTM_MOD_MOD(value)))
#define FTM_BWR_MOD_MOD(base, value) (FTM_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * FTM_CnSC - Channel (n) Status And Control
 ******************************************************************************/

/*!
 * @brief FTM_CnSC - Channel (n) Status And Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. Mode,
 * edge, and level selection DECAPEN COMBINE CPWMS MSnB:MSnA ELSnB:ELSnA Mode
 * Configuration X X X XX 00 Pin not used for FTM-revert the channel pin to general
 * purpose I/O or other peripheral control 0 0 0 00 01 Input Capture Capture on
 * Rising Edge Only 10 Capture on Falling Edge Only 11 Capture on Rising or Falling
 * Edge 01 01 Output Compare Toggle Output on match 10 Clear Output on match 11
 * Set Output on match 1X 10 Edge-Aligned PWM High-true pulses (clear Output on
 * match) X1 Low-true pulses (set Output on match) 1 XX 10 Center-Aligned PWM
 * High-true pulses (clear Output on match-up) X1 Low-true pulses (set Output on
 * match-up) 1 0 XX 10 Combine PWM High-true pulses (set on channel (n) match, and
 * clear on channel (n+1) match) X1 Low-true pulses (clear on channel (n) match, and
 * set on channel (n+1) match) 1 0 0 X0 See the following table (). Dual Edge
 * Capture One-Shot Capture mode X1 Continuous Capture mode Dual Edge Capture mode -
 * edge polarity selection ELSnB ELSnA Channel Port Enable Detected Edges 0 0
 * Disabled No edge 0 1 Enabled Rising edge 1 0 Enabled Falling edge 1 1 Enabled
 * Rising and falling edges
 */
/*!
 * @name Constants and macros for entire FTM_CnSC register
 */
/*@{*/
#define FTM_RD_CnSC(base, index) (FTM_CnSC_REG(base, index))
#define FTM_WR_CnSC(base, index, value) (FTM_CnSC_REG(base, index) = (value))
#define FTM_RMW_CnSC(base, index, mask, value) (FTM_WR_CnSC(base, index, (FTM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnSC(base, index, value) (BME_OR32(&FTM_CnSC_REG(base, index), (uint32_t)(value)))
#define FTM_CLR_CnSC(base, index, value) (BME_AND32(&FTM_CnSC_REG(base, index), (uint32_t)(~(value))))
#define FTM_TOG_CnSC(base, index, value) (BME_XOR32(&FTM_CnSC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnSC bitfields
 */

/*!
 * @name Register FTM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0b0 - Disable DMA transfers.
 * - 0b1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_DMA field. */
#define FTM_RD_CnSC_DMA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_DMA_MASK) >> FTM_CnSC_DMA_SHIFT)
#define FTM_BRD_CnSC_DMA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_DMA_SHIFT, FTM_CnSC_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define FTM_WR_CnSC_DMA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_DMA_MASK, FTM_CnSC_DMA(value)))
#define FTM_BWR_CnSC_DMA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_DMA_SHIFT), FTM_CnSC_DMA_SHIFT, FTM_CnSC_DMA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ICRST[1] (RW)
 *
 * FTM counter reset is driven by the selected event of the channel (n) in the
 * Input Capture mode. This field is write protected. It can be written only when
 * MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - FTM counter is not reset when the selected channel (n) input event is
 *     detected.
 * - 0b1 - FTM counter is reset when the selected channel (n) input event is
 *     detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ICRST field. */
#define FTM_RD_CnSC_ICRST(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ICRST_MASK) >> FTM_CnSC_ICRST_SHIFT)
#define FTM_BRD_CnSC_ICRST(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ICRST_SHIFT, FTM_CnSC_ICRST_WIDTH))

/*! @brief Set the ICRST field to a new value. */
#define FTM_WR_CnSC_ICRST(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ICRST_MASK, FTM_CnSC_ICRST(value)))
#define FTM_BWR_CnSC_ICRST(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ICRST_SHIFT), FTM_CnSC_ICRST_SHIFT, FTM_CnSC_ICRST_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See . This
 * field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSA field. */
#define FTM_RD_CnSC_ELSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSA_MASK) >> FTM_CnSC_ELSA_SHIFT)
#define FTM_BRD_CnSC_ELSA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSA_SHIFT, FTM_CnSC_ELSA_WIDTH))

/*! @brief Set the ELSA field to a new value. */
#define FTM_WR_CnSC_ELSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSA_MASK, FTM_CnSC_ELSA(value)))
#define FTM_BWR_CnSC_ELSA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ELSA_SHIFT), FTM_CnSC_ELSA_SHIFT, FTM_CnSC_ELSA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. See . This
 * field is write protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_ELSB field. */
#define FTM_RD_CnSC_ELSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_ELSB_MASK) >> FTM_CnSC_ELSB_SHIFT)
#define FTM_BRD_CnSC_ELSB(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_ELSB_SHIFT, FTM_CnSC_ELSB_WIDTH))

/*! @brief Set the ELSB field to a new value. */
#define FTM_WR_CnSC_ELSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_ELSB_MASK, FTM_CnSC_ELSB(value)))
#define FTM_BWR_CnSC_ELSB(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_ELSB_SHIFT), FTM_CnSC_ELSB_SHIFT, FTM_CnSC_ELSB_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSA field. */
#define FTM_RD_CnSC_MSA(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSA_MASK) >> FTM_CnSC_MSA_SHIFT)
#define FTM_BRD_CnSC_MSA(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSA_SHIFT, FTM_CnSC_MSA_WIDTH))

/*! @brief Set the MSA field to a new value. */
#define FTM_WR_CnSC_MSA(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSA_MASK, FTM_CnSC_MSA(value)))
#define FTM_BWR_CnSC_MSA(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_MSA_SHIFT), FTM_CnSC_MSA_SHIFT, FTM_CnSC_MSA_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. See . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_MSB field. */
#define FTM_RD_CnSC_MSB(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_MSB_MASK) >> FTM_CnSC_MSB_SHIFT)
#define FTM_BRD_CnSC_MSB(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_MSB_SHIFT, FTM_CnSC_MSB_WIDTH))

/*! @brief Set the MSB field to a new value. */
#define FTM_WR_CnSC_MSB(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_MSB_MASK, FTM_CnSC_MSB(value)))
#define FTM_BWR_CnSC_MSB(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_MSB_SHIFT), FTM_CnSC_MSB_SHIFT, FTM_CnSC_MSB_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0b0 - Disable channel interrupts. Use software polling.
 * - 0b1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHIE field. */
#define FTM_RD_CnSC_CHIE(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHIE_MASK) >> FTM_CnSC_CHIE_SHIFT)
#define FTM_BRD_CnSC_CHIE(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHIE_SHIFT, FTM_CnSC_CHIE_WIDTH))

/*! @brief Set the CHIE field to a new value. */
#define FTM_WR_CnSC_CHIE(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHIE_MASK, FTM_CnSC_CHIE(value)))
#define FTM_BWR_CnSC_CHIE(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_CHIE_SHIFT), FTM_CnSC_CHIE_SHIFT, FTM_CnSC_CHIE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CnSC, field CHF[7] (ROWZ)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * reading the CSC register while CHnF is set and then writing a 0 to the CHF bit.
 * Writing a 1 to CHF has no effect. If another event occurs between the read and
 * write operations, the write operation has no effect; therefore, CHF remains set
 * indicating an event has occurred. In this case a CHF interrupt request is not
 * lost due to the clearing sequence for a previous CHF.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_CnSC_CHF field. */
#define FTM_RD_CnSC_CHF(base, index) ((FTM_CnSC_REG(base, index) & FTM_CnSC_CHF_MASK) >> FTM_CnSC_CHF_SHIFT)
#define FTM_BRD_CnSC_CHF(base, index) (BME_UBFX32(&FTM_CnSC_REG(base, index), FTM_CnSC_CHF_SHIFT, FTM_CnSC_CHF_WIDTH))

/*! @brief Set the CHF field to a new value. */
#define FTM_WR_CnSC_CHF(base, index, value) (FTM_RMW_CnSC(base, index, FTM_CnSC_CHF_MASK, FTM_CnSC_CHF(value)))
#define FTM_BWR_CnSC_CHF(base, index, value) (BME_BFI32(&FTM_CnSC_REG(base, index), ((uint32_t)(value) << FTM_CnSC_CHF_SHIFT), FTM_CnSC_CHF_SHIFT, FTM_CnSC_CHF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief FTM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured FTM counter value for the input modes or
 * the match value for the output modes. In Input Capture, Capture Test, and
 * Dual Edge Capture modes, any write to a CnV register is ignored. In output modes,
 * writing to a CnV register latches the value into a buffer. A CnV register is
 * updated with the value of its write buffer according to Registers updated from
 * write buffers. If FTMEN = 0, this write coherency mechanism may be manually
 * reset by writing to the CnSC register whether BDM mode is active or not.
 */
/*!
 * @name Constants and macros for entire FTM_CnV register
 */
/*@{*/
#define FTM_RD_CnV(base, index)  (FTM_CnV_REG(base, index))
#define FTM_WR_CnV(base, index, value) (FTM_CnV_REG(base, index) = (value))
#define FTM_RMW_CnV(base, index, mask, value) (FTM_WR_CnV(base, index, (FTM_RD_CnV(base, index) & ~(mask)) | (value)))
#define FTM_SET_CnV(base, index, value) (BME_OR32(&FTM_CnV_REG(base, index), (uint32_t)(value)))
#define FTM_CLR_CnV(base, index, value) (BME_AND32(&FTM_CnV_REG(base, index), (uint32_t)(~(value))))
#define FTM_TOG_CnV(base, index, value) (BME_XOR32(&FTM_CnV_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CnV bitfields
 */

/*!
 * @name Register FTM_CnV, field VAL[15:0] (RW)
 *
 * Captured FTM counter value of the input modes or the match value for the
 * output modes
 */
/*@{*/
/*! @brief Read current value of the FTM_CnV_VAL field. */
#define FTM_RD_CnV_VAL(base, index) ((FTM_CnV_REG(base, index) & FTM_CnV_VAL_MASK) >> FTM_CnV_VAL_SHIFT)
#define FTM_BRD_CnV_VAL(base, index) (FTM_RD_CnV_VAL(base, index))

/*! @brief Set the VAL field to a new value. */
#define FTM_WR_CnV_VAL(base, index, value) (FTM_RMW_CnV(base, index, FTM_CnV_VAL_MASK, FTM_CnV_VAL(value)))
#define FTM_BWR_CnV_VAL(base, index, value) (FTM_WR_CnV_VAL(base, index, value))
/*@}*/

/*******************************************************************************
 * FTM_CNTIN - Counter Initial Value
 ******************************************************************************/

/*!
 * @brief FTM_CNTIN - Counter Initial Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Counter Initial Value register contains the initial value for the FTM
 * counter. Writing to the CNTIN register latches the value into a buffer. The CNTIN
 * register is updated with the value of its write buffer according to Registers
 * updated from write buffers. When the FTM clock is initially selected, by
 * writing a non-zero value to the CLKS bits, the FTM counter starts with the value
 * 0x0000. To avoid this behavior, before the first write to select the FTM clock,
 * write the new value to the the CNTIN register and then initialize the FTM
 * counter by writing any value to the CNT register.
 */
/*!
 * @name Constants and macros for entire FTM_CNTIN register
 */
/*@{*/
#define FTM_RD_CNTIN(base)       (FTM_CNTIN_REG(base))
#define FTM_WR_CNTIN(base, value) (FTM_CNTIN_REG(base) = (value))
#define FTM_RMW_CNTIN(base, mask, value) (FTM_WR_CNTIN(base, (FTM_RD_CNTIN(base) & ~(mask)) | (value)))
#define FTM_SET_CNTIN(base, value) (BME_OR32(&FTM_CNTIN_REG(base), (uint32_t)(value)))
#define FTM_CLR_CNTIN(base, value) (BME_AND32(&FTM_CNTIN_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CNTIN(base, value) (BME_XOR32(&FTM_CNTIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CNTIN bitfields
 */

/*!
 * @name Register FTM_CNTIN, field INIT[15:0] (RW)
 *
 * Initial Value Of The FTM Counter
 */
/*@{*/
/*! @brief Read current value of the FTM_CNTIN_INIT field. */
#define FTM_RD_CNTIN_INIT(base) ((FTM_CNTIN_REG(base) & FTM_CNTIN_INIT_MASK) >> FTM_CNTIN_INIT_SHIFT)
#define FTM_BRD_CNTIN_INIT(base) (FTM_RD_CNTIN_INIT(base))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_CNTIN_INIT(base, value) (FTM_RMW_CNTIN(base, FTM_CNTIN_INIT_MASK, FTM_CNTIN_INIT(value)))
#define FTM_BWR_CNTIN_INIT(base, value) (FTM_WR_CNTIN_INIT(base, value))
/*@}*/

/*******************************************************************************
 * FTM_STATUS - Capture And Compare Status
 ******************************************************************************/

/*!
 * @brief FTM_STATUS - Capture And Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag CHnF bit in CnSC for
 * each FTM channel for software convenience. Each CHnF bit in STATUS is a mirror
 * of CHnF bit in CnSC. All CHnF bits can be checked using only one read of
 * STATUS. All CHnF bits can be cleared by reading STATUS followed by writing 0x00 to
 * STATUS. Hardware sets the individual channel flags when an event occurs on the
 * channel. CHnF is cleared by reading STATUS while CHnF is set and then writing
 * a 0 to the CHnF bit. Writing a 1 to CHnF has no effect. If another event
 * occurs between the read and write operations, the write operation has no effect;
 * therefore, CHnF remains set indicating an event has occurred. In this case, a
 * CHnF interrupt request is not lost due to the clearing sequence for a previous
 * CHnF.
 */
/*!
 * @name Constants and macros for entire FTM_STATUS register
 */
/*@{*/
#define FTM_RD_STATUS(base)      (FTM_STATUS_REG(base))
#define FTM_WR_STATUS(base, value) (FTM_STATUS_REG(base) = (value))
#define FTM_RMW_STATUS(base, mask, value) (FTM_WR_STATUS(base, (FTM_RD_STATUS(base) & ~(mask)) | (value)))
#define FTM_SET_STATUS(base, value) (BME_OR32(&FTM_STATUS_REG(base), (uint32_t)(value)))
#define FTM_CLR_STATUS(base, value) (BME_AND32(&FTM_STATUS_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_STATUS(base, value) (BME_XOR32(&FTM_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_STATUS bitfields
 */

/*!
 * @name Register FTM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH0F field. */
#define FTM_RD_STATUS_CH0F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH0F_MASK) >> FTM_STATUS_CH0F_SHIFT)
#define FTM_BRD_STATUS_CH0F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH0F_SHIFT, FTM_STATUS_CH0F_WIDTH))

/*! @brief Set the CH0F field to a new value. */
#define FTM_WR_STATUS_CH0F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH0F(value)))
#define FTM_BWR_STATUS_CH0F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH0F_SHIFT), FTM_STATUS_CH0F_SHIFT, FTM_STATUS_CH0F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH1F field. */
#define FTM_RD_STATUS_CH1F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH1F_MASK) >> FTM_STATUS_CH1F_SHIFT)
#define FTM_BRD_STATUS_CH1F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH1F_SHIFT, FTM_STATUS_CH1F_WIDTH))

/*! @brief Set the CH1F field to a new value. */
#define FTM_WR_STATUS_CH1F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH1F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH1F(value)))
#define FTM_BWR_STATUS_CH1F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH1F_SHIFT), FTM_STATUS_CH1F_SHIFT, FTM_STATUS_CH1F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH2F field. */
#define FTM_RD_STATUS_CH2F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH2F_MASK) >> FTM_STATUS_CH2F_SHIFT)
#define FTM_BRD_STATUS_CH2F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH2F_SHIFT, FTM_STATUS_CH2F_WIDTH))

/*! @brief Set the CH2F field to a new value. */
#define FTM_WR_STATUS_CH2F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH2F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH2F(value)))
#define FTM_BWR_STATUS_CH2F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH2F_SHIFT), FTM_STATUS_CH2F_SHIFT, FTM_STATUS_CH2F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH3F field. */
#define FTM_RD_STATUS_CH3F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH3F_MASK) >> FTM_STATUS_CH3F_SHIFT)
#define FTM_BRD_STATUS_CH3F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH3F_SHIFT, FTM_STATUS_CH3F_WIDTH))

/*! @brief Set the CH3F field to a new value. */
#define FTM_WR_STATUS_CH3F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH3F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH3F(value)))
#define FTM_BWR_STATUS_CH3F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH3F_SHIFT), FTM_STATUS_CH3F_SHIFT, FTM_STATUS_CH3F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH4F field. */
#define FTM_RD_STATUS_CH4F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH4F_MASK) >> FTM_STATUS_CH4F_SHIFT)
#define FTM_BRD_STATUS_CH4F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH4F_SHIFT, FTM_STATUS_CH4F_WIDTH))

/*! @brief Set the CH4F field to a new value. */
#define FTM_WR_STATUS_CH4F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH4F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH4F(value)))
#define FTM_BWR_STATUS_CH4F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH4F_SHIFT), FTM_STATUS_CH4F_SHIFT, FTM_STATUS_CH4F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH5F field. */
#define FTM_RD_STATUS_CH5F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH5F_MASK) >> FTM_STATUS_CH5F_SHIFT)
#define FTM_BRD_STATUS_CH5F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH5F_SHIFT, FTM_STATUS_CH5F_WIDTH))

/*! @brief Set the CH5F field to a new value. */
#define FTM_WR_STATUS_CH5F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH5F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH6F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH5F(value)))
#define FTM_BWR_STATUS_CH5F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH5F_SHIFT), FTM_STATUS_CH5F_SHIFT, FTM_STATUS_CH5F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH6F[6] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH6F field. */
#define FTM_RD_STATUS_CH6F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH6F_MASK) >> FTM_STATUS_CH6F_SHIFT)
#define FTM_BRD_STATUS_CH6F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH6F_SHIFT, FTM_STATUS_CH6F_WIDTH))

/*! @brief Set the CH6F field to a new value. */
#define FTM_WR_STATUS_CH6F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH6F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH7F_MASK), FTM_STATUS_CH6F(value)))
#define FTM_BWR_STATUS_CH6F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH6F_SHIFT), FTM_STATUS_CH6F_SHIFT, FTM_STATUS_CH6F_WIDTH))
/*@}*/

/*!
 * @name Register FTM_STATUS, field CH7F[7] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0b0 - No channel event has occurred.
 * - 0b1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the FTM_STATUS_CH7F field. */
#define FTM_RD_STATUS_CH7F(base) ((FTM_STATUS_REG(base) & FTM_STATUS_CH7F_MASK) >> FTM_STATUS_CH7F_SHIFT)
#define FTM_BRD_STATUS_CH7F(base) (BME_UBFX32(&FTM_STATUS_REG(base), FTM_STATUS_CH7F_SHIFT, FTM_STATUS_CH7F_WIDTH))

/*! @brief Set the CH7F field to a new value. */
#define FTM_WR_STATUS_CH7F(base, value) (FTM_RMW_STATUS(base, (FTM_STATUS_CH7F_MASK | FTM_STATUS_CH0F_MASK | FTM_STATUS_CH1F_MASK | FTM_STATUS_CH2F_MASK | FTM_STATUS_CH3F_MASK | FTM_STATUS_CH4F_MASK | FTM_STATUS_CH5F_MASK | FTM_STATUS_CH6F_MASK), FTM_STATUS_CH7F(value)))
#define FTM_BWR_STATUS_CH7F(base, value) (BME_BFI32(&FTM_STATUS_REG(base), ((uint32_t)(value) << FTM_STATUS_CH7F_SHIFT), FTM_STATUS_CH7F_SHIFT, FTM_STATUS_CH7F_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_MODE - Features Mode Selection
 ******************************************************************************/

/*!
 * @brief FTM_MODE - Features Mode Selection (RW)
 *
 * Reset value: 0x00000004U
 *
 * This register contains the global enable bit for FTM-specific features and
 * the control bits used to configure: Fault control mode and interrupt Capture
 * Test mode PWM synchronization Write protection Channel output initialization
 * These controls relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire FTM_MODE register
 */
/*@{*/
#define FTM_RD_MODE(base)        (FTM_MODE_REG(base))
#define FTM_WR_MODE(base, value) (FTM_MODE_REG(base) = (value))
#define FTM_RMW_MODE(base, mask, value) (FTM_WR_MODE(base, (FTM_RD_MODE(base) & ~(mask)) | (value)))
#define FTM_SET_MODE(base, value) (BME_OR32(&FTM_MODE_REG(base), (uint32_t)(value)))
#define FTM_CLR_MODE(base, value) (BME_AND32(&FTM_MODE_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_MODE(base, value) (BME_XOR32(&FTM_MODE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_MODE bitfields
 */

/*!
 * @name Register FTM_MODE, field FTMEN[0] (RW)
 *
 * This field is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - TPM compatibility. Free running counter and synchronization
 *     compatible with TPM.
 * - 0b1 - Free running counter and synchronization are different from TPM
 *     behavior.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FTMEN field. */
#define FTM_RD_MODE_FTMEN(base) ((FTM_MODE_REG(base) & FTM_MODE_FTMEN_MASK) >> FTM_MODE_FTMEN_SHIFT)
#define FTM_BRD_MODE_FTMEN(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FTMEN_SHIFT, FTM_MODE_FTMEN_WIDTH))

/*! @brief Set the FTMEN field to a new value. */
#define FTM_WR_MODE_FTMEN(base, value) (FTM_RMW_MODE(base, FTM_MODE_FTMEN_MASK, FTM_MODE_FTMEN(value)))
#define FTM_BWR_MODE_FTMEN(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FTMEN_SHIFT), FTM_MODE_FTMEN_SHIFT, FTM_MODE_FTMEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field INIT[1] (RW)
 *
 * When a 1 is written to INIT bit the channels output is initialized according
 * to the state of their corresponding bit in the OUTINIT register. Writing a 0
 * to INIT bit has no effect. The INIT bit is always read as 0.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_INIT field. */
#define FTM_RD_MODE_INIT(base) ((FTM_MODE_REG(base) & FTM_MODE_INIT_MASK) >> FTM_MODE_INIT_SHIFT)
#define FTM_BRD_MODE_INIT(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_INIT_SHIFT, FTM_MODE_INIT_WIDTH))

/*! @brief Set the INIT field to a new value. */
#define FTM_WR_MODE_INIT(base, value) (FTM_RMW_MODE(base, FTM_MODE_INIT_MASK, FTM_MODE_INIT(value)))
#define FTM_BWR_MODE_INIT(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_INIT_SHIFT), FTM_MODE_INIT_SHIFT, FTM_MODE_INIT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field WPDIS[2] (RW)
 *
 * When write protection is enabled (WPDIS = 0), write protected bits cannot be
 * written. When write protection is disabled (WPDIS = 1), write protected bits
 * can be written. The WPDIS bit is the negation of the WPEN bit. WPDIS is cleared
 * when 1 is written to WPEN. WPDIS is set when WPEN bit is read as a 1 and then
 * 1 is written to WPDIS. Writing 0 to WPDIS has no effect.
 *
 * Values:
 * - 0b0 - Write protection is enabled.
 * - 0b1 - Write protection is disabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_WPDIS field. */
#define FTM_RD_MODE_WPDIS(base) ((FTM_MODE_REG(base) & FTM_MODE_WPDIS_MASK) >> FTM_MODE_WPDIS_SHIFT)
#define FTM_BRD_MODE_WPDIS(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_WPDIS_SHIFT, FTM_MODE_WPDIS_WIDTH))

/*! @brief Set the WPDIS field to a new value. */
#define FTM_WR_MODE_WPDIS(base, value) (FTM_RMW_MODE(base, FTM_MODE_WPDIS_MASK, FTM_MODE_WPDIS(value)))
#define FTM_BWR_MODE_WPDIS(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_WPDIS_SHIFT), FTM_MODE_WPDIS_SHIFT, FTM_MODE_WPDIS_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field PWMSYNC[3] (RW)
 *
 * Selects which triggers can be used by MOD, CnV, OUTMASK, and FTM counter
 * synchronization. See PWM synchronization. The PWMSYNC bit configures the
 * synchronization when SYNCMODE is 0.
 *
 * Values:
 * - 0b0 - No restrictions. Software and hardware triggers can be used by MOD,
 *     CnV, OUTMASK, and FTM counter synchronization.
 * - 0b1 - Software trigger can only be used by MOD and CnV synchronization, and
 *     hardware triggers can only be used by OUTMASK and FTM counter
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_PWMSYNC field. */
#define FTM_RD_MODE_PWMSYNC(base) ((FTM_MODE_REG(base) & FTM_MODE_PWMSYNC_MASK) >> FTM_MODE_PWMSYNC_SHIFT)
#define FTM_BRD_MODE_PWMSYNC(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_PWMSYNC_SHIFT, FTM_MODE_PWMSYNC_WIDTH))

/*! @brief Set the PWMSYNC field to a new value. */
#define FTM_WR_MODE_PWMSYNC(base, value) (FTM_RMW_MODE(base, FTM_MODE_PWMSYNC_MASK, FTM_MODE_PWMSYNC(value)))
#define FTM_BWR_MODE_PWMSYNC(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_PWMSYNC_SHIFT), FTM_MODE_PWMSYNC_SHIFT, FTM_MODE_PWMSYNC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field CAPTEST[4] (RW)
 *
 * Enables the capture test mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Capture test mode is disabled.
 * - 0b1 - Capture test mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_CAPTEST field. */
#define FTM_RD_MODE_CAPTEST(base) ((FTM_MODE_REG(base) & FTM_MODE_CAPTEST_MASK) >> FTM_MODE_CAPTEST_SHIFT)
#define FTM_BRD_MODE_CAPTEST(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_CAPTEST_SHIFT, FTM_MODE_CAPTEST_WIDTH))

/*! @brief Set the CAPTEST field to a new value. */
#define FTM_WR_MODE_CAPTEST(base, value) (FTM_RMW_MODE(base, FTM_MODE_CAPTEST_MASK, FTM_MODE_CAPTEST(value)))
#define FTM_BWR_MODE_CAPTEST(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_CAPTEST_SHIFT), FTM_MODE_CAPTEST_SHIFT, FTM_MODE_CAPTEST_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTM[6:5] (RW)
 *
 * Defines the FTM fault control mode. This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b00 - Fault control is disabled for all channels.
 * - 0b01 - Fault control is enabled for even channels only (channels 0, 2, 4,
 *     and 6), and the selected mode is the manual fault clearing.
 * - 0b10 - Fault control is enabled for all channels, and the selected mode is
 *     the manual fault clearing.
 * - 0b11 - Fault control is enabled for all channels, and the selected mode is
 *     the automatic fault clearing.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTM field. */
#define FTM_RD_MODE_FAULTM(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTM_MASK) >> FTM_MODE_FAULTM_SHIFT)
#define FTM_BRD_MODE_FAULTM(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FAULTM_SHIFT, FTM_MODE_FAULTM_WIDTH))

/*! @brief Set the FAULTM field to a new value. */
#define FTM_WR_MODE_FAULTM(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTM_MASK, FTM_MODE_FAULTM(value)))
#define FTM_BWR_MODE_FAULTM(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FAULTM_SHIFT), FTM_MODE_FAULTM_SHIFT, FTM_MODE_FAULTM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_MODE, field FAULTIE[7] (RW)
 *
 * Enables the generation of an interrupt when a fault is detected by FTM and
 * the FTM fault control is enabled.
 *
 * Values:
 * - 0b0 - Fault control interrupt is disabled.
 * - 0b1 - Fault control interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_MODE_FAULTIE field. */
#define FTM_RD_MODE_FAULTIE(base) ((FTM_MODE_REG(base) & FTM_MODE_FAULTIE_MASK) >> FTM_MODE_FAULTIE_SHIFT)
#define FTM_BRD_MODE_FAULTIE(base) (BME_UBFX32(&FTM_MODE_REG(base), FTM_MODE_FAULTIE_SHIFT, FTM_MODE_FAULTIE_WIDTH))

/*! @brief Set the FAULTIE field to a new value. */
#define FTM_WR_MODE_FAULTIE(base, value) (FTM_RMW_MODE(base, FTM_MODE_FAULTIE_MASK, FTM_MODE_FAULTIE(value)))
#define FTM_BWR_MODE_FAULTIE(base, value) (BME_BFI32(&FTM_MODE_REG(base), ((uint32_t)(value) << FTM_MODE_FAULTIE_SHIFT), FTM_MODE_FAULTIE_SHIFT, FTM_MODE_FAULTIE_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SYNC - Synchronization
 ******************************************************************************/

/*!
 * @brief FTM_SYNC - Synchronization (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the PWM synchronization. A synchronization event can
 * perform the synchronized update of MOD, CV, and OUTMASK registers with the
 * value of their write buffer and the FTM counter initialization. The software
 * trigger, SWSYNC bit, and hardware triggers TRIG0, TRIG1, and TRIG2 bits have a
 * potential conflict if used together when SYNCMODE = 0. Use only hardware or
 * software triggers but not both at the same time, otherwise unpredictable behavior
 * is likely to happen. The selection of the loading point, CNTMAX and CNTMIN
 * bits, is intended to provide the update of MOD, CNTIN, and CnV registers across
 * all enabled channels simultaneously. The use of the loading point selection
 * together with SYNCMODE = 0 and hardware trigger selection, TRIG0, TRIG1, or TRIG2
 * bits, is likely to result in unpredictable behavior. The synchronization
 * event selection also depends on the PWMSYNC (MODE register) and SYNCMODE (SYNCONF
 * register) bits. See PWM synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SYNC register
 */
/*@{*/
#define FTM_RD_SYNC(base)        (FTM_SYNC_REG(base))
#define FTM_WR_SYNC(base, value) (FTM_SYNC_REG(base) = (value))
#define FTM_RMW_SYNC(base, mask, value) (FTM_WR_SYNC(base, (FTM_RD_SYNC(base) & ~(mask)) | (value)))
#define FTM_SET_SYNC(base, value) (BME_OR32(&FTM_SYNC_REG(base), (uint32_t)(value)))
#define FTM_CLR_SYNC(base, value) (BME_AND32(&FTM_SYNC_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SYNC(base, value) (BME_XOR32(&FTM_SYNC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNC bitfields
 */

/*!
 * @name Register FTM_SYNC, field CNTMIN[0] (RW)
 *
 * Selects the minimum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMIN is one, the selected loading point is when the
 * FTM counter reaches its minimum value (CNTIN register).
 *
 * Values:
 * - 0b0 - The minimum loading point is disabled.
 * - 0b1 - The minimum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMIN field. */
#define FTM_RD_SYNC_CNTMIN(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMIN_MASK) >> FTM_SYNC_CNTMIN_SHIFT)
#define FTM_BRD_SYNC_CNTMIN(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMIN_SHIFT, FTM_SYNC_CNTMIN_WIDTH))

/*! @brief Set the CNTMIN field to a new value. */
#define FTM_WR_SYNC_CNTMIN(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMIN_MASK, FTM_SYNC_CNTMIN(value)))
#define FTM_BWR_SYNC_CNTMIN(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_CNTMIN_SHIFT), FTM_SYNC_CNTMIN_SHIFT, FTM_SYNC_CNTMIN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field CNTMAX[1] (RW)
 *
 * Selects the maximum loading point to PWM synchronization. See Boundary cycle
 * and loading points. If CNTMAX is 1, the selected loading point is when the FTM
 * counter reaches its maximum value (MOD register).
 *
 * Values:
 * - 0b0 - The maximum loading point is disabled.
 * - 0b1 - The maximum loading point is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_CNTMAX field. */
#define FTM_RD_SYNC_CNTMAX(base) ((FTM_SYNC_REG(base) & FTM_SYNC_CNTMAX_MASK) >> FTM_SYNC_CNTMAX_SHIFT)
#define FTM_BRD_SYNC_CNTMAX(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_CNTMAX_SHIFT, FTM_SYNC_CNTMAX_WIDTH))

/*! @brief Set the CNTMAX field to a new value. */
#define FTM_WR_SYNC_CNTMAX(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_CNTMAX_MASK, FTM_SYNC_CNTMAX(value)))
#define FTM_BWR_SYNC_CNTMAX(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_CNTMAX_SHIFT), FTM_SYNC_CNTMAX_SHIFT, FTM_SYNC_CNTMAX_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field REINIT[2] (RW)
 *
 * Determines if the FTM counter is reinitialized when the selected trigger for
 * the synchronization is detected. The REINIT bit configures the synchronization
 * when SYNCMODE is zero.
 *
 * Values:
 * - 0b0 - FTM counter continues to count normally.
 * - 0b1 - FTM counter is updated with its initial value when the selected
 *     trigger is detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_REINIT field. */
#define FTM_RD_SYNC_REINIT(base) ((FTM_SYNC_REG(base) & FTM_SYNC_REINIT_MASK) >> FTM_SYNC_REINIT_SHIFT)
#define FTM_BRD_SYNC_REINIT(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_REINIT_SHIFT, FTM_SYNC_REINIT_WIDTH))

/*! @brief Set the REINIT field to a new value. */
#define FTM_WR_SYNC_REINIT(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_REINIT_MASK, FTM_SYNC_REINIT(value)))
#define FTM_BWR_SYNC_REINIT(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_REINIT_SHIFT), FTM_SYNC_REINIT_SHIFT, FTM_SYNC_REINIT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SYNCHOM[3] (RW)
 *
 * Selects when the OUTMASK register is updated with the value of its buffer.
 *
 * Values:
 * - 0b0 - OUTMASK register is updated with the value of its buffer in all
 *     rising edges of the system clock.
 * - 0b1 - OUTMASK register is updated with the value of its buffer only by the
 *     PWM synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SYNCHOM field. */
#define FTM_RD_SYNC_SYNCHOM(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SYNCHOM_MASK) >> FTM_SYNC_SYNCHOM_SHIFT)
#define FTM_BRD_SYNC_SYNCHOM(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_SYNCHOM_SHIFT, FTM_SYNC_SYNCHOM_WIDTH))

/*! @brief Set the SYNCHOM field to a new value. */
#define FTM_WR_SYNC_SYNCHOM(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SYNCHOM_MASK, FTM_SYNC_SYNCHOM(value)))
#define FTM_BWR_SYNC_SYNCHOM(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_SYNCHOM_SHIFT), FTM_SYNC_SYNCHOM_SHIFT, FTM_SYNC_SYNCHOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG0[4] (RW)
 *
 * Enables hardware trigger 0 to the PWM synchronization. Hardware trigger 0
 * occurs when a rising edge is detected at the trigger 0 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG0 field. */
#define FTM_RD_SYNC_TRIG0(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG0_MASK) >> FTM_SYNC_TRIG0_SHIFT)
#define FTM_BRD_SYNC_TRIG0(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG0_SHIFT, FTM_SYNC_TRIG0_WIDTH))

/*! @brief Set the TRIG0 field to a new value. */
#define FTM_WR_SYNC_TRIG0(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG0_MASK, FTM_SYNC_TRIG0(value)))
#define FTM_BWR_SYNC_TRIG0(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG0_SHIFT), FTM_SYNC_TRIG0_SHIFT, FTM_SYNC_TRIG0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG1[5] (RW)
 *
 * Enables hardware trigger 1 to the PWM synchronization. Hardware trigger 1
 * happens when a rising edge is detected at the trigger 1 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG1 field. */
#define FTM_RD_SYNC_TRIG1(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG1_MASK) >> FTM_SYNC_TRIG1_SHIFT)
#define FTM_BRD_SYNC_TRIG1(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG1_SHIFT, FTM_SYNC_TRIG1_WIDTH))

/*! @brief Set the TRIG1 field to a new value. */
#define FTM_WR_SYNC_TRIG1(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG1_MASK, FTM_SYNC_TRIG1(value)))
#define FTM_BWR_SYNC_TRIG1(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG1_SHIFT), FTM_SYNC_TRIG1_SHIFT, FTM_SYNC_TRIG1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field TRIG2[6] (RW)
 *
 * Enables hardware trigger 2 to the PWM synchronization. Hardware trigger 2
 * happens when a rising edge is detected at the trigger 2 input signal.
 *
 * Values:
 * - 0b0 - Trigger is disabled.
 * - 0b1 - Trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_TRIG2 field. */
#define FTM_RD_SYNC_TRIG2(base) ((FTM_SYNC_REG(base) & FTM_SYNC_TRIG2_MASK) >> FTM_SYNC_TRIG2_SHIFT)
#define FTM_BRD_SYNC_TRIG2(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_TRIG2_SHIFT, FTM_SYNC_TRIG2_WIDTH))

/*! @brief Set the TRIG2 field to a new value. */
#define FTM_WR_SYNC_TRIG2(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_TRIG2_MASK, FTM_SYNC_TRIG2(value)))
#define FTM_BWR_SYNC_TRIG2(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_TRIG2_SHIFT), FTM_SYNC_TRIG2_SHIFT, FTM_SYNC_TRIG2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNC, field SWSYNC[7] (RW)
 *
 * Selects the software trigger as the PWM synchronization trigger. The software
 * trigger happens when a 1 is written to SWSYNC bit.
 *
 * Values:
 * - 0b0 - Software trigger is not selected.
 * - 0b1 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNC_SWSYNC field. */
#define FTM_RD_SYNC_SWSYNC(base) ((FTM_SYNC_REG(base) & FTM_SYNC_SWSYNC_MASK) >> FTM_SYNC_SWSYNC_SHIFT)
#define FTM_BRD_SYNC_SWSYNC(base) (BME_UBFX32(&FTM_SYNC_REG(base), FTM_SYNC_SWSYNC_SHIFT, FTM_SYNC_SWSYNC_WIDTH))

/*! @brief Set the SWSYNC field to a new value. */
#define FTM_WR_SYNC_SWSYNC(base, value) (FTM_RMW_SYNC(base, FTM_SYNC_SWSYNC_MASK, FTM_SYNC_SWSYNC(value)))
#define FTM_BWR_SYNC_SWSYNC(base, value) (BME_BFI32(&FTM_SYNC_REG(base), ((uint32_t)(value) << FTM_SYNC_SWSYNC_SHIFT), FTM_SYNC_SWSYNC_SHIFT, FTM_SYNC_SWSYNC_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_OUTINIT - Initial State For Channels Output
 ******************************************************************************/

/*!
 * @brief FTM_OUTINIT - Initial State For Channels Output (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FTM_OUTINIT register
 */
/*@{*/
#define FTM_RD_OUTINIT(base)     (FTM_OUTINIT_REG(base))
#define FTM_WR_OUTINIT(base, value) (FTM_OUTINIT_REG(base) = (value))
#define FTM_RMW_OUTINIT(base, mask, value) (FTM_WR_OUTINIT(base, (FTM_RD_OUTINIT(base) & ~(mask)) | (value)))
#define FTM_SET_OUTINIT(base, value) (BME_OR32(&FTM_OUTINIT_REG(base), (uint32_t)(value)))
#define FTM_CLR_OUTINIT(base, value) (BME_AND32(&FTM_OUTINIT_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_OUTINIT(base, value) (BME_XOR32(&FTM_OUTINIT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTINIT bitfields
 */

/*!
 * @name Register FTM_OUTINIT, field CH0OI[0] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH0OI field. */
#define FTM_RD_OUTINIT_CH0OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH0OI_MASK) >> FTM_OUTINIT_CH0OI_SHIFT)
#define FTM_BRD_OUTINIT_CH0OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH0OI_SHIFT, FTM_OUTINIT_CH0OI_WIDTH))

/*! @brief Set the CH0OI field to a new value. */
#define FTM_WR_OUTINIT_CH0OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH0OI_MASK, FTM_OUTINIT_CH0OI(value)))
#define FTM_BWR_OUTINIT_CH0OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH0OI_SHIFT), FTM_OUTINIT_CH0OI_SHIFT, FTM_OUTINIT_CH0OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH1OI[1] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH1OI field. */
#define FTM_RD_OUTINIT_CH1OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH1OI_MASK) >> FTM_OUTINIT_CH1OI_SHIFT)
#define FTM_BRD_OUTINIT_CH1OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH1OI_SHIFT, FTM_OUTINIT_CH1OI_WIDTH))

/*! @brief Set the CH1OI field to a new value. */
#define FTM_WR_OUTINIT_CH1OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH1OI_MASK, FTM_OUTINIT_CH1OI(value)))
#define FTM_BWR_OUTINIT_CH1OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH1OI_SHIFT), FTM_OUTINIT_CH1OI_SHIFT, FTM_OUTINIT_CH1OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH2OI[2] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH2OI field. */
#define FTM_RD_OUTINIT_CH2OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH2OI_MASK) >> FTM_OUTINIT_CH2OI_SHIFT)
#define FTM_BRD_OUTINIT_CH2OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH2OI_SHIFT, FTM_OUTINIT_CH2OI_WIDTH))

/*! @brief Set the CH2OI field to a new value. */
#define FTM_WR_OUTINIT_CH2OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH2OI_MASK, FTM_OUTINIT_CH2OI(value)))
#define FTM_BWR_OUTINIT_CH2OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH2OI_SHIFT), FTM_OUTINIT_CH2OI_SHIFT, FTM_OUTINIT_CH2OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH3OI[3] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH3OI field. */
#define FTM_RD_OUTINIT_CH3OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH3OI_MASK) >> FTM_OUTINIT_CH3OI_SHIFT)
#define FTM_BRD_OUTINIT_CH3OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH3OI_SHIFT, FTM_OUTINIT_CH3OI_WIDTH))

/*! @brief Set the CH3OI field to a new value. */
#define FTM_WR_OUTINIT_CH3OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH3OI_MASK, FTM_OUTINIT_CH3OI(value)))
#define FTM_BWR_OUTINIT_CH3OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH3OI_SHIFT), FTM_OUTINIT_CH3OI_SHIFT, FTM_OUTINIT_CH3OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH4OI[4] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH4OI field. */
#define FTM_RD_OUTINIT_CH4OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH4OI_MASK) >> FTM_OUTINIT_CH4OI_SHIFT)
#define FTM_BRD_OUTINIT_CH4OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH4OI_SHIFT, FTM_OUTINIT_CH4OI_WIDTH))

/*! @brief Set the CH4OI field to a new value. */
#define FTM_WR_OUTINIT_CH4OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH4OI_MASK, FTM_OUTINIT_CH4OI(value)))
#define FTM_BWR_OUTINIT_CH4OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH4OI_SHIFT), FTM_OUTINIT_CH4OI_SHIFT, FTM_OUTINIT_CH4OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH5OI[5] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH5OI field. */
#define FTM_RD_OUTINIT_CH5OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH5OI_MASK) >> FTM_OUTINIT_CH5OI_SHIFT)
#define FTM_BRD_OUTINIT_CH5OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH5OI_SHIFT, FTM_OUTINIT_CH5OI_WIDTH))

/*! @brief Set the CH5OI field to a new value. */
#define FTM_WR_OUTINIT_CH5OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH5OI_MASK, FTM_OUTINIT_CH5OI(value)))
#define FTM_BWR_OUTINIT_CH5OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH5OI_SHIFT), FTM_OUTINIT_CH5OI_SHIFT, FTM_OUTINIT_CH5OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH6OI[6] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH6OI field. */
#define FTM_RD_OUTINIT_CH6OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH6OI_MASK) >> FTM_OUTINIT_CH6OI_SHIFT)
#define FTM_BRD_OUTINIT_CH6OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH6OI_SHIFT, FTM_OUTINIT_CH6OI_WIDTH))

/*! @brief Set the CH6OI field to a new value. */
#define FTM_WR_OUTINIT_CH6OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH6OI_MASK, FTM_OUTINIT_CH6OI(value)))
#define FTM_BWR_OUTINIT_CH6OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH6OI_SHIFT), FTM_OUTINIT_CH6OI_SHIFT, FTM_OUTINIT_CH6OI_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTINIT, field CH7OI[7] (RW)
 *
 * Selects the value that is forced into the channel output when the
 * initialization occurs.
 *
 * Values:
 * - 0b0 - The initialization value is 0.
 * - 0b1 - The initialization value is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTINIT_CH7OI field. */
#define FTM_RD_OUTINIT_CH7OI(base) ((FTM_OUTINIT_REG(base) & FTM_OUTINIT_CH7OI_MASK) >> FTM_OUTINIT_CH7OI_SHIFT)
#define FTM_BRD_OUTINIT_CH7OI(base) (BME_UBFX32(&FTM_OUTINIT_REG(base), FTM_OUTINIT_CH7OI_SHIFT, FTM_OUTINIT_CH7OI_WIDTH))

/*! @brief Set the CH7OI field to a new value. */
#define FTM_WR_OUTINIT_CH7OI(base, value) (FTM_RMW_OUTINIT(base, FTM_OUTINIT_CH7OI_MASK, FTM_OUTINIT_CH7OI(value)))
#define FTM_BWR_OUTINIT_CH7OI(base, value) (BME_BFI32(&FTM_OUTINIT_REG(base), ((uint32_t)(value) << FTM_OUTINIT_CH7OI_SHIFT), FTM_OUTINIT_CH7OI_SHIFT, FTM_OUTINIT_CH7OI_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_OUTMASK - Output Mask
 ******************************************************************************/

/*!
 * @brief FTM_OUTMASK - Output Mask (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register provides a mask for each FTM channel. The mask of a channel
 * determines if its output responds, that is, it is masked or not, when a match
 * occurs. This feature is used for BLDC control where the PWM signal is presented
 * to an electric motor at specific times to provide electronic commutation. Any
 * write to the OUTMASK register, stores the value in its write buffer. The
 * register is updated with the value of its write buffer according to PWM
 * synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_OUTMASK register
 */
/*@{*/
#define FTM_RD_OUTMASK(base)     (FTM_OUTMASK_REG(base))
#define FTM_WR_OUTMASK(base, value) (FTM_OUTMASK_REG(base) = (value))
#define FTM_RMW_OUTMASK(base, mask, value) (FTM_WR_OUTMASK(base, (FTM_RD_OUTMASK(base) & ~(mask)) | (value)))
#define FTM_SET_OUTMASK(base, value) (BME_OR32(&FTM_OUTMASK_REG(base), (uint32_t)(value)))
#define FTM_CLR_OUTMASK(base, value) (BME_AND32(&FTM_OUTMASK_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_OUTMASK(base, value) (BME_XOR32(&FTM_OUTMASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_OUTMASK bitfields
 */

/*!
 * @name Register FTM_OUTMASK, field CH0OM[0] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH0OM field. */
#define FTM_RD_OUTMASK_CH0OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH0OM_MASK) >> FTM_OUTMASK_CH0OM_SHIFT)
#define FTM_BRD_OUTMASK_CH0OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH0OM_SHIFT, FTM_OUTMASK_CH0OM_WIDTH))

/*! @brief Set the CH0OM field to a new value. */
#define FTM_WR_OUTMASK_CH0OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH0OM_MASK, FTM_OUTMASK_CH0OM(value)))
#define FTM_BWR_OUTMASK_CH0OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH0OM_SHIFT), FTM_OUTMASK_CH0OM_SHIFT, FTM_OUTMASK_CH0OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH1OM[1] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH1OM field. */
#define FTM_RD_OUTMASK_CH1OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH1OM_MASK) >> FTM_OUTMASK_CH1OM_SHIFT)
#define FTM_BRD_OUTMASK_CH1OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH1OM_SHIFT, FTM_OUTMASK_CH1OM_WIDTH))

/*! @brief Set the CH1OM field to a new value. */
#define FTM_WR_OUTMASK_CH1OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH1OM_MASK, FTM_OUTMASK_CH1OM(value)))
#define FTM_BWR_OUTMASK_CH1OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH1OM_SHIFT), FTM_OUTMASK_CH1OM_SHIFT, FTM_OUTMASK_CH1OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH2OM[2] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH2OM field. */
#define FTM_RD_OUTMASK_CH2OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH2OM_MASK) >> FTM_OUTMASK_CH2OM_SHIFT)
#define FTM_BRD_OUTMASK_CH2OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH2OM_SHIFT, FTM_OUTMASK_CH2OM_WIDTH))

/*! @brief Set the CH2OM field to a new value. */
#define FTM_WR_OUTMASK_CH2OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH2OM_MASK, FTM_OUTMASK_CH2OM(value)))
#define FTM_BWR_OUTMASK_CH2OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH2OM_SHIFT), FTM_OUTMASK_CH2OM_SHIFT, FTM_OUTMASK_CH2OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH3OM[3] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH3OM field. */
#define FTM_RD_OUTMASK_CH3OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH3OM_MASK) >> FTM_OUTMASK_CH3OM_SHIFT)
#define FTM_BRD_OUTMASK_CH3OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH3OM_SHIFT, FTM_OUTMASK_CH3OM_WIDTH))

/*! @brief Set the CH3OM field to a new value. */
#define FTM_WR_OUTMASK_CH3OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH3OM_MASK, FTM_OUTMASK_CH3OM(value)))
#define FTM_BWR_OUTMASK_CH3OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH3OM_SHIFT), FTM_OUTMASK_CH3OM_SHIFT, FTM_OUTMASK_CH3OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH4OM[4] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH4OM field. */
#define FTM_RD_OUTMASK_CH4OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH4OM_MASK) >> FTM_OUTMASK_CH4OM_SHIFT)
#define FTM_BRD_OUTMASK_CH4OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH4OM_SHIFT, FTM_OUTMASK_CH4OM_WIDTH))

/*! @brief Set the CH4OM field to a new value. */
#define FTM_WR_OUTMASK_CH4OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH4OM_MASK, FTM_OUTMASK_CH4OM(value)))
#define FTM_BWR_OUTMASK_CH4OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH4OM_SHIFT), FTM_OUTMASK_CH4OM_SHIFT, FTM_OUTMASK_CH4OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH5OM[5] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH5OM field. */
#define FTM_RD_OUTMASK_CH5OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH5OM_MASK) >> FTM_OUTMASK_CH5OM_SHIFT)
#define FTM_BRD_OUTMASK_CH5OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH5OM_SHIFT, FTM_OUTMASK_CH5OM_WIDTH))

/*! @brief Set the CH5OM field to a new value. */
#define FTM_WR_OUTMASK_CH5OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH5OM_MASK, FTM_OUTMASK_CH5OM(value)))
#define FTM_BWR_OUTMASK_CH5OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH5OM_SHIFT), FTM_OUTMASK_CH5OM_SHIFT, FTM_OUTMASK_CH5OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH6OM[6] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH6OM field. */
#define FTM_RD_OUTMASK_CH6OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH6OM_MASK) >> FTM_OUTMASK_CH6OM_SHIFT)
#define FTM_BRD_OUTMASK_CH6OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH6OM_SHIFT, FTM_OUTMASK_CH6OM_WIDTH))

/*! @brief Set the CH6OM field to a new value. */
#define FTM_WR_OUTMASK_CH6OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH6OM_MASK, FTM_OUTMASK_CH6OM(value)))
#define FTM_BWR_OUTMASK_CH6OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH6OM_SHIFT), FTM_OUTMASK_CH6OM_SHIFT, FTM_OUTMASK_CH6OM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_OUTMASK, field CH7OM[7] (RW)
 *
 * Defines if the channel output is masked or unmasked.
 *
 * Values:
 * - 0b0 - Channel output is not masked. It continues to operate normally.
 * - 0b1 - Channel output is masked. It is forced to its inactive state.
 */
/*@{*/
/*! @brief Read current value of the FTM_OUTMASK_CH7OM field. */
#define FTM_RD_OUTMASK_CH7OM(base) ((FTM_OUTMASK_REG(base) & FTM_OUTMASK_CH7OM_MASK) >> FTM_OUTMASK_CH7OM_SHIFT)
#define FTM_BRD_OUTMASK_CH7OM(base) (BME_UBFX32(&FTM_OUTMASK_REG(base), FTM_OUTMASK_CH7OM_SHIFT, FTM_OUTMASK_CH7OM_WIDTH))

/*! @brief Set the CH7OM field to a new value. */
#define FTM_WR_OUTMASK_CH7OM(base, value) (FTM_RMW_OUTMASK(base, FTM_OUTMASK_CH7OM_MASK, FTM_OUTMASK_CH7OM(value)))
#define FTM_BWR_OUTMASK_CH7OM(base, value) (BME_BFI32(&FTM_OUTMASK_REG(base), ((uint32_t)(value) << FTM_OUTMASK_CH7OM_SHIFT), FTM_OUTMASK_CH7OM_SHIFT, FTM_OUTMASK_CH7OM_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_COMBINE - Function For Linked Channels
 ******************************************************************************/

/*!
 * @brief FTM_COMBINE - Function For Linked Channels (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the fault control,
 * synchronization, deadtime insertion, Dual Edge Capture mode, Complementary,
 * and Combine mode for each pair of channels (n) and (n+1), where n equals 0, 2,
 * 4, and 6.
 */
/*!
 * @name Constants and macros for entire FTM_COMBINE register
 */
/*@{*/
#define FTM_RD_COMBINE(base)     (FTM_COMBINE_REG(base))
#define FTM_WR_COMBINE(base, value) (FTM_COMBINE_REG(base) = (value))
#define FTM_RMW_COMBINE(base, mask, value) (FTM_WR_COMBINE(base, (FTM_RD_COMBINE(base) & ~(mask)) | (value)))
#define FTM_SET_COMBINE(base, value) (BME_OR32(&FTM_COMBINE_REG(base), (uint32_t)(value)))
#define FTM_CLR_COMBINE(base, value) (BME_AND32(&FTM_COMBINE_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_COMBINE(base, value) (BME_XOR32(&FTM_COMBINE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_COMBINE bitfields
 */

/*!
 * @name Register FTM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE0 field. */
#define FTM_RD_COMBINE_COMBINE0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE0_MASK) >> FTM_COMBINE_COMBINE0_SHIFT)
#define FTM_BRD_COMBINE_COMBINE0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE0_SHIFT, FTM_COMBINE_COMBINE0_WIDTH))

/*! @brief Set the COMBINE0 field to a new value. */
#define FTM_WR_COMBINE_COMBINE0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE0_MASK, FTM_COMBINE_COMBINE0(value)))
#define FTM_BWR_COMBINE_COMBINE0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE0_SHIFT), FTM_COMBINE_COMBINE0_SHIFT, FTM_COMBINE_COMBINE0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP0[1] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP0 field. */
#define FTM_RD_COMBINE_COMP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP0_MASK) >> FTM_COMBINE_COMP0_SHIFT)
#define FTM_BRD_COMBINE_COMP0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP0_SHIFT, FTM_COMBINE_COMP0_WIDTH))

/*! @brief Set the COMP0 field to a new value. */
#define FTM_WR_COMBINE_COMP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP0_MASK, FTM_COMBINE_COMP0(value)))
#define FTM_BWR_COMBINE_COMP0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP0_SHIFT), FTM_COMBINE_COMP0_SHIFT, FTM_COMBINE_COMP0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN0[2] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN0 field. */
#define FTM_RD_COMBINE_DECAPEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN0_MASK) >> FTM_COMBINE_DECAPEN0_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN0_SHIFT, FTM_COMBINE_DECAPEN0_WIDTH))

/*! @brief Set the DECAPEN0 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN0_MASK, FTM_COMBINE_DECAPEN0(value)))
#define FTM_BWR_COMBINE_DECAPEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN0_SHIFT), FTM_COMBINE_DECAPEN0_SHIFT, FTM_COMBINE_DECAPEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP0[3] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP0 field. */
#define FTM_RD_COMBINE_DECAP0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP0_MASK) >> FTM_COMBINE_DECAP0_SHIFT)
#define FTM_BRD_COMBINE_DECAP0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP0_SHIFT, FTM_COMBINE_DECAP0_WIDTH))

/*! @brief Set the DECAP0 field to a new value. */
#define FTM_WR_COMBINE_DECAP0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP0_MASK, FTM_COMBINE_DECAP0(value)))
#define FTM_BWR_COMBINE_DECAP0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP0_SHIFT), FTM_COMBINE_DECAP0_SHIFT, FTM_COMBINE_DECAP0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN0[4] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN0 field. */
#define FTM_RD_COMBINE_DTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN0_MASK) >> FTM_COMBINE_DTEN0_SHIFT)
#define FTM_BRD_COMBINE_DTEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN0_SHIFT, FTM_COMBINE_DTEN0_WIDTH))

/*! @brief Set the DTEN0 field to a new value. */
#define FTM_WR_COMBINE_DTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN0_MASK, FTM_COMBINE_DTEN0(value)))
#define FTM_BWR_COMBINE_DTEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN0_SHIFT), FTM_COMBINE_DTEN0_SHIFT, FTM_COMBINE_DTEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN0[5] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN0 field. */
#define FTM_RD_COMBINE_SYNCEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN0_MASK) >> FTM_COMBINE_SYNCEN0_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN0_SHIFT, FTM_COMBINE_SYNCEN0_WIDTH))

/*! @brief Set the SYNCEN0 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN0_MASK, FTM_COMBINE_SYNCEN0(value)))
#define FTM_BWR_COMBINE_SYNCEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN0_SHIFT), FTM_COMBINE_SYNCEN0_SHIFT, FTM_COMBINE_SYNCEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN0[6] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN0 field. */
#define FTM_RD_COMBINE_FAULTEN0(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN0_MASK) >> FTM_COMBINE_FAULTEN0_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN0(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN0_SHIFT, FTM_COMBINE_FAULTEN0_WIDTH))

/*! @brief Set the FAULTEN0 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN0(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN0_MASK, FTM_COMBINE_FAULTEN0(value)))
#define FTM_BWR_COMBINE_FAULTEN0(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN0_SHIFT), FTM_COMBINE_FAULTEN0_SHIFT, FTM_COMBINE_FAULTEN0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE1 field. */
#define FTM_RD_COMBINE_COMBINE1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE1_MASK) >> FTM_COMBINE_COMBINE1_SHIFT)
#define FTM_BRD_COMBINE_COMBINE1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE1_SHIFT, FTM_COMBINE_COMBINE1_WIDTH))

/*! @brief Set the COMBINE1 field to a new value. */
#define FTM_WR_COMBINE_COMBINE1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE1_MASK, FTM_COMBINE_COMBINE1(value)))
#define FTM_BWR_COMBINE_COMBINE1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE1_SHIFT), FTM_COMBINE_COMBINE1_SHIFT, FTM_COMBINE_COMBINE1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP1[9] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP1 field. */
#define FTM_RD_COMBINE_COMP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP1_MASK) >> FTM_COMBINE_COMP1_SHIFT)
#define FTM_BRD_COMBINE_COMP1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP1_SHIFT, FTM_COMBINE_COMP1_WIDTH))

/*! @brief Set the COMP1 field to a new value. */
#define FTM_WR_COMBINE_COMP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP1_MASK, FTM_COMBINE_COMP1(value)))
#define FTM_BWR_COMBINE_COMP1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP1_SHIFT), FTM_COMBINE_COMP1_SHIFT, FTM_COMBINE_COMP1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN1[10] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN1 field. */
#define FTM_RD_COMBINE_DECAPEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN1_MASK) >> FTM_COMBINE_DECAPEN1_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN1_SHIFT, FTM_COMBINE_DECAPEN1_WIDTH))

/*! @brief Set the DECAPEN1 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN1_MASK, FTM_COMBINE_DECAPEN1(value)))
#define FTM_BWR_COMBINE_DECAPEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN1_SHIFT), FTM_COMBINE_DECAPEN1_SHIFT, FTM_COMBINE_DECAPEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP1[11] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * Dual Edge Capture - One-Shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP1 field. */
#define FTM_RD_COMBINE_DECAP1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP1_MASK) >> FTM_COMBINE_DECAP1_SHIFT)
#define FTM_BRD_COMBINE_DECAP1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP1_SHIFT, FTM_COMBINE_DECAP1_WIDTH))

/*! @brief Set the DECAP1 field to a new value. */
#define FTM_WR_COMBINE_DECAP1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP1_MASK, FTM_COMBINE_DECAP1(value)))
#define FTM_BWR_COMBINE_DECAP1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP1_SHIFT), FTM_COMBINE_DECAP1_SHIFT, FTM_COMBINE_DECAP1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN1[12] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN1 field. */
#define FTM_RD_COMBINE_DTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN1_MASK) >> FTM_COMBINE_DTEN1_SHIFT)
#define FTM_BRD_COMBINE_DTEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN1_SHIFT, FTM_COMBINE_DTEN1_WIDTH))

/*! @brief Set the DTEN1 field to a new value. */
#define FTM_WR_COMBINE_DTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN1_MASK, FTM_COMBINE_DTEN1(value)))
#define FTM_BWR_COMBINE_DTEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN1_SHIFT), FTM_COMBINE_DTEN1_SHIFT, FTM_COMBINE_DTEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN1[13] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN1 field. */
#define FTM_RD_COMBINE_SYNCEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN1_MASK) >> FTM_COMBINE_SYNCEN1_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN1_SHIFT, FTM_COMBINE_SYNCEN1_WIDTH))

/*! @brief Set the SYNCEN1 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN1_MASK, FTM_COMBINE_SYNCEN1(value)))
#define FTM_BWR_COMBINE_SYNCEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN1_SHIFT), FTM_COMBINE_SYNCEN1_SHIFT, FTM_COMBINE_SYNCEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN1[14] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN1 field. */
#define FTM_RD_COMBINE_FAULTEN1(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN1_MASK) >> FTM_COMBINE_FAULTEN1_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN1(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN1_SHIFT, FTM_COMBINE_FAULTEN1_WIDTH))

/*! @brief Set the FAULTEN1 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN1(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN1_MASK, FTM_COMBINE_FAULTEN1(value)))
#define FTM_BWR_COMBINE_FAULTEN1(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN1_SHIFT), FTM_COMBINE_FAULTEN1_SHIFT, FTM_COMBINE_FAULTEN1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE2 field. */
#define FTM_RD_COMBINE_COMBINE2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE2_MASK) >> FTM_COMBINE_COMBINE2_SHIFT)
#define FTM_BRD_COMBINE_COMBINE2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE2_SHIFT, FTM_COMBINE_COMBINE2_WIDTH))

/*! @brief Set the COMBINE2 field to a new value. */
#define FTM_WR_COMBINE_COMBINE2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE2_MASK, FTM_COMBINE_COMBINE2(value)))
#define FTM_BWR_COMBINE_COMBINE2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE2_SHIFT), FTM_COMBINE_COMBINE2_SHIFT, FTM_COMBINE_COMBINE2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP2[17] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP2 field. */
#define FTM_RD_COMBINE_COMP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP2_MASK) >> FTM_COMBINE_COMP2_SHIFT)
#define FTM_BRD_COMBINE_COMP2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP2_SHIFT, FTM_COMBINE_COMP2_WIDTH))

/*! @brief Set the COMP2 field to a new value. */
#define FTM_WR_COMBINE_COMP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP2_MASK, FTM_COMBINE_COMP2(value)))
#define FTM_BWR_COMBINE_COMP2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP2_SHIFT), FTM_COMBINE_COMP2_SHIFT, FTM_COMBINE_COMP2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN2[18] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN2 field. */
#define FTM_RD_COMBINE_DECAPEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN2_MASK) >> FTM_COMBINE_DECAPEN2_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN2_SHIFT, FTM_COMBINE_DECAPEN2_WIDTH))

/*! @brief Set the DECAPEN2 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN2_MASK, FTM_COMBINE_DECAPEN2(value)))
#define FTM_BWR_COMBINE_DECAPEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN2_SHIFT), FTM_COMBINE_DECAPEN2_SHIFT, FTM_COMBINE_DECAPEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP2[19] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP2 field. */
#define FTM_RD_COMBINE_DECAP2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP2_MASK) >> FTM_COMBINE_DECAP2_SHIFT)
#define FTM_BRD_COMBINE_DECAP2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP2_SHIFT, FTM_COMBINE_DECAP2_WIDTH))

/*! @brief Set the DECAP2 field to a new value. */
#define FTM_WR_COMBINE_DECAP2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP2_MASK, FTM_COMBINE_DECAP2(value)))
#define FTM_BWR_COMBINE_DECAP2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP2_SHIFT), FTM_COMBINE_DECAP2_SHIFT, FTM_COMBINE_DECAP2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN2[20] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN2 field. */
#define FTM_RD_COMBINE_DTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN2_MASK) >> FTM_COMBINE_DTEN2_SHIFT)
#define FTM_BRD_COMBINE_DTEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN2_SHIFT, FTM_COMBINE_DTEN2_WIDTH))

/*! @brief Set the DTEN2 field to a new value. */
#define FTM_WR_COMBINE_DTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN2_MASK, FTM_COMBINE_DTEN2(value)))
#define FTM_BWR_COMBINE_DTEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN2_SHIFT), FTM_COMBINE_DTEN2_SHIFT, FTM_COMBINE_DTEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN2[21] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN2 field. */
#define FTM_RD_COMBINE_SYNCEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN2_MASK) >> FTM_COMBINE_SYNCEN2_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN2_SHIFT, FTM_COMBINE_SYNCEN2_WIDTH))

/*! @brief Set the SYNCEN2 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN2_MASK, FTM_COMBINE_SYNCEN2(value)))
#define FTM_BWR_COMBINE_SYNCEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN2_SHIFT), FTM_COMBINE_SYNCEN2_SHIFT, FTM_COMBINE_SYNCEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN2[22] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN2 field. */
#define FTM_RD_COMBINE_FAULTEN2(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN2_MASK) >> FTM_COMBINE_FAULTEN2_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN2(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN2_SHIFT, FTM_COMBINE_FAULTEN2_WIDTH))

/*! @brief Set the FAULTEN2 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN2(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN2_MASK, FTM_COMBINE_FAULTEN2(value)))
#define FTM_BWR_COMBINE_FAULTEN2(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN2_SHIFT), FTM_COMBINE_FAULTEN2_SHIFT, FTM_COMBINE_FAULTEN2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMBINE3[24] (RW)
 *
 * Enables the combine feature for channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Channels (n) and (n+1) are independent.
 * - 0b1 - Channels (n) and (n+1) are combined.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMBINE3 field. */
#define FTM_RD_COMBINE_COMBINE3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMBINE3_MASK) >> FTM_COMBINE_COMBINE3_SHIFT)
#define FTM_BRD_COMBINE_COMBINE3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMBINE3_SHIFT, FTM_COMBINE_COMBINE3_WIDTH))

/*! @brief Set the COMBINE3 field to a new value. */
#define FTM_WR_COMBINE_COMBINE3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMBINE3_MASK, FTM_COMBINE_COMBINE3(value)))
#define FTM_BWR_COMBINE_COMBINE3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMBINE3_SHIFT), FTM_COMBINE_COMBINE3_SHIFT, FTM_COMBINE_COMBINE3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field COMP3[25] (RW)
 *
 * Enables Complementary mode for the combined channels. In Complementary mode
 * the channel (n+1) output is the inverse of the channel (n) output. This field
 * is write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel (n+1) output is the same as the channel (n) output.
 * - 0b1 - The channel (n+1) output is the complement of the channel (n) output.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_COMP3 field. */
#define FTM_RD_COMBINE_COMP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_COMP3_MASK) >> FTM_COMBINE_COMP3_SHIFT)
#define FTM_BRD_COMBINE_COMP3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_COMP3_SHIFT, FTM_COMBINE_COMP3_WIDTH))

/*! @brief Set the COMP3 field to a new value. */
#define FTM_WR_COMBINE_COMP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_COMP3_MASK, FTM_COMBINE_COMP3(value)))
#define FTM_BWR_COMBINE_COMP3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_COMP3_SHIFT), FTM_COMBINE_COMP3_SHIFT, FTM_COMBINE_COMP3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAPEN3[26] (RW)
 *
 * Enables the Dual Edge Capture mode in the channels (n) and (n+1). This bit
 * reconfigures the function of MSnA, ELSnB:ELSnA and ELS(n+1)B:ELS(n+1)A bits in
 * Dual Edge Capture mode according to . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The Dual Edge Capture mode in this pair of channels is disabled.
 * - 0b1 - The Dual Edge Capture mode in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAPEN3 field. */
#define FTM_RD_COMBINE_DECAPEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAPEN3_MASK) >> FTM_COMBINE_DECAPEN3_SHIFT)
#define FTM_BRD_COMBINE_DECAPEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAPEN3_SHIFT, FTM_COMBINE_DECAPEN3_WIDTH))

/*! @brief Set the DECAPEN3 field to a new value. */
#define FTM_WR_COMBINE_DECAPEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAPEN3_MASK, FTM_COMBINE_DECAPEN3(value)))
#define FTM_BWR_COMBINE_DECAPEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAPEN3_SHIFT), FTM_COMBINE_DECAPEN3_SHIFT, FTM_COMBINE_DECAPEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DECAP3[27] (RW)
 *
 * Enables the capture of the FTM counter value according to the channel (n)
 * input event and the configuration of the dual edge capture bits. This field
 * applies only when DECAPEN = 1. DECAP bit is cleared automatically by hardware if
 * dual edge capture - one-shot mode is selected and when the capture of channel
 * (n+1) event is made.
 *
 * Values:
 * - 0b0 - The dual edge captures are inactive.
 * - 0b1 - The dual edge captures are active.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DECAP3 field. */
#define FTM_RD_COMBINE_DECAP3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DECAP3_MASK) >> FTM_COMBINE_DECAP3_SHIFT)
#define FTM_BRD_COMBINE_DECAP3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DECAP3_SHIFT, FTM_COMBINE_DECAP3_WIDTH))

/*! @brief Set the DECAP3 field to a new value. */
#define FTM_WR_COMBINE_DECAP3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DECAP3_MASK, FTM_COMBINE_DECAP3(value)))
#define FTM_BWR_COMBINE_DECAP3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DECAP3_SHIFT), FTM_COMBINE_DECAP3_SHIFT, FTM_COMBINE_DECAP3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field DTEN3[28] (RW)
 *
 * Enables the deadtime insertion in the channels (n) and (n+1). This field is
 * write protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The deadtime insertion in this pair of channels is disabled.
 * - 0b1 - The deadtime insertion in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_DTEN3 field. */
#define FTM_RD_COMBINE_DTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_DTEN3_MASK) >> FTM_COMBINE_DTEN3_SHIFT)
#define FTM_BRD_COMBINE_DTEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_DTEN3_SHIFT, FTM_COMBINE_DTEN3_WIDTH))

/*! @brief Set the DTEN3 field to a new value. */
#define FTM_WR_COMBINE_DTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_DTEN3_MASK, FTM_COMBINE_DTEN3(value)))
#define FTM_BWR_COMBINE_DTEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_DTEN3_SHIFT), FTM_COMBINE_DTEN3_SHIFT, FTM_COMBINE_DTEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field SYNCEN3[29] (RW)
 *
 * Enables PWM synchronization of registers C(n)V and C(n+1)V.
 *
 * Values:
 * - 0b0 - The PWM synchronization in this pair of channels is disabled.
 * - 0b1 - The PWM synchronization in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_SYNCEN3 field. */
#define FTM_RD_COMBINE_SYNCEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_SYNCEN3_MASK) >> FTM_COMBINE_SYNCEN3_SHIFT)
#define FTM_BRD_COMBINE_SYNCEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_SYNCEN3_SHIFT, FTM_COMBINE_SYNCEN3_WIDTH))

/*! @brief Set the SYNCEN3 field to a new value. */
#define FTM_WR_COMBINE_SYNCEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_SYNCEN3_MASK, FTM_COMBINE_SYNCEN3(value)))
#define FTM_BWR_COMBINE_SYNCEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_SYNCEN3_SHIFT), FTM_COMBINE_SYNCEN3_SHIFT, FTM_COMBINE_SYNCEN3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_COMBINE, field FAULTEN3[30] (RW)
 *
 * Enables the fault control in channels (n) and (n+1). This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault control in this pair of channels is disabled.
 * - 0b1 - The fault control in this pair of channels is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_COMBINE_FAULTEN3 field. */
#define FTM_RD_COMBINE_FAULTEN3(base) ((FTM_COMBINE_REG(base) & FTM_COMBINE_FAULTEN3_MASK) >> FTM_COMBINE_FAULTEN3_SHIFT)
#define FTM_BRD_COMBINE_FAULTEN3(base) (BME_UBFX32(&FTM_COMBINE_REG(base), FTM_COMBINE_FAULTEN3_SHIFT, FTM_COMBINE_FAULTEN3_WIDTH))

/*! @brief Set the FAULTEN3 field to a new value. */
#define FTM_WR_COMBINE_FAULTEN3(base, value) (FTM_RMW_COMBINE(base, FTM_COMBINE_FAULTEN3_MASK, FTM_COMBINE_FAULTEN3(value)))
#define FTM_BWR_COMBINE_FAULTEN3(base, value) (BME_BFI32(&FTM_COMBINE_REG(base), ((uint32_t)(value) << FTM_COMBINE_FAULTEN3_SHIFT), FTM_COMBINE_FAULTEN3_SHIFT, FTM_COMBINE_FAULTEN3_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_DEADTIME - Deadtime Insertion Control
 ******************************************************************************/

/*!
 * @brief FTM_DEADTIME - Deadtime Insertion Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the deadtime prescaler factor and deadtime value. All
 * FTM channels use this clock prescaler and this deadtime value for the deadtime
 * insertion.
 */
/*!
 * @name Constants and macros for entire FTM_DEADTIME register
 */
/*@{*/
#define FTM_RD_DEADTIME(base)    (FTM_DEADTIME_REG(base))
#define FTM_WR_DEADTIME(base, value) (FTM_DEADTIME_REG(base) = (value))
#define FTM_RMW_DEADTIME(base, mask, value) (FTM_WR_DEADTIME(base, (FTM_RD_DEADTIME(base) & ~(mask)) | (value)))
#define FTM_SET_DEADTIME(base, value) (BME_OR32(&FTM_DEADTIME_REG(base), (uint32_t)(value)))
#define FTM_CLR_DEADTIME(base, value) (BME_AND32(&FTM_DEADTIME_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_DEADTIME(base, value) (BME_XOR32(&FTM_DEADTIME_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_DEADTIME bitfields
 */

/*!
 * @name Register FTM_DEADTIME, field DTVAL[5:0] (RW)
 *
 * Selects the deadtime insertion value for the deadtime counter. The deadtime
 * counter is clocked by a scaled version of the system clock. See the description
 * of DTPS. Deadtime insert value = (DTPS * DTVAL). DTVAL selects the number of
 * deadtime counts inserted as follows: When DTVAL is 0, no counts are inserted.
 * When DTVAL is 1, 1 count is inserted. When DTVAL is 2, 2 counts are inserted.
 * This pattern continues up to a possible 63 counts. This field is write
 * protected. It can be written only when MODE[WPDIS] = 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTVAL field. */
#define FTM_RD_DEADTIME_DTVAL(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTVAL_MASK) >> FTM_DEADTIME_DTVAL_SHIFT)
#define FTM_BRD_DEADTIME_DTVAL(base) (BME_UBFX32(&FTM_DEADTIME_REG(base), FTM_DEADTIME_DTVAL_SHIFT, FTM_DEADTIME_DTVAL_WIDTH))

/*! @brief Set the DTVAL field to a new value. */
#define FTM_WR_DEADTIME_DTVAL(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTVAL_MASK, FTM_DEADTIME_DTVAL(value)))
#define FTM_BWR_DEADTIME_DTVAL(base, value) (BME_BFI32(&FTM_DEADTIME_REG(base), ((uint32_t)(value) << FTM_DEADTIME_DTVAL_SHIFT), FTM_DEADTIME_DTVAL_SHIFT, FTM_DEADTIME_DTVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_DEADTIME, field DTPS[7:6] (RW)
 *
 * Selects the division factor of the system clock. This prescaled clock is used
 * by the deadtime counter. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0x - Divide the system clock by 1.
 * - 0b10 - Divide the system clock by 4.
 * - 0b11 - Divide the system clock by 16.
 */
/*@{*/
/*! @brief Read current value of the FTM_DEADTIME_DTPS field. */
#define FTM_RD_DEADTIME_DTPS(base) ((FTM_DEADTIME_REG(base) & FTM_DEADTIME_DTPS_MASK) >> FTM_DEADTIME_DTPS_SHIFT)
#define FTM_BRD_DEADTIME_DTPS(base) (BME_UBFX32(&FTM_DEADTIME_REG(base), FTM_DEADTIME_DTPS_SHIFT, FTM_DEADTIME_DTPS_WIDTH))

/*! @brief Set the DTPS field to a new value. */
#define FTM_WR_DEADTIME_DTPS(base, value) (FTM_RMW_DEADTIME(base, FTM_DEADTIME_DTPS_MASK, FTM_DEADTIME_DTPS(value)))
#define FTM_BWR_DEADTIME_DTPS(base, value) (BME_BFI32(&FTM_DEADTIME_REG(base), ((uint32_t)(value) << FTM_DEADTIME_DTPS_SHIFT), FTM_DEADTIME_DTPS_SHIFT, FTM_DEADTIME_DTPS_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_EXTTRIG - FTM External Trigger
 ******************************************************************************/

/*!
 * @brief FTM_EXTTRIG - FTM External Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register: Indicates when a channel trigger was generated Enables the
 * generation of a trigger when the FTM counter is equal to its initial value
 * Selects which channels are used in the generation of the channel triggers Several
 * channels can be selected to generate multiple triggers in one PWM period. See
 * Channel trigger output and Initialization trigger. Channels 6 and 7 are not used
 * to generate channel triggers.
 */
/*!
 * @name Constants and macros for entire FTM_EXTTRIG register
 */
/*@{*/
#define FTM_RD_EXTTRIG(base)     (FTM_EXTTRIG_REG(base))
#define FTM_WR_EXTTRIG(base, value) (FTM_EXTTRIG_REG(base) = (value))
#define FTM_RMW_EXTTRIG(base, mask, value) (FTM_WR_EXTTRIG(base, (FTM_RD_EXTTRIG(base) & ~(mask)) | (value)))
#define FTM_SET_EXTTRIG(base, value) (BME_OR32(&FTM_EXTTRIG_REG(base), (uint32_t)(value)))
#define FTM_CLR_EXTTRIG(base, value) (BME_AND32(&FTM_EXTTRIG_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_EXTTRIG(base, value) (BME_XOR32(&FTM_EXTTRIG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_EXTTRIG bitfields
 */

/*!
 * @name Register FTM_EXTTRIG, field CH2TRIG[0] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH2TRIG field. */
#define FTM_RD_EXTTRIG_CH2TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH2TRIG_MASK) >> FTM_EXTTRIG_CH2TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH2TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH2TRIG_SHIFT, FTM_EXTTRIG_CH2TRIG_WIDTH))

/*! @brief Set the CH2TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH2TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH2TRIG_MASK, FTM_EXTTRIG_CH2TRIG(value)))
#define FTM_BWR_EXTTRIG_CH2TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH2TRIG_SHIFT), FTM_EXTTRIG_CH2TRIG_SHIFT, FTM_EXTTRIG_CH2TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH3TRIG[1] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH3TRIG field. */
#define FTM_RD_EXTTRIG_CH3TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH3TRIG_MASK) >> FTM_EXTTRIG_CH3TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH3TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH3TRIG_SHIFT, FTM_EXTTRIG_CH3TRIG_WIDTH))

/*! @brief Set the CH3TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH3TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH3TRIG_MASK, FTM_EXTTRIG_CH3TRIG(value)))
#define FTM_BWR_EXTTRIG_CH3TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH3TRIG_SHIFT), FTM_EXTTRIG_CH3TRIG_SHIFT, FTM_EXTTRIG_CH3TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH4TRIG[2] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH4TRIG field. */
#define FTM_RD_EXTTRIG_CH4TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH4TRIG_MASK) >> FTM_EXTTRIG_CH4TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH4TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH4TRIG_SHIFT, FTM_EXTTRIG_CH4TRIG_WIDTH))

/*! @brief Set the CH4TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH4TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH4TRIG_MASK, FTM_EXTTRIG_CH4TRIG(value)))
#define FTM_BWR_EXTTRIG_CH4TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH4TRIG_SHIFT), FTM_EXTTRIG_CH4TRIG_SHIFT, FTM_EXTTRIG_CH4TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH5TRIG[3] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH5TRIG field. */
#define FTM_RD_EXTTRIG_CH5TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH5TRIG_MASK) >> FTM_EXTTRIG_CH5TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH5TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH5TRIG_SHIFT, FTM_EXTTRIG_CH5TRIG_WIDTH))

/*! @brief Set the CH5TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH5TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH5TRIG_MASK, FTM_EXTTRIG_CH5TRIG(value)))
#define FTM_BWR_EXTTRIG_CH5TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH5TRIG_SHIFT), FTM_EXTTRIG_CH5TRIG_SHIFT, FTM_EXTTRIG_CH5TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH0TRIG[4] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH0TRIG field. */
#define FTM_RD_EXTTRIG_CH0TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH0TRIG_MASK) >> FTM_EXTTRIG_CH0TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH0TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH0TRIG_SHIFT, FTM_EXTTRIG_CH0TRIG_WIDTH))

/*! @brief Set the CH0TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH0TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH0TRIG_MASK, FTM_EXTTRIG_CH0TRIG(value)))
#define FTM_BWR_EXTTRIG_CH0TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH0TRIG_SHIFT), FTM_EXTTRIG_CH0TRIG_SHIFT, FTM_EXTTRIG_CH0TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field CH1TRIG[5] (RW)
 *
 * Enables the generation of the channel trigger when the FTM counter is equal
 * to the CnV register.
 *
 * Values:
 * - 0b0 - The generation of the channel trigger is disabled.
 * - 0b1 - The generation of the channel trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_CH1TRIG field. */
#define FTM_RD_EXTTRIG_CH1TRIG(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_CH1TRIG_MASK) >> FTM_EXTTRIG_CH1TRIG_SHIFT)
#define FTM_BRD_EXTTRIG_CH1TRIG(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_CH1TRIG_SHIFT, FTM_EXTTRIG_CH1TRIG_WIDTH))

/*! @brief Set the CH1TRIG field to a new value. */
#define FTM_WR_EXTTRIG_CH1TRIG(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_CH1TRIG_MASK, FTM_EXTTRIG_CH1TRIG(value)))
#define FTM_BWR_EXTTRIG_CH1TRIG(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_CH1TRIG_SHIFT), FTM_EXTTRIG_CH1TRIG_SHIFT, FTM_EXTTRIG_CH1TRIG_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field INITTRIGEN[6] (RW)
 *
 * Enables the generation of the trigger when the FTM counter is equal to the
 * CNTIN register.
 *
 * Values:
 * - 0b0 - The generation of initialization trigger is disabled.
 * - 0b1 - The generation of initialization trigger is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_INITTRIGEN field. */
#define FTM_RD_EXTTRIG_INITTRIGEN(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_INITTRIGEN_MASK) >> FTM_EXTTRIG_INITTRIGEN_SHIFT)
#define FTM_BRD_EXTTRIG_INITTRIGEN(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_INITTRIGEN_SHIFT, FTM_EXTTRIG_INITTRIGEN_WIDTH))

/*! @brief Set the INITTRIGEN field to a new value. */
#define FTM_WR_EXTTRIG_INITTRIGEN(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_INITTRIGEN_MASK, FTM_EXTTRIG_INITTRIGEN(value)))
#define FTM_BWR_EXTTRIG_INITTRIGEN(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_INITTRIGEN_SHIFT), FTM_EXTTRIG_INITTRIGEN_SHIFT, FTM_EXTTRIG_INITTRIGEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_EXTTRIG, field TRIGF[7] (ROWZ)
 *
 * Set by hardware when a channel trigger is generated. Clear TRIGF by reading
 * EXTTRIG while TRIGF is set and then writing a 0 to TRIGF. Writing a 1 to TRIGF
 * has no effect. If another channel trigger is generated before the clearing
 * sequence is completed, the sequence is reset so TRIGF remains set after the clear
 * sequence is completed for the earlier TRIGF.
 *
 * Values:
 * - 0b0 - No channel trigger was generated.
 * - 0b1 - A channel trigger was generated.
 */
/*@{*/
/*! @brief Read current value of the FTM_EXTTRIG_TRIGF field. */
#define FTM_RD_EXTTRIG_TRIGF(base) ((FTM_EXTTRIG_REG(base) & FTM_EXTTRIG_TRIGF_MASK) >> FTM_EXTTRIG_TRIGF_SHIFT)
#define FTM_BRD_EXTTRIG_TRIGF(base) (BME_UBFX32(&FTM_EXTTRIG_REG(base), FTM_EXTTRIG_TRIGF_SHIFT, FTM_EXTTRIG_TRIGF_WIDTH))

/*! @brief Set the TRIGF field to a new value. */
#define FTM_WR_EXTTRIG_TRIGF(base, value) (FTM_RMW_EXTTRIG(base, FTM_EXTTRIG_TRIGF_MASK, FTM_EXTTRIG_TRIGF(value)))
#define FTM_BWR_EXTTRIG_TRIGF(base, value) (BME_BFI32(&FTM_EXTTRIG_REG(base), ((uint32_t)(value) << FTM_EXTTRIG_TRIGF_SHIFT), FTM_EXTTRIG_TRIGF_SHIFT, FTM_EXTTRIG_TRIGF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_POL - Channels Polarity
 ******************************************************************************/

/*!
 * @brief FTM_POL - Channels Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the output polarity of the FTM channels. The safe value
 * that is driven in a channel output when the fault control is enabled and a
 * fault condition is detected is the inactive state of the channel. That is, the
 * safe value of a channel is the value of its POL bit.
 */
/*!
 * @name Constants and macros for entire FTM_POL register
 */
/*@{*/
#define FTM_RD_POL(base)         (FTM_POL_REG(base))
#define FTM_WR_POL(base, value)  (FTM_POL_REG(base) = (value))
#define FTM_RMW_POL(base, mask, value) (FTM_WR_POL(base, (FTM_RD_POL(base) & ~(mask)) | (value)))
#define FTM_SET_POL(base, value) (BME_OR32(&FTM_POL_REG(base), (uint32_t)(value)))
#define FTM_CLR_POL(base, value) (BME_AND32(&FTM_POL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_POL(base, value) (BME_XOR32(&FTM_POL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_POL bitfields
 */

/*!
 * @name Register FTM_POL, field POL0[0] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL0 field. */
#define FTM_RD_POL_POL0(base) ((FTM_POL_REG(base) & FTM_POL_POL0_MASK) >> FTM_POL_POL0_SHIFT)
#define FTM_BRD_POL_POL0(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL0_SHIFT, FTM_POL_POL0_WIDTH))

/*! @brief Set the POL0 field to a new value. */
#define FTM_WR_POL_POL0(base, value) (FTM_RMW_POL(base, FTM_POL_POL0_MASK, FTM_POL_POL0(value)))
#define FTM_BWR_POL_POL0(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL0_SHIFT), FTM_POL_POL0_SHIFT, FTM_POL_POL0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL1[1] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL1 field. */
#define FTM_RD_POL_POL1(base) ((FTM_POL_REG(base) & FTM_POL_POL1_MASK) >> FTM_POL_POL1_SHIFT)
#define FTM_BRD_POL_POL1(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL1_SHIFT, FTM_POL_POL1_WIDTH))

/*! @brief Set the POL1 field to a new value. */
#define FTM_WR_POL_POL1(base, value) (FTM_RMW_POL(base, FTM_POL_POL1_MASK, FTM_POL_POL1(value)))
#define FTM_BWR_POL_POL1(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL1_SHIFT), FTM_POL_POL1_SHIFT, FTM_POL_POL1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL2[2] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL2 field. */
#define FTM_RD_POL_POL2(base) ((FTM_POL_REG(base) & FTM_POL_POL2_MASK) >> FTM_POL_POL2_SHIFT)
#define FTM_BRD_POL_POL2(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL2_SHIFT, FTM_POL_POL2_WIDTH))

/*! @brief Set the POL2 field to a new value. */
#define FTM_WR_POL_POL2(base, value) (FTM_RMW_POL(base, FTM_POL_POL2_MASK, FTM_POL_POL2(value)))
#define FTM_BWR_POL_POL2(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL2_SHIFT), FTM_POL_POL2_SHIFT, FTM_POL_POL2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL3[3] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL3 field. */
#define FTM_RD_POL_POL3(base) ((FTM_POL_REG(base) & FTM_POL_POL3_MASK) >> FTM_POL_POL3_SHIFT)
#define FTM_BRD_POL_POL3(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL3_SHIFT, FTM_POL_POL3_WIDTH))

/*! @brief Set the POL3 field to a new value. */
#define FTM_WR_POL_POL3(base, value) (FTM_RMW_POL(base, FTM_POL_POL3_MASK, FTM_POL_POL3(value)))
#define FTM_BWR_POL_POL3(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL3_SHIFT), FTM_POL_POL3_SHIFT, FTM_POL_POL3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL4[4] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL4 field. */
#define FTM_RD_POL_POL4(base) ((FTM_POL_REG(base) & FTM_POL_POL4_MASK) >> FTM_POL_POL4_SHIFT)
#define FTM_BRD_POL_POL4(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL4_SHIFT, FTM_POL_POL4_WIDTH))

/*! @brief Set the POL4 field to a new value. */
#define FTM_WR_POL_POL4(base, value) (FTM_RMW_POL(base, FTM_POL_POL4_MASK, FTM_POL_POL4(value)))
#define FTM_BWR_POL_POL4(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL4_SHIFT), FTM_POL_POL4_SHIFT, FTM_POL_POL4_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL5[5] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL5 field. */
#define FTM_RD_POL_POL5(base) ((FTM_POL_REG(base) & FTM_POL_POL5_MASK) >> FTM_POL_POL5_SHIFT)
#define FTM_BRD_POL_POL5(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL5_SHIFT, FTM_POL_POL5_WIDTH))

/*! @brief Set the POL5 field to a new value. */
#define FTM_WR_POL_POL5(base, value) (FTM_RMW_POL(base, FTM_POL_POL5_MASK, FTM_POL_POL5(value)))
#define FTM_BWR_POL_POL5(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL5_SHIFT), FTM_POL_POL5_SHIFT, FTM_POL_POL5_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL6[6] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL6 field. */
#define FTM_RD_POL_POL6(base) ((FTM_POL_REG(base) & FTM_POL_POL6_MASK) >> FTM_POL_POL6_SHIFT)
#define FTM_BRD_POL_POL6(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL6_SHIFT, FTM_POL_POL6_WIDTH))

/*! @brief Set the POL6 field to a new value. */
#define FTM_WR_POL_POL6(base, value) (FTM_RMW_POL(base, FTM_POL_POL6_MASK, FTM_POL_POL6(value)))
#define FTM_BWR_POL_POL6(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL6_SHIFT), FTM_POL_POL6_SHIFT, FTM_POL_POL6_WIDTH))
/*@}*/

/*!
 * @name Register FTM_POL, field POL7[7] (RW)
 *
 * Defines the polarity of the channel output. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The channel polarity is active high.
 * - 0b1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the FTM_POL_POL7 field. */
#define FTM_RD_POL_POL7(base) ((FTM_POL_REG(base) & FTM_POL_POL7_MASK) >> FTM_POL_POL7_SHIFT)
#define FTM_BRD_POL_POL7(base) (BME_UBFX32(&FTM_POL_REG(base), FTM_POL_POL7_SHIFT, FTM_POL_POL7_WIDTH))

/*! @brief Set the POL7 field to a new value. */
#define FTM_WR_POL_POL7(base, value) (FTM_RMW_POL(base, FTM_POL_POL7_MASK, FTM_POL_POL7(value)))
#define FTM_BWR_POL_POL7(base, value) (BME_BFI32(&FTM_POL_REG(base), ((uint32_t)(value) << FTM_POL_POL7_SHIFT), FTM_POL_POL7_SHIFT, FTM_POL_POL7_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FMS - Fault Mode Status
 ******************************************************************************/

/*!
 * @brief FTM_FMS - Fault Mode Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the fault detection flags, write protection enable
 * bit, and the logic OR of the enabled fault inputs.
 */
/*!
 * @name Constants and macros for entire FTM_FMS register
 */
/*@{*/
#define FTM_RD_FMS(base)         (FTM_FMS_REG(base))
#define FTM_WR_FMS(base, value)  (FTM_FMS_REG(base) = (value))
#define FTM_RMW_FMS(base, mask, value) (FTM_WR_FMS(base, (FTM_RD_FMS(base) & ~(mask)) | (value)))
#define FTM_SET_FMS(base, value) (BME_OR32(&FTM_FMS_REG(base), (uint32_t)(value)))
#define FTM_CLR_FMS(base, value) (BME_AND32(&FTM_FMS_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FMS(base, value) (BME_XOR32(&FTM_FMS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FMS bitfields
 */

/*!
 * @name Register FTM_FMS, field FAULTF0[0] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF0
 * by reading the FMS register while FAULTF0 is set and then writing a 0 to
 * FAULTF0 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF0 has no effect. FAULTF0 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF0 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF0 field. */
#define FTM_RD_FMS_FAULTF0(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF0_MASK) >> FTM_FMS_FAULTF0_SHIFT)
#define FTM_BRD_FMS_FAULTF0(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF0_SHIFT, FTM_FMS_FAULTF0_WIDTH))

/*! @brief Set the FAULTF0 field to a new value. */
#define FTM_WR_FMS_FAULTF0(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF0_MASK, FTM_FMS_FAULTF0(value)))
#define FTM_BWR_FMS_FAULTF0(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF0_SHIFT), FTM_FMS_FAULTF0_SHIFT, FTM_FMS_FAULTF0_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF1[1] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF1
 * by reading the FMS register while FAULTF1 is set and then writing a 0 to
 * FAULTF1 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF1 has no effect. FAULTF1 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF1 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF1 field. */
#define FTM_RD_FMS_FAULTF1(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF1_MASK) >> FTM_FMS_FAULTF1_SHIFT)
#define FTM_BRD_FMS_FAULTF1(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF1_SHIFT, FTM_FMS_FAULTF1_WIDTH))

/*! @brief Set the FAULTF1 field to a new value. */
#define FTM_WR_FMS_FAULTF1(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF1_MASK, FTM_FMS_FAULTF1(value)))
#define FTM_BWR_FMS_FAULTF1(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF1_SHIFT), FTM_FMS_FAULTF1_SHIFT, FTM_FMS_FAULTF1_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF2[2] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF2
 * by reading the FMS register while FAULTF2 is set and then writing a 0 to
 * FAULTF2 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF2 has no effect. FAULTF2 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF2 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF2 field. */
#define FTM_RD_FMS_FAULTF2(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF2_MASK) >> FTM_FMS_FAULTF2_SHIFT)
#define FTM_BRD_FMS_FAULTF2(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF2_SHIFT, FTM_FMS_FAULTF2_WIDTH))

/*! @brief Set the FAULTF2 field to a new value. */
#define FTM_WR_FMS_FAULTF2(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF2_MASK, FTM_FMS_FAULTF2(value)))
#define FTM_BWR_FMS_FAULTF2(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF2_SHIFT), FTM_FMS_FAULTF2_SHIFT, FTM_FMS_FAULTF2_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF3[3] (ROWZ)
 *
 * Set by hardware when fault control is enabled, the corresponding fault input
 * is enabled and a fault condition is detected at the fault input. Clear FAULTF3
 * by reading the FMS register while FAULTF3 is set and then writing a 0 to
 * FAULTF3 while there is no existing fault condition at the corresponding fault
 * input. Writing a 1 to FAULTF3 has no effect. FAULTF3 bit is also cleared when
 * FAULTF bit is cleared. If another fault condition is detected at the corresponding
 * fault input before the clearing sequence is completed, the sequence is reset
 * so FAULTF3 remains set after the clearing sequence is completed for the
 * earlier fault condition.
 *
 * Values:
 * - 0b0 - No fault condition was detected at the fault input.
 * - 0b1 - A fault condition was detected at the fault input.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF3 field. */
#define FTM_RD_FMS_FAULTF3(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF3_MASK) >> FTM_FMS_FAULTF3_SHIFT)
#define FTM_BRD_FMS_FAULTF3(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF3_SHIFT, FTM_FMS_FAULTF3_WIDTH))

/*! @brief Set the FAULTF3 field to a new value. */
#define FTM_WR_FMS_FAULTF3(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF3_MASK, FTM_FMS_FAULTF3(value)))
#define FTM_BWR_FMS_FAULTF3(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF3_SHIFT), FTM_FMS_FAULTF3_SHIFT, FTM_FMS_FAULTF3_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTIN[5] (RO)
 *
 * Represents the logic OR of the enabled fault inputs after their filter (if
 * their filter is enabled) when fault control is enabled.
 *
 * Values:
 * - 0b0 - The logic OR of the enabled fault inputs is 0.
 * - 0b1 - The logic OR of the enabled fault inputs is 1.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTIN field. */
#define FTM_RD_FMS_FAULTIN(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTIN_MASK) >> FTM_FMS_FAULTIN_SHIFT)
#define FTM_BRD_FMS_FAULTIN(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTIN_SHIFT, FTM_FMS_FAULTIN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field WPEN[6] (RW)
 *
 * The WPEN bit is the negation of the WPDIS bit. WPEN is set when 1 is written
 * to it. WPEN is cleared when WPEN bit is read as a 1 and then 1 is written to
 * WPDIS. Writing 0 to WPEN has no effect.
 *
 * Values:
 * - 0b0 - Write protection is disabled. Write protected bits can be written.
 * - 0b1 - Write protection is enabled. Write protected bits cannot be written.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_WPEN field. */
#define FTM_RD_FMS_WPEN(base) ((FTM_FMS_REG(base) & FTM_FMS_WPEN_MASK) >> FTM_FMS_WPEN_SHIFT)
#define FTM_BRD_FMS_WPEN(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_WPEN_SHIFT, FTM_FMS_WPEN_WIDTH))

/*! @brief Set the WPEN field to a new value. */
#define FTM_WR_FMS_WPEN(base, value) (FTM_RMW_FMS(base, FTM_FMS_WPEN_MASK, FTM_FMS_WPEN(value)))
#define FTM_BWR_FMS_WPEN(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_WPEN_SHIFT), FTM_FMS_WPEN_SHIFT, FTM_FMS_WPEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FMS, field FAULTF[7] (ROWZ)
 *
 * Represents the logic OR of the individual FAULTFj bits where j = 3, 2, 1, 0.
 * Clear FAULTF by reading the FMS register while FAULTF is set and then writing
 * a 0 to FAULTF while there is no existing fault condition at the enabled fault
 * inputs. Writing a 1 to FAULTF has no effect. If another fault condition is
 * detected in an enabled fault input before the clearing sequence is completed, the
 * sequence is reset so FAULTF remains set after the clearing sequence is
 * completed for the earlier fault condition. FAULTF is also cleared when FAULTFj bits
 * are cleared individually.
 *
 * Values:
 * - 0b0 - No fault condition was detected.
 * - 0b1 - A fault condition was detected.
 */
/*@{*/
/*! @brief Read current value of the FTM_FMS_FAULTF field. */
#define FTM_RD_FMS_FAULTF(base) ((FTM_FMS_REG(base) & FTM_FMS_FAULTF_MASK) >> FTM_FMS_FAULTF_SHIFT)
#define FTM_BRD_FMS_FAULTF(base) (BME_UBFX32(&FTM_FMS_REG(base), FTM_FMS_FAULTF_SHIFT, FTM_FMS_FAULTF_WIDTH))

/*! @brief Set the FAULTF field to a new value. */
#define FTM_WR_FMS_FAULTF(base, value) (FTM_RMW_FMS(base, FTM_FMS_FAULTF_MASK, FTM_FMS_FAULTF(value)))
#define FTM_BWR_FMS_FAULTF(base, value) (BME_BFI32(&FTM_FMS_REG(base), ((uint32_t)(value) << FTM_FMS_FAULTF_SHIFT), FTM_FMS_FAULTF_SHIFT, FTM_FMS_FAULTF_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FILTER - Input Capture Filter Control
 ******************************************************************************/

/*!
 * @brief FTM_FILTER - Input Capture Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the inputs of channels. Channels
 * 4, 5, 6 and 7 do not have an input filter. Writing to the FILTER register has
 * immediate effect and must be done only when the channels 0, 1, 2, and 3 are not
 * in input modes. Failure to do this could result in a missing valid signal.
 */
/*!
 * @name Constants and macros for entire FTM_FILTER register
 */
/*@{*/
#define FTM_RD_FILTER(base)      (FTM_FILTER_REG(base))
#define FTM_WR_FILTER(base, value) (FTM_FILTER_REG(base) = (value))
#define FTM_RMW_FILTER(base, mask, value) (FTM_WR_FILTER(base, (FTM_RD_FILTER(base) & ~(mask)) | (value)))
#define FTM_SET_FILTER(base, value) (BME_OR32(&FTM_FILTER_REG(base), (uint32_t)(value)))
#define FTM_CLR_FILTER(base, value) (BME_AND32(&FTM_FILTER_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FILTER(base, value) (BME_XOR32(&FTM_FILTER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FILTER bitfields
 */

/*!
 * @name Register FTM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH0FVAL field. */
#define FTM_RD_FILTER_CH0FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH0FVAL_MASK) >> FTM_FILTER_CH0FVAL_SHIFT)
#define FTM_BRD_FILTER_CH0FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH0FVAL_SHIFT, FTM_FILTER_CH0FVAL_WIDTH))

/*! @brief Set the CH0FVAL field to a new value. */
#define FTM_WR_FILTER_CH0FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH0FVAL_MASK, FTM_FILTER_CH0FVAL(value)))
#define FTM_BWR_FILTER_CH0FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH0FVAL_SHIFT), FTM_FILTER_CH0FVAL_SHIFT, FTM_FILTER_CH0FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH1FVAL field. */
#define FTM_RD_FILTER_CH1FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH1FVAL_MASK) >> FTM_FILTER_CH1FVAL_SHIFT)
#define FTM_BRD_FILTER_CH1FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH1FVAL_SHIFT, FTM_FILTER_CH1FVAL_WIDTH))

/*! @brief Set the CH1FVAL field to a new value. */
#define FTM_WR_FILTER_CH1FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH1FVAL_MASK, FTM_FILTER_CH1FVAL(value)))
#define FTM_BWR_FILTER_CH1FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH1FVAL_SHIFT), FTM_FILTER_CH1FVAL_SHIFT, FTM_FILTER_CH1FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH2FVAL field. */
#define FTM_RD_FILTER_CH2FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH2FVAL_MASK) >> FTM_FILTER_CH2FVAL_SHIFT)
#define FTM_BRD_FILTER_CH2FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH2FVAL_SHIFT, FTM_FILTER_CH2FVAL_WIDTH))

/*! @brief Set the CH2FVAL field to a new value. */
#define FTM_WR_FILTER_CH2FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH2FVAL_MASK, FTM_FILTER_CH2FVAL(value)))
#define FTM_BWR_FILTER_CH2FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH2FVAL_SHIFT), FTM_FILTER_CH2FVAL_SHIFT, FTM_FILTER_CH2FVAL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input. The filter is disabled when
 * the value is zero.
 */
/*@{*/
/*! @brief Read current value of the FTM_FILTER_CH3FVAL field. */
#define FTM_RD_FILTER_CH3FVAL(base) ((FTM_FILTER_REG(base) & FTM_FILTER_CH3FVAL_MASK) >> FTM_FILTER_CH3FVAL_SHIFT)
#define FTM_BRD_FILTER_CH3FVAL(base) (BME_UBFX32(&FTM_FILTER_REG(base), FTM_FILTER_CH3FVAL_SHIFT, FTM_FILTER_CH3FVAL_WIDTH))

/*! @brief Set the CH3FVAL field to a new value. */
#define FTM_WR_FILTER_CH3FVAL(base, value) (FTM_RMW_FILTER(base, FTM_FILTER_CH3FVAL_MASK, FTM_FILTER_CH3FVAL(value)))
#define FTM_BWR_FILTER_CH3FVAL(base, value) (BME_BFI32(&FTM_FILTER_REG(base), ((uint32_t)(value) << FTM_FILTER_CH3FVAL_SHIFT), FTM_FILTER_CH3FVAL_SHIFT, FTM_FILTER_CH3FVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FLTCTRL - Fault Control
 ******************************************************************************/

/*!
 * @brief FTM_FLTCTRL - Fault Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value for the fault inputs, enables the
 * fault inputs and the fault inputs filter.
 */
/*!
 * @name Constants and macros for entire FTM_FLTCTRL register
 */
/*@{*/
#define FTM_RD_FLTCTRL(base)     (FTM_FLTCTRL_REG(base))
#define FTM_WR_FLTCTRL(base, value) (FTM_FLTCTRL_REG(base) = (value))
#define FTM_RMW_FLTCTRL(base, mask, value) (FTM_WR_FLTCTRL(base, (FTM_RD_FLTCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTCTRL(base, value) (BME_OR32(&FTM_FLTCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_FLTCTRL(base, value) (BME_AND32(&FTM_FLTCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FLTCTRL(base, value) (BME_XOR32(&FTM_FLTCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTCTRL bitfields
 */

/*!
 * @name Register FTM_FLTCTRL, field FAULT0EN[0] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT0EN field. */
#define FTM_RD_FLTCTRL_FAULT0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT0EN_MASK) >> FTM_FLTCTRL_FAULT0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT0EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT0EN_SHIFT, FTM_FLTCTRL_FAULT0EN_WIDTH))

/*! @brief Set the FAULT0EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT0EN_MASK, FTM_FLTCTRL_FAULT0EN(value)))
#define FTM_BWR_FLTCTRL_FAULT0EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT0EN_SHIFT), FTM_FLTCTRL_FAULT0EN_SHIFT, FTM_FLTCTRL_FAULT0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT1EN[1] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT1EN field. */
#define FTM_RD_FLTCTRL_FAULT1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT1EN_MASK) >> FTM_FLTCTRL_FAULT1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT1EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT1EN_SHIFT, FTM_FLTCTRL_FAULT1EN_WIDTH))

/*! @brief Set the FAULT1EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT1EN_MASK, FTM_FLTCTRL_FAULT1EN(value)))
#define FTM_BWR_FLTCTRL_FAULT1EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT1EN_SHIFT), FTM_FLTCTRL_FAULT1EN_SHIFT, FTM_FLTCTRL_FAULT1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT2EN[2] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT2EN field. */
#define FTM_RD_FLTCTRL_FAULT2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT2EN_MASK) >> FTM_FLTCTRL_FAULT2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT2EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT2EN_SHIFT, FTM_FLTCTRL_FAULT2EN_WIDTH))

/*! @brief Set the FAULT2EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT2EN_MASK, FTM_FLTCTRL_FAULT2EN(value)))
#define FTM_BWR_FLTCTRL_FAULT2EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT2EN_SHIFT), FTM_FLTCTRL_FAULT2EN_SHIFT, FTM_FLTCTRL_FAULT2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FAULT3EN[3] (RW)
 *
 * Enables the fault input. This field is write protected. It can be written
 * only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input is disabled.
 * - 0b1 - Fault input is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FAULT3EN field. */
#define FTM_RD_FLTCTRL_FAULT3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FAULT3EN_MASK) >> FTM_FLTCTRL_FAULT3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FAULT3EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FAULT3EN_SHIFT, FTM_FLTCTRL_FAULT3EN_WIDTH))

/*! @brief Set the FAULT3EN field to a new value. */
#define FTM_WR_FLTCTRL_FAULT3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FAULT3EN_MASK, FTM_FLTCTRL_FAULT3EN(value)))
#define FTM_BWR_FLTCTRL_FAULT3EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FAULT3EN_SHIFT), FTM_FLTCTRL_FAULT3EN_SHIFT, FTM_FLTCTRL_FAULT3EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR0EN[4] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR0EN field. */
#define FTM_RD_FLTCTRL_FFLTR0EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR0EN_MASK) >> FTM_FLTCTRL_FFLTR0EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR0EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR0EN_SHIFT, FTM_FLTCTRL_FFLTR0EN_WIDTH))

/*! @brief Set the FFLTR0EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR0EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR0EN_MASK, FTM_FLTCTRL_FFLTR0EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR0EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR0EN_SHIFT), FTM_FLTCTRL_FFLTR0EN_SHIFT, FTM_FLTCTRL_FFLTR0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR1EN[5] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR1EN field. */
#define FTM_RD_FLTCTRL_FFLTR1EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR1EN_MASK) >> FTM_FLTCTRL_FFLTR1EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR1EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR1EN_SHIFT, FTM_FLTCTRL_FFLTR1EN_WIDTH))

/*! @brief Set the FFLTR1EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR1EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR1EN_MASK, FTM_FLTCTRL_FFLTR1EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR1EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR1EN_SHIFT), FTM_FLTCTRL_FFLTR1EN_SHIFT, FTM_FLTCTRL_FFLTR1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR2EN[6] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR2EN field. */
#define FTM_RD_FLTCTRL_FFLTR2EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR2EN_MASK) >> FTM_FLTCTRL_FFLTR2EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR2EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR2EN_SHIFT, FTM_FLTCTRL_FFLTR2EN_WIDTH))

/*! @brief Set the FFLTR2EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR2EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR2EN_MASK, FTM_FLTCTRL_FFLTR2EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR2EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR2EN_SHIFT), FTM_FLTCTRL_FFLTR2EN_SHIFT, FTM_FLTCTRL_FFLTR2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFLTR3EN[7] (RW)
 *
 * Enables the filter for the fault input. This field is write protected. It can
 * be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Fault input filter is disabled.
 * - 0b1 - Fault input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFLTR3EN field. */
#define FTM_RD_FLTCTRL_FFLTR3EN(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFLTR3EN_MASK) >> FTM_FLTCTRL_FFLTR3EN_SHIFT)
#define FTM_BRD_FLTCTRL_FFLTR3EN(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFLTR3EN_SHIFT, FTM_FLTCTRL_FFLTR3EN_WIDTH))

/*! @brief Set the FFLTR3EN field to a new value. */
#define FTM_WR_FLTCTRL_FFLTR3EN(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFLTR3EN_MASK, FTM_FLTCTRL_FFLTR3EN(value)))
#define FTM_BWR_FLTCTRL_FFLTR3EN(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFLTR3EN_SHIFT), FTM_FLTCTRL_FFLTR3EN_SHIFT, FTM_FLTCTRL_FFLTR3EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTCTRL, field FFVAL[11:8] (RW)
 *
 * Selects the filter value for the fault inputs. The fault filter is disabled
 * when the value is zero. Writing to this field has immediate effect and must be
 * done only when the fault control or all fault inputs are disabled. Failure to
 * do this could result in a missing fault detection.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTCTRL_FFVAL field. */
#define FTM_RD_FLTCTRL_FFVAL(base) ((FTM_FLTCTRL_REG(base) & FTM_FLTCTRL_FFVAL_MASK) >> FTM_FLTCTRL_FFVAL_SHIFT)
#define FTM_BRD_FLTCTRL_FFVAL(base) (BME_UBFX32(&FTM_FLTCTRL_REG(base), FTM_FLTCTRL_FFVAL_SHIFT, FTM_FLTCTRL_FFVAL_WIDTH))

/*! @brief Set the FFVAL field to a new value. */
#define FTM_WR_FLTCTRL_FFVAL(base, value) (FTM_RMW_FLTCTRL(base, FTM_FLTCTRL_FFVAL_MASK, FTM_FLTCTRL_FFVAL(value)))
#define FTM_BWR_FLTCTRL_FFVAL(base, value) (BME_BFI32(&FTM_FLTCTRL_REG(base), ((uint32_t)(value) << FTM_FLTCTRL_FFVAL_SHIFT), FTM_FLTCTRL_FFVAL_SHIFT, FTM_FLTCTRL_FFVAL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_QDCTRL - Quadrature Decoder Control And Status
 ******************************************************************************/

/*!
 * @brief FTM_QDCTRL - Quadrature Decoder Control And Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the Quadrature Decoder mode.
 */
/*!
 * @name Constants and macros for entire FTM_QDCTRL register
 */
/*@{*/
#define FTM_RD_QDCTRL(base)      (FTM_QDCTRL_REG(base))
#define FTM_WR_QDCTRL(base, value) (FTM_QDCTRL_REG(base) = (value))
#define FTM_RMW_QDCTRL(base, mask, value) (FTM_WR_QDCTRL(base, (FTM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_QDCTRL(base, value) (BME_OR32(&FTM_QDCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_QDCTRL(base, value) (BME_AND32(&FTM_QDCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_QDCTRL(base, value) (BME_XOR32(&FTM_QDCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_QDCTRL bitfields
 */

/*!
 * @name Register FTM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the Quadrature Decoder mode. In this mode, the phase A and B input
 * signals control the FTM counter direction. The Quadrature Decoder mode has
 * precedence over the other modes. See . This field is write protected. It can be
 * written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - Quadrature Decoder mode is disabled.
 * - 0b1 - Quadrature Decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADEN field. */
#define FTM_RD_QDCTRL_QUADEN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADEN_MASK) >> FTM_QDCTRL_QUADEN_SHIFT)
#define FTM_BRD_QDCTRL_QUADEN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADEN_SHIFT, FTM_QDCTRL_QUADEN_WIDTH))

/*! @brief Set the QUADEN field to a new value. */
#define FTM_WR_QDCTRL_QUADEN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADEN_MASK, FTM_QDCTRL_QUADEN(value)))
#define FTM_BWR_QDCTRL_QUADEN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_QUADEN_SHIFT), FTM_QDCTRL_QUADEN_SHIFT, FTM_QDCTRL_QUADEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0b0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (CNTIN register)
 *     to its maximum value (MOD register).
 * - 0b1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (CNTIN register).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_TOFDIR field. */
#define FTM_RD_QDCTRL_TOFDIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_TOFDIR_MASK) >> FTM_QDCTRL_TOFDIR_SHIFT)
#define FTM_BRD_QDCTRL_TOFDIR(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_TOFDIR_SHIFT, FTM_QDCTRL_TOFDIR_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0b0 - Counting direction is decreasing (FTM counter decrement).
 * - 0b1 - Counting direction is increasing (FTM counter increment).
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADIR field. */
#define FTM_RD_QDCTRL_QUADIR(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADIR_MASK) >> FTM_QDCTRL_QUADIR_SHIFT)
#define FTM_BRD_QDCTRL_QUADIR(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADIR_SHIFT, FTM_QDCTRL_QUADIR_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the Quadrature Decoder mode.
 *
 * Values:
 * - 0b0 - Phase A and phase B encoding mode.
 * - 0b1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_QUADMODE field. */
#define FTM_RD_QDCTRL_QUADMODE(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_QUADMODE_MASK) >> FTM_QDCTRL_QUADMODE_SHIFT)
#define FTM_BRD_QDCTRL_QUADMODE(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_QUADMODE_SHIFT, FTM_QDCTRL_QUADMODE_WIDTH))

/*! @brief Set the QUADMODE field to a new value. */
#define FTM_WR_QDCTRL_QUADMODE(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_QUADMODE_MASK, FTM_QDCTRL_QUADMODE(value)))
#define FTM_BWR_QDCTRL_QUADMODE(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_QUADMODE_SHIFT), FTM_QDCTRL_QUADMODE_SHIFT, FTM_QDCTRL_QUADMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBPOL[4] (RW)
 *
 * Selects the polarity for the quadrature decoder phase B input.
 *
 * Values:
 * - 0b0 - Normal polarity. Phase B input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 0b1 - Inverted polarity. Phase B input signal is inverted before
 *     identifying the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBPOL field. */
#define FTM_RD_QDCTRL_PHBPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBPOL_MASK) >> FTM_QDCTRL_PHBPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHBPOL(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBPOL_SHIFT, FTM_QDCTRL_PHBPOL_WIDTH))

/*! @brief Set the PHBPOL field to a new value. */
#define FTM_WR_QDCTRL_PHBPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBPOL_MASK, FTM_QDCTRL_PHBPOL(value)))
#define FTM_BWR_QDCTRL_PHBPOL(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHBPOL_SHIFT), FTM_QDCTRL_PHBPOL_SHIFT, FTM_QDCTRL_PHBPOL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAPOL[5] (RW)
 *
 * Selects the polarity for the quadrature decoder phase A input.
 *
 * Values:
 * - 0b0 - Normal polarity. Phase A input signal is not inverted before
 *     identifying the rising and falling edges of this signal.
 * - 0b1 - Inverted polarity. Phase A input signal is inverted before
 *     identifying the rising and falling edges of this signal.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAPOL field. */
#define FTM_RD_QDCTRL_PHAPOL(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAPOL_MASK) >> FTM_QDCTRL_PHAPOL_SHIFT)
#define FTM_BRD_QDCTRL_PHAPOL(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAPOL_SHIFT, FTM_QDCTRL_PHAPOL_WIDTH))

/*! @brief Set the PHAPOL field to a new value. */
#define FTM_WR_QDCTRL_PHAPOL(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAPOL_MASK, FTM_QDCTRL_PHAPOL(value)))
#define FTM_BWR_QDCTRL_PHAPOL(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHAPOL_SHIFT), FTM_QDCTRL_PHAPOL_SHIFT, FTM_QDCTRL_PHAPOL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHBFLTREN[6] (RW)
 *
 * Enables the filter for the quadrature decoder phase B input. The filter value
 * for the phase B input is defined by the CH1FVAL field of FILTER. The phase B
 * filter is also disabled when CH1FVAL is zero.
 *
 * Values:
 * - 0b0 - Phase B input filter is disabled.
 * - 0b1 - Phase B input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHBFLTREN field. */
#define FTM_RD_QDCTRL_PHBFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHBFLTREN_MASK) >> FTM_QDCTRL_PHBFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHBFLTREN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHBFLTREN_SHIFT, FTM_QDCTRL_PHBFLTREN_WIDTH))

/*! @brief Set the PHBFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHBFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHBFLTREN_MASK, FTM_QDCTRL_PHBFLTREN(value)))
#define FTM_BWR_QDCTRL_PHBFLTREN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHBFLTREN_SHIFT), FTM_QDCTRL_PHBFLTREN_SHIFT, FTM_QDCTRL_PHBFLTREN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_QDCTRL, field PHAFLTREN[7] (RW)
 *
 * Enables the filter for the quadrature decoder phase A input. The filter value
 * for the phase A input is defined by the CH0FVAL field of FILTER. The phase A
 * filter is also disabled when CH0FVAL is zero.
 *
 * Values:
 * - 0b0 - Phase A input filter is disabled.
 * - 0b1 - Phase A input filter is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_QDCTRL_PHAFLTREN field. */
#define FTM_RD_QDCTRL_PHAFLTREN(base) ((FTM_QDCTRL_REG(base) & FTM_QDCTRL_PHAFLTREN_MASK) >> FTM_QDCTRL_PHAFLTREN_SHIFT)
#define FTM_BRD_QDCTRL_PHAFLTREN(base) (BME_UBFX32(&FTM_QDCTRL_REG(base), FTM_QDCTRL_PHAFLTREN_SHIFT, FTM_QDCTRL_PHAFLTREN_WIDTH))

/*! @brief Set the PHAFLTREN field to a new value. */
#define FTM_WR_QDCTRL_PHAFLTREN(base, value) (FTM_RMW_QDCTRL(base, FTM_QDCTRL_PHAFLTREN_MASK, FTM_QDCTRL_PHAFLTREN(value)))
#define FTM_BWR_QDCTRL_PHAFLTREN(base, value) (BME_BFI32(&FTM_QDCTRL_REG(base), ((uint32_t)(value) << FTM_QDCTRL_PHAFLTREN_SHIFT), FTM_QDCTRL_PHAFLTREN_SHIFT, FTM_QDCTRL_PHAFLTREN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief FTM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the number of times that the FTM counter overflow
 * should occur before the TOF bit to be set, the FTM behavior in BDM modes, the use
 * of an external global time base, and the global time base signal generation.
 */
/*!
 * @name Constants and macros for entire FTM_CONF register
 */
/*@{*/
#define FTM_RD_CONF(base)        (FTM_CONF_REG(base))
#define FTM_WR_CONF(base, value) (FTM_CONF_REG(base) = (value))
#define FTM_RMW_CONF(base, mask, value) (FTM_WR_CONF(base, (FTM_RD_CONF(base) & ~(mask)) | (value)))
#define FTM_SET_CONF(base, value) (BME_OR32(&FTM_CONF_REG(base), (uint32_t)(value)))
#define FTM_CLR_CONF(base, value) (BME_AND32(&FTM_CONF_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_CONF(base, value) (BME_XOR32(&FTM_CONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_CONF bitfields
 */

/*!
 * @name Register FTM_CONF, field NUMTOF[4:0] (RW)
 *
 * Selects the ratio between the number of counter overflows to the number of
 * times the TOF bit is set. NUMTOF = 0: The TOF bit is set for each counter
 * overflow. NUMTOF = 1: The TOF bit is set for the first counter overflow but not for
 * the next overflow. NUMTOF = 2: The TOF bit is set for the first counter
 * overflow but not for the next 2 overflows. NUMTOF = 3: The TOF bit is set for the
 * first counter overflow but not for the next 3 overflows. This pattern continues
 * up to a maximum of 31.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_NUMTOF field. */
#define FTM_RD_CONF_NUMTOF(base) ((FTM_CONF_REG(base) & FTM_CONF_NUMTOF_MASK) >> FTM_CONF_NUMTOF_SHIFT)
#define FTM_BRD_CONF_NUMTOF(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_NUMTOF_SHIFT, FTM_CONF_NUMTOF_WIDTH))

/*! @brief Set the NUMTOF field to a new value. */
#define FTM_WR_CONF_NUMTOF(base, value) (FTM_RMW_CONF(base, FTM_CONF_NUMTOF_MASK, FTM_CONF_NUMTOF(value)))
#define FTM_BWR_CONF_NUMTOF(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_NUMTOF_SHIFT), FTM_CONF_NUMTOF_SHIFT, FTM_CONF_NUMTOF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field BDMMODE[7:6] (RW)
 *
 * Selects the FTM behavior in BDM mode. See BDM mode.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_BDMMODE field. */
#define FTM_RD_CONF_BDMMODE(base) ((FTM_CONF_REG(base) & FTM_CONF_BDMMODE_MASK) >> FTM_CONF_BDMMODE_SHIFT)
#define FTM_BRD_CONF_BDMMODE(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_BDMMODE_SHIFT, FTM_CONF_BDMMODE_WIDTH))

/*! @brief Set the BDMMODE field to a new value. */
#define FTM_WR_CONF_BDMMODE(base, value) (FTM_RMW_CONF(base, FTM_CONF_BDMMODE_MASK, FTM_CONF_BDMMODE(value)))
#define FTM_BWR_CONF_BDMMODE(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_BDMMODE_SHIFT), FTM_CONF_BDMMODE_SHIFT, FTM_CONF_BDMMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the FTM to use an external global time base signal that is
 * generated by another FTM.
 *
 * Values:
 * - 0b0 - Use of an external global time base is disabled.
 * - 0b1 - Use of an external global time base is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEEN field. */
#define FTM_RD_CONF_GTBEEN(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEEN_MASK) >> FTM_CONF_GTBEEN_SHIFT)
#define FTM_BRD_CONF_GTBEEN(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_GTBEEN_SHIFT, FTM_CONF_GTBEEN_WIDTH))

/*! @brief Set the GTBEEN field to a new value. */
#define FTM_WR_CONF_GTBEEN(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEEN_MASK, FTM_CONF_GTBEEN(value)))
#define FTM_BWR_CONF_GTBEEN(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_GTBEEN_SHIFT), FTM_CONF_GTBEEN_SHIFT, FTM_CONF_GTBEEN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_CONF, field GTBEOUT[10] (RW)
 *
 * Enables the global time base signal generation to other FTMs.
 *
 * Values:
 * - 0b0 - A global time base signal generation is disabled.
 * - 0b1 - A global time base signal generation is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_CONF_GTBEOUT field. */
#define FTM_RD_CONF_GTBEOUT(base) ((FTM_CONF_REG(base) & FTM_CONF_GTBEOUT_MASK) >> FTM_CONF_GTBEOUT_SHIFT)
#define FTM_BRD_CONF_GTBEOUT(base) (BME_UBFX32(&FTM_CONF_REG(base), FTM_CONF_GTBEOUT_SHIFT, FTM_CONF_GTBEOUT_WIDTH))

/*! @brief Set the GTBEOUT field to a new value. */
#define FTM_WR_CONF_GTBEOUT(base, value) (FTM_RMW_CONF(base, FTM_CONF_GTBEOUT_MASK, FTM_CONF_GTBEOUT(value)))
#define FTM_BWR_CONF_GTBEOUT(base, value) (BME_BFI32(&FTM_CONF_REG(base), ((uint32_t)(value) << FTM_CONF_GTBEOUT_SHIFT), FTM_CONF_GTBEOUT_SHIFT, FTM_CONF_GTBEOUT_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_FLTPOL - FTM Fault Input Polarity
 ******************************************************************************/

/*!
 * @brief FTM_FLTPOL - FTM Fault Input Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the fault inputs polarity.
 */
/*!
 * @name Constants and macros for entire FTM_FLTPOL register
 */
/*@{*/
#define FTM_RD_FLTPOL(base)      (FTM_FLTPOL_REG(base))
#define FTM_WR_FLTPOL(base, value) (FTM_FLTPOL_REG(base) = (value))
#define FTM_RMW_FLTPOL(base, mask, value) (FTM_WR_FLTPOL(base, (FTM_RD_FLTPOL(base) & ~(mask)) | (value)))
#define FTM_SET_FLTPOL(base, value) (BME_OR32(&FTM_FLTPOL_REG(base), (uint32_t)(value)))
#define FTM_CLR_FLTPOL(base, value) (BME_AND32(&FTM_FLTPOL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_FLTPOL(base, value) (BME_XOR32(&FTM_FLTPOL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_FLTPOL bitfields
 */

/*!
 * @name Register FTM_FLTPOL, field FLT0POL[0] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT0POL field. */
#define FTM_RD_FLTPOL_FLT0POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT0POL_MASK) >> FTM_FLTPOL_FLT0POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT0POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT0POL_SHIFT, FTM_FLTPOL_FLT0POL_WIDTH))

/*! @brief Set the FLT0POL field to a new value. */
#define FTM_WR_FLTPOL_FLT0POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT0POL_MASK, FTM_FLTPOL_FLT0POL(value)))
#define FTM_BWR_FLTPOL_FLT0POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT0POL_SHIFT), FTM_FLTPOL_FLT0POL_SHIFT, FTM_FLTPOL_FLT0POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT1POL[1] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT1POL field. */
#define FTM_RD_FLTPOL_FLT1POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT1POL_MASK) >> FTM_FLTPOL_FLT1POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT1POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT1POL_SHIFT, FTM_FLTPOL_FLT1POL_WIDTH))

/*! @brief Set the FLT1POL field to a new value. */
#define FTM_WR_FLTPOL_FLT1POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT1POL_MASK, FTM_FLTPOL_FLT1POL(value)))
#define FTM_BWR_FLTPOL_FLT1POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT1POL_SHIFT), FTM_FLTPOL_FLT1POL_SHIFT, FTM_FLTPOL_FLT1POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT2POL[2] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT2POL field. */
#define FTM_RD_FLTPOL_FLT2POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT2POL_MASK) >> FTM_FLTPOL_FLT2POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT2POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT2POL_SHIFT, FTM_FLTPOL_FLT2POL_WIDTH))

/*! @brief Set the FLT2POL field to a new value. */
#define FTM_WR_FLTPOL_FLT2POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT2POL_MASK, FTM_FLTPOL_FLT2POL(value)))
#define FTM_BWR_FLTPOL_FLT2POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT2POL_SHIFT), FTM_FLTPOL_FLT2POL_SHIFT, FTM_FLTPOL_FLT2POL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_FLTPOL, field FLT3POL[3] (RW)
 *
 * Defines the polarity of the fault input. This field is write protected. It
 * can be written only when MODE[WPDIS] = 1.
 *
 * Values:
 * - 0b0 - The fault input polarity is active high. A 1 at the fault input
 *     indicates a fault.
 * - 0b1 - The fault input polarity is active low. A 0 at the fault input
 *     indicates a fault.
 */
/*@{*/
/*! @brief Read current value of the FTM_FLTPOL_FLT3POL field. */
#define FTM_RD_FLTPOL_FLT3POL(base) ((FTM_FLTPOL_REG(base) & FTM_FLTPOL_FLT3POL_MASK) >> FTM_FLTPOL_FLT3POL_SHIFT)
#define FTM_BRD_FLTPOL_FLT3POL(base) (BME_UBFX32(&FTM_FLTPOL_REG(base), FTM_FLTPOL_FLT3POL_SHIFT, FTM_FLTPOL_FLT3POL_WIDTH))

/*! @brief Set the FLT3POL field to a new value. */
#define FTM_WR_FLTPOL_FLT3POL(base, value) (FTM_RMW_FLTPOL(base, FTM_FLTPOL_FLT3POL_MASK, FTM_FLTPOL_FLT3POL(value)))
#define FTM_BWR_FLTPOL_FLT3POL(base, value) (BME_BFI32(&FTM_FLTPOL_REG(base), ((uint32_t)(value) << FTM_FLTPOL_FLT3POL_SHIFT), FTM_FLTPOL_FLT3POL_SHIFT, FTM_FLTPOL_FLT3POL_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SYNCONF - Synchronization Configuration
 ******************************************************************************/

/*!
 * @brief FTM_SYNCONF - Synchronization Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the PWM synchronization configuration, SWOCTRL, INVCTRL
 * and CNTIN registers synchronization, if FTM clears the TRIGj bit, where j =
 * 0, 1, 2, when the hardware trigger j is detected.
 */
/*!
 * @name Constants and macros for entire FTM_SYNCONF register
 */
/*@{*/
#define FTM_RD_SYNCONF(base)     (FTM_SYNCONF_REG(base))
#define FTM_WR_SYNCONF(base, value) (FTM_SYNCONF_REG(base) = (value))
#define FTM_RMW_SYNCONF(base, mask, value) (FTM_WR_SYNCONF(base, (FTM_RD_SYNCONF(base) & ~(mask)) | (value)))
#define FTM_SET_SYNCONF(base, value) (BME_OR32(&FTM_SYNCONF_REG(base), (uint32_t)(value)))
#define FTM_CLR_SYNCONF(base, value) (BME_AND32(&FTM_SYNCONF_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SYNCONF(base, value) (BME_XOR32(&FTM_SYNCONF_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SYNCONF bitfields
 */

/*!
 * @name Register FTM_SYNCONF, field HWTRIGMODE[0] (RW)
 *
 * Values:
 * - 0b0 - FTM clears the TRIGj bit when the hardware trigger j is detected,
 *     where j = 0, 1,2.
 * - 0b1 - FTM does not clear the TRIGj bit when the hardware trigger j is
 *     detected, where j = 0, 1,2.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWTRIGMODE field. */
#define FTM_RD_SYNCONF_HWTRIGMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWTRIGMODE_MASK) >> FTM_SYNCONF_HWTRIGMODE_SHIFT)
#define FTM_BRD_SYNCONF_HWTRIGMODE(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWTRIGMODE_SHIFT, FTM_SYNCONF_HWTRIGMODE_WIDTH))

/*! @brief Set the HWTRIGMODE field to a new value. */
#define FTM_WR_SYNCONF_HWTRIGMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWTRIGMODE_MASK, FTM_SYNCONF_HWTRIGMODE(value)))
#define FTM_BWR_SYNCONF_HWTRIGMODE(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWTRIGMODE_SHIFT), FTM_SYNCONF_HWTRIGMODE_SHIFT, FTM_SYNCONF_HWTRIGMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field CNTINC[2] (RW)
 *
 * Values:
 * - 0b0 - CNTIN register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - CNTIN register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_CNTINC field. */
#define FTM_RD_SYNCONF_CNTINC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_CNTINC_MASK) >> FTM_SYNCONF_CNTINC_SHIFT)
#define FTM_BRD_SYNCONF_CNTINC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_CNTINC_SHIFT, FTM_SYNCONF_CNTINC_WIDTH))

/*! @brief Set the CNTINC field to a new value. */
#define FTM_WR_SYNCONF_CNTINC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_CNTINC_MASK, FTM_SYNCONF_CNTINC(value)))
#define FTM_BWR_SYNCONF_CNTINC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_CNTINC_SHIFT), FTM_SYNCONF_CNTINC_SHIFT, FTM_SYNCONF_CNTINC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field INVC[4] (RW)
 *
 * Values:
 * - 0b0 - INVCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - INVCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_INVC field. */
#define FTM_RD_SYNCONF_INVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_INVC_MASK) >> FTM_SYNCONF_INVC_SHIFT)
#define FTM_BRD_SYNCONF_INVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_INVC_SHIFT, FTM_SYNCONF_INVC_WIDTH))

/*! @brief Set the INVC field to a new value. */
#define FTM_WR_SYNCONF_INVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_INVC_MASK, FTM_SYNCONF_INVC(value)))
#define FTM_BWR_SYNCONF_INVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_INVC_SHIFT), FTM_SYNCONF_INVC_SHIFT, FTM_SYNCONF_INVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOC[5] (RW)
 *
 * Values:
 * - 0b0 - SWOCTRL register is updated with its buffer value at all rising edges
 *     of system clock.
 * - 0b1 - SWOCTRL register is updated with its buffer value by the PWM
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOC field. */
#define FTM_RD_SYNCONF_SWOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOC_MASK) >> FTM_SYNCONF_SWOC_SHIFT)
#define FTM_BRD_SYNCONF_SWOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOC_SHIFT, FTM_SYNCONF_SWOC_WIDTH))

/*! @brief Set the SWOC field to a new value. */
#define FTM_WR_SYNCONF_SWOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOC_MASK, FTM_SYNCONF_SWOC(value)))
#define FTM_BWR_SYNCONF_SWOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWOC_SHIFT), FTM_SYNCONF_SWOC_SHIFT, FTM_SYNCONF_SWOC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SYNCMODE[7] (RW)
 *
 * Selects the PWM Synchronization mode.
 *
 * Values:
 * - 0b0 - Legacy PWM synchronization is selected.
 * - 0b1 - Enhanced PWM synchronization is selected.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SYNCMODE field. */
#define FTM_RD_SYNCONF_SYNCMODE(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SYNCMODE_MASK) >> FTM_SYNCONF_SYNCMODE_SHIFT)
#define FTM_BRD_SYNCONF_SYNCMODE(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SYNCMODE_SHIFT, FTM_SYNCONF_SYNCMODE_WIDTH))

/*! @brief Set the SYNCMODE field to a new value. */
#define FTM_WR_SYNCONF_SYNCMODE(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SYNCMODE_MASK, FTM_SYNCONF_SYNCMODE(value)))
#define FTM_BWR_SYNCONF_SYNCMODE(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SYNCMODE_SHIFT), FTM_SYNCONF_SYNCMODE_SHIFT, FTM_SYNCONF_SYNCMODE_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWRSTCNT[8] (RW)
 *
 * FTM counter synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the FTM counter
 *     synchronization.
 * - 0b1 - The software trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWRSTCNT field. */
#define FTM_RD_SYNCONF_SWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWRSTCNT_MASK) >> FTM_SYNCONF_SWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_SWRSTCNT(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWRSTCNT_SHIFT, FTM_SYNCONF_SWRSTCNT_WIDTH))

/*! @brief Set the SWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_SWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWRSTCNT_MASK, FTM_SYNCONF_SWRSTCNT(value)))
#define FTM_BWR_SYNCONF_SWRSTCNT(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWRSTCNT_SHIFT), FTM_SYNCONF_SWRSTCNT_SHIFT, FTM_SYNCONF_SWRSTCNT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWWRBUF[9] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by the software
 * trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 0b1 - The software trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWWRBUF field. */
#define FTM_RD_SYNCONF_SWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWWRBUF_MASK) >> FTM_SYNCONF_SWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_SWWRBUF(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWWRBUF_SHIFT, FTM_SYNCONF_SWWRBUF_WIDTH))

/*! @brief Set the SWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_SWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWWRBUF_MASK, FTM_SYNCONF_SWWRBUF(value)))
#define FTM_BWR_SYNCONF_SWWRBUF(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWWRBUF_SHIFT), FTM_SYNCONF_SWWRBUF_SHIFT, FTM_SYNCONF_SWWRBUF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWOM[10] (RW)
 *
 * Output mask synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the OUTMASK register
 *     synchronization.
 * - 0b1 - The software trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWOM field. */
#define FTM_RD_SYNCONF_SWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWOM_MASK) >> FTM_SYNCONF_SWOM_SHIFT)
#define FTM_BRD_SYNCONF_SWOM(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWOM_SHIFT, FTM_SYNCONF_SWOM_WIDTH))

/*! @brief Set the SWOM field to a new value. */
#define FTM_WR_SYNCONF_SWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWOM_MASK, FTM_SYNCONF_SWOM(value)))
#define FTM_BWR_SYNCONF_SWOM(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWOM_SHIFT), FTM_SYNCONF_SWOM_SHIFT, FTM_SYNCONF_SWOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWINVC[11] (RW)
 *
 * Inverting control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the INVCTRL register
 *     synchronization.
 * - 0b1 - The software trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWINVC field. */
#define FTM_RD_SYNCONF_SWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWINVC_MASK) >> FTM_SYNCONF_SWINVC_SHIFT)
#define FTM_BRD_SYNCONF_SWINVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWINVC_SHIFT, FTM_SYNCONF_SWINVC_WIDTH))

/*! @brief Set the SWINVC field to a new value. */
#define FTM_WR_SYNCONF_SWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWINVC_MASK, FTM_SYNCONF_SWINVC(value)))
#define FTM_BWR_SYNCONF_SWINVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWINVC_SHIFT), FTM_SYNCONF_SWINVC_SHIFT, FTM_SYNCONF_SWINVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field SWSOC[12] (RW)
 *
 * Software output control synchronization is activated by the software trigger.
 *
 * Values:
 * - 0b0 - The software trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 0b1 - The software trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_SWSOC field. */
#define FTM_RD_SYNCONF_SWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_SWSOC_MASK) >> FTM_SYNCONF_SWSOC_SHIFT)
#define FTM_BRD_SYNCONF_SWSOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_SWSOC_SHIFT, FTM_SYNCONF_SWSOC_WIDTH))

/*! @brief Set the SWSOC field to a new value. */
#define FTM_WR_SYNCONF_SWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_SWSOC_MASK, FTM_SYNCONF_SWSOC(value)))
#define FTM_BWR_SYNCONF_SWSOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_SWSOC_SHIFT), FTM_SYNCONF_SWSOC_SHIFT, FTM_SYNCONF_SWSOC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWRSTCNT[16] (RW)
 *
 * FTM counter synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the FTM counter synchronization.
 * - 0b1 - A hardware trigger activates the FTM counter synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWRSTCNT field. */
#define FTM_RD_SYNCONF_HWRSTCNT(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWRSTCNT_MASK) >> FTM_SYNCONF_HWRSTCNT_SHIFT)
#define FTM_BRD_SYNCONF_HWRSTCNT(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWRSTCNT_SHIFT, FTM_SYNCONF_HWRSTCNT_WIDTH))

/*! @brief Set the HWRSTCNT field to a new value. */
#define FTM_WR_SYNCONF_HWRSTCNT(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWRSTCNT_MASK, FTM_SYNCONF_HWRSTCNT(value)))
#define FTM_BWR_SYNCONF_HWRSTCNT(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWRSTCNT_SHIFT), FTM_SYNCONF_HWRSTCNT_SHIFT, FTM_SYNCONF_HWRSTCNT_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWWRBUF[17] (RW)
 *
 * MOD, CNTIN, and CV registers synchronization is activated by a hardware
 * trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate MOD, CNTIN, and CV registers
 *     synchronization.
 * - 0b1 - A hardware trigger activates MOD, CNTIN, and CV registers
 *     synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWWRBUF field. */
#define FTM_RD_SYNCONF_HWWRBUF(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWWRBUF_MASK) >> FTM_SYNCONF_HWWRBUF_SHIFT)
#define FTM_BRD_SYNCONF_HWWRBUF(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWWRBUF_SHIFT, FTM_SYNCONF_HWWRBUF_WIDTH))

/*! @brief Set the HWWRBUF field to a new value. */
#define FTM_WR_SYNCONF_HWWRBUF(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWWRBUF_MASK, FTM_SYNCONF_HWWRBUF(value)))
#define FTM_BWR_SYNCONF_HWWRBUF(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWWRBUF_SHIFT), FTM_SYNCONF_HWWRBUF_SHIFT, FTM_SYNCONF_HWWRBUF_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWOM[18] (RW)
 *
 * Output mask synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the OUTMASK register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the OUTMASK register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWOM field. */
#define FTM_RD_SYNCONF_HWOM(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWOM_MASK) >> FTM_SYNCONF_HWOM_SHIFT)
#define FTM_BRD_SYNCONF_HWOM(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWOM_SHIFT, FTM_SYNCONF_HWOM_WIDTH))

/*! @brief Set the HWOM field to a new value. */
#define FTM_WR_SYNCONF_HWOM(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWOM_MASK, FTM_SYNCONF_HWOM(value)))
#define FTM_BWR_SYNCONF_HWOM(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWOM_SHIFT), FTM_SYNCONF_HWOM_SHIFT, FTM_SYNCONF_HWOM_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWINVC[19] (RW)
 *
 * Inverting control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the INVCTRL register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the INVCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWINVC field. */
#define FTM_RD_SYNCONF_HWINVC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWINVC_MASK) >> FTM_SYNCONF_HWINVC_SHIFT)
#define FTM_BRD_SYNCONF_HWINVC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWINVC_SHIFT, FTM_SYNCONF_HWINVC_WIDTH))

/*! @brief Set the HWINVC field to a new value. */
#define FTM_WR_SYNCONF_HWINVC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWINVC_MASK, FTM_SYNCONF_HWINVC(value)))
#define FTM_BWR_SYNCONF_HWINVC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWINVC_SHIFT), FTM_SYNCONF_HWINVC_SHIFT, FTM_SYNCONF_HWINVC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SYNCONF, field HWSOC[20] (RW)
 *
 * Software output control synchronization is activated by a hardware trigger.
 *
 * Values:
 * - 0b0 - A hardware trigger does not activate the SWOCTRL register
 *     synchronization.
 * - 0b1 - A hardware trigger activates the SWOCTRL register synchronization.
 */
/*@{*/
/*! @brief Read current value of the FTM_SYNCONF_HWSOC field. */
#define FTM_RD_SYNCONF_HWSOC(base) ((FTM_SYNCONF_REG(base) & FTM_SYNCONF_HWSOC_MASK) >> FTM_SYNCONF_HWSOC_SHIFT)
#define FTM_BRD_SYNCONF_HWSOC(base) (BME_UBFX32(&FTM_SYNCONF_REG(base), FTM_SYNCONF_HWSOC_SHIFT, FTM_SYNCONF_HWSOC_WIDTH))

/*! @brief Set the HWSOC field to a new value. */
#define FTM_WR_SYNCONF_HWSOC(base, value) (FTM_RMW_SYNCONF(base, FTM_SYNCONF_HWSOC_MASK, FTM_SYNCONF_HWSOC(value)))
#define FTM_BWR_SYNCONF_HWSOC(base, value) (BME_BFI32(&FTM_SYNCONF_REG(base), ((uint32_t)(value) << FTM_SYNCONF_HWSOC_SHIFT), FTM_SYNCONF_HWSOC_SHIFT, FTM_SYNCONF_HWSOC_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_INVCTRL - FTM Inverting Control
 ******************************************************************************/

/*!
 * @brief FTM_INVCTRL - FTM Inverting Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls when the channel (n) output becomes the channel (n+1)
 * output, and channel (n+1) output becomes the channel (n) output. Each INVmEN
 * bit enables the inverting operation for the corresponding pair channels m. This
 * register has a write buffer. The INVmEN bit is updated by the INVCTRL
 * register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_INVCTRL register
 */
/*@{*/
#define FTM_RD_INVCTRL(base)     (FTM_INVCTRL_REG(base))
#define FTM_WR_INVCTRL(base, value) (FTM_INVCTRL_REG(base) = (value))
#define FTM_RMW_INVCTRL(base, mask, value) (FTM_WR_INVCTRL(base, (FTM_RD_INVCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_INVCTRL(base, value) (BME_OR32(&FTM_INVCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_INVCTRL(base, value) (BME_AND32(&FTM_INVCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_INVCTRL(base, value) (BME_XOR32(&FTM_INVCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_INVCTRL bitfields
 */

/*!
 * @name Register FTM_INVCTRL, field INV0EN[0] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV0EN field. */
#define FTM_RD_INVCTRL_INV0EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV0EN_MASK) >> FTM_INVCTRL_INV0EN_SHIFT)
#define FTM_BRD_INVCTRL_INV0EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV0EN_SHIFT, FTM_INVCTRL_INV0EN_WIDTH))

/*! @brief Set the INV0EN field to a new value. */
#define FTM_WR_INVCTRL_INV0EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV0EN_MASK, FTM_INVCTRL_INV0EN(value)))
#define FTM_BWR_INVCTRL_INV0EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV0EN_SHIFT), FTM_INVCTRL_INV0EN_SHIFT, FTM_INVCTRL_INV0EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV1EN[1] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV1EN field. */
#define FTM_RD_INVCTRL_INV1EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV1EN_MASK) >> FTM_INVCTRL_INV1EN_SHIFT)
#define FTM_BRD_INVCTRL_INV1EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV1EN_SHIFT, FTM_INVCTRL_INV1EN_WIDTH))

/*! @brief Set the INV1EN field to a new value. */
#define FTM_WR_INVCTRL_INV1EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV1EN_MASK, FTM_INVCTRL_INV1EN(value)))
#define FTM_BWR_INVCTRL_INV1EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV1EN_SHIFT), FTM_INVCTRL_INV1EN_SHIFT, FTM_INVCTRL_INV1EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV2EN[2] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV2EN field. */
#define FTM_RD_INVCTRL_INV2EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV2EN_MASK) >> FTM_INVCTRL_INV2EN_SHIFT)
#define FTM_BRD_INVCTRL_INV2EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV2EN_SHIFT, FTM_INVCTRL_INV2EN_WIDTH))

/*! @brief Set the INV2EN field to a new value. */
#define FTM_WR_INVCTRL_INV2EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV2EN_MASK, FTM_INVCTRL_INV2EN(value)))
#define FTM_BWR_INVCTRL_INV2EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV2EN_SHIFT), FTM_INVCTRL_INV2EN_SHIFT, FTM_INVCTRL_INV2EN_WIDTH))
/*@}*/

/*!
 * @name Register FTM_INVCTRL, field INV3EN[3] (RW)
 *
 * Values:
 * - 0b0 - Inverting is disabled.
 * - 0b1 - Inverting is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_INVCTRL_INV3EN field. */
#define FTM_RD_INVCTRL_INV3EN(base) ((FTM_INVCTRL_REG(base) & FTM_INVCTRL_INV3EN_MASK) >> FTM_INVCTRL_INV3EN_SHIFT)
#define FTM_BRD_INVCTRL_INV3EN(base) (BME_UBFX32(&FTM_INVCTRL_REG(base), FTM_INVCTRL_INV3EN_SHIFT, FTM_INVCTRL_INV3EN_WIDTH))

/*! @brief Set the INV3EN field to a new value. */
#define FTM_WR_INVCTRL_INV3EN(base, value) (FTM_RMW_INVCTRL(base, FTM_INVCTRL_INV3EN_MASK, FTM_INVCTRL_INV3EN(value)))
#define FTM_BWR_INVCTRL_INV3EN(base, value) (BME_BFI32(&FTM_INVCTRL_REG(base), ((uint32_t)(value) << FTM_INVCTRL_INV3EN_SHIFT), FTM_INVCTRL_INV3EN_SHIFT, FTM_INVCTRL_INV3EN_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_SWOCTRL - FTM Software Output Control
 ******************************************************************************/

/*!
 * @brief FTM_SWOCTRL - FTM Software Output Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register enables software control of channel (n) output and defines the
 * value forced to the channel (n) output: The CHnOC bits enable the control of
 * the corresponding channel (n) output by software. The CHnOCV bits select the
 * value that is forced at the corresponding channel (n) output. This register has
 * a write buffer. The fields are updated by the SWOCTRL register synchronization.
 */
/*!
 * @name Constants and macros for entire FTM_SWOCTRL register
 */
/*@{*/
#define FTM_RD_SWOCTRL(base)     (FTM_SWOCTRL_REG(base))
#define FTM_WR_SWOCTRL(base, value) (FTM_SWOCTRL_REG(base) = (value))
#define FTM_RMW_SWOCTRL(base, mask, value) (FTM_WR_SWOCTRL(base, (FTM_RD_SWOCTRL(base) & ~(mask)) | (value)))
#define FTM_SET_SWOCTRL(base, value) (BME_OR32(&FTM_SWOCTRL_REG(base), (uint32_t)(value)))
#define FTM_CLR_SWOCTRL(base, value) (BME_AND32(&FTM_SWOCTRL_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_SWOCTRL(base, value) (BME_XOR32(&FTM_SWOCTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_SWOCTRL bitfields
 */

/*!
 * @name Register FTM_SWOCTRL, field CH0OC[0] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OC field. */
#define FTM_RD_SWOCTRL_CH0OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OC_MASK) >> FTM_SWOCTRL_CH0OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OC_SHIFT, FTM_SWOCTRL_CH0OC_WIDTH))

/*! @brief Set the CH0OC field to a new value. */
#define FTM_WR_SWOCTRL_CH0OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OC_MASK, FTM_SWOCTRL_CH0OC(value)))
#define FTM_BWR_SWOCTRL_CH0OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH0OC_SHIFT), FTM_SWOCTRL_CH0OC_SHIFT, FTM_SWOCTRL_CH0OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OC[1] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OC field. */
#define FTM_RD_SWOCTRL_CH1OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OC_MASK) >> FTM_SWOCTRL_CH1OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OC_SHIFT, FTM_SWOCTRL_CH1OC_WIDTH))

/*! @brief Set the CH1OC field to a new value. */
#define FTM_WR_SWOCTRL_CH1OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OC_MASK, FTM_SWOCTRL_CH1OC(value)))
#define FTM_BWR_SWOCTRL_CH1OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH1OC_SHIFT), FTM_SWOCTRL_CH1OC_SHIFT, FTM_SWOCTRL_CH1OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OC[2] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OC field. */
#define FTM_RD_SWOCTRL_CH2OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OC_MASK) >> FTM_SWOCTRL_CH2OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OC_SHIFT, FTM_SWOCTRL_CH2OC_WIDTH))

/*! @brief Set the CH2OC field to a new value. */
#define FTM_WR_SWOCTRL_CH2OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OC_MASK, FTM_SWOCTRL_CH2OC(value)))
#define FTM_BWR_SWOCTRL_CH2OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH2OC_SHIFT), FTM_SWOCTRL_CH2OC_SHIFT, FTM_SWOCTRL_CH2OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OC[3] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OC field. */
#define FTM_RD_SWOCTRL_CH3OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OC_MASK) >> FTM_SWOCTRL_CH3OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OC_SHIFT, FTM_SWOCTRL_CH3OC_WIDTH))

/*! @brief Set the CH3OC field to a new value. */
#define FTM_WR_SWOCTRL_CH3OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OC_MASK, FTM_SWOCTRL_CH3OC(value)))
#define FTM_BWR_SWOCTRL_CH3OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH3OC_SHIFT), FTM_SWOCTRL_CH3OC_SHIFT, FTM_SWOCTRL_CH3OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OC[4] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OC field. */
#define FTM_RD_SWOCTRL_CH4OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OC_MASK) >> FTM_SWOCTRL_CH4OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OC_SHIFT, FTM_SWOCTRL_CH4OC_WIDTH))

/*! @brief Set the CH4OC field to a new value. */
#define FTM_WR_SWOCTRL_CH4OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OC_MASK, FTM_SWOCTRL_CH4OC(value)))
#define FTM_BWR_SWOCTRL_CH4OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH4OC_SHIFT), FTM_SWOCTRL_CH4OC_SHIFT, FTM_SWOCTRL_CH4OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OC[5] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OC field. */
#define FTM_RD_SWOCTRL_CH5OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OC_MASK) >> FTM_SWOCTRL_CH5OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OC_SHIFT, FTM_SWOCTRL_CH5OC_WIDTH))

/*! @brief Set the CH5OC field to a new value. */
#define FTM_WR_SWOCTRL_CH5OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OC_MASK, FTM_SWOCTRL_CH5OC(value)))
#define FTM_BWR_SWOCTRL_CH5OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH5OC_SHIFT), FTM_SWOCTRL_CH5OC_SHIFT, FTM_SWOCTRL_CH5OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OC[6] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OC field. */
#define FTM_RD_SWOCTRL_CH6OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OC_MASK) >> FTM_SWOCTRL_CH6OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OC_SHIFT, FTM_SWOCTRL_CH6OC_WIDTH))

/*! @brief Set the CH6OC field to a new value. */
#define FTM_WR_SWOCTRL_CH6OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OC_MASK, FTM_SWOCTRL_CH6OC(value)))
#define FTM_BWR_SWOCTRL_CH6OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH6OC_SHIFT), FTM_SWOCTRL_CH6OC_SHIFT, FTM_SWOCTRL_CH6OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OC[7] (RW)
 *
 * Values:
 * - 0b0 - The channel output is not affected by software output control.
 * - 0b1 - The channel output is affected by software output control.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OC field. */
#define FTM_RD_SWOCTRL_CH7OC(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OC_MASK) >> FTM_SWOCTRL_CH7OC_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OC(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OC_SHIFT, FTM_SWOCTRL_CH7OC_WIDTH))

/*! @brief Set the CH7OC field to a new value. */
#define FTM_WR_SWOCTRL_CH7OC(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OC_MASK, FTM_SWOCTRL_CH7OC(value)))
#define FTM_BWR_SWOCTRL_CH7OC(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH7OC_SHIFT), FTM_SWOCTRL_CH7OC_SHIFT, FTM_SWOCTRL_CH7OC_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH0OCV[8] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH0OCV field. */
#define FTM_RD_SWOCTRL_CH0OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH0OCV_MASK) >> FTM_SWOCTRL_CH0OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH0OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH0OCV_SHIFT, FTM_SWOCTRL_CH0OCV_WIDTH))

/*! @brief Set the CH0OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH0OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH0OCV_MASK, FTM_SWOCTRL_CH0OCV(value)))
#define FTM_BWR_SWOCTRL_CH0OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH0OCV_SHIFT), FTM_SWOCTRL_CH0OCV_SHIFT, FTM_SWOCTRL_CH0OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH1OCV[9] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH1OCV field. */
#define FTM_RD_SWOCTRL_CH1OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH1OCV_MASK) >> FTM_SWOCTRL_CH1OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH1OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH1OCV_SHIFT, FTM_SWOCTRL_CH1OCV_WIDTH))

/*! @brief Set the CH1OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH1OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH1OCV_MASK, FTM_SWOCTRL_CH1OCV(value)))
#define FTM_BWR_SWOCTRL_CH1OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH1OCV_SHIFT), FTM_SWOCTRL_CH1OCV_SHIFT, FTM_SWOCTRL_CH1OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH2OCV[10] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH2OCV field. */
#define FTM_RD_SWOCTRL_CH2OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH2OCV_MASK) >> FTM_SWOCTRL_CH2OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH2OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH2OCV_SHIFT, FTM_SWOCTRL_CH2OCV_WIDTH))

/*! @brief Set the CH2OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH2OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH2OCV_MASK, FTM_SWOCTRL_CH2OCV(value)))
#define FTM_BWR_SWOCTRL_CH2OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH2OCV_SHIFT), FTM_SWOCTRL_CH2OCV_SHIFT, FTM_SWOCTRL_CH2OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH3OCV[11] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH3OCV field. */
#define FTM_RD_SWOCTRL_CH3OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH3OCV_MASK) >> FTM_SWOCTRL_CH3OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH3OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH3OCV_SHIFT, FTM_SWOCTRL_CH3OCV_WIDTH))

/*! @brief Set the CH3OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH3OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH3OCV_MASK, FTM_SWOCTRL_CH3OCV(value)))
#define FTM_BWR_SWOCTRL_CH3OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH3OCV_SHIFT), FTM_SWOCTRL_CH3OCV_SHIFT, FTM_SWOCTRL_CH3OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH4OCV[12] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH4OCV field. */
#define FTM_RD_SWOCTRL_CH4OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH4OCV_MASK) >> FTM_SWOCTRL_CH4OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH4OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH4OCV_SHIFT, FTM_SWOCTRL_CH4OCV_WIDTH))

/*! @brief Set the CH4OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH4OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH4OCV_MASK, FTM_SWOCTRL_CH4OCV(value)))
#define FTM_BWR_SWOCTRL_CH4OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH4OCV_SHIFT), FTM_SWOCTRL_CH4OCV_SHIFT, FTM_SWOCTRL_CH4OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH5OCV[13] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH5OCV field. */
#define FTM_RD_SWOCTRL_CH5OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH5OCV_MASK) >> FTM_SWOCTRL_CH5OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH5OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH5OCV_SHIFT, FTM_SWOCTRL_CH5OCV_WIDTH))

/*! @brief Set the CH5OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH5OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH5OCV_MASK, FTM_SWOCTRL_CH5OCV(value)))
#define FTM_BWR_SWOCTRL_CH5OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH5OCV_SHIFT), FTM_SWOCTRL_CH5OCV_SHIFT, FTM_SWOCTRL_CH5OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH6OCV[14] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH6OCV field. */
#define FTM_RD_SWOCTRL_CH6OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH6OCV_MASK) >> FTM_SWOCTRL_CH6OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH6OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH6OCV_SHIFT, FTM_SWOCTRL_CH6OCV_WIDTH))

/*! @brief Set the CH6OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH6OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH6OCV_MASK, FTM_SWOCTRL_CH6OCV(value)))
#define FTM_BWR_SWOCTRL_CH6OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH6OCV_SHIFT), FTM_SWOCTRL_CH6OCV_SHIFT, FTM_SWOCTRL_CH6OCV_WIDTH))
/*@}*/

/*!
 * @name Register FTM_SWOCTRL, field CH7OCV[15] (RW)
 *
 * Values:
 * - 0b0 - The software output control forces 0 to the channel output.
 * - 0b1 - The software output control forces 1 to the channel output.
 */
/*@{*/
/*! @brief Read current value of the FTM_SWOCTRL_CH7OCV field. */
#define FTM_RD_SWOCTRL_CH7OCV(base) ((FTM_SWOCTRL_REG(base) & FTM_SWOCTRL_CH7OCV_MASK) >> FTM_SWOCTRL_CH7OCV_SHIFT)
#define FTM_BRD_SWOCTRL_CH7OCV(base) (BME_UBFX32(&FTM_SWOCTRL_REG(base), FTM_SWOCTRL_CH7OCV_SHIFT, FTM_SWOCTRL_CH7OCV_WIDTH))

/*! @brief Set the CH7OCV field to a new value. */
#define FTM_WR_SWOCTRL_CH7OCV(base, value) (FTM_RMW_SWOCTRL(base, FTM_SWOCTRL_CH7OCV_MASK, FTM_SWOCTRL_CH7OCV(value)))
#define FTM_BWR_SWOCTRL_CH7OCV(base, value) (BME_BFI32(&FTM_SWOCTRL_REG(base), ((uint32_t)(value) << FTM_SWOCTRL_CH7OCV_SHIFT), FTM_SWOCTRL_CH7OCV_SHIFT, FTM_SWOCTRL_CH7OCV_WIDTH))
/*@}*/

/*******************************************************************************
 * FTM_PWMLOAD - FTM PWM Load
 ******************************************************************************/

/*!
 * @brief FTM_PWMLOAD - FTM PWM Load (RW)
 *
 * Reset value: 0x00000000U
 *
 * Enables the loading of the MOD, CNTIN, C(n)V, and C(n+1)V registers with the
 * values of their write buffers when the FTM counter changes from the MOD
 * register value to its next value or when a channel (j) match occurs. A match occurs
 * for the channel (j) when FTM counter = C(j)V.
 */
/*!
 * @name Constants and macros for entire FTM_PWMLOAD register
 */
/*@{*/
#define FTM_RD_PWMLOAD(base)     (FTM_PWMLOAD_REG(base))
#define FTM_WR_PWMLOAD(base, value) (FTM_PWMLOAD_REG(base) = (value))
#define FTM_RMW_PWMLOAD(base, mask, value) (FTM_WR_PWMLOAD(base, (FTM_RD_PWMLOAD(base) & ~(mask)) | (value)))
#define FTM_SET_PWMLOAD(base, value) (BME_OR32(&FTM_PWMLOAD_REG(base), (uint32_t)(value)))
#define FTM_CLR_PWMLOAD(base, value) (BME_AND32(&FTM_PWMLOAD_REG(base), (uint32_t)(~(value))))
#define FTM_TOG_PWMLOAD(base, value) (BME_XOR32(&FTM_PWMLOAD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual FTM_PWMLOAD bitfields
 */

/*!
 * @name Register FTM_PWMLOAD, field CH0SEL[0] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH0SEL field. */
#define FTM_RD_PWMLOAD_CH0SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH0SEL_MASK) >> FTM_PWMLOAD_CH0SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH0SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH0SEL_SHIFT, FTM_PWMLOAD_CH0SEL_WIDTH))

/*! @brief Set the CH0SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH0SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH0SEL_MASK, FTM_PWMLOAD_CH0SEL(value)))
#define FTM_BWR_PWMLOAD_CH0SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH0SEL_SHIFT), FTM_PWMLOAD_CH0SEL_SHIFT, FTM_PWMLOAD_CH0SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH1SEL[1] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH1SEL field. */
#define FTM_RD_PWMLOAD_CH1SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH1SEL_MASK) >> FTM_PWMLOAD_CH1SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH1SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH1SEL_SHIFT, FTM_PWMLOAD_CH1SEL_WIDTH))

/*! @brief Set the CH1SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH1SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH1SEL_MASK, FTM_PWMLOAD_CH1SEL(value)))
#define FTM_BWR_PWMLOAD_CH1SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH1SEL_SHIFT), FTM_PWMLOAD_CH1SEL_SHIFT, FTM_PWMLOAD_CH1SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH2SEL[2] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH2SEL field. */
#define FTM_RD_PWMLOAD_CH2SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH2SEL_MASK) >> FTM_PWMLOAD_CH2SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH2SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH2SEL_SHIFT, FTM_PWMLOAD_CH2SEL_WIDTH))

/*! @brief Set the CH2SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH2SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH2SEL_MASK, FTM_PWMLOAD_CH2SEL(value)))
#define FTM_BWR_PWMLOAD_CH2SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH2SEL_SHIFT), FTM_PWMLOAD_CH2SEL_SHIFT, FTM_PWMLOAD_CH2SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH3SEL[3] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH3SEL field. */
#define FTM_RD_PWMLOAD_CH3SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH3SEL_MASK) >> FTM_PWMLOAD_CH3SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH3SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH3SEL_SHIFT, FTM_PWMLOAD_CH3SEL_WIDTH))

/*! @brief Set the CH3SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH3SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH3SEL_MASK, FTM_PWMLOAD_CH3SEL(value)))
#define FTM_BWR_PWMLOAD_CH3SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH3SEL_SHIFT), FTM_PWMLOAD_CH3SEL_SHIFT, FTM_PWMLOAD_CH3SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH4SEL[4] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH4SEL field. */
#define FTM_RD_PWMLOAD_CH4SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH4SEL_MASK) >> FTM_PWMLOAD_CH4SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH4SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH4SEL_SHIFT, FTM_PWMLOAD_CH4SEL_WIDTH))

/*! @brief Set the CH4SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH4SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH4SEL_MASK, FTM_PWMLOAD_CH4SEL(value)))
#define FTM_BWR_PWMLOAD_CH4SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH4SEL_SHIFT), FTM_PWMLOAD_CH4SEL_SHIFT, FTM_PWMLOAD_CH4SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH5SEL[5] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH5SEL field. */
#define FTM_RD_PWMLOAD_CH5SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH5SEL_MASK) >> FTM_PWMLOAD_CH5SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH5SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH5SEL_SHIFT, FTM_PWMLOAD_CH5SEL_WIDTH))

/*! @brief Set the CH5SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH5SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH5SEL_MASK, FTM_PWMLOAD_CH5SEL(value)))
#define FTM_BWR_PWMLOAD_CH5SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH5SEL_SHIFT), FTM_PWMLOAD_CH5SEL_SHIFT, FTM_PWMLOAD_CH5SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH6SEL[6] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH6SEL field. */
#define FTM_RD_PWMLOAD_CH6SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH6SEL_MASK) >> FTM_PWMLOAD_CH6SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH6SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH6SEL_SHIFT, FTM_PWMLOAD_CH6SEL_WIDTH))

/*! @brief Set the CH6SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH6SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH6SEL_MASK, FTM_PWMLOAD_CH6SEL(value)))
#define FTM_BWR_PWMLOAD_CH6SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH6SEL_SHIFT), FTM_PWMLOAD_CH6SEL_SHIFT, FTM_PWMLOAD_CH6SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field CH7SEL[7] (RW)
 *
 * Values:
 * - 0b0 - Do not include the channel in the matching process.
 * - 0b1 - Include the channel in the matching process.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_CH7SEL field. */
#define FTM_RD_PWMLOAD_CH7SEL(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_CH7SEL_MASK) >> FTM_PWMLOAD_CH7SEL_SHIFT)
#define FTM_BRD_PWMLOAD_CH7SEL(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_CH7SEL_SHIFT, FTM_PWMLOAD_CH7SEL_WIDTH))

/*! @brief Set the CH7SEL field to a new value. */
#define FTM_WR_PWMLOAD_CH7SEL(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_CH7SEL_MASK, FTM_PWMLOAD_CH7SEL(value)))
#define FTM_BWR_PWMLOAD_CH7SEL(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_CH7SEL_SHIFT), FTM_PWMLOAD_CH7SEL_SHIFT, FTM_PWMLOAD_CH7SEL_WIDTH))
/*@}*/

/*!
 * @name Register FTM_PWMLOAD, field LDOK[9] (RW)
 *
 * Enables the loading of the MOD, CNTIN, and CV registers with the values of
 * their write buffers.
 *
 * Values:
 * - 0b0 - Loading updated values is disabled.
 * - 0b1 - Loading updated values is enabled.
 */
/*@{*/
/*! @brief Read current value of the FTM_PWMLOAD_LDOK field. */
#define FTM_RD_PWMLOAD_LDOK(base) ((FTM_PWMLOAD_REG(base) & FTM_PWMLOAD_LDOK_MASK) >> FTM_PWMLOAD_LDOK_SHIFT)
#define FTM_BRD_PWMLOAD_LDOK(base) (BME_UBFX32(&FTM_PWMLOAD_REG(base), FTM_PWMLOAD_LDOK_SHIFT, FTM_PWMLOAD_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define FTM_WR_PWMLOAD_LDOK(base, value) (FTM_RMW_PWMLOAD(base, FTM_PWMLOAD_LDOK_MASK, FTM_PWMLOAD_LDOK(value)))
#define FTM_BWR_PWMLOAD_LDOK(base, value) (BME_BFI32(&FTM_PWMLOAD_REG(base), ((uint32_t)(value) << FTM_PWMLOAD_LDOK_SHIFT), FTM_PWMLOAD_LDOK_SHIFT, FTM_PWMLOAD_LDOK_WIDTH))
/*@}*/

/*
 * MKV58F24 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) |  (value)))
#define GPIO_CLR_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) & ~(value)))
#define GPIO_TOG_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) |  (value)))
#define GPIO_CLR_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) & ~(value)))
#define GPIO_TOG_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * MKV58F24 HSADC
 *
 * SAR Analog to digital converter
 *
 * Registers defined in this header file:
 * - HSADC_CTRL1 - HSADC Control Register 1
 * - HSADC_CTRL2 - HSADC Control Register 2
 * - HSADC_ZXCTRL1 - HSADC Zero Crossing Control 1 Register
 * - HSADC_ZXCTRL2 - HSADC Zero Crossing Control 2 Register
 * - HSADC_CLIST1 - HSADC Channel List Register 1
 * - HSADC_CLIST2 - HSADC Channel List Register 2
 * - HSADC_CLIST3 - HSADC Channel List Register 3
 * - HSADC_CLIST4 - HSADC Channel List Register 4
 * - HSADC_SDIS - HSADC Sample Disable Register
 * - HSADC_STAT - HSADC Status Register
 * - HSADC_RDY - HSADC Ready Register
 * - HSADC_LOLIMSTAT - HSADC Low Limit Status Register
 * - HSADC_HILIMSTAT - HSADC High Limit Status Register
 * - HSADC_ZXSTAT - HSADC Zero Crossing Status Register
 * - HSADC_RSLT - HSADC Result Registers with sign extension
 * - HSADC_LOLIM - HSADC Low Limit Registers
 * - HSADC_HILIM - HSADC High Limit Registers
 * - HSADC_OFFST - HSADC Offset Register
 * - HSADC_PWR - HSADC Power Control Register
 * - HSADC_SCTRL - HSADC Scan Control Register
 * - HSADC_PWR2 - HSADC Power Control Register 2
 * - HSADC_CTRL3 - HSADC Control Register 3
 * - HSADC_SCINTEN - HSADC Scan Interrupt Enable Register
 * - HSADC_SAMPTIM - HSADC Sampling Time Configuration Register
 * - HSADC_CALIB - HSADCs Calibration Configuration
 * - HSADC_CALVAL_A - Calibration Values for ADCA Register
 * - HSADC_CALVAL_B - Calibration Values for ADCB Register
 * - HSADC_MUX67_SEL - MUX6_7 Selection Controls Register
 */

#define HSADC_INSTANCE_COUNT (2U) /*!< Number of instances of the HSADC module. */
#define HSADC0_IDX (0U) /*!< Instance number for HSADC0. */
#define HSADC1_IDX (1U) /*!< Instance number for HSADC1. */

/*******************************************************************************
 * HSADC_CTRL1 - HSADC Control Register 1
 ******************************************************************************/

/*!
 * @brief HSADC_CTRL1 - HSADC Control Register 1 (RW)
 *
 * Reset value: 0x5005U
 *
 * The HSADCx_CTRL1 register provides the mode of scanning for the A and B
 * converters, the input mode, and various interrupt enables. The STOPA, STARTA,
 * SYNCA, and EOSIEA fields in CTRL1 control all types of scans except parallel scans
 * in the B converter when CTRL2[SIMULT]=0. Non-simultaneous parallel scan modes
 * allow independent parallel scanning in the A and B converter. CTRL2[STOPB],
 * CTRL2[STARTB], CTRL2[SYNCB], and CTRL2[EOSIEB] are used to control B converter
 * scans in non-simultaneous parallel scan modes.
 */
/*!
 * @name Constants and macros for entire HSADC_CTRL1 register
 */
/*@{*/
#define HSADC_RD_CTRL1(base)     (HSADC_CTRL1_REG(base))
#define HSADC_WR_CTRL1(base, value) (HSADC_CTRL1_REG(base) = (value))
#define HSADC_RMW_CTRL1(base, mask, value) (HSADC_WR_CTRL1(base, (HSADC_RD_CTRL1(base) & ~(mask)) | (value)))
#define HSADC_SET_CTRL1(base, value) (BME_OR16(&HSADC_CTRL1_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CTRL1(base, value) (BME_AND16(&HSADC_CTRL1_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CTRL1(base, value) (BME_XOR16(&HSADC_CTRL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CTRL1 bitfields
 */

/*!
 * @name Register HSADC_CTRL1, field SMODE[2:0] (RW)
 *
 * This field controls the HSADC module's scan mode. All scan modes use 16
 * sample slots defined by the CLIST1-4 registers. A scan is the process of stepping
 * through a subset of these sample slots, converting the input indicated by a
 * slot, and storing the result. Unused slots may be disabled using the SDIS
 * register. Input pairs ANA0-1, ANA2-3, ANA4-5, ANA6-7, ANB0-1, ANB2-3, ANB4-5, and
 * ANB6-7 may be configured as differential pairs using the CHNCFG fields. When a
 * slot refers to either member of a differential pair, a differential measurement
 * on that pair is made; otherwise, a single ended measurement is taken on that
 * input. The CTRL*[CHNCFG] fields' descriptions detail differential and single
 * ended measurement. The SMODE field determines whether the slots are used to
 * perform one long sequential scan or two shorter parallel scans, each performed by
 * one of the two converters. SMODE controls how these scans are initiated and
 * terminated. It also controls whether the scans are performed once or
 * repetitively. For details, refer to Sequential versus parallel sampling and Scan
 * Sequencing . Parallel scans may be simultaneous (CTRL2[SIMULT] is 1) or
 * non-simultaneous. Simultaneous parallel scans perform the A and B converter scan in lock
 * step using one set of shared controls. Non-simultaneous parallel scans operate
 * the A and B converters independently, with each converter using its own set of
 * controls. Refer to the CTRL2[SIMULT] bit's description for details. Setting any
 * sequential mode overrides the setting of CTRL2[SIMULT].
 *
 * Values:
 * - 0b000 - Once (single) sequential
 * - 0b001 - Once parallel
 * - 0b010 - Loop sequential
 * - 0b011 - Loop parallel
 * - 0b100 - Triggered sequential
 * - 0b101 - Triggered parallel (default)
 * - 0b11x -
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_SMODE field. */
#define HSADC_RD_CTRL1_SMODE(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_SMODE_MASK) >> HSADC_CTRL1_SMODE_SHIFT)
#define HSADC_BRD_CTRL1_SMODE(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_SMODE_SHIFT, HSADC_CTRL1_SMODE_WIDTH))

/*! @brief Set the SMODE field to a new value. */
#define HSADC_WR_CTRL1_SMODE(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_SMODE_MASK, HSADC_CTRL1_SMODE(value)))
#define HSADC_BWR_CTRL1_SMODE(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_SMODE_SHIFT), HSADC_CTRL1_SMODE_SHIFT, HSADC_CTRL1_SMODE_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field CHNCFG_L[7:4] (RW)
 *
 * The bits configure the analog inputs for either single ended or differential
 * conversions. Differential measurements return the max value ((2**12)-1) when
 * the + input is V REFH and the - input is V REFLO , return 0 when the + input is
 * at V REFLO and the - input is at V REFH , and scale linearly between based on
 * the voltage difference between the two signals. Single ended measurements
 * return the max value when the input is at V REFH , return 0 when the input is at
 * V REFLO , and scale linearly between based on the amount by which the input
 * exceeds V REFLO .
 *
 * Values:
 * - 0bxxx1 - Inputs = ANA0-ANA1
 * - 0bxxx0 - Inputs = ANA0-ANA1
 * - 0bxx1x - Inputs = ANA2-ANA3
 * - 0bxx0x - Inputs = ANA2-ANA3
 * - 0bx1xx - Inputs = ANB0-ANB1
 * - 0bx0xx - Inputs = ANB0-ANB1
 * - 0b1xxx - Inputs = ANB2-ANB3
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_CHNCFG_L field. */
#define HSADC_RD_CTRL1_CHNCFG_L(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_CHNCFG_L_MASK) >> HSADC_CTRL1_CHNCFG_L_SHIFT)
#define HSADC_BRD_CTRL1_CHNCFG_L(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_CHNCFG_L_SHIFT, HSADC_CTRL1_CHNCFG_L_WIDTH))

/*! @brief Set the CHNCFG_L field to a new value. */
#define HSADC_WR_CTRL1_CHNCFG_L(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_CHNCFG_L_MASK, HSADC_CTRL1_CHNCFG_L(value)))
#define HSADC_BWR_CTRL1_CHNCFG_L(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_CHNCFG_L_SHIFT), HSADC_CTRL1_CHNCFG_L_SHIFT, HSADC_CTRL1_CHNCFG_L_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field HLMTIE[8] (RW)
 *
 * This bit enables the High Limit exceeded interrupt if the current result
 * value is greater than the high limit register value. The raw result value is
 * compared to HILIM[HLMT] before the offset register value is subtracted.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_HLMTIE field. */
#define HSADC_RD_CTRL1_HLMTIE(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_HLMTIE_MASK) >> HSADC_CTRL1_HLMTIE_SHIFT)
#define HSADC_BRD_CTRL1_HLMTIE(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_HLMTIE_SHIFT, HSADC_CTRL1_HLMTIE_WIDTH))

/*! @brief Set the HLMTIE field to a new value. */
#define HSADC_WR_CTRL1_HLMTIE(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_HLMTIE_MASK, HSADC_CTRL1_HLMTIE(value)))
#define HSADC_BWR_CTRL1_HLMTIE(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_HLMTIE_SHIFT), HSADC_CTRL1_HLMTIE_SHIFT, HSADC_CTRL1_HLMTIE_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field LLMTIE[9] (RW)
 *
 * This bit enables the Low Limit exceeded interrupt when the current result
 * value is less than the low limit register value. The raw result value is compared
 * to LOLIM[LLMT] before the offset register value is subtracted.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_LLMTIE field. */
#define HSADC_RD_CTRL1_LLMTIE(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_LLMTIE_MASK) >> HSADC_CTRL1_LLMTIE_SHIFT)
#define HSADC_BRD_CTRL1_LLMTIE(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_LLMTIE_SHIFT, HSADC_CTRL1_LLMTIE_WIDTH))

/*! @brief Set the LLMTIE field to a new value. */
#define HSADC_WR_CTRL1_LLMTIE(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_LLMTIE_MASK, HSADC_CTRL1_LLMTIE(value)))
#define HSADC_BWR_CTRL1_LLMTIE(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_LLMTIE_SHIFT), HSADC_CTRL1_LLMTIE_SHIFT, HSADC_CTRL1_LLMTIE_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field ZCIE[10] (RW)
 *
 * This bit enables the zero crossing interrupt if the current result value has
 * a sign change from the previous result as configured by the ZXCTRL1 and
 * ZXCTRL2 registers.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_ZCIE field. */
#define HSADC_RD_CTRL1_ZCIE(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_ZCIE_MASK) >> HSADC_CTRL1_ZCIE_SHIFT)
#define HSADC_BRD_CTRL1_ZCIE(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_ZCIE_SHIFT, HSADC_CTRL1_ZCIE_WIDTH))

/*! @brief Set the ZCIE field to a new value. */
#define HSADC_WR_CTRL1_ZCIE(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_ZCIE_MASK, HSADC_CTRL1_ZCIE(value)))
#define HSADC_BWR_CTRL1_ZCIE(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_ZCIE_SHIFT), HSADC_CTRL1_ZCIE_SHIFT, HSADC_CTRL1_ZCIE_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field EOSIEA[11] (RW)
 *
 * This bit enables an EOSIA interrupt to be generated upon completion of the
 * scan. For looping scan modes, the interrupt will trigger after the completion of
 * each iteration of the loop.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_EOSIEA field. */
#define HSADC_RD_CTRL1_EOSIEA(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_EOSIEA_MASK) >> HSADC_CTRL1_EOSIEA_SHIFT)
#define HSADC_BRD_CTRL1_EOSIEA(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_EOSIEA_SHIFT, HSADC_CTRL1_EOSIEA_WIDTH))

/*! @brief Set the EOSIEA field to a new value. */
#define HSADC_WR_CTRL1_EOSIEA(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_EOSIEA_MASK, HSADC_CTRL1_EOSIEA(value)))
#define HSADC_BWR_CTRL1_EOSIEA(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_EOSIEA_SHIFT), HSADC_CTRL1_EOSIEA_SHIFT, HSADC_CTRL1_EOSIEA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field SYNCA[12] (RW)
 *
 * A conversion may be initiated by asserting a positive edge on the SYNCA
 * input. Any subsequent SYNCA input pulses while the scan remains in process are
 * ignored unless the scan is awaiting further SYNC inputs due to the SCTRL[SCn]
 * bits. CTRL1[SYNCA] is cleared in ONCE mode, CTRL1[SMODE=000 or 001], when the
 * first SYNC input is detected. This prevents unintentionally starting a new scan
 * after the first scan has completed. The ADC must be in a stable power mode prior
 * to SYNCA input assertion. Refer to the functional description of power modes
 * for further details. In "once" scan modes, only a first SYNCA input pulse is
 * honored. CTRL1[SYNCA] is cleared in this mode when the first SYNC input is
 * detected. This prevents unintentionally starting a new scan after the first scan
 * has completed. CTRL1[SYNCA] can be set again at any time including while the
 * scan remains in process
 *
 * Values:
 * - 0b0 - Scan is initiated by a write to CTRL1[STARTA] only
 * - 0b1 - Use a SYNCA input pulse or CTRL1[STARTA] to initiate a scan
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_SYNCA field. */
#define HSADC_RD_CTRL1_SYNCA(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_SYNCA_MASK) >> HSADC_CTRL1_SYNCA_SHIFT)
#define HSADC_BRD_CTRL1_SYNCA(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_SYNCA_SHIFT, HSADC_CTRL1_SYNCA_WIDTH))

/*! @brief Set the SYNCA field to a new value. */
#define HSADC_WR_CTRL1_SYNCA(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_SYNCA_MASK, HSADC_CTRL1_SYNCA(value)))
#define HSADC_BWR_CTRL1_SYNCA(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_SYNCA_SHIFT), HSADC_CTRL1_SYNCA_SHIFT, HSADC_CTRL1_SYNCA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field STARTA[13] (WORZ)
 *
 * A scan is started by writing 1 to this bit. This is a write only bit. Writing
 * 1 to it again while the scan remains in process, is ignored. The ADC must be
 * in a stable power configuration prior to writing the start bit. Refer to the
 * functional description of power modes for further details.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - Start command is issued
 */
/*@{*/
/*! @brief Set the STARTA field to a new value. */
#define HSADC_WR_CTRL1_STARTA(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_STARTA_MASK, HSADC_CTRL1_STARTA(value)))
#define HSADC_BWR_CTRL1_STARTA(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_STARTA_SHIFT), HSADC_CTRL1_STARTA_SHIFT, HSADC_CTRL1_STARTA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field STOPA[14] (RW)
 *
 * When this bit is asserted, the current scan is stopped and no further scans
 * can start. Any further SYNCA input pulses (see CTRL1[SYNCA]) or writes to
 * CTRL1[STARTA] are ignored until this bit has been cleared. After the ADC is in stop
 * mode, the result registers can be modified by the processor. Any changes to
 * the result registers in stop mode are treated as if the analog core supplied
 * the data. Therefore, limit checking, zero crossing, and associated interrupts
 * can occur when authorized. This is not the same as the chip's STOP mode.
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Stop mode
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_STOPA field. */
#define HSADC_RD_CTRL1_STOPA(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_STOPA_MASK) >> HSADC_CTRL1_STOPA_SHIFT)
#define HSADC_BRD_CTRL1_STOPA(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_STOPA_SHIFT, HSADC_CTRL1_STOPA_WIDTH))

/*! @brief Set the STOPA field to a new value. */
#define HSADC_WR_CTRL1_STOPA(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_STOPA_MASK, HSADC_CTRL1_STOPA(value)))
#define HSADC_BWR_CTRL1_STOPA(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_STOPA_SHIFT), HSADC_CTRL1_STOPA_SHIFT, HSADC_CTRL1_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL1, field DMAENA[15] (RW)
 *
 * When this bit is asserted, the DMA source selected by CTRL3[DMASRC] causes
 * the conversion results to be transferred by the DMA controller.
 *
 * Values:
 * - 0b0 - DMA is not enabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL1_DMAENA field. */
#define HSADC_RD_CTRL1_DMAENA(base) ((HSADC_CTRL1_REG(base) & HSADC_CTRL1_DMAENA_MASK) >> HSADC_CTRL1_DMAENA_SHIFT)
#define HSADC_BRD_CTRL1_DMAENA(base) (BME_UBFX16(&HSADC_CTRL1_REG(base), HSADC_CTRL1_DMAENA_SHIFT, HSADC_CTRL1_DMAENA_WIDTH))

/*! @brief Set the DMAENA field to a new value. */
#define HSADC_WR_CTRL1_DMAENA(base, value) (HSADC_RMW_CTRL1(base, HSADC_CTRL1_DMAENA_MASK, HSADC_CTRL1_DMAENA(value)))
#define HSADC_BWR_CTRL1_DMAENA(base, value) (BME_BFI16(&HSADC_CTRL1_REG(base), ((uint16_t)(value) << HSADC_CTRL1_DMAENA_SHIFT), HSADC_CTRL1_DMAENA_SHIFT, HSADC_CTRL1_DMAENA_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CTRL2 - HSADC Control Register 2
 ******************************************************************************/

/*!
 * @brief HSADC_CTRL2 - HSADC Control Register 2 (RW)
 *
 * Reset value: 0x5044U
 */
/*!
 * @name Constants and macros for entire HSADC_CTRL2 register
 */
/*@{*/
#define HSADC_RD_CTRL2(base)     (HSADC_CTRL2_REG(base))
#define HSADC_WR_CTRL2(base, value) (HSADC_CTRL2_REG(base) = (value))
#define HSADC_RMW_CTRL2(base, mask, value) (HSADC_WR_CTRL2(base, (HSADC_RD_CTRL2(base) & ~(mask)) | (value)))
#define HSADC_SET_CTRL2(base, value) (BME_OR16(&HSADC_CTRL2_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CTRL2(base, value) (BME_AND16(&HSADC_CTRL2_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CTRL2(base, value) (BME_XOR16(&HSADC_CTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CTRL2 bitfields
 */

/*!
 * @name Register HSADC_CTRL2, field DIVA[5:0] (RW)
 *
 * The divider circuit generates the ADC clock by dividing the system clock:
 * When DIVA is 0, the divisor is 2. For all other DIVA values, the divisor is (DIVA
 * + 1). A DIVA value must be chosen so the ADC clock does not exceed the
 * maximum frequency (80 MHz). This clock divisor is used by ADCA during all scans and
 * is used by ADCB during sequential scan modes and during parallel simultaneous
 * scan modes. The following table shows the ADC clock frequency based on the
 * value of DIVA for some frequencies of the clock source. DIVA Divisor HSADC clock
 * input 160 MHz HSADC clock input 240 MHz 00_0000 2 80.0M - 00_0001 2 80.0M -
 * 00_0010 3 53.33M 80.0M 00_0011 4 40.0M 60.0M 00_0100 5 32.00M 48.0M 00_0101 6
 * 26.67M 40.0M - - - - 11_1111 64 2.5M 3.75M
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_DIVA field. */
#define HSADC_RD_CTRL2_DIVA(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_DIVA_MASK) >> HSADC_CTRL2_DIVA_SHIFT)
#define HSADC_BRD_CTRL2_DIVA(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_DIVA_SHIFT, HSADC_CTRL2_DIVA_WIDTH))

/*! @brief Set the DIVA field to a new value. */
#define HSADC_WR_CTRL2_DIVA(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_DIVA_MASK, HSADC_CTRL2_DIVA(value)))
#define HSADC_BWR_CTRL2_DIVA(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_DIVA_SHIFT), HSADC_CTRL2_DIVA_SHIFT, HSADC_CTRL2_DIVA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field SIMULT[6] (RW)
 *
 * This bit only affects parallel scan modes. By default (CTRL2[SIMULT]=1)
 * parallel scans operate in simultaneous mode. The scans in the A and B converter
 * operate simultaneously and always result in pairs of simultaneous conversions in
 * the A and B converter. CTRL1[STOPA], CTRL1[SYNCA], and CTRL1[STARTA] control
 * bits and the SYNCA input are used to start and stop scans in both converters
 * simultaneously. A scan ends in both converters when either converter encounters
 * a disabled sample slot. When the parallel scan completes, the STAT[EOSIA]
 * triggers if CTRL1[EOSIEA] is set. The STAT[CIPA] status bit indicates that a
 * parallel scan is in process. When CTRL2[SIMULT]=0, parallel scans in the A and B
 * converters operate independently. The B converter has its own independent set of
 * the above controls (with a B suffix) which control its operation and report
 * its status. Each converter's scan continues until its sample list is exhausted
 * (8 samples) or a disabled sample IN ITS LIST is encountered. For looping
 * parallel scan mode, each converter starts its next iteration as soon as the
 * previous iteration in that converter is complete and continues until the CTRL*[STOP*]
 * bit for that converter is asserted.
 *
 * Values:
 * - 0b0 - Parallel scans done independently
 * - 0b1 - Parallel scans done simultaneously (default)
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_SIMULT field. */
#define HSADC_RD_CTRL2_SIMULT(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_SIMULT_MASK) >> HSADC_CTRL2_SIMULT_SHIFT)
#define HSADC_BRD_CTRL2_SIMULT(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_SIMULT_SHIFT, HSADC_CTRL2_SIMULT_WIDTH))

/*! @brief Set the SIMULT field to a new value. */
#define HSADC_WR_CTRL2_SIMULT(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_SIMULT_MASK, HSADC_CTRL2_SIMULT(value)))
#define HSADC_BWR_CTRL2_SIMULT(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_SIMULT_SHIFT), HSADC_CTRL2_SIMULT_SHIFT, HSADC_CTRL2_SIMULT_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field CHNCFG_H[10:7] (RW)
 *
 * The bits configure the analog inputs for either single ended or differential
 * conversions. Differential measurements return the max value ((2**12)-1) when
 * the + input is V REFH and the - input is V REFLO , return 0 when the + input is
 * at V REFLO and the - input is at V REFH , and scale linearly between based on
 * the voltage difference between the two signals. Single ended measurements
 * return the max value when the input is at V REFH , return 0 when the input is at
 * V REFLO , and scale linearly between based on the amount by which the input
 * exceeds V REFLO. See section Input Multiplex Function for details when using
 * ANA6/7 or ANB6/7.
 *
 * Values:
 * - 0bxxx1 - Inputs = ANA4-ANA5
 * - 0bxxx0 - Inputs = ANA4-ANA5
 * - 0bxx1x - Inputs = ANA6-ANA7
 * - 0bxx0x - Inputs = ANA6-ANA7
 * - 0bx1xx - Inputs = ANB4-ANB5
 * - 0bx0xx - Inputs = ANB4-ANB5
 * - 0b1xxx - Inputs = ANB6-ANB7
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_CHNCFG_H field. */
#define HSADC_RD_CTRL2_CHNCFG_H(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_CHNCFG_H_MASK) >> HSADC_CTRL2_CHNCFG_H_SHIFT)
#define HSADC_BRD_CTRL2_CHNCFG_H(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_CHNCFG_H_SHIFT, HSADC_CTRL2_CHNCFG_H_WIDTH))

/*! @brief Set the CHNCFG_H field to a new value. */
#define HSADC_WR_CTRL2_CHNCFG_H(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_CHNCFG_H_MASK, HSADC_CTRL2_CHNCFG_H(value)))
#define HSADC_BWR_CTRL2_CHNCFG_H(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_CHNCFG_H_SHIFT), HSADC_CTRL2_CHNCFG_H_SHIFT, HSADC_CTRL2_CHNCFG_H_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field EOSIEB[11] (RW)
 *
 * During parallel scan modes when SIMULT = 0, this bit enables interrupt
 * control for a B converter parallel scan. This bit enables an EOSIB interrupt to be
 * generated upon completion of the scan. For looping scan modes, the interrupt
 * will trigger after the completion of each iteration of the loop.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_EOSIEB field. */
#define HSADC_RD_CTRL2_EOSIEB(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_EOSIEB_MASK) >> HSADC_CTRL2_EOSIEB_SHIFT)
#define HSADC_BRD_CTRL2_EOSIEB(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_EOSIEB_SHIFT, HSADC_CTRL2_EOSIEB_WIDTH))

/*! @brief Set the EOSIEB field to a new value. */
#define HSADC_WR_CTRL2_EOSIEB(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_EOSIEB_MASK, HSADC_CTRL2_EOSIEB(value)))
#define HSADC_BWR_CTRL2_EOSIEB(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_EOSIEB_SHIFT), HSADC_CTRL2_EOSIEB_SHIFT, HSADC_CTRL2_EOSIEB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field SYNCB[12] (RW)
 *
 * During parallel scan modes when CTRL2[SIMULT]=0, setting this bit to 1
 * permits a B converter parallel scan to be initiated by asserting the SYNCB input for
 * at least one ADC clock cycle. CTRL2[SYNCB] is cleared in ONCE mode,
 * CTRL1[SMODE=000 or 001], when the first SYNC input is detected. This prevents
 * unintentionally starting a new scan after the first scan has completed. The ADC must be
 * in a stable power mode prior to SYNCB input assertion. Refer to the
 * functional description of power modes for further details. In "once" scan modes, only a
 * first SYNCB input pulse is honored. CTRL2[SYNCB] is cleared in this mode when
 * the first SYNCB input is detected. This prevents unintentionally starting a
 * new scan after the first scan has completed. CTRL2[SYNCB] can be set again at
 * any time including while the scan remains in process.
 *
 * Values:
 * - 0b0 - B converter parallel scan is initiated by a write to CTRL2[STARTB]
 *     only
 * - 0b1 - Use a SYNCB input pulse or CTRL2[STARTB] to initiate a B converter
 *     parallel scan
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_SYNCB field. */
#define HSADC_RD_CTRL2_SYNCB(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_SYNCB_MASK) >> HSADC_CTRL2_SYNCB_SHIFT)
#define HSADC_BRD_CTRL2_SYNCB(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_SYNCB_SHIFT, HSADC_CTRL2_SYNCB_WIDTH))

/*! @brief Set the SYNCB field to a new value. */
#define HSADC_WR_CTRL2_SYNCB(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_SYNCB_MASK, HSADC_CTRL2_SYNCB(value)))
#define HSADC_BWR_CTRL2_SYNCB(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_SYNCB_SHIFT), HSADC_CTRL2_SYNCB_SHIFT, HSADC_CTRL2_SYNCB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field STARTB[13] (WORZ)
 *
 * During parallel scan modes when SIMULT = 0, this bit enables start control of
 * a B converter parallel scan. A scan is started by writing 1 to this bit. This
 * is a write only bit. Writing 1 to it again while the scan remains in process,
 * is ignored. The ADC must be in a stable power configuration prior to writing
 * the start bit. Refer to the functional description of power modes for further
 * details.
 *
 * Values:
 * - 0b0 - No action
 * - 0b1 - Start command is issued
 */
/*@{*/
/*! @brief Set the STARTB field to a new value. */
#define HSADC_WR_CTRL2_STARTB(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_STARTB_MASK, HSADC_CTRL2_STARTB(value)))
#define HSADC_BWR_CTRL2_STARTB(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_STARTB_SHIFT), HSADC_CTRL2_STARTB_SHIFT, HSADC_CTRL2_STARTB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field STOPB[14] (RW)
 *
 * During parallel scan modes when SIMULT = 0, this bit enables stop control of
 * a B converter parallel scan. When this bit is asserted, the current scan is
 * stopped and no further scans can start. Any further SYNCB input pulses (see
 * CTRL2[SYNCB]) or writes to CTRL2[STARTB] are ignored until this bit has been
 * cleared. After the ADC is in stop mode, the result registers can be modified by the
 * processor. Any changes to the result registers in stop mode are treated as if
 * the analog core supplied the data. Therefore, limit checking, zero crossing,
 * and associated interrupts can occur when authorized. This is not the same as
 * the chip's STOP mode.
 *
 * Values:
 * - 0b0 - Normal operation
 * - 0b1 - Stop mode
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_STOPB field. */
#define HSADC_RD_CTRL2_STOPB(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_STOPB_MASK) >> HSADC_CTRL2_STOPB_SHIFT)
#define HSADC_BRD_CTRL2_STOPB(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_STOPB_SHIFT, HSADC_CTRL2_STOPB_WIDTH))

/*! @brief Set the STOPB field to a new value. */
#define HSADC_WR_CTRL2_STOPB(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_STOPB_MASK, HSADC_CTRL2_STOPB(value)))
#define HSADC_BWR_CTRL2_STOPB(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_STOPB_SHIFT), HSADC_CTRL2_STOPB_SHIFT, HSADC_CTRL2_STOPB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL2, field DMAENB[15] (RW)
 *
 * During parallel scan modes when SIMULT=0, this bit enables DMA for converter
 * B. When this bit is asserted, the DMA source selected by CTRL3[DMASRC] causes
 * the conversion results to be transferred by the DMA controller.
 *
 * Values:
 * - 0b0 - DMA is not enabled.
 * - 0b1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL2_DMAENB field. */
#define HSADC_RD_CTRL2_DMAENB(base) ((HSADC_CTRL2_REG(base) & HSADC_CTRL2_DMAENB_MASK) >> HSADC_CTRL2_DMAENB_SHIFT)
#define HSADC_BRD_CTRL2_DMAENB(base) (BME_UBFX16(&HSADC_CTRL2_REG(base), HSADC_CTRL2_DMAENB_SHIFT, HSADC_CTRL2_DMAENB_WIDTH))

/*! @brief Set the DMAENB field to a new value. */
#define HSADC_WR_CTRL2_DMAENB(base, value) (HSADC_RMW_CTRL2(base, HSADC_CTRL2_DMAENB_MASK, HSADC_CTRL2_DMAENB(value)))
#define HSADC_BWR_CTRL2_DMAENB(base, value) (BME_BFI16(&HSADC_CTRL2_REG(base), ((uint16_t)(value) << HSADC_CTRL2_DMAENB_SHIFT), HSADC_CTRL2_DMAENB_SHIFT, HSADC_CTRL2_DMAENB_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_ZXCTRL1 - HSADC Zero Crossing Control 1 Register
 ******************************************************************************/

/*!
 * @brief HSADC_ZXCTRL1 - HSADC Zero Crossing Control 1 Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The HSADC Zero crossing 1 register controls the zero cross feature for each
 * of the eight ADC conversions made on HSADC channels acquired by SAMPLE0 to
 * SAMPLE7 in the CLIST1 and CLIST2 registers. Each of the ZCEn fields corresponds to
 * the SAMPLEn channel selected. For example, ZCE7 field will enable/disable
 * zero cross detect on the HSADC channel selected by SAMPLE7 field in CLIST2
 * register.
 */
/*!
 * @name Constants and macros for entire HSADC_ZXCTRL1 register
 */
/*@{*/
#define HSADC_RD_ZXCTRL1(base)   (HSADC_ZXCTRL1_REG(base))
#define HSADC_WR_ZXCTRL1(base, value) (HSADC_ZXCTRL1_REG(base) = (value))
#define HSADC_RMW_ZXCTRL1(base, mask, value) (HSADC_WR_ZXCTRL1(base, (HSADC_RD_ZXCTRL1(base) & ~(mask)) | (value)))
#define HSADC_SET_ZXCTRL1(base, value) (BME_OR16(&HSADC_ZXCTRL1_REG(base), (uint16_t)(value)))
#define HSADC_CLR_ZXCTRL1(base, value) (BME_AND16(&HSADC_ZXCTRL1_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_ZXCTRL1(base, value) (BME_XOR16(&HSADC_ZXCTRL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_ZXCTRL1 bitfields
 */

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE0[1:0] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE0 field. */
#define HSADC_RD_ZXCTRL1_ZCE0(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE0_MASK) >> HSADC_ZXCTRL1_ZCE0_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE0(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE0_SHIFT, HSADC_ZXCTRL1_ZCE0_WIDTH))

/*! @brief Set the ZCE0 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE0(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE0_MASK, HSADC_ZXCTRL1_ZCE0(value)))
#define HSADC_BWR_ZXCTRL1_ZCE0(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE0_SHIFT), HSADC_ZXCTRL1_ZCE0_SHIFT, HSADC_ZXCTRL1_ZCE0_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE1[3:2] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE1 field. */
#define HSADC_RD_ZXCTRL1_ZCE1(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE1_MASK) >> HSADC_ZXCTRL1_ZCE1_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE1(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE1_SHIFT, HSADC_ZXCTRL1_ZCE1_WIDTH))

/*! @brief Set the ZCE1 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE1(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE1_MASK, HSADC_ZXCTRL1_ZCE1(value)))
#define HSADC_BWR_ZXCTRL1_ZCE1(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE1_SHIFT), HSADC_ZXCTRL1_ZCE1_SHIFT, HSADC_ZXCTRL1_ZCE1_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE2[5:4] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE2 field. */
#define HSADC_RD_ZXCTRL1_ZCE2(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE2_MASK) >> HSADC_ZXCTRL1_ZCE2_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE2(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE2_SHIFT, HSADC_ZXCTRL1_ZCE2_WIDTH))

/*! @brief Set the ZCE2 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE2(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE2_MASK, HSADC_ZXCTRL1_ZCE2(value)))
#define HSADC_BWR_ZXCTRL1_ZCE2(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE2_SHIFT), HSADC_ZXCTRL1_ZCE2_SHIFT, HSADC_ZXCTRL1_ZCE2_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE3[7:6] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE3 field. */
#define HSADC_RD_ZXCTRL1_ZCE3(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE3_MASK) >> HSADC_ZXCTRL1_ZCE3_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE3(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE3_SHIFT, HSADC_ZXCTRL1_ZCE3_WIDTH))

/*! @brief Set the ZCE3 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE3(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE3_MASK, HSADC_ZXCTRL1_ZCE3(value)))
#define HSADC_BWR_ZXCTRL1_ZCE3(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE3_SHIFT), HSADC_ZXCTRL1_ZCE3_SHIFT, HSADC_ZXCTRL1_ZCE3_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE4[9:8] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE4 field. */
#define HSADC_RD_ZXCTRL1_ZCE4(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE4_MASK) >> HSADC_ZXCTRL1_ZCE4_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE4(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE4_SHIFT, HSADC_ZXCTRL1_ZCE4_WIDTH))

/*! @brief Set the ZCE4 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE4(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE4_MASK, HSADC_ZXCTRL1_ZCE4(value)))
#define HSADC_BWR_ZXCTRL1_ZCE4(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE4_SHIFT), HSADC_ZXCTRL1_ZCE4_SHIFT, HSADC_ZXCTRL1_ZCE4_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE5[11:10] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE5 field. */
#define HSADC_RD_ZXCTRL1_ZCE5(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE5_MASK) >> HSADC_ZXCTRL1_ZCE5_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE5(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE5_SHIFT, HSADC_ZXCTRL1_ZCE5_WIDTH))

/*! @brief Set the ZCE5 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE5(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE5_MASK, HSADC_ZXCTRL1_ZCE5(value)))
#define HSADC_BWR_ZXCTRL1_ZCE5(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE5_SHIFT), HSADC_ZXCTRL1_ZCE5_SHIFT, HSADC_ZXCTRL1_ZCE5_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE6[13:12] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE6 field. */
#define HSADC_RD_ZXCTRL1_ZCE6(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE6_MASK) >> HSADC_ZXCTRL1_ZCE6_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE6(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE6_SHIFT, HSADC_ZXCTRL1_ZCE6_WIDTH))

/*! @brief Set the ZCE6 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE6(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE6_MASK, HSADC_ZXCTRL1_ZCE6(value)))
#define HSADC_BWR_ZXCTRL1_ZCE6(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE6_SHIFT), HSADC_ZXCTRL1_ZCE6_SHIFT, HSADC_ZXCTRL1_ZCE6_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL1, field ZCE7[15:14] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL1_ZCE7 field. */
#define HSADC_RD_ZXCTRL1_ZCE7(base) ((HSADC_ZXCTRL1_REG(base) & HSADC_ZXCTRL1_ZCE7_MASK) >> HSADC_ZXCTRL1_ZCE7_SHIFT)
#define HSADC_BRD_ZXCTRL1_ZCE7(base) (BME_UBFX16(&HSADC_ZXCTRL1_REG(base), HSADC_ZXCTRL1_ZCE7_SHIFT, HSADC_ZXCTRL1_ZCE7_WIDTH))

/*! @brief Set the ZCE7 field to a new value. */
#define HSADC_WR_ZXCTRL1_ZCE7(base, value) (HSADC_RMW_ZXCTRL1(base, HSADC_ZXCTRL1_ZCE7_MASK, HSADC_ZXCTRL1_ZCE7(value)))
#define HSADC_BWR_ZXCTRL1_ZCE7(base, value) (BME_BFI16(&HSADC_ZXCTRL1_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL1_ZCE7_SHIFT), HSADC_ZXCTRL1_ZCE7_SHIFT, HSADC_ZXCTRL1_ZCE7_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_ZXCTRL2 - HSADC Zero Crossing Control 2 Register
 ******************************************************************************/

/*!
 * @brief HSADC_ZXCTRL2 - HSADC Zero Crossing Control 2 Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The HSADC Zero Crossing Control 2 register controls the zero cross feature
 * for each of the eight ADC conversions made on HSADC channels acquired by SAMPLE8
 * to SAMPLE15 in the CLIST3 and CLIST4 registers. Each of the ZCEn fields
 * corresponds to the SAMPLEn channel selected. For example, ZCE15 field will
 * enable/disable zero cross detect on the HSADC channel selected by SAMPLE15 field in
 * CLIST4 register.
 */
/*!
 * @name Constants and macros for entire HSADC_ZXCTRL2 register
 */
/*@{*/
#define HSADC_RD_ZXCTRL2(base)   (HSADC_ZXCTRL2_REG(base))
#define HSADC_WR_ZXCTRL2(base, value) (HSADC_ZXCTRL2_REG(base) = (value))
#define HSADC_RMW_ZXCTRL2(base, mask, value) (HSADC_WR_ZXCTRL2(base, (HSADC_RD_ZXCTRL2(base) & ~(mask)) | (value)))
#define HSADC_SET_ZXCTRL2(base, value) (BME_OR16(&HSADC_ZXCTRL2_REG(base), (uint16_t)(value)))
#define HSADC_CLR_ZXCTRL2(base, value) (BME_AND16(&HSADC_ZXCTRL2_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_ZXCTRL2(base, value) (BME_XOR16(&HSADC_ZXCTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_ZXCTRL2 bitfields
 */

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE8[1:0] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE8 field. */
#define HSADC_RD_ZXCTRL2_ZCE8(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE8_MASK) >> HSADC_ZXCTRL2_ZCE8_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE8(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE8_SHIFT, HSADC_ZXCTRL2_ZCE8_WIDTH))

/*! @brief Set the ZCE8 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE8(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE8_MASK, HSADC_ZXCTRL2_ZCE8(value)))
#define HSADC_BWR_ZXCTRL2_ZCE8(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE8_SHIFT), HSADC_ZXCTRL2_ZCE8_SHIFT, HSADC_ZXCTRL2_ZCE8_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE9[3:2] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE9 field. */
#define HSADC_RD_ZXCTRL2_ZCE9(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE9_MASK) >> HSADC_ZXCTRL2_ZCE9_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE9(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE9_SHIFT, HSADC_ZXCTRL2_ZCE9_WIDTH))

/*! @brief Set the ZCE9 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE9(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE9_MASK, HSADC_ZXCTRL2_ZCE9(value)))
#define HSADC_BWR_ZXCTRL2_ZCE9(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE9_SHIFT), HSADC_ZXCTRL2_ZCE9_SHIFT, HSADC_ZXCTRL2_ZCE9_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE10[5:4] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE10 field. */
#define HSADC_RD_ZXCTRL2_ZCE10(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE10_MASK) >> HSADC_ZXCTRL2_ZCE10_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE10(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE10_SHIFT, HSADC_ZXCTRL2_ZCE10_WIDTH))

/*! @brief Set the ZCE10 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE10(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE10_MASK, HSADC_ZXCTRL2_ZCE10(value)))
#define HSADC_BWR_ZXCTRL2_ZCE10(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE10_SHIFT), HSADC_ZXCTRL2_ZCE10_SHIFT, HSADC_ZXCTRL2_ZCE10_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE11[7:6] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE11 field. */
#define HSADC_RD_ZXCTRL2_ZCE11(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE11_MASK) >> HSADC_ZXCTRL2_ZCE11_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE11(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE11_SHIFT, HSADC_ZXCTRL2_ZCE11_WIDTH))

/*! @brief Set the ZCE11 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE11(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE11_MASK, HSADC_ZXCTRL2_ZCE11(value)))
#define HSADC_BWR_ZXCTRL2_ZCE11(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE11_SHIFT), HSADC_ZXCTRL2_ZCE11_SHIFT, HSADC_ZXCTRL2_ZCE11_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE12[9:8] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE12 field. */
#define HSADC_RD_ZXCTRL2_ZCE12(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE12_MASK) >> HSADC_ZXCTRL2_ZCE12_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE12(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE12_SHIFT, HSADC_ZXCTRL2_ZCE12_WIDTH))

/*! @brief Set the ZCE12 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE12(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE12_MASK, HSADC_ZXCTRL2_ZCE12(value)))
#define HSADC_BWR_ZXCTRL2_ZCE12(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE12_SHIFT), HSADC_ZXCTRL2_ZCE12_SHIFT, HSADC_ZXCTRL2_ZCE12_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE13[11:10] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE13 field. */
#define HSADC_RD_ZXCTRL2_ZCE13(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE13_MASK) >> HSADC_ZXCTRL2_ZCE13_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE13(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE13_SHIFT, HSADC_ZXCTRL2_ZCE13_WIDTH))

/*! @brief Set the ZCE13 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE13(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE13_MASK, HSADC_ZXCTRL2_ZCE13(value)))
#define HSADC_BWR_ZXCTRL2_ZCE13(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE13_SHIFT), HSADC_ZXCTRL2_ZCE13_SHIFT, HSADC_ZXCTRL2_ZCE13_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE14[13:12] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE14 field. */
#define HSADC_RD_ZXCTRL2_ZCE14(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE14_MASK) >> HSADC_ZXCTRL2_ZCE14_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE14(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE14_SHIFT, HSADC_ZXCTRL2_ZCE14_WIDTH))

/*! @brief Set the ZCE14 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE14(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE14_MASK, HSADC_ZXCTRL2_ZCE14(value)))
#define HSADC_BWR_ZXCTRL2_ZCE14(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE14_SHIFT), HSADC_ZXCTRL2_ZCE14_SHIFT, HSADC_ZXCTRL2_ZCE14_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_ZXCTRL2, field ZCE15[15:14] (RW)
 *
 * Values:
 * - 0b00 - Zero Crossing disabled
 * - 0b01 - Zero Crossing enabled for positive to negative sign change
 * - 0b10 - Zero Crossing enabled for negative to positive sign change
 * - 0b11 - Zero Crossing enabled for any sign change
 */
/*@{*/
/*! @brief Read current value of the HSADC_ZXCTRL2_ZCE15 field. */
#define HSADC_RD_ZXCTRL2_ZCE15(base) ((HSADC_ZXCTRL2_REG(base) & HSADC_ZXCTRL2_ZCE15_MASK) >> HSADC_ZXCTRL2_ZCE15_SHIFT)
#define HSADC_BRD_ZXCTRL2_ZCE15(base) (BME_UBFX16(&HSADC_ZXCTRL2_REG(base), HSADC_ZXCTRL2_ZCE15_SHIFT, HSADC_ZXCTRL2_ZCE15_WIDTH))

/*! @brief Set the ZCE15 field to a new value. */
#define HSADC_WR_ZXCTRL2_ZCE15(base, value) (HSADC_RMW_ZXCTRL2(base, HSADC_ZXCTRL2_ZCE15_MASK, HSADC_ZXCTRL2_ZCE15(value)))
#define HSADC_BWR_ZXCTRL2_ZCE15(base, value) (BME_BFI16(&HSADC_ZXCTRL2_REG(base), ((uint16_t)(value) << HSADC_ZXCTRL2_ZCE15_SHIFT), HSADC_ZXCTRL2_ZCE15_SHIFT, HSADC_ZXCTRL2_ZCE15_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CLIST1 - HSADC Channel List Register 1
 ******************************************************************************/

/*!
 * @brief HSADC_CLIST1 - HSADC Channel List Register 1 (RW)
 *
 * Reset value: 0x3210U
 *
 * This register configures the analog inputs to be sampled. For ANx6 and ANx7,
 * see Input Multiplex Function for more details.
 */
/*!
 * @name Constants and macros for entire HSADC_CLIST1 register
 */
/*@{*/
#define HSADC_RD_CLIST1(base)    (HSADC_CLIST1_REG(base))
#define HSADC_WR_CLIST1(base, value) (HSADC_CLIST1_REG(base) = (value))
#define HSADC_RMW_CLIST1(base, mask, value) (HSADC_WR_CLIST1(base, (HSADC_RD_CLIST1(base) & ~(mask)) | (value)))
#define HSADC_SET_CLIST1(base, value) (BME_OR16(&HSADC_CLIST1_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CLIST1(base, value) (BME_AND16(&HSADC_CLIST1_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CLIST1(base, value) (BME_XOR16(&HSADC_CLIST1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CLIST1 bitfields
 */

/*!
 * @name Register HSADC_CLIST1, field SAMPLE0[3:0] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[0].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST1_SAMPLE0 field. */
#define HSADC_RD_CLIST1_SAMPLE0(base) ((HSADC_CLIST1_REG(base) & HSADC_CLIST1_SAMPLE0_MASK) >> HSADC_CLIST1_SAMPLE0_SHIFT)
#define HSADC_BRD_CLIST1_SAMPLE0(base) (BME_UBFX16(&HSADC_CLIST1_REG(base), HSADC_CLIST1_SAMPLE0_SHIFT, HSADC_CLIST1_SAMPLE0_WIDTH))

/*! @brief Set the SAMPLE0 field to a new value. */
#define HSADC_WR_CLIST1_SAMPLE0(base, value) (HSADC_RMW_CLIST1(base, HSADC_CLIST1_SAMPLE0_MASK, HSADC_CLIST1_SAMPLE0(value)))
#define HSADC_BWR_CLIST1_SAMPLE0(base, value) (BME_BFI16(&HSADC_CLIST1_REG(base), ((uint16_t)(value) << HSADC_CLIST1_SAMPLE0_SHIFT), HSADC_CLIST1_SAMPLE0_SHIFT, HSADC_CLIST1_SAMPLE0_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST1, field SAMPLE1[7:4] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[1].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST1_SAMPLE1 field. */
#define HSADC_RD_CLIST1_SAMPLE1(base) ((HSADC_CLIST1_REG(base) & HSADC_CLIST1_SAMPLE1_MASK) >> HSADC_CLIST1_SAMPLE1_SHIFT)
#define HSADC_BRD_CLIST1_SAMPLE1(base) (BME_UBFX16(&HSADC_CLIST1_REG(base), HSADC_CLIST1_SAMPLE1_SHIFT, HSADC_CLIST1_SAMPLE1_WIDTH))

/*! @brief Set the SAMPLE1 field to a new value. */
#define HSADC_WR_CLIST1_SAMPLE1(base, value) (HSADC_RMW_CLIST1(base, HSADC_CLIST1_SAMPLE1_MASK, HSADC_CLIST1_SAMPLE1(value)))
#define HSADC_BWR_CLIST1_SAMPLE1(base, value) (BME_BFI16(&HSADC_CLIST1_REG(base), ((uint16_t)(value) << HSADC_CLIST1_SAMPLE1_SHIFT), HSADC_CLIST1_SAMPLE1_SHIFT, HSADC_CLIST1_SAMPLE1_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST1, field SAMPLE2[11:8] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[2].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST1_SAMPLE2 field. */
#define HSADC_RD_CLIST1_SAMPLE2(base) ((HSADC_CLIST1_REG(base) & HSADC_CLIST1_SAMPLE2_MASK) >> HSADC_CLIST1_SAMPLE2_SHIFT)
#define HSADC_BRD_CLIST1_SAMPLE2(base) (BME_UBFX16(&HSADC_CLIST1_REG(base), HSADC_CLIST1_SAMPLE2_SHIFT, HSADC_CLIST1_SAMPLE2_WIDTH))

/*! @brief Set the SAMPLE2 field to a new value. */
#define HSADC_WR_CLIST1_SAMPLE2(base, value) (HSADC_RMW_CLIST1(base, HSADC_CLIST1_SAMPLE2_MASK, HSADC_CLIST1_SAMPLE2(value)))
#define HSADC_BWR_CLIST1_SAMPLE2(base, value) (BME_BFI16(&HSADC_CLIST1_REG(base), ((uint16_t)(value) << HSADC_CLIST1_SAMPLE2_SHIFT), HSADC_CLIST1_SAMPLE2_SHIFT, HSADC_CLIST1_SAMPLE2_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST1, field SAMPLE3[15:12] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[DS3].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST1_SAMPLE3 field. */
#define HSADC_RD_CLIST1_SAMPLE3(base) ((HSADC_CLIST1_REG(base) & HSADC_CLIST1_SAMPLE3_MASK) >> HSADC_CLIST1_SAMPLE3_SHIFT)
#define HSADC_BRD_CLIST1_SAMPLE3(base) (BME_UBFX16(&HSADC_CLIST1_REG(base), HSADC_CLIST1_SAMPLE3_SHIFT, HSADC_CLIST1_SAMPLE3_WIDTH))

/*! @brief Set the SAMPLE3 field to a new value. */
#define HSADC_WR_CLIST1_SAMPLE3(base, value) (HSADC_RMW_CLIST1(base, HSADC_CLIST1_SAMPLE3_MASK, HSADC_CLIST1_SAMPLE3(value)))
#define HSADC_BWR_CLIST1_SAMPLE3(base, value) (BME_BFI16(&HSADC_CLIST1_REG(base), ((uint16_t)(value) << HSADC_CLIST1_SAMPLE3_SHIFT), HSADC_CLIST1_SAMPLE3_SHIFT, HSADC_CLIST1_SAMPLE3_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CLIST2 - HSADC Channel List Register 2
 ******************************************************************************/

/*!
 * @brief HSADC_CLIST2 - HSADC Channel List Register 2 (RW)
 *
 * Reset value: 0x7654U
 *
 * This register configures the analog inputs to be sampled. For ANx6 and ANx7,
 * see Input Multiplex Function for more details.
 */
/*!
 * @name Constants and macros for entire HSADC_CLIST2 register
 */
/*@{*/
#define HSADC_RD_CLIST2(base)    (HSADC_CLIST2_REG(base))
#define HSADC_WR_CLIST2(base, value) (HSADC_CLIST2_REG(base) = (value))
#define HSADC_RMW_CLIST2(base, mask, value) (HSADC_WR_CLIST2(base, (HSADC_RD_CLIST2(base) & ~(mask)) | (value)))
#define HSADC_SET_CLIST2(base, value) (BME_OR16(&HSADC_CLIST2_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CLIST2(base, value) (BME_AND16(&HSADC_CLIST2_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CLIST2(base, value) (BME_XOR16(&HSADC_CLIST2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CLIST2 bitfields
 */

/*!
 * @name Register HSADC_CLIST2, field SAMPLE4[3:0] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[4].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST2_SAMPLE4 field. */
#define HSADC_RD_CLIST2_SAMPLE4(base) ((HSADC_CLIST2_REG(base) & HSADC_CLIST2_SAMPLE4_MASK) >> HSADC_CLIST2_SAMPLE4_SHIFT)
#define HSADC_BRD_CLIST2_SAMPLE4(base) (BME_UBFX16(&HSADC_CLIST2_REG(base), HSADC_CLIST2_SAMPLE4_SHIFT, HSADC_CLIST2_SAMPLE4_WIDTH))

/*! @brief Set the SAMPLE4 field to a new value. */
#define HSADC_WR_CLIST2_SAMPLE4(base, value) (HSADC_RMW_CLIST2(base, HSADC_CLIST2_SAMPLE4_MASK, HSADC_CLIST2_SAMPLE4(value)))
#define HSADC_BWR_CLIST2_SAMPLE4(base, value) (BME_BFI16(&HSADC_CLIST2_REG(base), ((uint16_t)(value) << HSADC_CLIST2_SAMPLE4_SHIFT), HSADC_CLIST2_SAMPLE4_SHIFT, HSADC_CLIST2_SAMPLE4_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST2, field SAMPLE5[7:4] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[5].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST2_SAMPLE5 field. */
#define HSADC_RD_CLIST2_SAMPLE5(base) ((HSADC_CLIST2_REG(base) & HSADC_CLIST2_SAMPLE5_MASK) >> HSADC_CLIST2_SAMPLE5_SHIFT)
#define HSADC_BRD_CLIST2_SAMPLE5(base) (BME_UBFX16(&HSADC_CLIST2_REG(base), HSADC_CLIST2_SAMPLE5_SHIFT, HSADC_CLIST2_SAMPLE5_WIDTH))

/*! @brief Set the SAMPLE5 field to a new value. */
#define HSADC_WR_CLIST2_SAMPLE5(base, value) (HSADC_RMW_CLIST2(base, HSADC_CLIST2_SAMPLE5_MASK, HSADC_CLIST2_SAMPLE5(value)))
#define HSADC_BWR_CLIST2_SAMPLE5(base, value) (BME_BFI16(&HSADC_CLIST2_REG(base), ((uint16_t)(value) << HSADC_CLIST2_SAMPLE5_SHIFT), HSADC_CLIST2_SAMPLE5_SHIFT, HSADC_CLIST2_SAMPLE5_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST2, field SAMPLE6[11:8] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[6].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST2_SAMPLE6 field. */
#define HSADC_RD_CLIST2_SAMPLE6(base) ((HSADC_CLIST2_REG(base) & HSADC_CLIST2_SAMPLE6_MASK) >> HSADC_CLIST2_SAMPLE6_SHIFT)
#define HSADC_BRD_CLIST2_SAMPLE6(base) (BME_UBFX16(&HSADC_CLIST2_REG(base), HSADC_CLIST2_SAMPLE6_SHIFT, HSADC_CLIST2_SAMPLE6_WIDTH))

/*! @brief Set the SAMPLE6 field to a new value. */
#define HSADC_WR_CLIST2_SAMPLE6(base, value) (HSADC_RMW_CLIST2(base, HSADC_CLIST2_SAMPLE6_MASK, HSADC_CLIST2_SAMPLE6(value)))
#define HSADC_BWR_CLIST2_SAMPLE6(base, value) (BME_BFI16(&HSADC_CLIST2_REG(base), ((uint16_t)(value) << HSADC_CLIST2_SAMPLE6_SHIFT), HSADC_CLIST2_SAMPLE6_SHIFT, HSADC_CLIST2_SAMPLE6_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST2, field SAMPLE7[15:12] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[7].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST2_SAMPLE7 field. */
#define HSADC_RD_CLIST2_SAMPLE7(base) ((HSADC_CLIST2_REG(base) & HSADC_CLIST2_SAMPLE7_MASK) >> HSADC_CLIST2_SAMPLE7_SHIFT)
#define HSADC_BRD_CLIST2_SAMPLE7(base) (BME_UBFX16(&HSADC_CLIST2_REG(base), HSADC_CLIST2_SAMPLE7_SHIFT, HSADC_CLIST2_SAMPLE7_WIDTH))

/*! @brief Set the SAMPLE7 field to a new value. */
#define HSADC_WR_CLIST2_SAMPLE7(base, value) (HSADC_RMW_CLIST2(base, HSADC_CLIST2_SAMPLE7_MASK, HSADC_CLIST2_SAMPLE7(value)))
#define HSADC_BWR_CLIST2_SAMPLE7(base, value) (BME_BFI16(&HSADC_CLIST2_REG(base), ((uint16_t)(value) << HSADC_CLIST2_SAMPLE7_SHIFT), HSADC_CLIST2_SAMPLE7_SHIFT, HSADC_CLIST2_SAMPLE7_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CLIST3 - HSADC Channel List Register 3
 ******************************************************************************/

/*!
 * @brief HSADC_CLIST3 - HSADC Channel List Register 3 (RW)
 *
 * Reset value: 0xBA98U
 *
 * This register configures the analog inputs to be sampled. For ANx6 and ANx7,
 * see Input Multiplex Function for more details.
 */
/*!
 * @name Constants and macros for entire HSADC_CLIST3 register
 */
/*@{*/
#define HSADC_RD_CLIST3(base)    (HSADC_CLIST3_REG(base))
#define HSADC_WR_CLIST3(base, value) (HSADC_CLIST3_REG(base) = (value))
#define HSADC_RMW_CLIST3(base, mask, value) (HSADC_WR_CLIST3(base, (HSADC_RD_CLIST3(base) & ~(mask)) | (value)))
#define HSADC_SET_CLIST3(base, value) (BME_OR16(&HSADC_CLIST3_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CLIST3(base, value) (BME_AND16(&HSADC_CLIST3_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CLIST3(base, value) (BME_XOR16(&HSADC_CLIST3_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CLIST3 bitfields
 */

/*!
 * @name Register HSADC_CLIST3, field SAMPLE8[3:0] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[8].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST3_SAMPLE8 field. */
#define HSADC_RD_CLIST3_SAMPLE8(base) ((HSADC_CLIST3_REG(base) & HSADC_CLIST3_SAMPLE8_MASK) >> HSADC_CLIST3_SAMPLE8_SHIFT)
#define HSADC_BRD_CLIST3_SAMPLE8(base) (BME_UBFX16(&HSADC_CLIST3_REG(base), HSADC_CLIST3_SAMPLE8_SHIFT, HSADC_CLIST3_SAMPLE8_WIDTH))

/*! @brief Set the SAMPLE8 field to a new value. */
#define HSADC_WR_CLIST3_SAMPLE8(base, value) (HSADC_RMW_CLIST3(base, HSADC_CLIST3_SAMPLE8_MASK, HSADC_CLIST3_SAMPLE8(value)))
#define HSADC_BWR_CLIST3_SAMPLE8(base, value) (BME_BFI16(&HSADC_CLIST3_REG(base), ((uint16_t)(value) << HSADC_CLIST3_SAMPLE8_SHIFT), HSADC_CLIST3_SAMPLE8_SHIFT, HSADC_CLIST3_SAMPLE8_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST3, field SAMPLE9[7:4] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[9].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST3_SAMPLE9 field. */
#define HSADC_RD_CLIST3_SAMPLE9(base) ((HSADC_CLIST3_REG(base) & HSADC_CLIST3_SAMPLE9_MASK) >> HSADC_CLIST3_SAMPLE9_SHIFT)
#define HSADC_BRD_CLIST3_SAMPLE9(base) (BME_UBFX16(&HSADC_CLIST3_REG(base), HSADC_CLIST3_SAMPLE9_SHIFT, HSADC_CLIST3_SAMPLE9_WIDTH))

/*! @brief Set the SAMPLE9 field to a new value. */
#define HSADC_WR_CLIST3_SAMPLE9(base, value) (HSADC_RMW_CLIST3(base, HSADC_CLIST3_SAMPLE9_MASK, HSADC_CLIST3_SAMPLE9(value)))
#define HSADC_BWR_CLIST3_SAMPLE9(base, value) (BME_BFI16(&HSADC_CLIST3_REG(base), ((uint16_t)(value) << HSADC_CLIST3_SAMPLE9_SHIFT), HSADC_CLIST3_SAMPLE9_SHIFT, HSADC_CLIST3_SAMPLE9_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST3, field SAMPLE10[11:8] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[10].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST3_SAMPLE10 field. */
#define HSADC_RD_CLIST3_SAMPLE10(base) ((HSADC_CLIST3_REG(base) & HSADC_CLIST3_SAMPLE10_MASK) >> HSADC_CLIST3_SAMPLE10_SHIFT)
#define HSADC_BRD_CLIST3_SAMPLE10(base) (BME_UBFX16(&HSADC_CLIST3_REG(base), HSADC_CLIST3_SAMPLE10_SHIFT, HSADC_CLIST3_SAMPLE10_WIDTH))

/*! @brief Set the SAMPLE10 field to a new value. */
#define HSADC_WR_CLIST3_SAMPLE10(base, value) (HSADC_RMW_CLIST3(base, HSADC_CLIST3_SAMPLE10_MASK, HSADC_CLIST3_SAMPLE10(value)))
#define HSADC_BWR_CLIST3_SAMPLE10(base, value) (BME_BFI16(&HSADC_CLIST3_REG(base), ((uint16_t)(value) << HSADC_CLIST3_SAMPLE10_SHIFT), HSADC_CLIST3_SAMPLE10_SHIFT, HSADC_CLIST3_SAMPLE10_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST3, field SAMPLE11[15:12] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[11].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST3_SAMPLE11 field. */
#define HSADC_RD_CLIST3_SAMPLE11(base) ((HSADC_CLIST3_REG(base) & HSADC_CLIST3_SAMPLE11_MASK) >> HSADC_CLIST3_SAMPLE11_SHIFT)
#define HSADC_BRD_CLIST3_SAMPLE11(base) (BME_UBFX16(&HSADC_CLIST3_REG(base), HSADC_CLIST3_SAMPLE11_SHIFT, HSADC_CLIST3_SAMPLE11_WIDTH))

/*! @brief Set the SAMPLE11 field to a new value. */
#define HSADC_WR_CLIST3_SAMPLE11(base, value) (HSADC_RMW_CLIST3(base, HSADC_CLIST3_SAMPLE11_MASK, HSADC_CLIST3_SAMPLE11(value)))
#define HSADC_BWR_CLIST3_SAMPLE11(base, value) (BME_BFI16(&HSADC_CLIST3_REG(base), ((uint16_t)(value) << HSADC_CLIST3_SAMPLE11_SHIFT), HSADC_CLIST3_SAMPLE11_SHIFT, HSADC_CLIST3_SAMPLE11_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CLIST4 - HSADC Channel List Register 4
 ******************************************************************************/

/*!
 * @brief HSADC_CLIST4 - HSADC Channel List Register 4 (RW)
 *
 * Reset value: 0xFEDCU
 *
 * This register configures the analog inputs to be sampled. For ANx6 and ANx7,
 * see Input Multiplex Function for more details.
 */
/*!
 * @name Constants and macros for entire HSADC_CLIST4 register
 */
/*@{*/
#define HSADC_RD_CLIST4(base)    (HSADC_CLIST4_REG(base))
#define HSADC_WR_CLIST4(base, value) (HSADC_CLIST4_REG(base) = (value))
#define HSADC_RMW_CLIST4(base, mask, value) (HSADC_WR_CLIST4(base, (HSADC_RD_CLIST4(base) & ~(mask)) | (value)))
#define HSADC_SET_CLIST4(base, value) (BME_OR16(&HSADC_CLIST4_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CLIST4(base, value) (BME_AND16(&HSADC_CLIST4_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CLIST4(base, value) (BME_XOR16(&HSADC_CLIST4_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CLIST4 bitfields
 */

/*!
 * @name Register HSADC_CLIST4, field SAMPLE12[3:0] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[12].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST4_SAMPLE12 field. */
#define HSADC_RD_CLIST4_SAMPLE12(base) ((HSADC_CLIST4_REG(base) & HSADC_CLIST4_SAMPLE12_MASK) >> HSADC_CLIST4_SAMPLE12_SHIFT)
#define HSADC_BRD_CLIST4_SAMPLE12(base) (BME_UBFX16(&HSADC_CLIST4_REG(base), HSADC_CLIST4_SAMPLE12_SHIFT, HSADC_CLIST4_SAMPLE12_WIDTH))

/*! @brief Set the SAMPLE12 field to a new value. */
#define HSADC_WR_CLIST4_SAMPLE12(base, value) (HSADC_RMW_CLIST4(base, HSADC_CLIST4_SAMPLE12_MASK, HSADC_CLIST4_SAMPLE12(value)))
#define HSADC_BWR_CLIST4_SAMPLE12(base, value) (BME_BFI16(&HSADC_CLIST4_REG(base), ((uint16_t)(value) << HSADC_CLIST4_SAMPLE12_SHIFT), HSADC_CLIST4_SAMPLE12_SHIFT, HSADC_CLIST4_SAMPLE12_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST4, field SAMPLE13[7:4] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[13].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST4_SAMPLE13 field. */
#define HSADC_RD_CLIST4_SAMPLE13(base) ((HSADC_CLIST4_REG(base) & HSADC_CLIST4_SAMPLE13_MASK) >> HSADC_CLIST4_SAMPLE13_SHIFT)
#define HSADC_BRD_CLIST4_SAMPLE13(base) (BME_UBFX16(&HSADC_CLIST4_REG(base), HSADC_CLIST4_SAMPLE13_SHIFT, HSADC_CLIST4_SAMPLE13_WIDTH))

/*! @brief Set the SAMPLE13 field to a new value. */
#define HSADC_WR_CLIST4_SAMPLE13(base, value) (HSADC_RMW_CLIST4(base, HSADC_CLIST4_SAMPLE13_MASK, HSADC_CLIST4_SAMPLE13(value)))
#define HSADC_BWR_CLIST4_SAMPLE13(base, value) (BME_BFI16(&HSADC_CLIST4_REG(base), ((uint16_t)(value) << HSADC_CLIST4_SAMPLE13_SHIFT), HSADC_CLIST4_SAMPLE13_SHIFT, HSADC_CLIST4_SAMPLE13_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST4, field SAMPLE14[11:8] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[14].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST4_SAMPLE14 field. */
#define HSADC_RD_CLIST4_SAMPLE14(base) ((HSADC_CLIST4_REG(base) & HSADC_CLIST4_SAMPLE14_MASK) >> HSADC_CLIST4_SAMPLE14_SHIFT)
#define HSADC_BRD_CLIST4_SAMPLE14(base) (BME_UBFX16(&HSADC_CLIST4_REG(base), HSADC_CLIST4_SAMPLE14_SHIFT, HSADC_CLIST4_SAMPLE14_WIDTH))

/*! @brief Set the SAMPLE14 field to a new value. */
#define HSADC_WR_CLIST4_SAMPLE14(base, value) (HSADC_RMW_CLIST4(base, HSADC_CLIST4_SAMPLE14_MASK, HSADC_CLIST4_SAMPLE14(value)))
#define HSADC_BWR_CLIST4_SAMPLE14(base, value) (BME_BFI16(&HSADC_CLIST4_REG(base), ((uint16_t)(value) << HSADC_CLIST4_SAMPLE14_SHIFT), HSADC_CLIST4_SAMPLE14_SHIFT, HSADC_CLIST4_SAMPLE14_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CLIST4, field SAMPLE15[15:12] (RW)
 *
 * This sample and all subsequent samples can be disabled by setting SDIS[15].
 *
 * Values:
 * - 0b0000 - Single Ended: ANA0, Differential: ANA0+, ANA1-
 * - 0b0001 - Single Ended: ANA1, Differential: ANA0+, ANA1-
 * - 0b0010 - Single Ended: ANA2, Differential: ANA2+, ANA3-
 * - 0b0011 - Single Ended: ANA3, Differential: ANA2+, ANA3-
 * - 0b0100 - Single Ended: ANA4, Differential: ANA4+, ANA5-
 * - 0b0101 - Single Ended: ANA5, Differential: ANA4+, ANA5-
 * - 0b0110 - Single Ended: ANA6, Differential: ANA6+, ANA7-
 * - 0b0111 - Single Ended: ANA7, Differential: ANA6+, ANA7-
 * - 0b1000 - Single Ended: ANB0, Differential: ANB0+, ANB1-
 * - 0b1001 - Single Ended: ANB1, Differential: ANB0+, ANB1-
 * - 0b1010 - Single Ended: ANB2, Differential: ANB2+, ANB3-
 * - 0b1011 - Single Ended: ANB3, Differential: ANB2+, ANB3-
 * - 0b1100 - Single Ended: ANB4, Differential: ANB4+, ANB5-
 * - 0b1101 - Single Ended: ANB5, Differential: ANB4+, ANB5-
 * - 0b1110 - Single Ended: ANB6, Differential: ANB6+, ANB7-. See Input
 *     Multiplex Function section for more details.
 * - 0b1111 - Single Ended: ANB7, Differential: ANB6+, ANB7-
 */
/*@{*/
/*! @brief Read current value of the HSADC_CLIST4_SAMPLE15 field. */
#define HSADC_RD_CLIST4_SAMPLE15(base) ((HSADC_CLIST4_REG(base) & HSADC_CLIST4_SAMPLE15_MASK) >> HSADC_CLIST4_SAMPLE15_SHIFT)
#define HSADC_BRD_CLIST4_SAMPLE15(base) (BME_UBFX16(&HSADC_CLIST4_REG(base), HSADC_CLIST4_SAMPLE15_SHIFT, HSADC_CLIST4_SAMPLE15_WIDTH))

/*! @brief Set the SAMPLE15 field to a new value. */
#define HSADC_WR_CLIST4_SAMPLE15(base, value) (HSADC_RMW_CLIST4(base, HSADC_CLIST4_SAMPLE15_MASK, HSADC_CLIST4_SAMPLE15(value)))
#define HSADC_BWR_CLIST4_SAMPLE15(base, value) (BME_BFI16(&HSADC_CLIST4_REG(base), ((uint16_t)(value) << HSADC_CLIST4_SAMPLE15_SHIFT), HSADC_CLIST4_SAMPLE15_SHIFT, HSADC_CLIST4_SAMPLE15_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_SDIS - HSADC Sample Disable Register
 ******************************************************************************/

/*!
 * @brief HSADC_SDIS - HSADC Sample Disable Register (RW)
 *
 * Reset value: 0xF0F0U
 *
 * Each field of SDIS corresponds to a SAMPLEx field in one or multiple CLISTn
 * registers. For example, bit 0 of SDIS will enable/disable CLIST1[SAMPLE0], and
 * bit 15 of SDIS will enable/disable CLIST4[SAMPLE15]. If an SDIS bit is clear,
 * then the corresponding SAMPLEx field will be enabled in an HSADC scan. If the
 * SDIS bit is set, then the corresponding SAMPLEx field will be disabled and the
 * HSADC scan will be halted and subsequent ADC conversions will also not occur.
 * The HSADC will sequentially scan in order SAMPLE0, SAMPLE1, SAMPLE2,... and
 * so on. If SDIS=0xFFFE, then an HSADC scan will acquire SAMPLE0 while SAMPLE1,
 * SAMPLE2, and all other acquistions will not occur. The 4-bit wide SAMPLEx
 * fields are found in the CLISTn registers which select a particular HSADC channel
 * and whether it will be a differential or single ended conversion.
 */
/*!
 * @name Constants and macros for entire HSADC_SDIS register
 */
/*@{*/
#define HSADC_RD_SDIS(base)      (HSADC_SDIS_REG(base))
#define HSADC_WR_SDIS(base, value) (HSADC_SDIS_REG(base) = (value))
#define HSADC_RMW_SDIS(base, mask, value) (HSADC_WR_SDIS(base, (HSADC_RD_SDIS(base) & ~(mask)) | (value)))
#define HSADC_SET_SDIS(base, value) (BME_OR16(&HSADC_SDIS_REG(base), (uint16_t)(value)))
#define HSADC_CLR_SDIS(base, value) (BME_AND16(&HSADC_SDIS_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_SDIS(base, value) (BME_XOR16(&HSADC_SDIS_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_STAT - HSADC Status Register
 ******************************************************************************/

/*!
 * @brief HSADC_STAT - HSADC Status Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register provides the current status of the HSADC module. STAT[HLMTI]
 * and STAT[LLMTI] are cleared by writing 1s to all asserted bits in the limit
 * status register, LIMSTAT. Likewise, the STAT[ZCI] bit, is cleared by writing 1s to
 * all asserted bits in the zero crossing status register, ZXSTAT. The
 * STAT[EOSIx] bits are cleared by writing a one to them. Except for CIPA, CIPB, DUMMYA,
 * DUMMYB, CALONA, and CALONB, this register's fields are sticky. Once set to a
 * one state, they require some specific action to clear them. They are not cleared
 * automatically on the next scan sequence.
 */
/*!
 * @name Constants and macros for entire HSADC_STAT register
 */
/*@{*/
#define HSADC_RD_STAT(base)      (HSADC_STAT_REG(base))
#define HSADC_WR_STAT(base, value) (HSADC_STAT_REG(base) = (value))
#define HSADC_RMW_STAT(base, mask, value) (HSADC_WR_STAT(base, (HSADC_RD_STAT(base) & ~(mask)) | (value)))
#define HSADC_SET_STAT(base, value) (BME_OR16(&HSADC_STAT_REG(base), (uint16_t)(value)))
#define HSADC_CLR_STAT(base, value) (BME_AND16(&HSADC_STAT_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_STAT(base, value) (BME_XOR16(&HSADC_STAT_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_STAT bitfields
 */

/*!
 * @name Register HSADC_STAT, field CALONA[0] (RO)
 *
 * Values:
 * - 0b0 - Calibration is not running
 * - 0b1 - ADCA is running calibration conversions
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_CALONA field. */
#define HSADC_RD_STAT_CALONA(base) ((HSADC_STAT_REG(base) & HSADC_STAT_CALONA_MASK) >> HSADC_STAT_CALONA_SHIFT)
#define HSADC_BRD_STAT_CALONA(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_CALONA_SHIFT, HSADC_STAT_CALONA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field CALONB[1] (RO)
 *
 * Values:
 * - 0b0 - Calibration is not running
 * - 0b1 - ADCB is running calibration conversions
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_CALONB field. */
#define HSADC_RD_STAT_CALONB(base) ((HSADC_STAT_REG(base) & HSADC_STAT_CALONB_MASK) >> HSADC_STAT_CALONB_SHIFT)
#define HSADC_BRD_STAT_CALONB(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_CALONB_SHIFT, HSADC_STAT_CALONB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field DUMMYA[2] (RO)
 *
 * Values:
 * - 0b0 - Dummy conversion is not running
 * - 0b1 - Dummy conversion is running on ADCA
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_DUMMYA field. */
#define HSADC_RD_STAT_DUMMYA(base) ((HSADC_STAT_REG(base) & HSADC_STAT_DUMMYA_MASK) >> HSADC_STAT_DUMMYA_SHIFT)
#define HSADC_BRD_STAT_DUMMYA(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_DUMMYA_SHIFT, HSADC_STAT_DUMMYA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field DUMMYB[3] (RO)
 *
 * Values:
 * - 0b0 - Dummy conversion is not running
 * - 0b1 - Dummy conversion is running on ADCB
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_DUMMYB field. */
#define HSADC_RD_STAT_DUMMYB(base) ((HSADC_STAT_REG(base) & HSADC_STAT_DUMMYB_MASK) >> HSADC_STAT_DUMMYB_SHIFT)
#define HSADC_BRD_STAT_DUMMYB(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_DUMMYB_SHIFT, HSADC_STAT_DUMMYB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field EOCALIA[4] (W1C)
 *
 * It is asserted when requested calibrations (single, differential) are ended.
 * If just one type is requested then this flag is asserted at the end of that
 * calibration. It is cleared by writing 1 in the field.
 *
 * Values:
 * - 0b0 - Calibration is not finished.
 * - 0b1 - Calibration is finished on ADCA. The IRQ occurs if CALIB[EOCALIEA] is
 *     asserted.
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_EOCALIA field. */
#define HSADC_RD_STAT_EOCALIA(base) ((HSADC_STAT_REG(base) & HSADC_STAT_EOCALIA_MASK) >> HSADC_STAT_EOCALIA_SHIFT)
#define HSADC_BRD_STAT_EOCALIA(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_EOCALIA_SHIFT, HSADC_STAT_EOCALIA_WIDTH))

/*! @brief Set the EOCALIA field to a new value. */
#define HSADC_WR_STAT_EOCALIA(base, value) (HSADC_RMW_STAT(base, (HSADC_STAT_EOCALIA_MASK | HSADC_STAT_EOCALIB_MASK | HSADC_STAT_EOSIA_MASK | HSADC_STAT_EOSIB_MASK), HSADC_STAT_EOCALIA(value)))
#define HSADC_BWR_STAT_EOCALIA(base, value) (BME_BFI16(&HSADC_STAT_REG(base), ((uint16_t)(value) << HSADC_STAT_EOCALIA_SHIFT), HSADC_STAT_EOCALIA_SHIFT, HSADC_STAT_EOCALIA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field EOCALIB[5] (W1C)
 *
 * It is asserted when requested calibrations (single, differential) are ended.
 * If just one type is requested then this flag is asserted at the end of that
 * calibration. It is cleared by writing 1 in the field.
 *
 * Values:
 * - 0b0 - Calibration is not finished.
 * - 0b1 - Calibration is finished on ADCB. The IRQ occurs if CALIB[EOCALIEB] is
 *     asserted.
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_EOCALIB field. */
#define HSADC_RD_STAT_EOCALIB(base) ((HSADC_STAT_REG(base) & HSADC_STAT_EOCALIB_MASK) >> HSADC_STAT_EOCALIB_SHIFT)
#define HSADC_BRD_STAT_EOCALIB(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_EOCALIB_SHIFT, HSADC_STAT_EOCALIB_WIDTH))

/*! @brief Set the EOCALIB field to a new value. */
#define HSADC_WR_STAT_EOCALIB(base, value) (HSADC_RMW_STAT(base, (HSADC_STAT_EOCALIB_MASK | HSADC_STAT_EOCALIA_MASK | HSADC_STAT_EOSIA_MASK | HSADC_STAT_EOSIB_MASK), HSADC_STAT_EOCALIB(value)))
#define HSADC_BWR_STAT_EOCALIB(base, value) (BME_BFI16(&HSADC_STAT_REG(base), ((uint16_t)(value) << HSADC_STAT_EOCALIB_SHIFT), HSADC_STAT_EOCALIB_SHIFT, HSADC_STAT_EOCALIB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field HLMTI[8] (RO)
 *
 * If the respective high limit register is enabled by having a value other than
 * 7FF8h, high limit checking is enabled. This interrupt asserts at the
 * completion of an individual conversion which may or may not be the end of a scan. This
 * bit is cleared by writing a "1" to all active HILIMSTAT[HLS] bits.
 *
 * Values:
 * - 0b0 - No high limit interrupt request
 * - 0b1 - High limit exceeded, IRQ pending if CTRL1[HLMTIE] is set
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_HLMTI field. */
#define HSADC_RD_STAT_HLMTI(base) ((HSADC_STAT_REG(base) & HSADC_STAT_HLMTI_MASK) >> HSADC_STAT_HLMTI_SHIFT)
#define HSADC_BRD_STAT_HLMTI(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_HLMTI_SHIFT, HSADC_STAT_HLMTI_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field LLMTI[9] (RO)
 *
 * If the respective low limit register is enabled by having a value other than
 * 0000h, low limit checking is enabled. This interrupt asserts at the completion
 * of an individual conversion which may or may not be the end of a scan. This
 * bit is cleared by writing a "1" to all active LOLIMSTAT[LLS] bits.
 *
 * Values:
 * - 0b0 - No low limit interrupt request
 * - 0b1 - Low limit exceeded, IRQ pending if CTRL1[LLMTIE] is set
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_LLMTI field. */
#define HSADC_RD_STAT_LLMTI(base) ((HSADC_STAT_REG(base) & HSADC_STAT_LLMTI_MASK) >> HSADC_STAT_LLMTI_SHIFT)
#define HSADC_BRD_STAT_LLMTI(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_LLMTI_SHIFT, HSADC_STAT_LLMTI_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field ZCI[10] (RO)
 *
 * If the respective offset register is configured by having a value greater
 * than 0000h, zero crossing checking is enabled. If the offset register is
 * programmed with 7FF8h, the result will always be less than or equal to zero. On the
 * other hand, if 0000h is programmed into the offset register, the result will
 * always be greater than or equal to zero, and no zero crossing can occur because
 * the sign of the result will not change. This interrupt asserts at the
 * completion of an individual conversion which may or may not be the end of a scan. This
 * bit is cleared by writing a "1" to all active ZXSTAT[ZCS] bits.
 *
 * Values:
 * - 0b0 - No zero crossing interrupt request
 * - 0b1 - Zero crossing encountered, IRQ pending if CTRL1[ZCIE] is set
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_ZCI field. */
#define HSADC_RD_STAT_ZCI(base) ((HSADC_STAT_REG(base) & HSADC_STAT_ZCI_MASK) >> HSADC_STAT_ZCI_SHIFT)
#define HSADC_BRD_STAT_ZCI(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_ZCI_SHIFT, HSADC_STAT_ZCI_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field EOSIA[11] (W1C)
 *
 * This bit indicates whether a scan of analog inputs have been completed since
 * the last read of the status register or since a reset. This bit is cleared by
 * writing a one to it. This bit cannot be set by software. STAT[EOSIA] is the
 * preferred bit to poll for scan completion if interrupts are not enabled. In
 * looping scan modes, this interrupt is triggered at the completion of each
 * iteration of the loop. This interrupt is triggered upon the completion of any scan
 * except for the completion of a B converter scan in non-simultaneous parallel scan
 * modes.
 *
 * Values:
 * - 0b0 - A scan cycle has not been completed, no end of scan IRQ pending
 * - 0b1 - A scan cycle has been completed, end of scan IRQ pending
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_EOSIA field. */
#define HSADC_RD_STAT_EOSIA(base) ((HSADC_STAT_REG(base) & HSADC_STAT_EOSIA_MASK) >> HSADC_STAT_EOSIA_SHIFT)
#define HSADC_BRD_STAT_EOSIA(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_EOSIA_SHIFT, HSADC_STAT_EOSIA_WIDTH))

/*! @brief Set the EOSIA field to a new value. */
#define HSADC_WR_STAT_EOSIA(base, value) (HSADC_RMW_STAT(base, (HSADC_STAT_EOSIA_MASK | HSADC_STAT_EOCALIA_MASK | HSADC_STAT_EOCALIB_MASK | HSADC_STAT_EOSIB_MASK), HSADC_STAT_EOSIA(value)))
#define HSADC_BWR_STAT_EOSIA(base, value) (BME_BFI16(&HSADC_STAT_REG(base), ((uint16_t)(value) << HSADC_STAT_EOSIA_SHIFT), HSADC_STAT_EOSIA_SHIFT, HSADC_STAT_EOSIA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field EOSIB[12] (W1C)
 *
 * This bit indicates whether a scan of analog inputs have been completed since
 * the last read of the status register or since a reset. This bit is cleared by
 * writing a one to it. This bit cannot be set by software. In looping scan
 * modes, this interrupt is triggered at the completion of each iteration of the loop.
 * This interrupt is triggered only by the completion of a B converter scan in
 * non-simultaneous parallel scan modes.
 *
 * Values:
 * - 0b0 - A scan cycle has not been completed, no end of scan IRQ pending
 * - 0b1 - A scan cycle has been completed, end of scan IRQ pending
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_EOSIB field. */
#define HSADC_RD_STAT_EOSIB(base) ((HSADC_STAT_REG(base) & HSADC_STAT_EOSIB_MASK) >> HSADC_STAT_EOSIB_SHIFT)
#define HSADC_BRD_STAT_EOSIB(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_EOSIB_SHIFT, HSADC_STAT_EOSIB_WIDTH))

/*! @brief Set the EOSIB field to a new value. */
#define HSADC_WR_STAT_EOSIB(base, value) (HSADC_RMW_STAT(base, (HSADC_STAT_EOSIB_MASK | HSADC_STAT_EOCALIA_MASK | HSADC_STAT_EOCALIB_MASK | HSADC_STAT_EOSIA_MASK), HSADC_STAT_EOSIB(value)))
#define HSADC_BWR_STAT_EOSIB(base, value) (BME_BFI16(&HSADC_STAT_REG(base), ((uint16_t)(value) << HSADC_STAT_EOSIB_SHIFT), HSADC_STAT_EOSIB_SHIFT, HSADC_STAT_EOSIB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field CIPB[14] (RO)
 *
 * This bit indicates whether a scan is in progress. It also indicates if the
 * HSADC is running a dummy conversion or it is running a calibration procedure.
 * This refers only to a B converter scan / activity in non-simultaneous parallel
 * scan modes.
 *
 * Values:
 * - 0b0 - Idle state
 * - 0b1 - A scan cycle is in progress. The HSADC will ignore all sync pulses or
 *     start commands
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_CIPB field. */
#define HSADC_RD_STAT_CIPB(base) ((HSADC_STAT_REG(base) & HSADC_STAT_CIPB_MASK) >> HSADC_STAT_CIPB_SHIFT)
#define HSADC_BRD_STAT_CIPB(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_CIPB_SHIFT, HSADC_STAT_CIPB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_STAT, field CIPA[15] (RO)
 *
 * This bit indicates whether a scan is in progress. It also indicates if the
 * HSADC is running a dummy conversion or it is running a calibration procedure.
 * This refers to any scan / activity except a B converter scan in non-simultaneous
 * parallel scan modes.
 *
 * Values:
 * - 0b0 - Idle state
 * - 0b1 - A scan cycle is in progress. The HSADC will ignore all sync pulses or
 *     start commands
 */
/*@{*/
/*! @brief Read current value of the HSADC_STAT_CIPA field. */
#define HSADC_RD_STAT_CIPA(base) ((HSADC_STAT_REG(base) & HSADC_STAT_CIPA_MASK) >> HSADC_STAT_CIPA_SHIFT)
#define HSADC_BRD_STAT_CIPA(base) (BME_UBFX16(&HSADC_STAT_REG(base), HSADC_STAT_CIPA_SHIFT, HSADC_STAT_CIPA_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_RDY - HSADC Ready Register
 ******************************************************************************/

/*!
 * @brief HSADC_RDY - HSADC Ready Register (RO)
 *
 * Reset value: 0x0000U
 *
 * This register provides the current status of the HSADC conversions. RDY[RDYx]
 * bits are cleared by reading their corresponding result registers (RSLTx).
 */
/*!
 * @name Constants and macros for entire HSADC_RDY register
 */
/*@{*/
#define HSADC_RD_RDY(base)       (HSADC_RDY_REG(base))
/*@}*/

/*******************************************************************************
 * HSADC_LOLIMSTAT - HSADC Low Limit Status Register
 ******************************************************************************/

/*!
 * @brief HSADC_LOLIMSTAT - HSADC Low Limit Status Register (W1C)
 *
 * Reset value: 0x0000U
 *
 * The low limit status register latches in the result of the comparison between
 * the result of the sample and the respective low limit register, LOLIM0-15.
 * For example, if the result for the channel programmed in CLIST1[SAMPLE0] is
 * lower than the value programmed into the LOLIM0 register, then LOLIMSTAT[LLS0] is
 * set to one. An interrupt is generated if the CTRL1[LLMTIE] bit is set. These
 * bits are sticky. They are not cleared automatically by subsequent conversions.
 * Each bit is cleared only by writing a value of one to that specific bit.
 */
/*!
 * @name Constants and macros for entire HSADC_LOLIMSTAT register
 */
/*@{*/
#define HSADC_RD_LOLIMSTAT(base) (HSADC_LOLIMSTAT_REG(base))
#define HSADC_WR_LOLIMSTAT(base, value) (HSADC_LOLIMSTAT_REG(base) = (value))
#define HSADC_RMW_LOLIMSTAT(base, mask, value) (HSADC_WR_LOLIMSTAT(base, (HSADC_RD_LOLIMSTAT(base) & ~(mask)) | (value)))
#define HSADC_SET_LOLIMSTAT(base, value) (BME_OR16(&HSADC_LOLIMSTAT_REG(base), (uint16_t)(value)))
#define HSADC_CLR_LOLIMSTAT(base, value) (BME_AND16(&HSADC_LOLIMSTAT_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_LOLIMSTAT(base, value) (BME_XOR16(&HSADC_LOLIMSTAT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_HILIMSTAT - HSADC High Limit Status Register
 ******************************************************************************/

/*!
 * @brief HSADC_HILIMSTAT - HSADC High Limit Status Register (W1C)
 *
 * Reset value: 0x0000U
 *
 * The high limit status register latches in the result of the comparison
 * between the result of the sample and the respective high limit register, HILIM0-15.
 * For example, if the result for the channel programmed in CLIST1[SAMPLE0] is
 * greater than the value programmed into the HILIM0 register, then the
 * HILIMSTAT[HLS0] bit is set to one. An interrupt is generated if the CTRL1[HLMTIE] bit is
 * set. These bits are sticky. They are not cleared automatically by subsequent
 * conversions. Each bit is cleared only by writing a value of one to that
 * specific bit.
 */
/*!
 * @name Constants and macros for entire HSADC_HILIMSTAT register
 */
/*@{*/
#define HSADC_RD_HILIMSTAT(base) (HSADC_HILIMSTAT_REG(base))
#define HSADC_WR_HILIMSTAT(base, value) (HSADC_HILIMSTAT_REG(base) = (value))
#define HSADC_RMW_HILIMSTAT(base, mask, value) (HSADC_WR_HILIMSTAT(base, (HSADC_RD_HILIMSTAT(base) & ~(mask)) | (value)))
#define HSADC_SET_HILIMSTAT(base, value) (BME_OR16(&HSADC_HILIMSTAT_REG(base), (uint16_t)(value)))
#define HSADC_CLR_HILIMSTAT(base, value) (BME_AND16(&HSADC_HILIMSTAT_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_HILIMSTAT(base, value) (BME_XOR16(&HSADC_HILIMSTAT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_ZXSTAT - HSADC Zero Crossing Status Register
 ******************************************************************************/

/*!
 * @brief HSADC_ZXSTAT - HSADC Zero Crossing Status Register (W1C)
 *
 * Reset value: 0x0000U
 *
 * The ZXSTAT register provides a status flag for each of the 16 SAMPLEx HSADC
 * conversions that has zero crossing detection enabled.
 */
/*!
 * @name Constants and macros for entire HSADC_ZXSTAT register
 */
/*@{*/
#define HSADC_RD_ZXSTAT(base)    (HSADC_ZXSTAT_REG(base))
#define HSADC_WR_ZXSTAT(base, value) (HSADC_ZXSTAT_REG(base) = (value))
#define HSADC_RMW_ZXSTAT(base, mask, value) (HSADC_WR_ZXSTAT(base, (HSADC_RD_ZXSTAT(base) & ~(mask)) | (value)))
#define HSADC_SET_ZXSTAT(base, value) (BME_OR16(&HSADC_ZXSTAT_REG(base), (uint16_t)(value)))
#define HSADC_CLR_ZXSTAT(base, value) (BME_AND16(&HSADC_ZXSTAT_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_ZXSTAT(base, value) (BME_XOR16(&HSADC_ZXSTAT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_RSLT - HSADC Result Registers with sign extension
 ******************************************************************************/

/*!
 * @brief HSADC_RSLT - HSADC Result Registers with sign extension (RW)
 *
 * Reset value: 0x0000U
 *
 * The result registers contain the converted results from a scan. The
 * CLIST1[SAMPLE0] result is loaded into RSLT0, CLIST1[SAMPLE1] result in RSLT1, and so
 * on. In a parallel scan mode, the first channel pair designated by
 * CLIST1[SAMPLE0] and CLIST3[SAMPLE8] are stored in RSLT0 and RSLT8, respectively. The
 * measured ADC raw conversion made by SAMPLEn is not stored directly into its
 * corresponding RSLTn register. The values stored in the corresponding OFFSTn register is
 * subtracted from the SAMPLn raw conversion then stored into the RSLTn
 * register. RSLTn = SAMPLEn conversion - OFFSTn value. ( if BYPA/BYPB = 1) If BYPA/BYPB
 * = 0 then RSLTn register = SAMPLEn conversion + cal factor - OFFSTn. See ADC
 * Calibration section for further details. When writing to this register, only the
 * RSLT portion of the value written is used. This value is modified and the
 * result of the subtraction is stored. The SEXT bit is only set as a result of this
 * subtraction and is not directly determined by the value written. When using
 * conversions of 10, 8, or 6 bits resolution, only the MSB bits (10, or 8, or 6
 * bits) of the RSLT portion should be considered. The remaining bits have no
 * meaning.
 */
/*!
 * @name Constants and macros for entire HSADC_RSLT register
 */
/*@{*/
#define HSADC_RD_RSLT(base, index) (HSADC_RSLT_REG(base, index))
#define HSADC_WR_RSLT(base, index, value) (HSADC_RSLT_REG(base, index) = (value))
#define HSADC_RMW_RSLT(base, index, mask, value) (HSADC_WR_RSLT(base, index, (HSADC_RD_RSLT(base, index) & ~(mask)) | (value)))
#define HSADC_SET_RSLT(base, index, value) (BME_OR16(&HSADC_RSLT_REG(base, index), (uint16_t)(value)))
#define HSADC_CLR_RSLT(base, index, value) (BME_AND16(&HSADC_RSLT_REG(base, index), (uint16_t)(~(value))))
#define HSADC_TOG_RSLT(base, index, value) (BME_XOR16(&HSADC_RSLT_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_RSLT bitfields
 */

/*!
 * @name Register HSADC_RSLT, field RSLT[14:3] (RW)
 *
 * RSLT can be interpreted as either a signed integer or a signed fractional
 * number. As a signed fractional number, the RSLT can be used directly. As a signed
 * integer, it is an option to right shift with sign extend (ASR) three places
 * and interpret the number, or accept the number as presented, knowing there are
 * missing codes. The lower three bits are always going to be zero. Negative
 * results, RSLT*[SEXT] = 1, are always presented in two's complement format. If it
 * is a requirement of your application that the result registers always be
 * positive, the offset registers must always be set to zero. The interpretation of the
 * numbers programmed into the limit and offset registers, LOLIM, HILIM, and
 * OFFST should match your interpretation of the result register.
 */
/*@{*/
/*! @brief Read current value of the HSADC_RSLT_RSLT field. */
#define HSADC_RD_RSLT_RSLT(base, index) ((HSADC_RSLT_REG(base, index) & HSADC_RSLT_RSLT_MASK) >> HSADC_RSLT_RSLT_SHIFT)
#define HSADC_BRD_RSLT_RSLT(base, index) (HSADC_RD_RSLT_RSLT(base, index))

/*! @brief Set the RSLT field to a new value. */
#define HSADC_WR_RSLT_RSLT(base, index, value) (HSADC_RMW_RSLT(base, index, HSADC_RSLT_RSLT_MASK, HSADC_RSLT_RSLT(value)))
#define HSADC_BWR_RSLT_RSLT(base, index, value) (HSADC_WR_RSLT_RSLT(base, index, value))
/*@}*/

/*!
 * @name Register HSADC_RSLT, field SEXT[15] (RO)
 *
 * This is the sign-extend bit of the result. RSLT*[SEXT] set to one implies a
 * negative result; RSLT*[SEXT] set to zero implies a positive result. If unsigned
 * results are required, then the respective offset register must be set to a
 * value of zero.
 */
/*@{*/
/*! @brief Read current value of the HSADC_RSLT_SEXT field. */
#define HSADC_RD_RSLT_SEXT(base, index) ((HSADC_RSLT_REG(base, index) & HSADC_RSLT_SEXT_MASK) >> HSADC_RSLT_SEXT_SHIFT)
#define HSADC_BRD_RSLT_SEXT(base, index) (BME_UBFX16(&HSADC_RSLT_REG(base, index), HSADC_RSLT_SEXT_SHIFT, HSADC_RSLT_SEXT_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_LOLIM - HSADC Low Limit Registers
 ******************************************************************************/

/*!
 * @brief HSADC_LOLIM - HSADC Low Limit Registers (RW)
 *
 * Reset value: 0x0000U
 *
 * Each HSADC sample is compared against the values in the limit registers. The
 * comparison is based upon the raw conversion value with no offset correction
 * applied. The limit register used corresponds to the result register the value
 * will be written to. The low limit register is used for the comparison of Result
 * < Low Limit. The low limit checking can be disabled by programming the
 * respective low limit register with 0000h. At reset, limit checking is disabled.
 */
/*!
 * @name Constants and macros for entire HSADC_LOLIM register
 */
/*@{*/
#define HSADC_RD_LOLIM(base, index) (HSADC_LOLIM_REG(base, index))
#define HSADC_WR_LOLIM(base, index, value) (HSADC_LOLIM_REG(base, index) = (value))
#define HSADC_RMW_LOLIM(base, index, mask, value) (HSADC_WR_LOLIM(base, index, (HSADC_RD_LOLIM(base, index) & ~(mask)) | (value)))
#define HSADC_SET_LOLIM(base, index, value) (BME_OR16(&HSADC_LOLIM_REG(base, index), (uint16_t)(value)))
#define HSADC_CLR_LOLIM(base, index, value) (BME_AND16(&HSADC_LOLIM_REG(base, index), (uint16_t)(~(value))))
#define HSADC_TOG_LOLIM(base, index, value) (BME_XOR16(&HSADC_LOLIM_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_LOLIM bitfields
 */

/*!
 * @name Register HSADC_LOLIM, field LLMT[14:3] (RW)
 */
/*@{*/
/*! @brief Read current value of the HSADC_LOLIM_LLMT field. */
#define HSADC_RD_LOLIM_LLMT(base, index) ((HSADC_LOLIM_REG(base, index) & HSADC_LOLIM_LLMT_MASK) >> HSADC_LOLIM_LLMT_SHIFT)
#define HSADC_BRD_LOLIM_LLMT(base, index) (HSADC_RD_LOLIM_LLMT(base, index))

/*! @brief Set the LLMT field to a new value. */
#define HSADC_WR_LOLIM_LLMT(base, index, value) (HSADC_RMW_LOLIM(base, index, HSADC_LOLIM_LLMT_MASK, HSADC_LOLIM_LLMT(value)))
#define HSADC_BWR_LOLIM_LLMT(base, index, value) (HSADC_WR_LOLIM_LLMT(base, index, value))
/*@}*/

/*******************************************************************************
 * HSADC_HILIM - HSADC High Limit Registers
 ******************************************************************************/

/*!
 * @brief HSADC_HILIM - HSADC High Limit Registers (RW)
 *
 * Reset value: 0x7FF8U
 *
 * Each HSADC sample is compared against the values in the limit registers. The
 * comparison is based upon the raw conversion value with no offset correction
 * applied. The limit register used corresponds to the result register the value
 * will be written to. The high limit register is used for the comparison of Result
 * > High Limit. The limit checking can be disabled by programming the
 * respective high limit register with 7FF8h. At reset, limit checking is disabled.
 */
/*!
 * @name Constants and macros for entire HSADC_HILIM register
 */
/*@{*/
#define HSADC_RD_HILIM(base, index) (HSADC_HILIM_REG(base, index))
#define HSADC_WR_HILIM(base, index, value) (HSADC_HILIM_REG(base, index) = (value))
#define HSADC_RMW_HILIM(base, index, mask, value) (HSADC_WR_HILIM(base, index, (HSADC_RD_HILIM(base, index) & ~(mask)) | (value)))
#define HSADC_SET_HILIM(base, index, value) (BME_OR16(&HSADC_HILIM_REG(base, index), (uint16_t)(value)))
#define HSADC_CLR_HILIM(base, index, value) (BME_AND16(&HSADC_HILIM_REG(base, index), (uint16_t)(~(value))))
#define HSADC_TOG_HILIM(base, index, value) (BME_XOR16(&HSADC_HILIM_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_HILIM bitfields
 */

/*!
 * @name Register HSADC_HILIM, field HLMT[14:3] (RW)
 */
/*@{*/
/*! @brief Read current value of the HSADC_HILIM_HLMT field. */
#define HSADC_RD_HILIM_HLMT(base, index) ((HSADC_HILIM_REG(base, index) & HSADC_HILIM_HLMT_MASK) >> HSADC_HILIM_HLMT_SHIFT)
#define HSADC_BRD_HILIM_HLMT(base, index) (HSADC_RD_HILIM_HLMT(base, index))

/*! @brief Set the HLMT field to a new value. */
#define HSADC_WR_HILIM_HLMT(base, index, value) (HSADC_RMW_HILIM(base, index, HSADC_HILIM_HLMT_MASK, HSADC_HILIM_HLMT(value)))
#define HSADC_BWR_HILIM_HLMT(base, index, value) (HSADC_WR_HILIM_HLMT(base, index, value))
/*@}*/

/*******************************************************************************
 * HSADC_OFFST - HSADC Offset Register
 ******************************************************************************/

/*!
 * @brief HSADC_OFFST - HSADC Offset Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The value of the OFFSTn register is used to correct the ADC result before it
 * is stored in the RSLTn register. The offset value is subtracted from the raw
 * ADC result. To obtain unsigned results, program the respective offset register
 * with a value of $0000, thus giving a result range of $0000 to $7FF8.
 */
/*!
 * @name Constants and macros for entire HSADC_OFFST register
 */
/*@{*/
#define HSADC_RD_OFFST(base, index) (HSADC_OFFST_REG(base, index))
#define HSADC_WR_OFFST(base, index, value) (HSADC_OFFST_REG(base, index) = (value))
#define HSADC_RMW_OFFST(base, index, mask, value) (HSADC_WR_OFFST(base, index, (HSADC_RD_OFFST(base, index) & ~(mask)) | (value)))
#define HSADC_SET_OFFST(base, index, value) (BME_OR16(&HSADC_OFFST_REG(base, index), (uint16_t)(value)))
#define HSADC_CLR_OFFST(base, index, value) (BME_AND16(&HSADC_OFFST_REG(base, index), (uint16_t)(~(value))))
#define HSADC_TOG_OFFST(base, index, value) (BME_XOR16(&HSADC_OFFST_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_OFFST bitfields
 */

/*!
 * @name Register HSADC_OFFST, field OFFSET[14:3] (RW)
 */
/*@{*/
/*! @brief Read current value of the HSADC_OFFST_OFFSET field. */
#define HSADC_RD_OFFST_OFFSET(base, index) ((HSADC_OFFST_REG(base, index) & HSADC_OFFST_OFFSET_MASK) >> HSADC_OFFST_OFFSET_SHIFT)
#define HSADC_BRD_OFFST_OFFSET(base, index) (HSADC_RD_OFFST_OFFSET(base, index))

/*! @brief Set the OFFSET field to a new value. */
#define HSADC_WR_OFFST_OFFSET(base, index, value) (HSADC_RMW_OFFST(base, index, HSADC_OFFST_OFFSET_MASK, HSADC_OFFST_OFFSET(value)))
#define HSADC_BWR_OFFST_OFFSET(base, index, value) (HSADC_WR_OFFST_OFFSET(base, index, value))
/*@}*/

/*******************************************************************************
 * HSADC_PWR - HSADC Power Control Register
 ******************************************************************************/

/*!
 * @brief HSADC_PWR - HSADC Power Control Register (RW)
 *
 * Reset value: 0x1D27U
 *
 * This register controls the power management features of the HSADC module.
 * There are individual manual power down controls for the two ADC converters and
 * their internal voltage reference generators. There are also five distinct power
 * modes. The following terms are used to describe power modes and their related
 * controls. Power down state Each converter and voltage reference generator can
 * individually be put into a power down state. When powered down, the unit
 * consumes no power. Results of scans referencing a powered down converter are
 * undefined. At least one converter must be powered up to use the HSADC module. Manual
 * power down controls Each converter and voltage reference generator have a
 * manual power control bit capable of putting that component into the power down
 * state. Converters have other mechanisms that can automatically put them into the
 * power down state. Idle state The HSADC module is idle when neither of the two
 * converters has a scan in process. Active state The HSADC module is active
 * when at least one of the two converters has a scan in process. Startup delay
 * Auto-powerdown and auto-standby power modes cause a startup delay when the HSADC
 * module goes between the power down and active states to allow time to power up
 * the internal ADC LDO. Dummy conversion or calibration delay Auto-powerdown and
 * auto-standby power modes cause a dummy conversion execution delay or a
 * calibration execution delay after the HSADC module is powered up.
 */
/*!
 * @name Constants and macros for entire HSADC_PWR register
 */
/*@{*/
#define HSADC_RD_PWR(base)       (HSADC_PWR_REG(base))
#define HSADC_WR_PWR(base, value) (HSADC_PWR_REG(base) = (value))
#define HSADC_RMW_PWR(base, mask, value) (HSADC_WR_PWR(base, (HSADC_RD_PWR(base) & ~(mask)) | (value)))
#define HSADC_SET_PWR(base, value) (BME_OR16(&HSADC_PWR_REG(base), (uint16_t)(value)))
#define HSADC_CLR_PWR(base, value) (BME_AND16(&HSADC_PWR_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_PWR(base, value) (BME_XOR16(&HSADC_PWR_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_PWR bitfields
 */

/*!
 * @name Register HSADC_PWR, field PDA[0] (RW)
 *
 * This bit forces ADC converter A to power down. Asserting this bit powers down
 * converter A immediately, except when it is in power-up phase. The results of
 * a scan using converter A will be invalid while PWR[PDA] is asserted. When
 * PWR[PDA] is cleared, converter A is either continuously powered up (PWR[APD] = 0)
 * or automatically powered up when needed (PWR[APD]=1). When clearing this bit
 * in any power mode except auto-powerdown (PWR[APD]=1) or auto-standby
 * (PWR[ASB]=1), wait (PWR[PUDELAY] x 32) ADC clock cycles before initiating a scan to
 * stabilize power levels within the converter. PWR[PSTSA] can be polled to determine
 * when the (PWR[PUDELAY] x 32) time has elapsed. Failure to follow this
 * procedure can result in loss of accuracy of the calibration procedure and of the
 * initial samples. During power-up delay phase if the stop request (STOPA) is set,
 * the power-down request is only recognized at the end of this phase, after the
 * ADC reset is applied (two ADC clock cycles).
 *
 * Values:
 * - 0b0 - Power Up ADC converter A
 * - 0b1 - Power Down ADC converter A
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_PDA field. */
#define HSADC_RD_PWR_PDA(base) ((HSADC_PWR_REG(base) & HSADC_PWR_PDA_MASK) >> HSADC_PWR_PDA_SHIFT)
#define HSADC_BRD_PWR_PDA(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_PDA_SHIFT, HSADC_PWR_PDA_WIDTH))

/*! @brief Set the PDA field to a new value. */
#define HSADC_WR_PWR_PDA(base, value) (HSADC_RMW_PWR(base, HSADC_PWR_PDA_MASK, HSADC_PWR_PDA(value)))
#define HSADC_BWR_PWR_PDA(base, value) (BME_BFI16(&HSADC_PWR_REG(base), ((uint16_t)(value) << HSADC_PWR_PDA_SHIFT), HSADC_PWR_PDA_SHIFT, HSADC_PWR_PDA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field PDB[1] (RW)
 *
 * This bit forces ADC converter B to power down. Asserting this bit powers down
 * converter B immediately, except when it is in power-up phase. The results of
 * a scan using converter B will be invalid while PWR[PDB] is asserted. When
 * PWR[PDB] is cleared, converter B is either continuously powered up (PWR[APD] = 0)
 * or automatically powered up when needed (PWR[APD]=1). When clearing this bit
 * in any power mode except auto-powerdown (PWR[APD]=1) or auto-standby
 * (PWR[ASB]=1), wait (PWR[PUDELAY] x 32) ADC clock cycles before initiating a scan to
 * stabilize power levels within the converter. PWR[PSTSB] can be polled to determine
 * when the (PWR[PUDELAY] x 32) time has elapsed. Failure to follow this
 * procedure can result in loss of accuracy of the calibration procedure and of the
 * initial samples. During power-up delay phase if the stop request (STOPB) is set,
 * the power-down request is only recognized at the end of this phase, after the
 * ADC reset is applied (two ADC clock cycles).
 *
 * Values:
 * - 0b0 - Power Up ADC converter B
 * - 0b1 - Power Down ADC converter B
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_PDB field. */
#define HSADC_RD_PWR_PDB(base) ((HSADC_PWR_REG(base) & HSADC_PWR_PDB_MASK) >> HSADC_PWR_PDB_SHIFT)
#define HSADC_BRD_PWR_PDB(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_PDB_SHIFT, HSADC_PWR_PDB_WIDTH))

/*! @brief Set the PDB field to a new value. */
#define HSADC_WR_PWR_PDB(base, value) (HSADC_RMW_PWR(base, HSADC_PWR_PDB_MASK, HSADC_PWR_PDB(value)))
#define HSADC_BWR_PWR_PDB(base, value) (BME_BFI16(&HSADC_PWR_REG(base), ((uint16_t)(value) << HSADC_PWR_PDB_SHIFT), HSADC_PWR_PDB_SHIFT, HSADC_PWR_PDB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field APD[3] (RW)
 *
 * Auto-powerdown mode powers down converters when not in use for a scan.
 * PWR[APD] takes precedence over PWR[ASB]. When a scan is started in PWR[APD] mode, a
 * delay of (PWR[PUDELAY] x 32) ADC clock cycles is imposed during which the
 * needed converter(s) are powered up. The HSADC then initiates a scan equivalent to
 * that done when PWR[APD] is not active. When the scan is completed, the
 * converter(s) are powered down again. If PWR[ASB] or PWR[APD] are asserted while a
 * scan is in progress, that scan is unaffected and the HSADC waits to enter its low
 * power state until after all conversions are complete and both ADCs are idle
 * (for sequential or parallel simultaneous scan modes). PWR[ASB] and PWR[APD] are
 * not useful in looping modes. The continuous nature of scanning means that the
 * low power state can never be entered.
 *
 * Values:
 * - 0b0 - Auto Powerdown Mode is not active
 * - 0b1 - Auto Powerdown Mode is active
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_APD field. */
#define HSADC_RD_PWR_APD(base) ((HSADC_PWR_REG(base) & HSADC_PWR_APD_MASK) >> HSADC_PWR_APD_SHIFT)
#define HSADC_BRD_PWR_APD(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_APD_SHIFT, HSADC_PWR_APD_WIDTH))

/*! @brief Set the APD field to a new value. */
#define HSADC_WR_PWR_APD(base, value) (HSADC_RMW_PWR(base, HSADC_PWR_APD_MASK, HSADC_PWR_APD(value)))
#define HSADC_BWR_PWR_APD(base, value) (BME_BFI16(&HSADC_PWR_REG(base), ((uint16_t)(value) << HSADC_PWR_APD_SHIFT), HSADC_PWR_APD_SHIFT, HSADC_PWR_APD_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field PUDELAY[9:4] (RW)
 *
 * This 6-bit field multiplied by 32 determines the number of ADC clocks
 * provided to power up an ADC converter (after setting PWR[PDA] and PWR[PDB] to 0)
 * before allowing a scan to start. It also determines the number of ADC clocks of
 * delay provided in auto-powerdown (APD) and auto-standby (ASB) modes between when
 * the ADC goes from the idle to active state and when the scan is allowed to
 * start. The default value is 18 that means a power-up time of about 18x32 ADC
 * clocks. Accuracy of the initial conversions in a scan will be degraded if
 * PWR[PUDELAY] is set to a too small value. PWR[PUDELAY] defaults to a value that is
 * typically sufficient for any power mode. The latency of a scan can be reduced by
 * reducing PWR[PUDELAY] to the lowest value for which accuracy is not degraded.
 * Refer to the data sheet for further details.
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_PUDELAY field. */
#define HSADC_RD_PWR_PUDELAY(base) ((HSADC_PWR_REG(base) & HSADC_PWR_PUDELAY_MASK) >> HSADC_PWR_PUDELAY_SHIFT)
#define HSADC_BRD_PWR_PUDELAY(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_PUDELAY_SHIFT, HSADC_PWR_PUDELAY_WIDTH))

/*! @brief Set the PUDELAY field to a new value. */
#define HSADC_WR_PWR_PUDELAY(base, value) (HSADC_RMW_PWR(base, HSADC_PWR_PUDELAY_MASK, HSADC_PWR_PUDELAY(value)))
#define HSADC_BWR_PWR_PUDELAY(base, value) (BME_BFI16(&HSADC_PWR_REG(base), ((uint16_t)(value) << HSADC_PWR_PUDELAY_SHIFT), HSADC_PWR_PUDELAY_SHIFT, HSADC_PWR_PUDELAY_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field PSTSA[10] (RO)
 *
 * This bit is asserted immediately following a write of "1" to PWR[PDA]. It is
 * de-asserted (PWR[PUDELAY] x 32) ADC clock cycles after a write of "0" to
 * PWR[PDA] if PWR[APD] is "0". This bit can be read as a status bit to determine when
 * the ADC is ready for operation. During auto-powerdown mode, this bit
 * indicates the current powered state of converter A.
 *
 * Values:
 * - 0b0 - ADC Converter A is currently powered up
 * - 0b1 - ADC Converter A is currently powered down
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_PSTSA field. */
#define HSADC_RD_PWR_PSTSA(base) ((HSADC_PWR_REG(base) & HSADC_PWR_PSTSA_MASK) >> HSADC_PWR_PSTSA_SHIFT)
#define HSADC_BRD_PWR_PSTSA(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_PSTSA_SHIFT, HSADC_PWR_PSTSA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field PSTSB[11] (RO)
 *
 * This bit is asserted immediately following a write of "1" to PWR[PDB]. It is
 * de-asserted (PWR[PUDELAY] x 32) ADC clock cycles after a write of "0" to
 * PWR[PDB] if PWR[APD] is "0". This bit can be read as a status bit to determine when
 * the ADC is ready for operation. During auto-powerdown mode, this bit
 * indicates the current powered state of converter B.
 *
 * Values:
 * - 0b0 - ADC Converter B is currently powered up
 * - 0b1 - ADC Converter B is currently powered down
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_PSTSB field. */
#define HSADC_RD_PWR_PSTSB(base) ((HSADC_PWR_REG(base) & HSADC_PWR_PSTSB_MASK) >> HSADC_PWR_PSTSB_SHIFT)
#define HSADC_BRD_PWR_PSTSB(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_PSTSB_SHIFT, HSADC_PWR_PSTSB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_PWR, field ASB[15] (RW)
 *
 * This bit selects auto-standby mode. PWR[ASB] is ignored if PWR[APD] is 1.
 * When the HSADC is idle, auto-standby mode selects the auto-standby clock as the
 * HSADC clock source and puts the converters into standby mode. At the start of
 * any scan, the conversion clock is selected as the ADC clock and then a delay of
 * (PWR[PUDELAY] x32) ADC clock cycles and one ADC dummy conversion or the
 * calibration cycle are imposed for ADC levels to stabilize. After this delay, the
 * HSADC initiates the scan. When the HSADC returns to the idle state, the standby
 * clock is again selected and the converters revert to the standby state.
 * PWR[ASB] can be set at the same time or prior to clearing PWR[PDB/A]. Otherwise the
 * high speed conversion clock is used in the power-up delay counting before
 * going to standby idle state.
 *
 * Values:
 * - 0b0 - Auto standby mode disabled
 * - 0b1 - Auto standby mode enabled
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR_ASB field. */
#define HSADC_RD_PWR_ASB(base) ((HSADC_PWR_REG(base) & HSADC_PWR_ASB_MASK) >> HSADC_PWR_ASB_SHIFT)
#define HSADC_BRD_PWR_ASB(base) (BME_UBFX16(&HSADC_PWR_REG(base), HSADC_PWR_ASB_SHIFT, HSADC_PWR_ASB_WIDTH))

/*! @brief Set the ASB field to a new value. */
#define HSADC_WR_PWR_ASB(base, value) (HSADC_RMW_PWR(base, HSADC_PWR_ASB_MASK, HSADC_PWR_ASB(value)))
#define HSADC_BWR_PWR_ASB(base, value) (BME_BFI16(&HSADC_PWR_REG(base), ((uint16_t)(value) << HSADC_PWR_ASB_SHIFT), HSADC_PWR_ASB_SHIFT, HSADC_PWR_ASB_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_SCTRL - HSADC Scan Control Register
 ******************************************************************************/

/*!
 * @brief HSADC_SCTRL - HSADC Scan Control Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is an extension to the CLIST1-4 registers, providing the
 * ability to pause and await a new sync while processing samples programmed in the
 * CLIST*[SAMPLE0â€"SAMPLE15] fields. These 16 control bits are used to determine
 * whether a sample in a scan occurs immediately or if the sample waits for an
 * enabled sync input to occur. The sync input must occur after the conversion of
 * the current sample completes. During sequential mode scans, the SCTRL[SC] bits
 * are used in order from SC0 to SC15. During simultaneous parallel scan modes,
 * the bits are used in order from SC0 to SC3 and SC8-SC11. In non-simultaneous
 * parallel scans, ADCA uses the bits in order from SC0 to SC3 followed by SC8 to
 * SC11. ADCB will use bits SC4 to SC7 followed by SC12 to SC15 in
 * non-simultaneous parallel scans. When setting SCTRL[SC0], there is no need to set
 * CTRL1[STARTA] or CTRL2[STARTB]. Just clear CTRL1[STOPA] or CTRL2[STOPB] and the first
 * enabled sync input will start the scan. Setting SC0 delays sample 0 until a sync
 * pulse occurs. Setting SC1 delays sample 1 until a sync pulse occurs after
 * completing sample 0.
 */
/*!
 * @name Constants and macros for entire HSADC_SCTRL register
 */
/*@{*/
#define HSADC_RD_SCTRL(base)     (HSADC_SCTRL_REG(base))
#define HSADC_WR_SCTRL(base, value) (HSADC_SCTRL_REG(base) = (value))
#define HSADC_RMW_SCTRL(base, mask, value) (HSADC_WR_SCTRL(base, (HSADC_RD_SCTRL(base) & ~(mask)) | (value)))
#define HSADC_SET_SCTRL(base, value) (BME_OR16(&HSADC_SCTRL_REG(base), (uint16_t)(value)))
#define HSADC_CLR_SCTRL(base, value) (BME_AND16(&HSADC_SCTRL_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_SCTRL(base, value) (BME_XOR16(&HSADC_SCTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_PWR2 - HSADC Power Control Register 2
 ******************************************************************************/

/*!
 * @brief HSADC_PWR2 - HSADC Power Control Register 2 (RW)
 *
 * Reset value: 0x0400U
 *
 * The PWR2 register is only used in parallel non-simultaneous mode. It provides
 * an independent clock speed for ADCB, therefore ADCB and ADCA can have
 * different conversion rates.
 */
/*!
 * @name Constants and macros for entire HSADC_PWR2 register
 */
/*@{*/
#define HSADC_RD_PWR2(base)      (HSADC_PWR2_REG(base))
#define HSADC_WR_PWR2(base, value) (HSADC_PWR2_REG(base) = (value))
#define HSADC_RMW_PWR2(base, mask, value) (HSADC_WR_PWR2(base, (HSADC_RD_PWR2(base) & ~(mask)) | (value)))
#define HSADC_SET_PWR2(base, value) (BME_OR16(&HSADC_PWR2_REG(base), (uint16_t)(value)))
#define HSADC_CLR_PWR2(base, value) (BME_AND16(&HSADC_PWR2_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_PWR2(base, value) (BME_XOR16(&HSADC_PWR2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_PWR2 bitfields
 */

/*!
 * @name Register HSADC_PWR2, field DIVB[13:8] (RW)
 *
 * The divider circuit operates in the same manner as CTRL2[DIVA] but is used to
 * generate the clock used by ADCB during parallel non-simultaneous scan modes.
 */
/*@{*/
/*! @brief Read current value of the HSADC_PWR2_DIVB field. */
#define HSADC_RD_PWR2_DIVB(base) ((HSADC_PWR2_REG(base) & HSADC_PWR2_DIVB_MASK) >> HSADC_PWR2_DIVB_SHIFT)
#define HSADC_BRD_PWR2_DIVB(base) (BME_UBFX16(&HSADC_PWR2_REG(base), HSADC_PWR2_DIVB_SHIFT, HSADC_PWR2_DIVB_WIDTH))

/*! @brief Set the DIVB field to a new value. */
#define HSADC_WR_PWR2_DIVB(base, value) (HSADC_RMW_PWR2(base, HSADC_PWR2_DIVB_MASK, HSADC_PWR2_DIVB(value)))
#define HSADC_BWR_PWR2_DIVB(base, value) (BME_BFI16(&HSADC_PWR2_REG(base), ((uint16_t)(value) << HSADC_PWR2_DIVB_SHIFT), HSADC_PWR2_DIVB_SHIFT, HSADC_PWR2_DIVB_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CTRL3 - HSADC Control Register 3
 ******************************************************************************/

/*!
 * @brief HSADC_CTRL3 - HSADC Control Register 3 (RW)
 *
 * Reset value: 0x0300U
 *
 * The CTRL3 register selects the HSADC bit resolution for both ADCA and ADCB.
 * Both ADCA and ADCB bit resolutions will be the same, and cannot be different.
 */
/*!
 * @name Constants and macros for entire HSADC_CTRL3 register
 */
/*@{*/
#define HSADC_RD_CTRL3(base)     (HSADC_CTRL3_REG(base))
#define HSADC_WR_CTRL3(base, value) (HSADC_CTRL3_REG(base) = (value))
#define HSADC_RMW_CTRL3(base, mask, value) (HSADC_WR_CTRL3(base, (HSADC_RD_CTRL3(base) & ~(mask)) | (value)))
#define HSADC_SET_CTRL3(base, value) (BME_OR16(&HSADC_CTRL3_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CTRL3(base, value) (BME_AND16(&HSADC_CTRL3_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CTRL3(base, value) (BME_XOR16(&HSADC_CTRL3_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CTRL3 bitfields
 */

/*!
 * @name Register HSADC_CTRL3, field DMASRC[6] (RW)
 *
 * During sequential and simultaneous parallel scan modes CTRL3[DMASRC] selects
 * between EOSIA and RDY bits as the DMA source. During non-simultaneous parallel
 * scan mode CTRL3[DMASRC] selects between EOSIA/EOSIB for converters A and B,
 * and the RDY bits as the DMA source.
 *
 * Values:
 * - 0b0 - DMA trigger source is end of scan interrupt
 * - 0b1 - DMA trigger source is RDY bits
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL3_DMASRC field. */
#define HSADC_RD_CTRL3_DMASRC(base) ((HSADC_CTRL3_REG(base) & HSADC_CTRL3_DMASRC_MASK) >> HSADC_CTRL3_DMASRC_SHIFT)
#define HSADC_BRD_CTRL3_DMASRC(base) (BME_UBFX16(&HSADC_CTRL3_REG(base), HSADC_CTRL3_DMASRC_SHIFT, HSADC_CTRL3_DMASRC_WIDTH))

/*! @brief Set the DMASRC field to a new value. */
#define HSADC_WR_CTRL3_DMASRC(base, value) (HSADC_RMW_CTRL3(base, HSADC_CTRL3_DMASRC_MASK, HSADC_CTRL3_DMASRC(value)))
#define HSADC_BWR_CTRL3_DMASRC(base, value) (BME_BFI16(&HSADC_CTRL3_REG(base), ((uint16_t)(value) << HSADC_CTRL3_DMASRC_SHIFT), HSADC_CTRL3_DMASRC_SHIFT, HSADC_CTRL3_DMASRC_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CTRL3, field ADCRES[9:8] (RW)
 *
 * Selects the ADCA and B conversion result resolution.
 *
 * Values:
 * - 0b00 - 6-bit mode
 * - 0b01 - 8-bit mode
 * - 0b10 - 10-bit mode
 * - 0b11 - 12-bit mode
 */
/*@{*/
/*! @brief Read current value of the HSADC_CTRL3_ADCRES field. */
#define HSADC_RD_CTRL3_ADCRES(base) ((HSADC_CTRL3_REG(base) & HSADC_CTRL3_ADCRES_MASK) >> HSADC_CTRL3_ADCRES_SHIFT)
#define HSADC_BRD_CTRL3_ADCRES(base) (BME_UBFX16(&HSADC_CTRL3_REG(base), HSADC_CTRL3_ADCRES_SHIFT, HSADC_CTRL3_ADCRES_WIDTH))

/*! @brief Set the ADCRES field to a new value. */
#define HSADC_WR_CTRL3_ADCRES(base, value) (HSADC_RMW_CTRL3(base, HSADC_CTRL3_ADCRES_MASK, HSADC_CTRL3_ADCRES(value)))
#define HSADC_BWR_CTRL3_ADCRES(base, value) (BME_BFI16(&HSADC_CTRL3_REG(base), ((uint16_t)(value) << HSADC_CTRL3_ADCRES_SHIFT), HSADC_CTRL3_ADCRES_SHIFT, HSADC_CTRL3_ADCRES_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_SCINTEN - HSADC Scan Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief HSADC_SCINTEN - HSADC Scan Interrupt Enable Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used with the ready register (RDY) to select the samples
 * that will generate a scan interrupt. If SCINTEN is set, an interrupt occurs when
 * the corresponding RDY bit is set, after the conversion is completed for the
 * SAMPLEn.
 */
/*!
 * @name Constants and macros for entire HSADC_SCINTEN register
 */
/*@{*/
#define HSADC_RD_SCINTEN(base)   (HSADC_SCINTEN_REG(base))
#define HSADC_WR_SCINTEN(base, value) (HSADC_SCINTEN_REG(base) = (value))
#define HSADC_RMW_SCINTEN(base, mask, value) (HSADC_WR_SCINTEN(base, (HSADC_RD_SCINTEN(base) & ~(mask)) | (value)))
#define HSADC_SET_SCINTEN(base, value) (BME_OR16(&HSADC_SCINTEN_REG(base), (uint16_t)(value)))
#define HSADC_CLR_SCINTEN(base, value) (BME_AND16(&HSADC_SCINTEN_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_SCINTEN(base, value) (BME_XOR16(&HSADC_SCINTEN_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * HSADC_SAMPTIM - HSADC Sampling Time Configuration Register
 ******************************************************************************/

/*!
 * @brief HSADC_SAMPTIM - HSADC Sampling Time Configuration Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to configure the required sampling time for ADCA and
 * ADCB.
 */
/*!
 * @name Constants and macros for entire HSADC_SAMPTIM register
 */
/*@{*/
#define HSADC_RD_SAMPTIM(base)   (HSADC_SAMPTIM_REG(base))
#define HSADC_WR_SAMPTIM(base, value) (HSADC_SAMPTIM_REG(base) = (value))
#define HSADC_RMW_SAMPTIM(base, mask, value) (HSADC_WR_SAMPTIM(base, (HSADC_RD_SAMPTIM(base) & ~(mask)) | (value)))
#define HSADC_SET_SAMPTIM(base, value) (BME_OR16(&HSADC_SAMPTIM_REG(base), (uint16_t)(value)))
#define HSADC_CLR_SAMPTIM(base, value) (BME_AND16(&HSADC_SAMPTIM_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_SAMPTIM(base, value) (BME_XOR16(&HSADC_SAMPTIM_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_SAMPTIM bitfields
 */

/*!
 * @name Register HSADC_SAMPTIM, field SAMPT_A[7:0] (RW)
 *
 * This field is used to configure the sampling time for ADCA. The sampling time
 * is related to the ADCA clock period (TclkA). The resultant sampling time is
 * (1.5 + SAMPT_A) x TclkA.
 */
/*@{*/
/*! @brief Read current value of the HSADC_SAMPTIM_SAMPT_A field. */
#define HSADC_RD_SAMPTIM_SAMPT_A(base) ((HSADC_SAMPTIM_REG(base) & HSADC_SAMPTIM_SAMPT_A_MASK) >> HSADC_SAMPTIM_SAMPT_A_SHIFT)
#define HSADC_BRD_SAMPTIM_SAMPT_A(base) (BME_UBFX16(&HSADC_SAMPTIM_REG(base), HSADC_SAMPTIM_SAMPT_A_SHIFT, HSADC_SAMPTIM_SAMPT_A_WIDTH))

/*! @brief Set the SAMPT_A field to a new value. */
#define HSADC_WR_SAMPTIM_SAMPT_A(base, value) (HSADC_RMW_SAMPTIM(base, HSADC_SAMPTIM_SAMPT_A_MASK, HSADC_SAMPTIM_SAMPT_A(value)))
#define HSADC_BWR_SAMPTIM_SAMPT_A(base, value) (BME_BFI16(&HSADC_SAMPTIM_REG(base), ((uint16_t)(value) << HSADC_SAMPTIM_SAMPT_A_SHIFT), HSADC_SAMPTIM_SAMPT_A_SHIFT, HSADC_SAMPTIM_SAMPT_A_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_SAMPTIM, field SAMPT_B[15:8] (RW)
 *
 * This field is used to configure the sampling time for ADCB. The sampling time
 * is related to the ADCB clock period (TclkB). The resultant sampling time is
 * (1.5 + SAMPT_B) x TclkB. In sequential or parallel simultaneous mode the
 * effective value is SAMPT_A.
 */
/*@{*/
/*! @brief Read current value of the HSADC_SAMPTIM_SAMPT_B field. */
#define HSADC_RD_SAMPTIM_SAMPT_B(base) ((HSADC_SAMPTIM_REG(base) & HSADC_SAMPTIM_SAMPT_B_MASK) >> HSADC_SAMPTIM_SAMPT_B_SHIFT)
#define HSADC_BRD_SAMPTIM_SAMPT_B(base) (BME_UBFX16(&HSADC_SAMPTIM_REG(base), HSADC_SAMPTIM_SAMPT_B_SHIFT, HSADC_SAMPTIM_SAMPT_B_WIDTH))

/*! @brief Set the SAMPT_B field to a new value. */
#define HSADC_WR_SAMPTIM_SAMPT_B(base, value) (HSADC_RMW_SAMPTIM(base, HSADC_SAMPTIM_SAMPT_B_MASK, HSADC_SAMPTIM_SAMPT_B(value)))
#define HSADC_BWR_SAMPTIM_SAMPT_B(base, value) (BME_BFI16(&HSADC_SAMPTIM_REG(base), ((uint16_t)(value) << HSADC_SAMPTIM_SAMPT_B_SHIFT), HSADC_SAMPTIM_SAMPT_B_SHIFT, HSADC_SAMPTIM_SAMPT_B_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CALIB - HSADCs Calibration Configuration
 ******************************************************************************/

/*!
 * @brief HSADC_CALIB - HSADCs Calibration Configuration (RW)
 *
 * Reset value: 0x0000U
 *
 * This register controls the request of calibration for ADCA and ADCB. The
 * values obtained from this ADC internal calibration process are used in the ADCs
 * calibration sub-block.
 */
/*!
 * @name Constants and macros for entire HSADC_CALIB register
 */
/*@{*/
#define HSADC_RD_CALIB(base)     (HSADC_CALIB_REG(base))
#define HSADC_WR_CALIB(base, value) (HSADC_CALIB_REG(base) = (value))
#define HSADC_RMW_CALIB(base, mask, value) (HSADC_WR_CALIB(base, (HSADC_RD_CALIB(base) & ~(mask)) | (value)))
#define HSADC_SET_CALIB(base, value) (BME_OR16(&HSADC_CALIB_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CALIB(base, value) (BME_AND16(&HSADC_CALIB_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CALIB(base, value) (BME_XOR16(&HSADC_CALIB_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CALIB bitfields
 */

/*!
 * @name Register HSADC_CALIB, field REQSINGA[0] (RW)
 *
 * This bit is used to request to ADCA to run automatically the conversions to
 * obtain the calibration value for single ended analog input mode. This
 * calibration value is used by the ADCA for each single-ended input conversion.
 *
 * Values:
 * - 0b0 - Calibration value calculation is not requested to be run on ADCA.
 * - 0b1 - Calibration value calculation for single-ended input mode is
 *     requested to be run on ADCA.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_REQSINGA field. */
#define HSADC_RD_CALIB_REQSINGA(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_REQSINGA_MASK) >> HSADC_CALIB_REQSINGA_SHIFT)
#define HSADC_BRD_CALIB_REQSINGA(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_REQSINGA_SHIFT, HSADC_CALIB_REQSINGA_WIDTH))

/*! @brief Set the REQSINGA field to a new value. */
#define HSADC_WR_CALIB_REQSINGA(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_REQSINGA_MASK, HSADC_CALIB_REQSINGA(value)))
#define HSADC_BWR_CALIB_REQSINGA(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_REQSINGA_SHIFT), HSADC_CALIB_REQSINGA_SHIFT, HSADC_CALIB_REQSINGA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field REQDIFA[1] (RW)
 *
 * This bit is used to request to ADCA to run automatically the conversions to
 * obtain the calibration value for differential analog input mode. This
 * calibration factor is used by the ADCA for each differential conversion.
 *
 * Values:
 * - 0b0 - Calibration value calculation is not requested to ADCA.
 * - 0b1 - Calibration value calculation for differential input mode is
 *     requested to be run on ADCA.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_REQDIFA field. */
#define HSADC_RD_CALIB_REQDIFA(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_REQDIFA_MASK) >> HSADC_CALIB_REQDIFA_SHIFT)
#define HSADC_BRD_CALIB_REQDIFA(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_REQDIFA_SHIFT, HSADC_CALIB_REQDIFA_WIDTH))

/*! @brief Set the REQDIFA field to a new value. */
#define HSADC_WR_CALIB_REQDIFA(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_REQDIFA_MASK, HSADC_CALIB_REQDIFA(value)))
#define HSADC_BWR_CALIB_REQDIFA(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_REQDIFA_SHIFT), HSADC_CALIB_REQDIFA_SHIFT, HSADC_CALIB_REQDIFA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field BYPA[2] (RW)
 *
 * This bit field is used to bypass the calibration sum operation on ADCA.
 *
 * Values:
 * - 0b0 - ADCA block uses the calibration values to obtain the final conversion
 *     result (differential or single-ended mode)
 * - 0b1 - Calibration operation is bypassed on ADCA.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_BYPA field. */
#define HSADC_RD_CALIB_BYPA(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_BYPA_MASK) >> HSADC_CALIB_BYPA_SHIFT)
#define HSADC_BRD_CALIB_BYPA(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_BYPA_SHIFT, HSADC_CALIB_BYPA_WIDTH))

/*! @brief Set the BYPA field to a new value. */
#define HSADC_WR_CALIB_BYPA(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_BYPA_MASK, HSADC_CALIB_BYPA(value)))
#define HSADC_BWR_CALIB_BYPA(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_BYPA_SHIFT), HSADC_CALIB_BYPA_SHIFT, HSADC_CALIB_BYPA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field CAL_REQA[3] (WORZ)
 *
 * This calibration request is recognized at the end of a scan. It is
 * recommended to disable the scan start trigger when this calibration starts, otherwise a
 * delay can occur to start the next scan. This request is automatically cleared
 * when the calibration is started. The calibrations to be done are indicated by
 * bit fields CALIB[REQSINGA] and CALIB[REQDIFFA].
 *
 * Values:
 * - 0b0 - None.
 * - 0b1 - Calibration request for ADCA.
 */
/*@{*/
/*! @brief Set the CAL_REQA field to a new value. */
#define HSADC_WR_CALIB_CAL_REQA(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_CAL_REQA_MASK, HSADC_CALIB_CAL_REQA(value)))
#define HSADC_BWR_CALIB_CAL_REQA(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_CAL_REQA_SHIFT), HSADC_CALIB_CAL_REQA_SHIFT, HSADC_CALIB_CAL_REQA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field REQSINGB[4] (RW)
 *
 * This bit is used to request to ADCB to run automatically the conversions to
 * obtain the calibration value for single-ended analog input mode. This
 * calibration factor is used by the ADCB for each single-ended input conversion.
 *
 * Values:
 * - 0b0 - Calibration value calculation is not requested to be run on ADCB.
 * - 0b1 - Calibration value calculation for single-ended input mode is
 *     requested to be run on ADCB.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_REQSINGB field. */
#define HSADC_RD_CALIB_REQSINGB(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_REQSINGB_MASK) >> HSADC_CALIB_REQSINGB_SHIFT)
#define HSADC_BRD_CALIB_REQSINGB(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_REQSINGB_SHIFT, HSADC_CALIB_REQSINGB_WIDTH))

/*! @brief Set the REQSINGB field to a new value. */
#define HSADC_WR_CALIB_REQSINGB(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_REQSINGB_MASK, HSADC_CALIB_REQSINGB(value)))
#define HSADC_BWR_CALIB_REQSINGB(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_REQSINGB_SHIFT), HSADC_CALIB_REQSINGB_SHIFT, HSADC_CALIB_REQSINGB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field REQDIFB[5] (RW)
 *
 * This bit is used to request to ADCB to run automatically the conversions to
 * obtain the calibration value for differential analog input mode. This
 * calibration factor is used by the ADCB for each differential conversion.
 *
 * Values:
 * - 0b0 - Calibration value calculation is not requested to be run on ADCB.
 * - 0b1 - Calibration value calculation for differential input mode is
 *     requested to be run onr ADCB
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_REQDIFB field. */
#define HSADC_RD_CALIB_REQDIFB(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_REQDIFB_MASK) >> HSADC_CALIB_REQDIFB_SHIFT)
#define HSADC_BRD_CALIB_REQDIFB(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_REQDIFB_SHIFT, HSADC_CALIB_REQDIFB_WIDTH))

/*! @brief Set the REQDIFB field to a new value. */
#define HSADC_WR_CALIB_REQDIFB(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_REQDIFB_MASK, HSADC_CALIB_REQDIFB(value)))
#define HSADC_BWR_CALIB_REQDIFB(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_REQDIFB_SHIFT), HSADC_CALIB_REQDIFB_SHIFT, HSADC_CALIB_REQDIFB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field BYPB[6] (RW)
 *
 * This bit field is used to bypass the calibration sum operation on ADCB.
 *
 * Values:
 * - 0b0 - ADCB block uses the calibration values to obtain the final conversion
 *     result (differential or single-ended mode)
 * - 0b1 - Calibration operation is bypassed on ADCB.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_BYPB field. */
#define HSADC_RD_CALIB_BYPB(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_BYPB_MASK) >> HSADC_CALIB_BYPB_SHIFT)
#define HSADC_BRD_CALIB_BYPB(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_BYPB_SHIFT, HSADC_CALIB_BYPB_WIDTH))

/*! @brief Set the BYPB field to a new value. */
#define HSADC_WR_CALIB_BYPB(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_BYPB_MASK, HSADC_CALIB_BYPB(value)))
#define HSADC_BWR_CALIB_BYPB(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_BYPB_SHIFT), HSADC_CALIB_BYPB_SHIFT, HSADC_CALIB_BYPB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field CAL_REQB[7] (WORZ)
 *
 * This calibration request is recognized at the end of a scan. It is
 * recommended to disable the scan start trigger when this calibration starts, otherwise a
 * delay can occur to start the next scan. This request is automatically cleared
 * when the calibration is started. The calibrations to be done are indicated by
 * bit fields CALIB[REQSINGB] and CALIB[REQDIFFB]. However in simultaneous mode
 * of operation (sequential mode or parallel and simultaneous operation) the ADCB
 * uses the configuration for ADCA.
 *
 * Values:
 * - 0b0 - Calibration is not requested.
 * - 0b1 - Calibration is requested for ADCB.
 */
/*@{*/
/*! @brief Set the CAL_REQB field to a new value. */
#define HSADC_WR_CALIB_CAL_REQB(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_CAL_REQB_MASK, HSADC_CALIB_CAL_REQB(value)))
#define HSADC_BWR_CALIB_CAL_REQB(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_CAL_REQB_SHIFT), HSADC_CALIB_CAL_REQB_SHIFT, HSADC_CALIB_CAL_REQB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field EOCALIEA[8] (RW)
 *
 * This bit enables an EOCALIA interrupt to be generated when the requested
 * calibrations for ADCA are finished.
 *
 * Values:
 * - 0b0 - Interrupt is not enabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_EOCALIEA field. */
#define HSADC_RD_CALIB_EOCALIEA(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_EOCALIEA_MASK) >> HSADC_CALIB_EOCALIEA_SHIFT)
#define HSADC_BRD_CALIB_EOCALIEA(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_EOCALIEA_SHIFT, HSADC_CALIB_EOCALIEA_WIDTH))

/*! @brief Set the EOCALIEA field to a new value. */
#define HSADC_WR_CALIB_EOCALIEA(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_EOCALIEA_MASK, HSADC_CALIB_EOCALIEA(value)))
#define HSADC_BWR_CALIB_EOCALIEA(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_EOCALIEA_SHIFT), HSADC_CALIB_EOCALIEA_SHIFT, HSADC_CALIB_EOCALIEA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALIB, field EOCALIEB[9] (RW)
 *
 * This bit enables an EOCALIB interrupt to be generated when the requested
 * calibrations for ADCB are finished.
 *
 * Values:
 * - 0b0 - Interrupt is not enabled.
 * - 0b1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALIB_EOCALIEB field. */
#define HSADC_RD_CALIB_EOCALIEB(base) ((HSADC_CALIB_REG(base) & HSADC_CALIB_EOCALIEB_MASK) >> HSADC_CALIB_EOCALIEB_SHIFT)
#define HSADC_BRD_CALIB_EOCALIEB(base) (BME_UBFX16(&HSADC_CALIB_REG(base), HSADC_CALIB_EOCALIEB_SHIFT, HSADC_CALIB_EOCALIEB_WIDTH))

/*! @brief Set the EOCALIEB field to a new value. */
#define HSADC_WR_CALIB_EOCALIEB(base, value) (HSADC_RMW_CALIB(base, HSADC_CALIB_EOCALIEB_MASK, HSADC_CALIB_EOCALIEB(value)))
#define HSADC_BWR_CALIB_EOCALIEB(base, value) (BME_BFI16(&HSADC_CALIB_REG(base), ((uint16_t)(value) << HSADC_CALIB_EOCALIEB_SHIFT), HSADC_CALIB_EOCALIEB_SHIFT, HSADC_CALIB_EOCALIEB_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CALVAL_A - Calibration Values for ADCA Register
 ******************************************************************************/

/*!
 * @brief HSADC_CALVAL_A - Calibration Values for ADCA Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to store the calibration values for ADCA. When the ADCA
 * calibration is requested (single or differential), the ADCA calibration
 * result is written into this register.
 */
/*!
 * @name Constants and macros for entire HSADC_CALVAL_A register
 */
/*@{*/
#define HSADC_RD_CALVAL_A(base)  (HSADC_CALVAL_A_REG(base))
#define HSADC_WR_CALVAL_A(base, value) (HSADC_CALVAL_A_REG(base) = (value))
#define HSADC_RMW_CALVAL_A(base, mask, value) (HSADC_WR_CALVAL_A(base, (HSADC_RD_CALVAL_A(base) & ~(mask)) | (value)))
#define HSADC_SET_CALVAL_A(base, value) (BME_OR16(&HSADC_CALVAL_A_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CALVAL_A(base, value) (BME_AND16(&HSADC_CALVAL_A_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CALVAL_A(base, value) (BME_XOR16(&HSADC_CALVAL_A_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CALVAL_A bitfields
 */

/*!
 * @name Register HSADC_CALVAL_A, field CALVSING[6:0] (RW)
 *
 * This field is used to store the calibration value to be used in the
 * single-ended conversions. When the ADC calibration process ends, the calibration value
 * is written in this field for single-ended input mode.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALVAL_A_CALVSING field. */
#define HSADC_RD_CALVAL_A_CALVSING(base) ((HSADC_CALVAL_A_REG(base) & HSADC_CALVAL_A_CALVSING_MASK) >> HSADC_CALVAL_A_CALVSING_SHIFT)
#define HSADC_BRD_CALVAL_A_CALVSING(base) (BME_UBFX16(&HSADC_CALVAL_A_REG(base), HSADC_CALVAL_A_CALVSING_SHIFT, HSADC_CALVAL_A_CALVSING_WIDTH))

/*! @brief Set the CALVSING field to a new value. */
#define HSADC_WR_CALVAL_A_CALVSING(base, value) (HSADC_RMW_CALVAL_A(base, HSADC_CALVAL_A_CALVSING_MASK, HSADC_CALVAL_A_CALVSING(value)))
#define HSADC_BWR_CALVAL_A_CALVSING(base, value) (BME_BFI16(&HSADC_CALVAL_A_REG(base), ((uint16_t)(value) << HSADC_CALVAL_A_CALVSING_SHIFT), HSADC_CALVAL_A_CALVSING_SHIFT, HSADC_CALVAL_A_CALVSING_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALVAL_A, field CALVDIF[14:8] (RW)
 *
 * This field is used to store the calibration value to be used in the
 * differential conversions. When the ADC calibration process ends, the calibration result
 * is written into this field if differential mode is selected.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALVAL_A_CALVDIF field. */
#define HSADC_RD_CALVAL_A_CALVDIF(base) ((HSADC_CALVAL_A_REG(base) & HSADC_CALVAL_A_CALVDIF_MASK) >> HSADC_CALVAL_A_CALVDIF_SHIFT)
#define HSADC_BRD_CALVAL_A_CALVDIF(base) (BME_UBFX16(&HSADC_CALVAL_A_REG(base), HSADC_CALVAL_A_CALVDIF_SHIFT, HSADC_CALVAL_A_CALVDIF_WIDTH))

/*! @brief Set the CALVDIF field to a new value. */
#define HSADC_WR_CALVAL_A_CALVDIF(base, value) (HSADC_RMW_CALVAL_A(base, HSADC_CALVAL_A_CALVDIF_MASK, HSADC_CALVAL_A_CALVDIF(value)))
#define HSADC_BWR_CALVAL_A_CALVDIF(base, value) (BME_BFI16(&HSADC_CALVAL_A_REG(base), ((uint16_t)(value) << HSADC_CALVAL_A_CALVDIF_SHIFT), HSADC_CALVAL_A_CALVDIF_SHIFT, HSADC_CALVAL_A_CALVDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_CALVAL_B - Calibration Values for ADCB Register
 ******************************************************************************/

/*!
 * @brief HSADC_CALVAL_B - Calibration Values for ADCB Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is used to store the calibration values for ADCB. When the ADCB
 * calibration is requested (single or differential), the ADCB calibration
 * result is written into this register.
 */
/*!
 * @name Constants and macros for entire HSADC_CALVAL_B register
 */
/*@{*/
#define HSADC_RD_CALVAL_B(base)  (HSADC_CALVAL_B_REG(base))
#define HSADC_WR_CALVAL_B(base, value) (HSADC_CALVAL_B_REG(base) = (value))
#define HSADC_RMW_CALVAL_B(base, mask, value) (HSADC_WR_CALVAL_B(base, (HSADC_RD_CALVAL_B(base) & ~(mask)) | (value)))
#define HSADC_SET_CALVAL_B(base, value) (BME_OR16(&HSADC_CALVAL_B_REG(base), (uint16_t)(value)))
#define HSADC_CLR_CALVAL_B(base, value) (BME_AND16(&HSADC_CALVAL_B_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_CALVAL_B(base, value) (BME_XOR16(&HSADC_CALVAL_B_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_CALVAL_B bitfields
 */

/*!
 * @name Register HSADC_CALVAL_B, field CALVSING[6:0] (RW)
 *
 * This field is used to store the calibration value to be used in the
 * single-ended conversions. When the ADC calibration process ends, the calibration value
 * is written into this field for single-ended input mode.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALVAL_B_CALVSING field. */
#define HSADC_RD_CALVAL_B_CALVSING(base) ((HSADC_CALVAL_B_REG(base) & HSADC_CALVAL_B_CALVSING_MASK) >> HSADC_CALVAL_B_CALVSING_SHIFT)
#define HSADC_BRD_CALVAL_B_CALVSING(base) (BME_UBFX16(&HSADC_CALVAL_B_REG(base), HSADC_CALVAL_B_CALVSING_SHIFT, HSADC_CALVAL_B_CALVSING_WIDTH))

/*! @brief Set the CALVSING field to a new value. */
#define HSADC_WR_CALVAL_B_CALVSING(base, value) (HSADC_RMW_CALVAL_B(base, HSADC_CALVAL_B_CALVSING_MASK, HSADC_CALVAL_B_CALVSING(value)))
#define HSADC_BWR_CALVAL_B_CALVSING(base, value) (BME_BFI16(&HSADC_CALVAL_B_REG(base), ((uint16_t)(value) << HSADC_CALVAL_B_CALVSING_SHIFT), HSADC_CALVAL_B_CALVSING_SHIFT, HSADC_CALVAL_B_CALVSING_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_CALVAL_B, field CALVDIF[14:8] (RW)
 *
 * This field is used to store the calibration value to be used in the
 * differential conversions. When the ADC calibration process ends, the calibration value
 * is written into this field if differential mode is selected.
 */
/*@{*/
/*! @brief Read current value of the HSADC_CALVAL_B_CALVDIF field. */
#define HSADC_RD_CALVAL_B_CALVDIF(base) ((HSADC_CALVAL_B_REG(base) & HSADC_CALVAL_B_CALVDIF_MASK) >> HSADC_CALVAL_B_CALVDIF_SHIFT)
#define HSADC_BRD_CALVAL_B_CALVDIF(base) (BME_UBFX16(&HSADC_CALVAL_B_REG(base), HSADC_CALVAL_B_CALVDIF_SHIFT, HSADC_CALVAL_B_CALVDIF_WIDTH))

/*! @brief Set the CALVDIF field to a new value. */
#define HSADC_WR_CALVAL_B_CALVDIF(base, value) (HSADC_RMW_CALVAL_B(base, HSADC_CALVAL_B_CALVDIF_MASK, HSADC_CALVAL_B_CALVDIF(value)))
#define HSADC_BWR_CALVAL_B_CALVDIF(base, value) (BME_BFI16(&HSADC_CALVAL_B_REG(base), ((uint16_t)(value) << HSADC_CALVAL_B_CALVDIF_SHIFT), HSADC_CALVAL_B_CALVDIF_SHIFT, HSADC_CALVAL_B_CALVDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * HSADC_MUX67_SEL - MUX6_7 Selection Controls Register
 ******************************************************************************/

/*!
 * @brief HSADC_MUX67_SEL - MUX6_7 Selection Controls Register (RW)
 *
 * Reset value: 0x0000U
 *
 * This register controls the MUXes for analog inputs CH6 and CH7 and expands
 * the number of input ADC channels for ADCA and ADCB. They are used together with
 * SAMPLEx, CHNCFG_L and CHNCFG_H. See Input Multiplex Function for more details.
 */
/*!
 * @name Constants and macros for entire HSADC_MUX67_SEL register
 */
/*@{*/
#define HSADC_RD_MUX67_SEL(base) (HSADC_MUX67_SEL_REG(base))
#define HSADC_WR_MUX67_SEL(base, value) (HSADC_MUX67_SEL_REG(base) = (value))
#define HSADC_RMW_MUX67_SEL(base, mask, value) (HSADC_WR_MUX67_SEL(base, (HSADC_RD_MUX67_SEL(base) & ~(mask)) | (value)))
#define HSADC_SET_MUX67_SEL(base, value) (BME_OR16(&HSADC_MUX67_SEL_REG(base), (uint16_t)(value)))
#define HSADC_CLR_MUX67_SEL(base, value) (BME_AND16(&HSADC_MUX67_SEL_REG(base), (uint16_t)(~(value))))
#define HSADC_TOG_MUX67_SEL(base, value) (BME_XOR16(&HSADC_MUX67_SEL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual HSADC_MUX67_SEL bitfields
 */

/*!
 * @name Register HSADC_MUX67_SEL, field CH6_SELA[2:0] (RW)
 *
 * This bit field is used to expand the number of input channels to the ADCA
 * when using SAMPLEx = 6 (4'b0110). The signals connected to the inputs of the
 * additional MUX are defined in the device.
 */
/*@{*/
/*! @brief Read current value of the HSADC_MUX67_SEL_CH6_SELA field. */
#define HSADC_RD_MUX67_SEL_CH6_SELA(base) ((HSADC_MUX67_SEL_REG(base) & HSADC_MUX67_SEL_CH6_SELA_MASK) >> HSADC_MUX67_SEL_CH6_SELA_SHIFT)
#define HSADC_BRD_MUX67_SEL_CH6_SELA(base) (BME_UBFX16(&HSADC_MUX67_SEL_REG(base), HSADC_MUX67_SEL_CH6_SELA_SHIFT, HSADC_MUX67_SEL_CH6_SELA_WIDTH))

/*! @brief Set the CH6_SELA field to a new value. */
#define HSADC_WR_MUX67_SEL_CH6_SELA(base, value) (HSADC_RMW_MUX67_SEL(base, HSADC_MUX67_SEL_CH6_SELA_MASK, HSADC_MUX67_SEL_CH6_SELA(value)))
#define HSADC_BWR_MUX67_SEL_CH6_SELA(base, value) (BME_BFI16(&HSADC_MUX67_SEL_REG(base), ((uint16_t)(value) << HSADC_MUX67_SEL_CH6_SELA_SHIFT), HSADC_MUX67_SEL_CH6_SELA_SHIFT, HSADC_MUX67_SEL_CH6_SELA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_MUX67_SEL, field CH7_SELA[6:4] (RW)
 *
 * This bit field is used to expand the number of input channels to the ADCA
 * when using SAMPLEx = 7 (4'b0111). The signals connected to the inputs of the
 * additional MUX are defined in the device.
 */
/*@{*/
/*! @brief Read current value of the HSADC_MUX67_SEL_CH7_SELA field. */
#define HSADC_RD_MUX67_SEL_CH7_SELA(base) ((HSADC_MUX67_SEL_REG(base) & HSADC_MUX67_SEL_CH7_SELA_MASK) >> HSADC_MUX67_SEL_CH7_SELA_SHIFT)
#define HSADC_BRD_MUX67_SEL_CH7_SELA(base) (BME_UBFX16(&HSADC_MUX67_SEL_REG(base), HSADC_MUX67_SEL_CH7_SELA_SHIFT, HSADC_MUX67_SEL_CH7_SELA_WIDTH))

/*! @brief Set the CH7_SELA field to a new value. */
#define HSADC_WR_MUX67_SEL_CH7_SELA(base, value) (HSADC_RMW_MUX67_SEL(base, HSADC_MUX67_SEL_CH7_SELA_MASK, HSADC_MUX67_SEL_CH7_SELA(value)))
#define HSADC_BWR_MUX67_SEL_CH7_SELA(base, value) (BME_BFI16(&HSADC_MUX67_SEL_REG(base), ((uint16_t)(value) << HSADC_MUX67_SEL_CH7_SELA_SHIFT), HSADC_MUX67_SEL_CH7_SELA_SHIFT, HSADC_MUX67_SEL_CH7_SELA_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_MUX67_SEL, field CH6_SELB[10:8] (RW)
 *
 * This bit field is used to expand the number of input channels to the ADCB
 * when using SAMPLEx = 14 (4'b1110). The signals connected to the inputs of the
 * additional MUX are defined in the device.
 */
/*@{*/
/*! @brief Read current value of the HSADC_MUX67_SEL_CH6_SELB field. */
#define HSADC_RD_MUX67_SEL_CH6_SELB(base) ((HSADC_MUX67_SEL_REG(base) & HSADC_MUX67_SEL_CH6_SELB_MASK) >> HSADC_MUX67_SEL_CH6_SELB_SHIFT)
#define HSADC_BRD_MUX67_SEL_CH6_SELB(base) (BME_UBFX16(&HSADC_MUX67_SEL_REG(base), HSADC_MUX67_SEL_CH6_SELB_SHIFT, HSADC_MUX67_SEL_CH6_SELB_WIDTH))

/*! @brief Set the CH6_SELB field to a new value. */
#define HSADC_WR_MUX67_SEL_CH6_SELB(base, value) (HSADC_RMW_MUX67_SEL(base, HSADC_MUX67_SEL_CH6_SELB_MASK, HSADC_MUX67_SEL_CH6_SELB(value)))
#define HSADC_BWR_MUX67_SEL_CH6_SELB(base, value) (BME_BFI16(&HSADC_MUX67_SEL_REG(base), ((uint16_t)(value) << HSADC_MUX67_SEL_CH6_SELB_SHIFT), HSADC_MUX67_SEL_CH6_SELB_SHIFT, HSADC_MUX67_SEL_CH6_SELB_WIDTH))
/*@}*/

/*!
 * @name Register HSADC_MUX67_SEL, field CH7_SELB[14:12] (RW)
 *
 * This bit field is used to expand the number of input channels to the ADCB
 * when using SAMPLEx = 15 (4'b1111). The signals connected to the inputs of the
 * additional MUX are defined in the device.
 */
/*@{*/
/*! @brief Read current value of the HSADC_MUX67_SEL_CH7_SELB field. */
#define HSADC_RD_MUX67_SEL_CH7_SELB(base) ((HSADC_MUX67_SEL_REG(base) & HSADC_MUX67_SEL_CH7_SELB_MASK) >> HSADC_MUX67_SEL_CH7_SELB_SHIFT)
#define HSADC_BRD_MUX67_SEL_CH7_SELB(base) (BME_UBFX16(&HSADC_MUX67_SEL_REG(base), HSADC_MUX67_SEL_CH7_SELB_SHIFT, HSADC_MUX67_SEL_CH7_SELB_WIDTH))

/*! @brief Set the CH7_SELB field to a new value. */
#define HSADC_WR_MUX67_SEL_CH7_SELB(base, value) (HSADC_RMW_MUX67_SEL(base, HSADC_MUX67_SEL_CH7_SELB_MASK, HSADC_MUX67_SEL_CH7_SELB(value)))
#define HSADC_BWR_MUX67_SEL_CH7_SELB(base, value) (BME_BFI16(&HSADC_MUX67_SEL_REG(base), ((uint16_t)(value) << HSADC_MUX67_SEL_CH7_SELB_SHIFT), HSADC_MUX67_SEL_CH7_SELB_SHIFT, HSADC_MUX67_SEL_CH7_SELB_WIDTH))
/*@}*/

/*
 * MKV58F24 I2C
 *
 * Inter-Integrated Circuit
 *
 * Registers defined in this header file:
 * - I2C_A1 - I2C Address Register 1
 * - I2C_F - I2C Frequency Divider register
 * - I2C_C1 - I2C Control Register 1
 * - I2C_S - I2C Status register
 * - I2C_D - I2C Data I/O register
 * - I2C_C2 - I2C Control Register 2
 * - I2C_FLT - I2C Programmable Input Glitch Filter Register
 * - I2C_RA - I2C Range Address register
 * - I2C_SMB - I2C SMBus Control and Status register
 * - I2C_A2 - I2C Address Register 2
 * - I2C_SLTH - I2C SCL Low Timeout Register High
 * - I2C_SLTL - I2C SCL Low Timeout Register Low
 */

#define I2C_INSTANCE_COUNT (2U) /*!< Number of instances of the I2C module. */
#define I2C0_IDX (0U) /*!< Instance number for I2C0. */
#define I2C1_IDX (1U) /*!< Instance number for I2C1. */

/*******************************************************************************
 * I2C_A1 - I2C Address Register 1
 ******************************************************************************/

/*!
 * @brief I2C_A1 - I2C Address Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains the slave address to be used by the I2C module.
 */
/*!
 * @name Constants and macros for entire I2C_A1 register
 */
/*@{*/
#define I2C_RD_A1(base)          (I2C_A1_REG(base))
#define I2C_WR_A1(base, value)   (I2C_A1_REG(base) = (value))
#define I2C_RMW_A1(base, mask, value) (I2C_WR_A1(base, (I2C_RD_A1(base) & ~(mask)) | (value)))
#define I2C_SET_A1(base, value)  (BME_OR8(&I2C_A1_REG(base), (uint8_t)(value)))
#define I2C_CLR_A1(base, value)  (BME_AND8(&I2C_A1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A1(base, value)  (BME_XOR8(&I2C_A1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A1 bitfields
 */

/*!
 * @name Register I2C_A1, field AD[7:1] (RW)
 *
 * Contains the primary slave address used by the I2C module when it is
 * addressed as a slave. This field is used in the 7-bit address scheme and the lower
 * seven bits in the 10-bit address scheme.
 */
/*@{*/
/*! @brief Read current value of the I2C_A1_AD field. */
#define I2C_RD_A1_AD(base)   ((I2C_A1_REG(base) & I2C_A1_AD_MASK) >> I2C_A1_AD_SHIFT)
#define I2C_BRD_A1_AD(base)  (BME_UBFX8(&I2C_A1_REG(base), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_A1_AD(base, value) (I2C_RMW_A1(base, I2C_A1_AD_MASK, I2C_A1_AD(value)))
#define I2C_BWR_A1_AD(base, value) (BME_BFI8(&I2C_A1_REG(base), ((uint8_t)(value) << I2C_A1_AD_SHIFT), I2C_A1_AD_SHIFT, I2C_A1_AD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_F - I2C Frequency Divider register
 ******************************************************************************/

/*!
 * @brief I2C_F - I2C Frequency Divider register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_F register
 */
/*@{*/
#define I2C_RD_F(base)           (I2C_F_REG(base))
#define I2C_WR_F(base, value)    (I2C_F_REG(base) = (value))
#define I2C_RMW_F(base, mask, value) (I2C_WR_F(base, (I2C_RD_F(base) & ~(mask)) | (value)))
#define I2C_SET_F(base, value)   (BME_OR8(&I2C_F_REG(base), (uint8_t)(value)))
#define I2C_CLR_F(base, value)   (BME_AND8(&I2C_F_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_F(base, value)   (BME_XOR8(&I2C_F_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_F bitfields
 */

/*!
 * @name Register I2C_F, field ICR[5:0] (RW)
 *
 * Prescales the I2C module clock for bit rate selection. This field and the
 * MULT field determine the I2C baud rate, the SDA hold time, the SCL start hold
 * time, and the SCL stop hold time. For a list of values corresponding to each ICR
 * setting, see I2C divider and hold values. The SCL divider multiplied by
 * multiplier factor (mul) determines the I2C baud rate. I2C baud rate = I2C module
 * clock speed (Hz)/(mul * SCL divider) The SDA hold time is the delay from the
 * falling edge of SCL (I2C clock) to the changing of SDA (I2C data). SDA hold time =
 * I2C module clock period (s) * mul * SDA hold value The SCL start hold time is
 * the delay from the falling edge of SDA (I2C data) while SCL is high (start
 * condition) to the falling edge of SCL (I2C clock). SCL start hold time = I2C
 * module clock period (s) * mul * SCL start hold value The SCL stop hold time is
 * the delay from the rising edge of SCL (I2C clock) to the rising edge of SDA (I2C
 * data) while SCL is high (stop condition). SCL stop hold time = I2C module
 * clock period (s) * mul * SCL stop hold value For example, if the I2C module clock
 * speed is 8 MHz, the following table shows the possible hold time values with
 * different ICR and MULT selections to achieve an I2C baud rate of 100 kbit/s.
 * MULT ICR Hold times (us) SDA SCL Start SCL Stop 2h 00h 3.500 3.000 5.500 1h 07h
 * 2.500 4.000 5.250 1h 0Bh 2.250 4.000 5.250 0h 14h 2.125 4.250 5.125 0h 18h
 * 1.125 4.750 5.125
 */
/*@{*/
/*! @brief Read current value of the I2C_F_ICR field. */
#define I2C_RD_F_ICR(base)   ((I2C_F_REG(base) & I2C_F_ICR_MASK) >> I2C_F_ICR_SHIFT)
#define I2C_BRD_F_ICR(base)  (BME_UBFX8(&I2C_F_REG(base), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))

/*! @brief Set the ICR field to a new value. */
#define I2C_WR_F_ICR(base, value) (I2C_RMW_F(base, I2C_F_ICR_MASK, I2C_F_ICR(value)))
#define I2C_BWR_F_ICR(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_ICR_SHIFT), I2C_F_ICR_SHIFT, I2C_F_ICR_WIDTH))
/*@}*/

/*!
 * @name Register I2C_F, field MULT[7:6] (RW)
 *
 * Defines the multiplier factor (mul). This factor is used along with the SCL
 * divider to generate the I2C baud rate.
 *
 * Values:
 * - 0b00 - mul = 1
 * - 0b01 - mul = 2
 * - 0b10 - mul = 4
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the I2C_F_MULT field. */
#define I2C_RD_F_MULT(base)  ((I2C_F_REG(base) & I2C_F_MULT_MASK) >> I2C_F_MULT_SHIFT)
#define I2C_BRD_F_MULT(base) (BME_UBFX8(&I2C_F_REG(base), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define I2C_WR_F_MULT(base, value) (I2C_RMW_F(base, I2C_F_MULT_MASK, I2C_F_MULT(value)))
#define I2C_BWR_F_MULT(base, value) (BME_BFI8(&I2C_F_REG(base), ((uint8_t)(value) << I2C_F_MULT_SHIFT), I2C_F_MULT_SHIFT, I2C_F_MULT_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_C1 - I2C Control Register 1
 ******************************************************************************/

/*!
 * @brief I2C_C1 - I2C Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C1 register
 */
/*@{*/
#define I2C_RD_C1(base)          (I2C_C1_REG(base))
#define I2C_WR_C1(base, value)   (I2C_C1_REG(base) = (value))
#define I2C_RMW_C1(base, mask, value) (I2C_WR_C1(base, (I2C_RD_C1(base) & ~(mask)) | (value)))
#define I2C_SET_C1(base, value)  (BME_OR8(&I2C_C1_REG(base), (uint8_t)(value)))
#define I2C_CLR_C1(base, value)  (BME_AND8(&I2C_C1_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C1(base, value)  (BME_XOR8(&I2C_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C1 bitfields
 */

/*!
 * @name Register I2C_C1, field DMAEN[0] (RW)
 *
 * Enables or disables the DMA function.
 *
 * Values:
 * - 0b0 - All DMA signalling disabled.
 * - 0b1 - DMA transfer is enabled. While SMB[FACK] = 0, the following
 *     conditions trigger the DMA request: a data byte is received, and either address or
 *     data is transmitted. (ACK/NACK is automatic) the first byte received
 *     matches the A1 register or is a general call address. If any address matching
 *     occurs, S[IAAS] and S[TCF] are set. If the direction of transfer is known
 *     from master to slave, then it is not required to check S[SRW]. With this
 *     assumption, DMA can also be used in this case. In other cases, if the master
 *     reads data from the slave, then it is required to rewrite the C1 register
 *     operation. With this assumption, DMA cannot be used. When FACK = 1, an
 *     address or a data byte is transmitted.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_DMAEN field. */
#define I2C_RD_C1_DMAEN(base) ((I2C_C1_REG(base) & I2C_C1_DMAEN_MASK) >> I2C_C1_DMAEN_SHIFT)
#define I2C_BRD_C1_DMAEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define I2C_WR_C1_DMAEN(base, value) (I2C_RMW_C1(base, I2C_C1_DMAEN_MASK, I2C_C1_DMAEN(value)))
#define I2C_BWR_C1_DMAEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_DMAEN_SHIFT), I2C_C1_DMAEN_SHIFT, I2C_C1_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field WUEN[1] (RW)
 *
 * The I2C module can wake the MCU from low power mode with no peripheral bus
 * running when slave address matching occurs.
 *
 * Values:
 * - 0b0 - Normal operation. No interrupt generated when address matching in low
 *     power mode.
 * - 0b1 - Enables the wakeup function in low power mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_WUEN field. */
#define I2C_RD_C1_WUEN(base) ((I2C_C1_REG(base) & I2C_C1_WUEN_MASK) >> I2C_C1_WUEN_SHIFT)
#define I2C_BRD_C1_WUEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))

/*! @brief Set the WUEN field to a new value. */
#define I2C_WR_C1_WUEN(base, value) (I2C_RMW_C1(base, I2C_C1_WUEN_MASK, I2C_C1_WUEN(value)))
#define I2C_BWR_C1_WUEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_WUEN_SHIFT), I2C_C1_WUEN_SHIFT, I2C_C1_WUEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field RSTA[2] (WORZ)
 *
 * Writing 1 to this bit generates a repeated START condition provided it is the
 * current master. This bit will always be read as 0. Attempting a repeat at the
 * wrong time results in loss of arbitration.
 */
/*@{*/
/*! @brief Set the RSTA field to a new value. */
#define I2C_WR_C1_RSTA(base, value) (I2C_RMW_C1(base, I2C_C1_RSTA_MASK, I2C_C1_RSTA(value)))
#define I2C_BWR_C1_RSTA(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_RSTA_SHIFT), I2C_C1_RSTA_SHIFT, I2C_C1_RSTA_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TXAK[3] (RW)
 *
 * Specifies the value driven onto the SDA during data acknowledge cycles for
 * both master and slave receivers. The value of SMB[FACK] affects NACK/ACK
 * generation. SCL is held low until TXAK is written.
 *
 * Values:
 * - 0b0 - An acknowledge signal is sent to the bus on the following receiving
 *     byte (if FACK is cleared) or the current receiving byte (if FACK is set).
 * - 0b1 - No acknowledge signal is sent to the bus on the following receiving
 *     data byte (if FACK is cleared) or the current receiving data byte (if FACK
 *     is set).
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TXAK field. */
#define I2C_RD_C1_TXAK(base) ((I2C_C1_REG(base) & I2C_C1_TXAK_MASK) >> I2C_C1_TXAK_SHIFT)
#define I2C_BRD_C1_TXAK(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))

/*! @brief Set the TXAK field to a new value. */
#define I2C_WR_C1_TXAK(base, value) (I2C_RMW_C1(base, I2C_C1_TXAK_MASK, I2C_C1_TXAK(value)))
#define I2C_BWR_C1_TXAK(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TXAK_SHIFT), I2C_C1_TXAK_SHIFT, I2C_C1_TXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field TX[4] (RW)
 *
 * Selects the direction of master and slave transfers. In master mode this bit
 * must be set according to the type of transfer required. Therefore, for address
 * cycles, this bit is always set. When addressed as a slave this bit must be
 * set by software according to the SRW bit in the status register.
 *
 * Values:
 * - 0b0 - Receive
 * - 0b1 - Transmit
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_TX field. */
#define I2C_RD_C1_TX(base)   ((I2C_C1_REG(base) & I2C_C1_TX_MASK) >> I2C_C1_TX_SHIFT)
#define I2C_BRD_C1_TX(base)  (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))

/*! @brief Set the TX field to a new value. */
#define I2C_WR_C1_TX(base, value) (I2C_RMW_C1(base, I2C_C1_TX_MASK, I2C_C1_TX(value)))
#define I2C_BWR_C1_TX(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_TX_SHIFT), I2C_C1_TX_SHIFT, I2C_C1_TX_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field MST[5] (RW)
 *
 * When MST is changed from 0 to 1, a START signal is generated on the bus and
 * master mode is selected. When this bit changes from 1 to 0, a STOP signal is
 * generated and the mode of operation changes from master to slave.
 *
 * Values:
 * - 0b0 - Slave mode
 * - 0b1 - Master mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_MST field. */
#define I2C_RD_C1_MST(base)  ((I2C_C1_REG(base) & I2C_C1_MST_MASK) >> I2C_C1_MST_SHIFT)
#define I2C_BRD_C1_MST(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))

/*! @brief Set the MST field to a new value. */
#define I2C_WR_C1_MST(base, value) (I2C_RMW_C1(base, I2C_C1_MST_MASK, I2C_C1_MST(value)))
#define I2C_BWR_C1_MST(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_MST_SHIFT), I2C_C1_MST_SHIFT, I2C_C1_MST_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICIE[6] (RW)
 *
 * Enables I2C interrupt requests.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICIE field. */
#define I2C_RD_C1_IICIE(base) ((I2C_C1_REG(base) & I2C_C1_IICIE_MASK) >> I2C_C1_IICIE_SHIFT)
#define I2C_BRD_C1_IICIE(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))

/*! @brief Set the IICIE field to a new value. */
#define I2C_WR_C1_IICIE(base, value) (I2C_RMW_C1(base, I2C_C1_IICIE_MASK, I2C_C1_IICIE(value)))
#define I2C_BWR_C1_IICIE(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICIE_SHIFT), I2C_C1_IICIE_SHIFT, I2C_C1_IICIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C1, field IICEN[7] (RW)
 *
 * Enables I2C module operation.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C1_IICEN field. */
#define I2C_RD_C1_IICEN(base) ((I2C_C1_REG(base) & I2C_C1_IICEN_MASK) >> I2C_C1_IICEN_SHIFT)
#define I2C_BRD_C1_IICEN(base) (BME_UBFX8(&I2C_C1_REG(base), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))

/*! @brief Set the IICEN field to a new value. */
#define I2C_WR_C1_IICEN(base, value) (I2C_RMW_C1(base, I2C_C1_IICEN_MASK, I2C_C1_IICEN(value)))
#define I2C_BWR_C1_IICEN(base, value) (BME_BFI8(&I2C_C1_REG(base), ((uint8_t)(value) << I2C_C1_IICEN_SHIFT), I2C_C1_IICEN_SHIFT, I2C_C1_IICEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_S - I2C Status register
 ******************************************************************************/

/*!
 * @brief I2C_S - I2C Status register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire I2C_S register
 */
/*@{*/
#define I2C_RD_S(base)           (I2C_S_REG(base))
#define I2C_WR_S(base, value)    (I2C_S_REG(base) = (value))
#define I2C_RMW_S(base, mask, value) (I2C_WR_S(base, (I2C_RD_S(base) & ~(mask)) | (value)))
#define I2C_SET_S(base, value)   (BME_OR8(&I2C_S_REG(base), (uint8_t)(value)))
#define I2C_CLR_S(base, value)   (BME_AND8(&I2C_S_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_S(base, value)   (BME_XOR8(&I2C_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_S bitfields
 */

/*!
 * @name Register I2C_S, field RXAK[0] (RO)
 *
 * Values:
 * - 0b0 - Acknowledge signal was received after the completion of one byte of
 *     data transmission on the bus
 * - 0b1 - No acknowledge signal detected
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RXAK field. */
#define I2C_RD_S_RXAK(base)  ((I2C_S_REG(base) & I2C_S_RXAK_MASK) >> I2C_S_RXAK_SHIFT)
#define I2C_BRD_S_RXAK(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_RXAK_SHIFT, I2C_S_RXAK_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IICIF[1] (W1C)
 *
 * This bit sets when an interrupt is pending. This bit must be cleared by
 * software by writing 1 to it, such as in the interrupt routine. One of the following
 * events can set this bit: One byte transfer, including ACK/NACK bit, completes
 * if FACK is 0. An ACK or NACK is sent on the bus by writing 0 or 1 to TXAK
 * after this bit is set in receive mode. One byte transfer, excluding ACK/NACK bit,
 * completes if FACK is 1. Match of slave address to calling address including
 * primary slave address, range slave address , alert response address, second
 * slave address, or general call address. Arbitration lost In SMBus mode, any
 * timeouts except SCL and SDA high timeouts I2C bus stop or start detection if the
 * SSIE bit in the Input Glitch Filter register is 1 To clear the I2C bus stop or
 * start detection interrupt: In the interrupt service routine, first clear the
 * STOPF or STARTF bit in the Input Glitch Filter register by writing 1 to it, and
 * then clear the IICIF bit. If this sequence is reversed, the IICIF bit is
 * asserted again.
 *
 * Values:
 * - 0b0 - No interrupt pending
 * - 0b1 - Interrupt pending
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IICIF field. */
#define I2C_RD_S_IICIF(base) ((I2C_S_REG(base) & I2C_S_IICIF_MASK) >> I2C_S_IICIF_SHIFT)
#define I2C_BRD_S_IICIF(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))

/*! @brief Set the IICIF field to a new value. */
#define I2C_WR_S_IICIF(base, value) (I2C_RMW_S(base, (I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IICIF(value)))
#define I2C_BWR_S_IICIF(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IICIF_SHIFT), I2C_S_IICIF_SHIFT, I2C_S_IICIF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field SRW[2] (RO)
 *
 * When addressed as a slave, SRW indicates the value of the R/W command bit of
 * the calling address sent to the master.
 *
 * Values:
 * - 0b0 - Slave receive, master writing to slave
 * - 0b1 - Slave transmit, master reading from slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_SRW field. */
#define I2C_RD_S_SRW(base)   ((I2C_S_REG(base) & I2C_S_SRW_MASK) >> I2C_S_SRW_SHIFT)
#define I2C_BRD_S_SRW(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_SRW_SHIFT, I2C_S_SRW_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field RAM[3] (RW)
 *
 * This bit is set to 1 by any of the following conditions, if I2C_C2[RMEN] = 1:
 * Any nonzero calling address is received that matches the address in the RA
 * register. The calling address is within the range of values of the A1 and RA
 * registers. For the RAM bit to be set to 1 correctly, C1[IICIE] must be set to 1.
 * Writing the C1 register with any value clears this bit to 0.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_RAM field. */
#define I2C_RD_S_RAM(base)   ((I2C_S_REG(base) & I2C_S_RAM_MASK) >> I2C_S_RAM_SHIFT)
#define I2C_BRD_S_RAM(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))

/*! @brief Set the RAM field to a new value. */
#define I2C_WR_S_RAM(base, value) (I2C_RMW_S(base, (I2C_S_RAM_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_RAM(value)))
#define I2C_BWR_S_RAM(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_RAM_SHIFT), I2C_S_RAM_SHIFT, I2C_S_RAM_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field ARBL[4] (W1C)
 *
 * This bit is set by hardware when the arbitration procedure is lost. The ARBL
 * bit must be cleared by software, by writing 1 to it.
 *
 * Values:
 * - 0b0 - Standard bus operation.
 * - 0b1 - Loss of arbitration.
 */
/*@{*/
/*! @brief Read current value of the I2C_S_ARBL field. */
#define I2C_RD_S_ARBL(base)  ((I2C_S_REG(base) & I2C_S_ARBL_MASK) >> I2C_S_ARBL_SHIFT)
#define I2C_BRD_S_ARBL(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))

/*! @brief Set the ARBL field to a new value. */
#define I2C_WR_S_ARBL(base, value) (I2C_RMW_S(base, (I2C_S_ARBL_MASK | I2C_S_IICIF_MASK), I2C_S_ARBL(value)))
#define I2C_BWR_S_ARBL(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_ARBL_SHIFT), I2C_S_ARBL_SHIFT, I2C_S_ARBL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field BUSY[5] (RO)
 *
 * Indicates the status of the bus regardless of slave or master mode. This bit
 * is set when a START signal is detected and cleared when a STOP signal is
 * detected.
 *
 * Values:
 * - 0b0 - Bus is idle
 * - 0b1 - Bus is busy
 */
/*@{*/
/*! @brief Read current value of the I2C_S_BUSY field. */
#define I2C_RD_S_BUSY(base)  ((I2C_S_REG(base) & I2C_S_BUSY_MASK) >> I2C_S_BUSY_SHIFT)
#define I2C_BRD_S_BUSY(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_BUSY_SHIFT, I2C_S_BUSY_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field IAAS[6] (RW)
 *
 * This bit is set by one of the following conditions: The calling address
 * matches the programmed primary slave address in the A1 register, or matches the
 * range address in the RA register (which must be set to a nonzero value and under
 * the condition I2C_C2[RMEN] = 1). C2[GCAEN] is set and a general call is
 * received. SMB[SIICAEN] is set and the calling address matches the second programmed
 * slave address. ALERTEN is set and an SMBus alert response address is received
 * RMEN is set and an address is received that is within the range between the
 * values of the A1 and RA registers. IAAS sets before the ACK bit. The CPU must
 * check the SRW bit and set TX/RX accordingly. Writing the C1 register with any
 * value clears this bit.
 *
 * Values:
 * - 0b0 - Not addressed
 * - 0b1 - Addressed as a slave
 */
/*@{*/
/*! @brief Read current value of the I2C_S_IAAS field. */
#define I2C_RD_S_IAAS(base)  ((I2C_S_REG(base) & I2C_S_IAAS_MASK) >> I2C_S_IAAS_SHIFT)
#define I2C_BRD_S_IAAS(base) (BME_UBFX8(&I2C_S_REG(base), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))

/*! @brief Set the IAAS field to a new value. */
#define I2C_WR_S_IAAS(base, value) (I2C_RMW_S(base, (I2C_S_IAAS_MASK | I2C_S_IICIF_MASK | I2C_S_ARBL_MASK), I2C_S_IAAS(value)))
#define I2C_BWR_S_IAAS(base, value) (BME_BFI8(&I2C_S_REG(base), ((uint8_t)(value) << I2C_S_IAAS_SHIFT), I2C_S_IAAS_SHIFT, I2C_S_IAAS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_S, field TCF[7] (RO)
 *
 * Acknowledges a byte transfer; TCF is set on the completion of a byte
 * transfer. This bit is valid only during or immediately following a transfer to or from
 * the I2C module. TCF is cleared by reading the I2C data register in receive
 * mode or by writing to the I2C data register in transmit mode.
 *
 * Values:
 * - 0b0 - Transfer in progress
 * - 0b1 - Transfer complete
 */
/*@{*/
/*! @brief Read current value of the I2C_S_TCF field. */
#define I2C_RD_S_TCF(base)   ((I2C_S_REG(base) & I2C_S_TCF_MASK) >> I2C_S_TCF_SHIFT)
#define I2C_BRD_S_TCF(base)  (BME_UBFX8(&I2C_S_REG(base), I2C_S_TCF_SHIFT, I2C_S_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_D - I2C Data I/O register
 ******************************************************************************/

/*!
 * @brief I2C_D - I2C Data I/O register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_D register
 */
/*@{*/
#define I2C_RD_D(base)           (I2C_D_REG(base))
#define I2C_WR_D(base, value)    (I2C_D_REG(base) = (value))
#define I2C_RMW_D(base, mask, value) (I2C_WR_D(base, (I2C_RD_D(base) & ~(mask)) | (value)))
#define I2C_SET_D(base, value)   (BME_OR8(&I2C_D_REG(base), (uint8_t)(value)))
#define I2C_CLR_D(base, value)   (BME_AND8(&I2C_D_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_D(base, value)   (BME_XOR8(&I2C_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_C2 - I2C Control Register 2
 ******************************************************************************/

/*!
 * @brief I2C_C2 - I2C Control Register 2 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_C2 register
 */
/*@{*/
#define I2C_RD_C2(base)          (I2C_C2_REG(base))
#define I2C_WR_C2(base, value)   (I2C_C2_REG(base) = (value))
#define I2C_RMW_C2(base, mask, value) (I2C_WR_C2(base, (I2C_RD_C2(base) & ~(mask)) | (value)))
#define I2C_SET_C2(base, value)  (BME_OR8(&I2C_C2_REG(base), (uint8_t)(value)))
#define I2C_CLR_C2(base, value)  (BME_AND8(&I2C_C2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_C2(base, value)  (BME_XOR8(&I2C_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_C2 bitfields
 */

/*!
 * @name Register I2C_C2, field AD[2:0] (RW)
 *
 * Contains the upper three bits of the slave address in the 10-bit address
 * scheme. This field is valid only while the ADEXT bit is set.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_AD field. */
#define I2C_RD_C2_AD(base)   ((I2C_C2_REG(base) & I2C_C2_AD_MASK) >> I2C_C2_AD_SHIFT)
#define I2C_BRD_C2_AD(base)  (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))

/*! @brief Set the AD field to a new value. */
#define I2C_WR_C2_AD(base, value) (I2C_RMW_C2(base, I2C_C2_AD_MASK, I2C_C2_AD(value)))
#define I2C_BWR_C2_AD(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_AD_SHIFT), I2C_C2_AD_SHIFT, I2C_C2_AD_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field RMEN[3] (RW)
 *
 * This bit controls the slave address matching for addresses between the values
 * of the A1 and RA registers. When this bit is set, a slave address matching
 * occurs for any address greater than the value of the A1 register and less than
 * or equal to the value of the RA register.
 *
 * Values:
 * - 0b0 - Range mode disabled. No address matching occurs for an address within
 *     the range of values of the A1 and RA registers.
 * - 0b1 - Range mode enabled. Address matching occurs when a slave receives an
 *     address within the range of values of the A1 and RA registers.
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_RMEN field. */
#define I2C_RD_C2_RMEN(base) ((I2C_C2_REG(base) & I2C_C2_RMEN_MASK) >> I2C_C2_RMEN_SHIFT)
#define I2C_BRD_C2_RMEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))

/*! @brief Set the RMEN field to a new value. */
#define I2C_WR_C2_RMEN(base, value) (I2C_RMW_C2(base, I2C_C2_RMEN_MASK, I2C_C2_RMEN(value)))
#define I2C_BWR_C2_RMEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_RMEN_SHIFT), I2C_C2_RMEN_SHIFT, I2C_C2_RMEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field SBRC[4] (RW)
 *
 * Enables independent slave mode baud rate at maximum frequency, which forces
 * clock stretching on SCL in very fast I2C modes. To a slave, an example of a
 * "very fast" mode is when the master transfers at 40 kbit/s but the slave can
 * capture the master's data at only 10 kbit/s.
 *
 * Values:
 * - 0b0 - The slave baud rate follows the master baud rate and clock stretching
 *     may occur
 * - 0b1 - Slave baud rate is independent of the master baud rate
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_SBRC field. */
#define I2C_RD_C2_SBRC(base) ((I2C_C2_REG(base) & I2C_C2_SBRC_MASK) >> I2C_C2_SBRC_SHIFT)
#define I2C_BRD_C2_SBRC(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))

/*! @brief Set the SBRC field to a new value. */
#define I2C_WR_C2_SBRC(base, value) (I2C_RMW_C2(base, I2C_C2_SBRC_MASK, I2C_C2_SBRC(value)))
#define I2C_BWR_C2_SBRC(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_SBRC_SHIFT), I2C_C2_SBRC_SHIFT, I2C_C2_SBRC_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field HDRS[5] (RW)
 *
 * Controls the drive capability of the I2C pads.
 *
 * Values:
 * - 0b0 - Normal drive mode
 * - 0b1 - High drive mode
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_HDRS field. */
#define I2C_RD_C2_HDRS(base) ((I2C_C2_REG(base) & I2C_C2_HDRS_MASK) >> I2C_C2_HDRS_SHIFT)
#define I2C_BRD_C2_HDRS(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))

/*! @brief Set the HDRS field to a new value. */
#define I2C_WR_C2_HDRS(base, value) (I2C_RMW_C2(base, I2C_C2_HDRS_MASK, I2C_C2_HDRS(value)))
#define I2C_BWR_C2_HDRS(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_HDRS_SHIFT), I2C_C2_HDRS_SHIFT, I2C_C2_HDRS_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field ADEXT[6] (RW)
 *
 * Controls the number of bits used for the slave address.
 *
 * Values:
 * - 0b0 - 7-bit address scheme
 * - 0b1 - 10-bit address scheme
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_ADEXT field. */
#define I2C_RD_C2_ADEXT(base) ((I2C_C2_REG(base) & I2C_C2_ADEXT_MASK) >> I2C_C2_ADEXT_SHIFT)
#define I2C_BRD_C2_ADEXT(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))

/*! @brief Set the ADEXT field to a new value. */
#define I2C_WR_C2_ADEXT(base, value) (I2C_RMW_C2(base, I2C_C2_ADEXT_MASK, I2C_C2_ADEXT(value)))
#define I2C_BWR_C2_ADEXT(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_ADEXT_SHIFT), I2C_C2_ADEXT_SHIFT, I2C_C2_ADEXT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_C2, field GCAEN[7] (RW)
 *
 * Enables general call address.
 *
 * Values:
 * - 0b0 - Disabled
 * - 0b1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_C2_GCAEN field. */
#define I2C_RD_C2_GCAEN(base) ((I2C_C2_REG(base) & I2C_C2_GCAEN_MASK) >> I2C_C2_GCAEN_SHIFT)
#define I2C_BRD_C2_GCAEN(base) (BME_UBFX8(&I2C_C2_REG(base), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))

/*! @brief Set the GCAEN field to a new value. */
#define I2C_WR_C2_GCAEN(base, value) (I2C_RMW_C2(base, I2C_C2_GCAEN_MASK, I2C_C2_GCAEN(value)))
#define I2C_BWR_C2_GCAEN(base, value) (BME_BFI8(&I2C_C2_REG(base), ((uint8_t)(value) << I2C_C2_GCAEN_SHIFT), I2C_C2_GCAEN_SHIFT, I2C_C2_GCAEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_FLT - I2C Programmable Input Glitch Filter Register
 ******************************************************************************/

/*!
 * @brief I2C_FLT - I2C Programmable Input Glitch Filter Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_FLT register
 */
/*@{*/
#define I2C_RD_FLT(base)         (I2C_FLT_REG(base))
#define I2C_WR_FLT(base, value)  (I2C_FLT_REG(base) = (value))
#define I2C_RMW_FLT(base, mask, value) (I2C_WR_FLT(base, (I2C_RD_FLT(base) & ~(mask)) | (value)))
#define I2C_SET_FLT(base, value) (BME_OR8(&I2C_FLT_REG(base), (uint8_t)(value)))
#define I2C_CLR_FLT(base, value) (BME_AND8(&I2C_FLT_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_FLT(base, value) (BME_XOR8(&I2C_FLT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_FLT bitfields
 */

/*!
 * @name Register I2C_FLT, field FLT[3:0] (RW)
 *
 * Controls the width of the glitch, in terms of I2C module clock cycles, that
 * the filter must absorb. For any glitch whose size is less than or equal to this
 * width setting, the filter does not allow the glitch to pass.
 *
 * Values:
 * - 0b0000 - No filter/bypass
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_FLT field. */
#define I2C_RD_FLT_FLT(base) ((I2C_FLT_REG(base) & I2C_FLT_FLT_MASK) >> I2C_FLT_FLT_SHIFT)
#define I2C_BRD_FLT_FLT(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))

/*! @brief Set the FLT field to a new value. */
#define I2C_WR_FLT_FLT(base, value) (I2C_RMW_FLT(base, (I2C_FLT_FLT_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_FLT(value)))
#define I2C_BWR_FLT_FLT(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_FLT_SHIFT), I2C_FLT_FLT_SHIFT, I2C_FLT_FLT_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STARTF[4] (W1C)
 *
 * Hardware sets this bit when the I2C bus's start status is detected. The
 * STARTF bit must be cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No start happens on I2C bus
 * - 0b1 - Start detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STARTF field. */
#define I2C_RD_FLT_STARTF(base) ((I2C_FLT_REG(base) & I2C_FLT_STARTF_MASK) >> I2C_FLT_STARTF_SHIFT)
#define I2C_BRD_FLT_STARTF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))

/*! @brief Set the STARTF field to a new value. */
#define I2C_WR_FLT_STARTF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_STARTF(value)))
#define I2C_BWR_FLT_STARTF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STARTF_SHIFT), I2C_FLT_STARTF_SHIFT, I2C_FLT_STARTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SSIE[5] (RW)
 *
 * This bit enables the interrupt for I2C bus stop or start detection. To clear
 * the I2C bus stop or start detection interrupt: In the interrupt service
 * routine, first clear the STOPF or STARTF bit by writing 1 to it, and then clear the
 * IICIF bit in the status register. If this sequence is reversed, the IICIF bit
 * is asserted again.
 *
 * Values:
 * - 0b0 - Stop or start detection interrupt is disabled
 * - 0b1 - Stop or start detection interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SSIE field. */
#define I2C_RD_FLT_SSIE(base) ((I2C_FLT_REG(base) & I2C_FLT_SSIE_MASK) >> I2C_FLT_SSIE_SHIFT)
#define I2C_BRD_FLT_SSIE(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))

/*! @brief Set the SSIE field to a new value. */
#define I2C_WR_FLT_SSIE(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SSIE_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SSIE(value)))
#define I2C_BWR_FLT_SSIE(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SSIE_SHIFT), I2C_FLT_SSIE_SHIFT, I2C_FLT_SSIE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field STOPF[6] (W1C)
 *
 * Hardware sets this bit when the I2C bus's stop status is detected. The STOPF
 * bit must be cleared by writing 1 to it.The stop flag is only for the matched
 * slave devices, therefore the master will not respond for it.
 *
 * Values:
 * - 0b0 - No stop happens on I2C bus
 * - 0b1 - Stop detected on I2C bus
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_STOPF field. */
#define I2C_RD_FLT_STOPF(base) ((I2C_FLT_REG(base) & I2C_FLT_STOPF_MASK) >> I2C_FLT_STOPF_SHIFT)
#define I2C_BRD_FLT_STOPF(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))

/*! @brief Set the STOPF field to a new value. */
#define I2C_WR_FLT_STOPF(base, value) (I2C_RMW_FLT(base, (I2C_FLT_STOPF_MASK | I2C_FLT_STARTF_MASK), I2C_FLT_STOPF(value)))
#define I2C_BWR_FLT_STOPF(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_STOPF_SHIFT), I2C_FLT_STOPF_SHIFT, I2C_FLT_STOPF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_FLT, field SHEN[7] (RW)
 *
 * Set this bit to hold off entry to stop mode when any data transmission or
 * reception is occurring. The following scenario explains the holdoff
 * functionality: The I2C module is configured for a basic transfer, and the SHEN bit is set
 * to 1. A transfer begins. The MCU signals the I2C module to enter stop mode. The
 * byte currently being transferred, including both address and data, completes
 * its transfer. The I2C slave or master acknowledges that the in-transfer byte
 * completed its transfer and acknowledges the request to enter stop mode. After
 * receiving the I2C module's acknowledgment of the request to enter stop mode,
 * the MCU determines whether to shut off the I2C module's clock. If the SHEN bit
 * is set to 1 and the I2C module is in an idle or disabled state when the MCU
 * signals to enter stop mode, the module immediately acknowledges the request to
 * enter stop mode. If SHEN is cleared to 0 and the overall data transmission or
 * reception that was suspended by stop mode entry was incomplete: To resume the
 * overall transmission or reception after the MCU exits stop mode, software must
 * reinitialize the transfer by resending the address of the slave. If the I2C
 * Control Register 1's IICIE bit was set to 1 before the MCU entered stop mode,
 * system software will receive the interrupt triggered by the I2C Status Register's
 * TCF bit after the MCU wakes from the stop mode.
 *
 * Values:
 * - 0b0 - Stop holdoff is disabled. The MCU's entry to stop mode is not gated.
 * - 0b1 - Stop holdoff is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2C_FLT_SHEN field. */
#define I2C_RD_FLT_SHEN(base) ((I2C_FLT_REG(base) & I2C_FLT_SHEN_MASK) >> I2C_FLT_SHEN_SHIFT)
#define I2C_BRD_FLT_SHEN(base) (BME_UBFX8(&I2C_FLT_REG(base), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))

/*! @brief Set the SHEN field to a new value. */
#define I2C_WR_FLT_SHEN(base, value) (I2C_RMW_FLT(base, (I2C_FLT_SHEN_MASK | I2C_FLT_STARTF_MASK | I2C_FLT_STOPF_MASK), I2C_FLT_SHEN(value)))
#define I2C_BWR_FLT_SHEN(base, value) (BME_BFI8(&I2C_FLT_REG(base), ((uint8_t)(value) << I2C_FLT_SHEN_SHIFT), I2C_FLT_SHEN_SHIFT, I2C_FLT_SHEN_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_RA - I2C Range Address register
 ******************************************************************************/

/*!
 * @brief I2C_RA - I2C Range Address register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_RA register
 */
/*@{*/
#define I2C_RD_RA(base)          (I2C_RA_REG(base))
#define I2C_WR_RA(base, value)   (I2C_RA_REG(base) = (value))
#define I2C_RMW_RA(base, mask, value) (I2C_WR_RA(base, (I2C_RD_RA(base) & ~(mask)) | (value)))
#define I2C_SET_RA(base, value)  (BME_OR8(&I2C_RA_REG(base), (uint8_t)(value)))
#define I2C_CLR_RA(base, value)  (BME_AND8(&I2C_RA_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_RA(base, value)  (BME_XOR8(&I2C_RA_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_RA bitfields
 */

/*!
 * @name Register I2C_RA, field RAD[7:1] (RW)
 *
 * This field contains the slave address to be used by the I2C module. The field
 * is used in the 7-bit address scheme. If I2C_C2[RMEN] is set to 1, any nonzero
 * value write enables this register. This register value can be considered as a
 * maximum boundary in the range matching mode.
 */
/*@{*/
/*! @brief Read current value of the I2C_RA_RAD field. */
#define I2C_RD_RA_RAD(base)  ((I2C_RA_REG(base) & I2C_RA_RAD_MASK) >> I2C_RA_RAD_SHIFT)
#define I2C_BRD_RA_RAD(base) (BME_UBFX8(&I2C_RA_REG(base), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))

/*! @brief Set the RAD field to a new value. */
#define I2C_WR_RA_RAD(base, value) (I2C_RMW_RA(base, I2C_RA_RAD_MASK, I2C_RA_RAD(value)))
#define I2C_BWR_RA_RAD(base, value) (BME_BFI8(&I2C_RA_REG(base), ((uint8_t)(value) << I2C_RA_RAD_SHIFT), I2C_RA_RAD_SHIFT, I2C_RA_RAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SMB - I2C SMBus Control and Status register
 ******************************************************************************/

/*!
 * @brief I2C_SMB - I2C SMBus Control and Status register (RW)
 *
 * Reset value: 0x00U
 *
 * When the SCL and SDA signals are held high for a length of time greater than
 * the high timeout period, the SHTF1 flag sets. Before reaching this threshold,
 * while the system is detecting how long these signals are being held high, a
 * master assumes that the bus is free. However, the SHTF1 bit is set to 1 in the
 * bus transmission process with the idle bus state. When the TCKSEL bit is set,
 * there is no need to monitor the SHTF1 bit because the bus speed is too high to
 * match the protocol of SMBus.
 */
/*!
 * @name Constants and macros for entire I2C_SMB register
 */
/*@{*/
#define I2C_RD_SMB(base)         (I2C_SMB_REG(base))
#define I2C_WR_SMB(base, value)  (I2C_SMB_REG(base) = (value))
#define I2C_RMW_SMB(base, mask, value) (I2C_WR_SMB(base, (I2C_RD_SMB(base) & ~(mask)) | (value)))
#define I2C_SET_SMB(base, value) (BME_OR8(&I2C_SMB_REG(base), (uint8_t)(value)))
#define I2C_CLR_SMB(base, value) (BME_AND8(&I2C_SMB_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SMB(base, value) (BME_XOR8(&I2C_SMB_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_SMB bitfields
 */

/*!
 * @name Register I2C_SMB, field SHTF2IE[0] (RW)
 *
 * Enables SCL high and SDA low timeout interrupt.
 *
 * Values:
 * - 0b0 - SHTF2 interrupt is disabled
 * - 0b1 - SHTF2 interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2IE field. */
#define I2C_RD_SMB_SHTF2IE(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2IE_MASK) >> I2C_SMB_SHTF2IE_SHIFT)
#define I2C_BRD_SMB_SHTF2IE(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))

/*! @brief Set the SHTF2IE field to a new value. */
#define I2C_WR_SMB_SHTF2IE(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2IE_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2IE(value)))
#define I2C_BWR_SMB_SHTF2IE(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2IE_SHIFT), I2C_SMB_SHTF2IE_SHIFT, I2C_SMB_SHTF2IE_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF2[1] (W1C)
 *
 * This bit sets when SCL is held high and SDA is held low more than clock *
 * LoValue / 512. Software clears this bit by writing 1 to it.
 *
 * Values:
 * - 0b0 - No SCL high and SDA low timeout occurs
 * - 0b1 - SCL high and SDA low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF2 field. */
#define I2C_RD_SMB_SHTF2(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF2_MASK) >> I2C_SMB_SHTF2_SHIFT)
#define I2C_BRD_SMB_SHTF2(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))

/*! @brief Set the SHTF2 field to a new value. */
#define I2C_WR_SMB_SHTF2(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SHTF2(value)))
#define I2C_BWR_SMB_SHTF2(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SHTF2_SHIFT), I2C_SMB_SHTF2_SHIFT, I2C_SMB_SHTF2_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SHTF1[2] (RO)
 *
 * This read-only bit sets when SCL and SDA are held high more than clock *
 * LoValue / 512, which indicates the bus is free. This bit is cleared automatically.
 *
 * Values:
 * - 0b0 - No SCL high and SDA high timeout occurs
 * - 0b1 - SCL high and SDA high timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SHTF1 field. */
#define I2C_RD_SMB_SHTF1(base) ((I2C_SMB_REG(base) & I2C_SMB_SHTF1_MASK) >> I2C_SMB_SHTF1_SHIFT)
#define I2C_BRD_SMB_SHTF1(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SHTF1_SHIFT, I2C_SMB_SHTF1_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SLTF[3] (W1C)
 *
 * This bit is set when the SLT register (consisting of the SLTH and SLTL
 * registers) is loaded with a non-zero value (LoValue) and an SCL low timeout occurs.
 * Software clears this bit by writing a logic 1 to it. The low timeout function
 * is disabled when the SLT register's value is 0.
 *
 * Values:
 * - 0b0 - No low timeout occurs
 * - 0b1 - Low timeout occurs
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SLTF field. */
#define I2C_RD_SMB_SLTF(base) ((I2C_SMB_REG(base) & I2C_SMB_SLTF_MASK) >> I2C_SMB_SLTF_SHIFT)
#define I2C_BRD_SMB_SLTF(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))

/*! @brief Set the SLTF field to a new value. */
#define I2C_WR_SMB_SLTF(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SLTF_MASK | I2C_SMB_SHTF2_MASK), I2C_SMB_SLTF(value)))
#define I2C_BWR_SMB_SLTF(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SLTF_SHIFT), I2C_SMB_SLTF_SHIFT, I2C_SMB_SLTF_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field TCKSEL[4] (RW)
 *
 * Selects the clock source of the timeout counter.
 *
 * Values:
 * - 0b0 - Timeout counter counts at the frequency of the I2C module clock / 64
 * - 0b1 - Timeout counter counts at the frequency of the I2C module clock
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_TCKSEL field. */
#define I2C_RD_SMB_TCKSEL(base) ((I2C_SMB_REG(base) & I2C_SMB_TCKSEL_MASK) >> I2C_SMB_TCKSEL_SHIFT)
#define I2C_BRD_SMB_TCKSEL(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))

/*! @brief Set the TCKSEL field to a new value. */
#define I2C_WR_SMB_TCKSEL(base, value) (I2C_RMW_SMB(base, (I2C_SMB_TCKSEL_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_TCKSEL(value)))
#define I2C_BWR_SMB_TCKSEL(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_TCKSEL_SHIFT), I2C_SMB_TCKSEL_SHIFT, I2C_SMB_TCKSEL_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field SIICAEN[5] (RW)
 *
 * Enables or disables SMBus device default address.
 *
 * Values:
 * - 0b0 - I2C address register 2 matching is disabled
 * - 0b1 - I2C address register 2 matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_SIICAEN field. */
#define I2C_RD_SMB_SIICAEN(base) ((I2C_SMB_REG(base) & I2C_SMB_SIICAEN_MASK) >> I2C_SMB_SIICAEN_SHIFT)
#define I2C_BRD_SMB_SIICAEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))

/*! @brief Set the SIICAEN field to a new value. */
#define I2C_WR_SMB_SIICAEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_SIICAEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_SIICAEN(value)))
#define I2C_BWR_SMB_SIICAEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_SIICAEN_SHIFT), I2C_SMB_SIICAEN_SHIFT, I2C_SMB_SIICAEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field ALERTEN[6] (RW)
 *
 * Enables or disables SMBus alert response address matching. After the host
 * responds to a device that used the alert response address, you must use software
 * to put the device's address on the bus. The alert protocol is described in the
 * SMBus specification.
 *
 * Values:
 * - 0b0 - SMBus alert response address matching is disabled
 * - 0b1 - SMBus alert response address matching is enabled
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_ALERTEN field. */
#define I2C_RD_SMB_ALERTEN(base) ((I2C_SMB_REG(base) & I2C_SMB_ALERTEN_MASK) >> I2C_SMB_ALERTEN_SHIFT)
#define I2C_BRD_SMB_ALERTEN(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))

/*! @brief Set the ALERTEN field to a new value. */
#define I2C_WR_SMB_ALERTEN(base, value) (I2C_RMW_SMB(base, (I2C_SMB_ALERTEN_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_ALERTEN(value)))
#define I2C_BWR_SMB_ALERTEN(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_ALERTEN_SHIFT), I2C_SMB_ALERTEN_SHIFT, I2C_SMB_ALERTEN_WIDTH))
/*@}*/

/*!
 * @name Register I2C_SMB, field FACK[7] (RW)
 *
 * For SMBus packet error checking, the CPU must be able to issue an ACK or NACK
 * according to the result of receiving data byte.
 *
 * Values:
 * - 0b0 - An ACK or NACK is sent on the following receiving data byte
 * - 0b1 - Writing 0 to TXAK after receiving a data byte generates an ACK.
 *     Writing 1 to TXAK after receiving a data byte generates a NACK.
 */
/*@{*/
/*! @brief Read current value of the I2C_SMB_FACK field. */
#define I2C_RD_SMB_FACK(base) ((I2C_SMB_REG(base) & I2C_SMB_FACK_MASK) >> I2C_SMB_FACK_SHIFT)
#define I2C_BRD_SMB_FACK(base) (BME_UBFX8(&I2C_SMB_REG(base), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))

/*! @brief Set the FACK field to a new value. */
#define I2C_WR_SMB_FACK(base, value) (I2C_RMW_SMB(base, (I2C_SMB_FACK_MASK | I2C_SMB_SHTF2_MASK | I2C_SMB_SLTF_MASK), I2C_SMB_FACK(value)))
#define I2C_BWR_SMB_FACK(base, value) (BME_BFI8(&I2C_SMB_REG(base), ((uint8_t)(value) << I2C_SMB_FACK_SHIFT), I2C_SMB_FACK_SHIFT, I2C_SMB_FACK_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_A2 - I2C Address Register 2
 ******************************************************************************/

/*!
 * @brief I2C_A2 - I2C Address Register 2 (RW)
 *
 * Reset value: 0xC2U
 */
/*!
 * @name Constants and macros for entire I2C_A2 register
 */
/*@{*/
#define I2C_RD_A2(base)          (I2C_A2_REG(base))
#define I2C_WR_A2(base, value)   (I2C_A2_REG(base) = (value))
#define I2C_RMW_A2(base, mask, value) (I2C_WR_A2(base, (I2C_RD_A2(base) & ~(mask)) | (value)))
#define I2C_SET_A2(base, value)  (BME_OR8(&I2C_A2_REG(base), (uint8_t)(value)))
#define I2C_CLR_A2(base, value)  (BME_AND8(&I2C_A2_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_A2(base, value)  (BME_XOR8(&I2C_A2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual I2C_A2 bitfields
 */

/*!
 * @name Register I2C_A2, field SAD[7:1] (RW)
 *
 * Contains the slave address used by the SMBus. This field is used on the
 * device default address or other related addresses.
 */
/*@{*/
/*! @brief Read current value of the I2C_A2_SAD field. */
#define I2C_RD_A2_SAD(base)  ((I2C_A2_REG(base) & I2C_A2_SAD_MASK) >> I2C_A2_SAD_SHIFT)
#define I2C_BRD_A2_SAD(base) (BME_UBFX8(&I2C_A2_REG(base), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))

/*! @brief Set the SAD field to a new value. */
#define I2C_WR_A2_SAD(base, value) (I2C_RMW_A2(base, I2C_A2_SAD_MASK, I2C_A2_SAD(value)))
#define I2C_BWR_A2_SAD(base, value) (BME_BFI8(&I2C_A2_REG(base), ((uint8_t)(value) << I2C_A2_SAD_SHIFT), I2C_A2_SAD_SHIFT, I2C_A2_SAD_WIDTH))
/*@}*/

/*******************************************************************************
 * I2C_SLTH - I2C SCL Low Timeout Register High
 ******************************************************************************/

/*!
 * @brief I2C_SLTH - I2C SCL Low Timeout Register High (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTH register
 */
/*@{*/
#define I2C_RD_SLTH(base)        (I2C_SLTH_REG(base))
#define I2C_WR_SLTH(base, value) (I2C_SLTH_REG(base) = (value))
#define I2C_RMW_SLTH(base, mask, value) (I2C_WR_SLTH(base, (I2C_RD_SLTH(base) & ~(mask)) | (value)))
#define I2C_SET_SLTH(base, value) (BME_OR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTH(base, value) (BME_AND8(&I2C_SLTH_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTH(base, value) (BME_XOR8(&I2C_SLTH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * I2C_SLTL - I2C SCL Low Timeout Register Low
 ******************************************************************************/

/*!
 * @brief I2C_SLTL - I2C SCL Low Timeout Register Low (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire I2C_SLTL register
 */
/*@{*/
#define I2C_RD_SLTL(base)        (I2C_SLTL_REG(base))
#define I2C_WR_SLTL(base, value) (I2C_SLTL_REG(base) = (value))
#define I2C_RMW_SLTL(base, mask, value) (I2C_WR_SLTL(base, (I2C_RD_SLTL(base) & ~(mask)) | (value)))
#define I2C_SET_SLTL(base, value) (BME_OR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
#define I2C_CLR_SLTL(base, value) (BME_AND8(&I2C_SLTL_REG(base), (uint8_t)(~(value))))
#define I2C_TOG_SLTL(base, value) (BME_XOR8(&I2C_SLTL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * MKV58F24 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_PE3 - LLWU Pin Enable 3 register
 * - LLWU_PE4 - LLWU Pin Enable 4 register
 * - LLWU_PE5 - LLWU Pin Enable 5 register
 * - LLWU_PE6 - LLWU Pin Enable 6 register
 * - LLWU_PE7 - LLWU Pin Enable 7 register
 * - LLWU_PE8 - LLWU Pin Enable 8 register
 * - LLWU_ME - LLWU Module Enable register
 * - LLWU_PF1 - LLWU Pin Flag 1 register
 * - LLWU_PF2 - LLWU Pin Flag 2 register
 * - LLWU_PF3 - LLWU Pin Flag 3 register
 * - LLWU_PF4 - LLWU Pin Flag 4 register
 * - LLWU_MF5 - LLWU Module Flag 5 register
 * - LLWU_FILT1 - LLWU Pin Filter 1 register
 * - LLWU_FILT2 - LLWU Pin Filter 2 register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (BME_OR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE1(base, value) (BME_AND8(&LLWU_PE1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE1(base, value) (BME_XOR8(&LLWU_PE1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE0_SHIFT), LLWU_PE1_WUPE0_SHIFT, LLWU_PE1_WUPE0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE1_SHIFT), LLWU_PE1_WUPE1_SHIFT, LLWU_PE1_WUPE1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE2_SHIFT), LLWU_PE1_WUPE2_SHIFT, LLWU_PE1_WUPE2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (BME_UBFX8(&LLWU_PE1_REG(base), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (BME_BFI8(&LLWU_PE1_REG(base), ((uint8_t)(value) << LLWU_PE1_WUPE3_SHIFT), LLWU_PE1_WUPE3_SHIFT, LLWU_PE1_WUPE3_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (BME_OR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE2(base, value) (BME_AND8(&LLWU_PE2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE2(base, value) (BME_XOR8(&LLWU_PE2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE4_SHIFT), LLWU_PE2_WUPE4_SHIFT, LLWU_PE2_WUPE4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE5_SHIFT), LLWU_PE2_WUPE5_SHIFT, LLWU_PE2_WUPE5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE6_SHIFT), LLWU_PE2_WUPE6_SHIFT, LLWU_PE2_WUPE6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (BME_UBFX8(&LLWU_PE2_REG(base), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (BME_BFI8(&LLWU_PE2_REG(base), ((uint8_t)(value) << LLWU_PE2_WUPE7_SHIFT), LLWU_PE2_WUPE7_SHIFT, LLWU_PE2_WUPE7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (BME_OR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE3(base, value) (BME_AND8(&LLWU_PE3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE3(base, value) (BME_XOR8(&LLWU_PE3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE8_SHIFT), LLWU_PE3_WUPE8_SHIFT, LLWU_PE3_WUPE8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE9_SHIFT), LLWU_PE3_WUPE9_SHIFT, LLWU_PE3_WUPE9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE10_SHIFT), LLWU_PE3_WUPE10_SHIFT, LLWU_PE3_WUPE10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (BME_UBFX8(&LLWU_PE3_REG(base), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (BME_BFI8(&LLWU_PE3_REG(base), ((uint8_t)(value) << LLWU_PE3_WUPE11_SHIFT), LLWU_PE3_WUPE11_SHIFT, LLWU_PE3_WUPE11_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (BME_OR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE4(base, value) (BME_AND8(&LLWU_PE4_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE4(base, value) (BME_XOR8(&LLWU_PE4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE12_SHIFT), LLWU_PE4_WUPE12_SHIFT, LLWU_PE4_WUPE12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE13_SHIFT), LLWU_PE4_WUPE13_SHIFT, LLWU_PE4_WUPE13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE14_SHIFT), LLWU_PE4_WUPE14_SHIFT, LLWU_PE4_WUPE14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (BME_UBFX8(&LLWU_PE4_REG(base), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (BME_BFI8(&LLWU_PE4_REG(base), ((uint8_t)(value) << LLWU_PE4_WUPE15_SHIFT), LLWU_PE4_WUPE15_SHIFT, LLWU_PE4_WUPE15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE5 - LLWU Pin Enable 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE5 - LLWU Pin Enable 5 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE5 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P19-LLWU_P16. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE5 register
 */
/*@{*/
#define LLWU_RD_PE5(base)        (LLWU_PE5_REG(base))
#define LLWU_WR_PE5(base, value) (LLWU_PE5_REG(base) = (value))
#define LLWU_RMW_PE5(base, mask, value) (LLWU_WR_PE5(base, (LLWU_RD_PE5(base) & ~(mask)) | (value)))
#define LLWU_SET_PE5(base, value) (BME_OR8(&LLWU_PE5_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE5(base, value) (BME_AND8(&LLWU_PE5_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE5(base, value) (BME_XOR8(&LLWU_PE5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE5 bitfields
 */

/*!
 * @name Register LLWU_PE5, field WUPE16[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE16 field. */
#define LLWU_RD_PE5_WUPE16(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE16_MASK) >> LLWU_PE5_WUPE16_SHIFT)
#define LLWU_BRD_PE5_WUPE16(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE16_SHIFT, LLWU_PE5_WUPE16_WIDTH))

/*! @brief Set the WUPE16 field to a new value. */
#define LLWU_WR_PE5_WUPE16(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE16_MASK, LLWU_PE5_WUPE16(value)))
#define LLWU_BWR_PE5_WUPE16(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE16_SHIFT), LLWU_PE5_WUPE16_SHIFT, LLWU_PE5_WUPE16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE17[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE17 field. */
#define LLWU_RD_PE5_WUPE17(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE17_MASK) >> LLWU_PE5_WUPE17_SHIFT)
#define LLWU_BRD_PE5_WUPE17(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE17_SHIFT, LLWU_PE5_WUPE17_WIDTH))

/*! @brief Set the WUPE17 field to a new value. */
#define LLWU_WR_PE5_WUPE17(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE17_MASK, LLWU_PE5_WUPE17(value)))
#define LLWU_BWR_PE5_WUPE17(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE17_SHIFT), LLWU_PE5_WUPE17_SHIFT, LLWU_PE5_WUPE17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE18[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE18 field. */
#define LLWU_RD_PE5_WUPE18(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE18_MASK) >> LLWU_PE5_WUPE18_SHIFT)
#define LLWU_BRD_PE5_WUPE18(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE18_SHIFT, LLWU_PE5_WUPE18_WIDTH))

/*! @brief Set the WUPE18 field to a new value. */
#define LLWU_WR_PE5_WUPE18(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE18_MASK, LLWU_PE5_WUPE18(value)))
#define LLWU_BWR_PE5_WUPE18(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE18_SHIFT), LLWU_PE5_WUPE18_SHIFT, LLWU_PE5_WUPE18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE19[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE19 field. */
#define LLWU_RD_PE5_WUPE19(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE19_MASK) >> LLWU_PE5_WUPE19_SHIFT)
#define LLWU_BRD_PE5_WUPE19(base) (BME_UBFX8(&LLWU_PE5_REG(base), LLWU_PE5_WUPE19_SHIFT, LLWU_PE5_WUPE19_WIDTH))

/*! @brief Set the WUPE19 field to a new value. */
#define LLWU_WR_PE5_WUPE19(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE19_MASK, LLWU_PE5_WUPE19(value)))
#define LLWU_BWR_PE5_WUPE19(base, value) (BME_BFI8(&LLWU_PE5_REG(base), ((uint8_t)(value) << LLWU_PE5_WUPE19_SHIFT), LLWU_PE5_WUPE19_SHIFT, LLWU_PE5_WUPE19_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE6 - LLWU Pin Enable 6 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE6 - LLWU Pin Enable 6 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE6 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P23-LLWU_P20. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE6 register
 */
/*@{*/
#define LLWU_RD_PE6(base)        (LLWU_PE6_REG(base))
#define LLWU_WR_PE6(base, value) (LLWU_PE6_REG(base) = (value))
#define LLWU_RMW_PE6(base, mask, value) (LLWU_WR_PE6(base, (LLWU_RD_PE6(base) & ~(mask)) | (value)))
#define LLWU_SET_PE6(base, value) (BME_OR8(&LLWU_PE6_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE6(base, value) (BME_AND8(&LLWU_PE6_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE6(base, value) (BME_XOR8(&LLWU_PE6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE6 bitfields
 */

/*!
 * @name Register LLWU_PE6, field WUPE20[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE20 field. */
#define LLWU_RD_PE6_WUPE20(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE20_MASK) >> LLWU_PE6_WUPE20_SHIFT)
#define LLWU_BRD_PE6_WUPE20(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE20_SHIFT, LLWU_PE6_WUPE20_WIDTH))

/*! @brief Set the WUPE20 field to a new value. */
#define LLWU_WR_PE6_WUPE20(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE20_MASK, LLWU_PE6_WUPE20(value)))
#define LLWU_BWR_PE6_WUPE20(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE20_SHIFT), LLWU_PE6_WUPE20_SHIFT, LLWU_PE6_WUPE20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE21[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE21 field. */
#define LLWU_RD_PE6_WUPE21(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE21_MASK) >> LLWU_PE6_WUPE21_SHIFT)
#define LLWU_BRD_PE6_WUPE21(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE21_SHIFT, LLWU_PE6_WUPE21_WIDTH))

/*! @brief Set the WUPE21 field to a new value. */
#define LLWU_WR_PE6_WUPE21(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE21_MASK, LLWU_PE6_WUPE21(value)))
#define LLWU_BWR_PE6_WUPE21(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE21_SHIFT), LLWU_PE6_WUPE21_SHIFT, LLWU_PE6_WUPE21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE22[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE22 field. */
#define LLWU_RD_PE6_WUPE22(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE22_MASK) >> LLWU_PE6_WUPE22_SHIFT)
#define LLWU_BRD_PE6_WUPE22(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE22_SHIFT, LLWU_PE6_WUPE22_WIDTH))

/*! @brief Set the WUPE22 field to a new value. */
#define LLWU_WR_PE6_WUPE22(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE22_MASK, LLWU_PE6_WUPE22(value)))
#define LLWU_BWR_PE6_WUPE22(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE22_SHIFT), LLWU_PE6_WUPE22_SHIFT, LLWU_PE6_WUPE22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE23[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE23 field. */
#define LLWU_RD_PE6_WUPE23(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE23_MASK) >> LLWU_PE6_WUPE23_SHIFT)
#define LLWU_BRD_PE6_WUPE23(base) (BME_UBFX8(&LLWU_PE6_REG(base), LLWU_PE6_WUPE23_SHIFT, LLWU_PE6_WUPE23_WIDTH))

/*! @brief Set the WUPE23 field to a new value. */
#define LLWU_WR_PE6_WUPE23(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE23_MASK, LLWU_PE6_WUPE23(value)))
#define LLWU_BWR_PE6_WUPE23(base, value) (BME_BFI8(&LLWU_PE6_REG(base), ((uint8_t)(value) << LLWU_PE6_WUPE23_SHIFT), LLWU_PE6_WUPE23_SHIFT, LLWU_PE6_WUPE23_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE7 - LLWU Pin Enable 7 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE7 - LLWU Pin Enable 7 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE7 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P27-LLWU_P24. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE7 register
 */
/*@{*/
#define LLWU_RD_PE7(base)        (LLWU_PE7_REG(base))
#define LLWU_WR_PE7(base, value) (LLWU_PE7_REG(base) = (value))
#define LLWU_RMW_PE7(base, mask, value) (LLWU_WR_PE7(base, (LLWU_RD_PE7(base) & ~(mask)) | (value)))
#define LLWU_SET_PE7(base, value) (BME_OR8(&LLWU_PE7_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE7(base, value) (BME_AND8(&LLWU_PE7_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE7(base, value) (BME_XOR8(&LLWU_PE7_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE7 bitfields
 */

/*!
 * @name Register LLWU_PE7, field WUPE24[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE24 field. */
#define LLWU_RD_PE7_WUPE24(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE24_MASK) >> LLWU_PE7_WUPE24_SHIFT)
#define LLWU_BRD_PE7_WUPE24(base) (BME_UBFX8(&LLWU_PE7_REG(base), LLWU_PE7_WUPE24_SHIFT, LLWU_PE7_WUPE24_WIDTH))

/*! @brief Set the WUPE24 field to a new value. */
#define LLWU_WR_PE7_WUPE24(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE24_MASK, LLWU_PE7_WUPE24(value)))
#define LLWU_BWR_PE7_WUPE24(base, value) (BME_BFI8(&LLWU_PE7_REG(base), ((uint8_t)(value) << LLWU_PE7_WUPE24_SHIFT), LLWU_PE7_WUPE24_SHIFT, LLWU_PE7_WUPE24_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE25[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE25 field. */
#define LLWU_RD_PE7_WUPE25(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE25_MASK) >> LLWU_PE7_WUPE25_SHIFT)
#define LLWU_BRD_PE7_WUPE25(base) (BME_UBFX8(&LLWU_PE7_REG(base), LLWU_PE7_WUPE25_SHIFT, LLWU_PE7_WUPE25_WIDTH))

/*! @brief Set the WUPE25 field to a new value. */
#define LLWU_WR_PE7_WUPE25(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE25_MASK, LLWU_PE7_WUPE25(value)))
#define LLWU_BWR_PE7_WUPE25(base, value) (BME_BFI8(&LLWU_PE7_REG(base), ((uint8_t)(value) << LLWU_PE7_WUPE25_SHIFT), LLWU_PE7_WUPE25_SHIFT, LLWU_PE7_WUPE25_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE26[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE26 field. */
#define LLWU_RD_PE7_WUPE26(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE26_MASK) >> LLWU_PE7_WUPE26_SHIFT)
#define LLWU_BRD_PE7_WUPE26(base) (BME_UBFX8(&LLWU_PE7_REG(base), LLWU_PE7_WUPE26_SHIFT, LLWU_PE7_WUPE26_WIDTH))

/*! @brief Set the WUPE26 field to a new value. */
#define LLWU_WR_PE7_WUPE26(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE26_MASK, LLWU_PE7_WUPE26(value)))
#define LLWU_BWR_PE7_WUPE26(base, value) (BME_BFI8(&LLWU_PE7_REG(base), ((uint8_t)(value) << LLWU_PE7_WUPE26_SHIFT), LLWU_PE7_WUPE26_SHIFT, LLWU_PE7_WUPE26_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE27[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE27 field. */
#define LLWU_RD_PE7_WUPE27(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE27_MASK) >> LLWU_PE7_WUPE27_SHIFT)
#define LLWU_BRD_PE7_WUPE27(base) (BME_UBFX8(&LLWU_PE7_REG(base), LLWU_PE7_WUPE27_SHIFT, LLWU_PE7_WUPE27_WIDTH))

/*! @brief Set the WUPE27 field to a new value. */
#define LLWU_WR_PE7_WUPE27(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE27_MASK, LLWU_PE7_WUPE27(value)))
#define LLWU_BWR_PE7_WUPE27(base, value) (BME_BFI8(&LLWU_PE7_REG(base), ((uint8_t)(value) << LLWU_PE7_WUPE27_SHIFT), LLWU_PE7_WUPE27_SHIFT, LLWU_PE7_WUPE27_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PE8 - LLWU Pin Enable 8 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE8 - LLWU Pin Enable 8 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE8 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P31-LLWU_P28. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE8 register
 */
/*@{*/
#define LLWU_RD_PE8(base)        (LLWU_PE8_REG(base))
#define LLWU_WR_PE8(base, value) (LLWU_PE8_REG(base) = (value))
#define LLWU_RMW_PE8(base, mask, value) (LLWU_WR_PE8(base, (LLWU_RD_PE8(base) & ~(mask)) | (value)))
#define LLWU_SET_PE8(base, value) (BME_OR8(&LLWU_PE8_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PE8(base, value) (BME_AND8(&LLWU_PE8_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PE8(base, value) (BME_XOR8(&LLWU_PE8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE8 bitfields
 */

/*!
 * @name Register LLWU_PE8, field WUPE28[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE28 field. */
#define LLWU_RD_PE8_WUPE28(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE28_MASK) >> LLWU_PE8_WUPE28_SHIFT)
#define LLWU_BRD_PE8_WUPE28(base) (BME_UBFX8(&LLWU_PE8_REG(base), LLWU_PE8_WUPE28_SHIFT, LLWU_PE8_WUPE28_WIDTH))

/*! @brief Set the WUPE28 field to a new value. */
#define LLWU_WR_PE8_WUPE28(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE28_MASK, LLWU_PE8_WUPE28(value)))
#define LLWU_BWR_PE8_WUPE28(base, value) (BME_BFI8(&LLWU_PE8_REG(base), ((uint8_t)(value) << LLWU_PE8_WUPE28_SHIFT), LLWU_PE8_WUPE28_SHIFT, LLWU_PE8_WUPE28_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE29[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE29 field. */
#define LLWU_RD_PE8_WUPE29(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE29_MASK) >> LLWU_PE8_WUPE29_SHIFT)
#define LLWU_BRD_PE8_WUPE29(base) (BME_UBFX8(&LLWU_PE8_REG(base), LLWU_PE8_WUPE29_SHIFT, LLWU_PE8_WUPE29_WIDTH))

/*! @brief Set the WUPE29 field to a new value. */
#define LLWU_WR_PE8_WUPE29(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE29_MASK, LLWU_PE8_WUPE29(value)))
#define LLWU_BWR_PE8_WUPE29(base, value) (BME_BFI8(&LLWU_PE8_REG(base), ((uint8_t)(value) << LLWU_PE8_WUPE29_SHIFT), LLWU_PE8_WUPE29_SHIFT, LLWU_PE8_WUPE29_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE30[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE30 field. */
#define LLWU_RD_PE8_WUPE30(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE30_MASK) >> LLWU_PE8_WUPE30_SHIFT)
#define LLWU_BRD_PE8_WUPE30(base) (BME_UBFX8(&LLWU_PE8_REG(base), LLWU_PE8_WUPE30_SHIFT, LLWU_PE8_WUPE30_WIDTH))

/*! @brief Set the WUPE30 field to a new value. */
#define LLWU_WR_PE8_WUPE30(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE30_MASK, LLWU_PE8_WUPE30(value)))
#define LLWU_BWR_PE8_WUPE30(base, value) (BME_BFI8(&LLWU_PE8_REG(base), ((uint8_t)(value) << LLWU_PE8_WUPE30_SHIFT), LLWU_PE8_WUPE30_SHIFT, LLWU_PE8_WUPE30_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE31[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 0b00 - External input pin disabled as wakeup input
 * - 0b01 - External input pin enabled with rising edge detection
 * - 0b10 - External input pin enabled with falling edge detection
 * - 0b11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE31 field. */
#define LLWU_RD_PE8_WUPE31(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE31_MASK) >> LLWU_PE8_WUPE31_SHIFT)
#define LLWU_BRD_PE8_WUPE31(base) (BME_UBFX8(&LLWU_PE8_REG(base), LLWU_PE8_WUPE31_SHIFT, LLWU_PE8_WUPE31_WIDTH))

/*! @brief Set the WUPE31 field to a new value. */
#define LLWU_WR_PE8_WUPE31(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE31_MASK, LLWU_PE8_WUPE31(value)))
#define LLWU_BWR_PE8_WUPE31(base, value) (BME_BFI8(&LLWU_PE8_REG(base), ((uint8_t)(value) << LLWU_PE8_WUPE31_SHIFT), LLWU_PE8_WUPE31_SHIFT, LLWU_PE8_WUPE31_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (BME_OR8(&LLWU_ME_REG(base), (uint8_t)(value)))
#define LLWU_CLR_ME(base, value) (BME_AND8(&LLWU_ME_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_ME(base, value) (BME_XOR8(&LLWU_ME_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME0_SHIFT), LLWU_ME_WUME0_SHIFT, LLWU_ME_WUME0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME1_SHIFT), LLWU_ME_WUME1_SHIFT, LLWU_ME_WUME1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME2_SHIFT), LLWU_ME_WUME2_SHIFT, LLWU_ME_WUME2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME3_SHIFT), LLWU_ME_WUME3_SHIFT, LLWU_ME_WUME3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME4_SHIFT), LLWU_ME_WUME4_SHIFT, LLWU_ME_WUME4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME5_SHIFT), LLWU_ME_WUME5_SHIFT, LLWU_ME_WUME5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME6_SHIFT), LLWU_ME_WUME6_SHIFT, LLWU_ME_WUME6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0b0 - Internal module flag not used as wakeup source
 * - 0b1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BME_UBFX8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BME_BFI8(&LLWU_ME_REG(base), ((uint8_t)(value) << LLWU_ME_WUME7_SHIFT), LLWU_ME_WUME7_SHIFT, LLWU_ME_WUME7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF1 - LLWU Pin Flag 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF1 - LLWU Pin Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is accomplished
 * by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF1 register
 */
/*@{*/
#define LLWU_RD_PF1(base)        (LLWU_PF1_REG(base))
#define LLWU_WR_PF1(base, value) (LLWU_PF1_REG(base) = (value))
#define LLWU_RMW_PF1(base, mask, value) (LLWU_WR_PF1(base, (LLWU_RD_PF1(base) & ~(mask)) | (value)))
#define LLWU_SET_PF1(base, value) (BME_OR8(&LLWU_PF1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF1(base, value) (BME_AND8(&LLWU_PF1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF1(base, value) (BME_XOR8(&LLWU_PF1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF1 bitfields
 */

/*!
 * @name Register LLWU_PF1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF0.
 *
 * Values:
 * - 0b0 - LLWU_P0 input was not a wakeup source
 * - 0b1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF0 field. */
#define LLWU_RD_PF1_WUF0(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF0_MASK) >> LLWU_PF1_WUF0_SHIFT)
#define LLWU_BRD_PF1_WUF0(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF0_SHIFT, LLWU_PF1_WUF0_WIDTH))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_PF1_WUF0(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF0(value)))
#define LLWU_BWR_PF1_WUF0(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF0_SHIFT), LLWU_PF1_WUF0_SHIFT, LLWU_PF1_WUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF1.
 *
 * Values:
 * - 0b0 - LLWU_P1 input was not a wakeup source
 * - 0b1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF1 field. */
#define LLWU_RD_PF1_WUF1(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF1_MASK) >> LLWU_PF1_WUF1_SHIFT)
#define LLWU_BRD_PF1_WUF1(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF1_SHIFT, LLWU_PF1_WUF1_WIDTH))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_PF1_WUF1(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF1(value)))
#define LLWU_BWR_PF1_WUF1(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF1_SHIFT), LLWU_PF1_WUF1_SHIFT, LLWU_PF1_WUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF2.
 *
 * Values:
 * - 0b0 - LLWU_P2 input was not a wakeup source
 * - 0b1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF2 field. */
#define LLWU_RD_PF1_WUF2(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF2_MASK) >> LLWU_PF1_WUF2_SHIFT)
#define LLWU_BRD_PF1_WUF2(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF2_SHIFT, LLWU_PF1_WUF2_WIDTH))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_PF1_WUF2(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF2(value)))
#define LLWU_BWR_PF1_WUF2(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF2_SHIFT), LLWU_PF1_WUF2_SHIFT, LLWU_PF1_WUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF3.
 *
 * Values:
 * - 0b0 - LLWU_P3 input was not a wakeup source
 * - 0b1 - LLWU_P3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF3 field. */
#define LLWU_RD_PF1_WUF3(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF3_MASK) >> LLWU_PF1_WUF3_SHIFT)
#define LLWU_BRD_PF1_WUF3(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF3_SHIFT, LLWU_PF1_WUF3_WIDTH))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_PF1_WUF3(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF3(value)))
#define LLWU_BWR_PF1_WUF3(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF3_SHIFT), LLWU_PF1_WUF3_SHIFT, LLWU_PF1_WUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF4.
 *
 * Values:
 * - 0b0 - LLWU_P4 input was not a wakeup source
 * - 0b1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF4 field. */
#define LLWU_RD_PF1_WUF4(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF4_MASK) >> LLWU_PF1_WUF4_SHIFT)
#define LLWU_BRD_PF1_WUF4(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF4_SHIFT, LLWU_PF1_WUF4_WIDTH))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_PF1_WUF4(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF4(value)))
#define LLWU_BWR_PF1_WUF4(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF4_SHIFT), LLWU_PF1_WUF4_SHIFT, LLWU_PF1_WUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF5.
 *
 * Values:
 * - 0b0 - LLWU_P5 input was not a wakeup source
 * - 0b1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF5 field. */
#define LLWU_RD_PF1_WUF5(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF5_MASK) >> LLWU_PF1_WUF5_SHIFT)
#define LLWU_BRD_PF1_WUF5(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF5_SHIFT, LLWU_PF1_WUF5_WIDTH))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_PF1_WUF5(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF5(value)))
#define LLWU_BWR_PF1_WUF5(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF5_SHIFT), LLWU_PF1_WUF5_SHIFT, LLWU_PF1_WUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF6.
 *
 * Values:
 * - 0b0 - LLWU_P6 input was not a wakeup source
 * - 0b1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF6 field. */
#define LLWU_RD_PF1_WUF6(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF6_MASK) >> LLWU_PF1_WUF6_SHIFT)
#define LLWU_BRD_PF1_WUF6(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF6_SHIFT, LLWU_PF1_WUF6_WIDTH))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_PF1_WUF6(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF6(value)))
#define LLWU_BWR_PF1_WUF6(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF6_SHIFT), LLWU_PF1_WUF6_SHIFT, LLWU_PF1_WUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF7.
 *
 * Values:
 * - 0b0 - LLWU_P7 input was not a wakeup source
 * - 0b1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF7 field. */
#define LLWU_RD_PF1_WUF7(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF7_MASK) >> LLWU_PF1_WUF7_SHIFT)
#define LLWU_BRD_PF1_WUF7(base) (BME_UBFX8(&LLWU_PF1_REG(base), LLWU_PF1_WUF7_SHIFT, LLWU_PF1_WUF7_WIDTH))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_PF1_WUF7(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF7_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK), LLWU_PF1_WUF7(value)))
#define LLWU_BWR_PF1_WUF7(base, value) (BME_BFI8(&LLWU_PF1_REG(base), ((uint8_t)(value) << LLWU_PF1_WUF7_SHIFT), LLWU_PF1_WUF7_SHIFT, LLWU_PF1_WUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF2 - LLWU Pin Flag 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF2 - LLWU Pin Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit or VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is
 * accomplished by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the
 * Reset Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF2 register
 */
/*@{*/
#define LLWU_RD_PF2(base)        (LLWU_PF2_REG(base))
#define LLWU_WR_PF2(base, value) (LLWU_PF2_REG(base) = (value))
#define LLWU_RMW_PF2(base, mask, value) (LLWU_WR_PF2(base, (LLWU_RD_PF2(base) & ~(mask)) | (value)))
#define LLWU_SET_PF2(base, value) (BME_OR8(&LLWU_PF2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF2(base, value) (BME_AND8(&LLWU_PF2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF2(base, value) (BME_XOR8(&LLWU_PF2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF2 bitfields
 */

/*!
 * @name Register LLWU_PF2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF8.
 *
 * Values:
 * - 0b0 - LLWU_P8 input was not a wakeup source
 * - 0b1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF8 field. */
#define LLWU_RD_PF2_WUF8(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF8_MASK) >> LLWU_PF2_WUF8_SHIFT)
#define LLWU_BRD_PF2_WUF8(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF8_SHIFT, LLWU_PF2_WUF8_WIDTH))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_PF2_WUF8(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF8(value)))
#define LLWU_BWR_PF2_WUF8(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF8_SHIFT), LLWU_PF2_WUF8_SHIFT, LLWU_PF2_WUF8_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF9.
 *
 * Values:
 * - 0b0 - LLWU_P9 input was not a wakeup source
 * - 0b1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF9 field. */
#define LLWU_RD_PF2_WUF9(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF9_MASK) >> LLWU_PF2_WUF9_SHIFT)
#define LLWU_BRD_PF2_WUF9(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF9_SHIFT, LLWU_PF2_WUF9_WIDTH))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_PF2_WUF9(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF9(value)))
#define LLWU_BWR_PF2_WUF9(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF9_SHIFT), LLWU_PF2_WUF9_SHIFT, LLWU_PF2_WUF9_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF10.
 *
 * Values:
 * - 0b0 - LLWU_P10 input was not a wakeup source
 * - 0b1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF10 field. */
#define LLWU_RD_PF2_WUF10(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF10_MASK) >> LLWU_PF2_WUF10_SHIFT)
#define LLWU_BRD_PF2_WUF10(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF10_SHIFT, LLWU_PF2_WUF10_WIDTH))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_PF2_WUF10(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF10(value)))
#define LLWU_BWR_PF2_WUF10(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF10_SHIFT), LLWU_PF2_WUF10_SHIFT, LLWU_PF2_WUF10_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF11.
 *
 * Values:
 * - 0b0 - LLWU_P11 input was not a wakeup source
 * - 0b1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF11 field. */
#define LLWU_RD_PF2_WUF11(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF11_MASK) >> LLWU_PF2_WUF11_SHIFT)
#define LLWU_BRD_PF2_WUF11(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF11_SHIFT, LLWU_PF2_WUF11_WIDTH))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_PF2_WUF11(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF11(value)))
#define LLWU_BWR_PF2_WUF11(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF11_SHIFT), LLWU_PF2_WUF11_SHIFT, LLWU_PF2_WUF11_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF12.
 *
 * Values:
 * - 0b0 - LLWU_P12 input was not a wakeup source
 * - 0b1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF12 field. */
#define LLWU_RD_PF2_WUF12(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF12_MASK) >> LLWU_PF2_WUF12_SHIFT)
#define LLWU_BRD_PF2_WUF12(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF12_SHIFT, LLWU_PF2_WUF12_WIDTH))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_PF2_WUF12(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF12(value)))
#define LLWU_BWR_PF2_WUF12(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF12_SHIFT), LLWU_PF2_WUF12_SHIFT, LLWU_PF2_WUF12_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF13.
 *
 * Values:
 * - 0b0 - LLWU_P13 input was not a wakeup source
 * - 0b1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF13 field. */
#define LLWU_RD_PF2_WUF13(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF13_MASK) >> LLWU_PF2_WUF13_SHIFT)
#define LLWU_BRD_PF2_WUF13(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF13_SHIFT, LLWU_PF2_WUF13_WIDTH))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_PF2_WUF13(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF13(value)))
#define LLWU_BWR_PF2_WUF13(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF13_SHIFT), LLWU_PF2_WUF13_SHIFT, LLWU_PF2_WUF13_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF14.
 *
 * Values:
 * - 0b0 - LLWU_P14 input was not a wakeup source
 * - 0b1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF14 field. */
#define LLWU_RD_PF2_WUF14(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF14_MASK) >> LLWU_PF2_WUF14_SHIFT)
#define LLWU_BRD_PF2_WUF14(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF14_SHIFT, LLWU_PF2_WUF14_WIDTH))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_PF2_WUF14(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF14(value)))
#define LLWU_BWR_PF2_WUF14(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF14_SHIFT), LLWU_PF2_WUF14_SHIFT, LLWU_PF2_WUF14_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF15.
 *
 * Values:
 * - 0b0 - LLWU_P15 input was not a wakeup source
 * - 0b1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF15 field. */
#define LLWU_RD_PF2_WUF15(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF15_MASK) >> LLWU_PF2_WUF15_SHIFT)
#define LLWU_BRD_PF2_WUF15(base) (BME_UBFX8(&LLWU_PF2_REG(base), LLWU_PF2_WUF15_SHIFT, LLWU_PF2_WUF15_WIDTH))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_PF2_WUF15(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF15_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK), LLWU_PF2_WUF15(value)))
#define LLWU_BWR_PF2_WUF15(base, value) (BME_BFI8(&LLWU_PF2_REG(base), ((uint8_t)(value) << LLWU_PF2_WUF15_SHIFT), LLWU_PF2_WUF15_SHIFT, LLWU_PF2_WUF15_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF3 - LLWU Pin Flag 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF3 - LLWU Pin Flag 3 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF3 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is accomplished
 * by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS. See
 * the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF3 register
 */
/*@{*/
#define LLWU_RD_PF3(base)        (LLWU_PF3_REG(base))
#define LLWU_WR_PF3(base, value) (LLWU_PF3_REG(base) = (value))
#define LLWU_RMW_PF3(base, mask, value) (LLWU_WR_PF3(base, (LLWU_RD_PF3(base) & ~(mask)) | (value)))
#define LLWU_SET_PF3(base, value) (BME_OR8(&LLWU_PF3_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF3(base, value) (BME_AND8(&LLWU_PF3_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF3(base, value) (BME_XOR8(&LLWU_PF3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF3 bitfields
 */

/*!
 * @name Register LLWU_PF3, field WUF16[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF16.
 *
 * Values:
 * - 0b0 - LLWU_P16 input was not a wakeup source
 * - 0b1 - LLWU_P16 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF16 field. */
#define LLWU_RD_PF3_WUF16(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF16_MASK) >> LLWU_PF3_WUF16_SHIFT)
#define LLWU_BRD_PF3_WUF16(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF16_SHIFT, LLWU_PF3_WUF16_WIDTH))

/*! @brief Set the WUF16 field to a new value. */
#define LLWU_WR_PF3_WUF16(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF16(value)))
#define LLWU_BWR_PF3_WUF16(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF16_SHIFT), LLWU_PF3_WUF16_SHIFT, LLWU_PF3_WUF16_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF17[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF17.
 *
 * Values:
 * - 0b0 - LLWU_P17 input was not a wakeup source
 * - 0b1 - LLWU_P17 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF17 field. */
#define LLWU_RD_PF3_WUF17(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF17_MASK) >> LLWU_PF3_WUF17_SHIFT)
#define LLWU_BRD_PF3_WUF17(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF17_SHIFT, LLWU_PF3_WUF17_WIDTH))

/*! @brief Set the WUF17 field to a new value. */
#define LLWU_WR_PF3_WUF17(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF17(value)))
#define LLWU_BWR_PF3_WUF17(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF17_SHIFT), LLWU_PF3_WUF17_SHIFT, LLWU_PF3_WUF17_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF18[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF18.
 *
 * Values:
 * - 0b0 - LLWU_P18 input was not a wakeup source
 * - 0b1 - LLWU_P18 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF18 field. */
#define LLWU_RD_PF3_WUF18(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF18_MASK) >> LLWU_PF3_WUF18_SHIFT)
#define LLWU_BRD_PF3_WUF18(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF18_SHIFT, LLWU_PF3_WUF18_WIDTH))

/*! @brief Set the WUF18 field to a new value. */
#define LLWU_WR_PF3_WUF18(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF18(value)))
#define LLWU_BWR_PF3_WUF18(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF18_SHIFT), LLWU_PF3_WUF18_SHIFT, LLWU_PF3_WUF18_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF19[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF19.
 *
 * Values:
 * - 0b0 - LLWU_P19 input was not a wakeup source
 * - 0b1 - LLWU_P19 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF19 field. */
#define LLWU_RD_PF3_WUF19(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF19_MASK) >> LLWU_PF3_WUF19_SHIFT)
#define LLWU_BRD_PF3_WUF19(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF19_SHIFT, LLWU_PF3_WUF19_WIDTH))

/*! @brief Set the WUF19 field to a new value. */
#define LLWU_WR_PF3_WUF19(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF19(value)))
#define LLWU_BWR_PF3_WUF19(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF19_SHIFT), LLWU_PF3_WUF19_SHIFT, LLWU_PF3_WUF19_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF20[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF20.
 *
 * Values:
 * - 0b0 - LLWU_P20 input was not a wakeup source
 * - 0b1 - LLWU_P20 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF20 field. */
#define LLWU_RD_PF3_WUF20(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF20_MASK) >> LLWU_PF3_WUF20_SHIFT)
#define LLWU_BRD_PF3_WUF20(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF20_SHIFT, LLWU_PF3_WUF20_WIDTH))

/*! @brief Set the WUF20 field to a new value. */
#define LLWU_WR_PF3_WUF20(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF20(value)))
#define LLWU_BWR_PF3_WUF20(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF20_SHIFT), LLWU_PF3_WUF20_SHIFT, LLWU_PF3_WUF20_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF21[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF21.
 *
 * Values:
 * - 0b0 - LLWU_P21 input was not a wakeup source
 * - 0b1 - LLWU_P21 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF21 field. */
#define LLWU_RD_PF3_WUF21(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF21_MASK) >> LLWU_PF3_WUF21_SHIFT)
#define LLWU_BRD_PF3_WUF21(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF21_SHIFT, LLWU_PF3_WUF21_WIDTH))

/*! @brief Set the WUF21 field to a new value. */
#define LLWU_WR_PF3_WUF21(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF21(value)))
#define LLWU_BWR_PF3_WUF21(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF21_SHIFT), LLWU_PF3_WUF21_SHIFT, LLWU_PF3_WUF21_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF22[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF22.
 *
 * Values:
 * - 0b0 - LLWU_P22 input was not a wakeup source
 * - 0b1 - LLWU_P22 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF22 field. */
#define LLWU_RD_PF3_WUF22(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF22_MASK) >> LLWU_PF3_WUF22_SHIFT)
#define LLWU_BRD_PF3_WUF22(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF22_SHIFT, LLWU_PF3_WUF22_WIDTH))

/*! @brief Set the WUF22 field to a new value. */
#define LLWU_WR_PF3_WUF22(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF22(value)))
#define LLWU_BWR_PF3_WUF22(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF22_SHIFT), LLWU_PF3_WUF22_SHIFT, LLWU_PF3_WUF22_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF23[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF23.
 *
 * Values:
 * - 0b0 - LLWU_P23 input was not a wakeup source
 * - 0b1 - LLWU_P23 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF23 field. */
#define LLWU_RD_PF3_WUF23(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF23_MASK) >> LLWU_PF3_WUF23_SHIFT)
#define LLWU_BRD_PF3_WUF23(base) (BME_UBFX8(&LLWU_PF3_REG(base), LLWU_PF3_WUF23_SHIFT, LLWU_PF3_WUF23_WIDTH))

/*! @brief Set the WUF23 field to a new value. */
#define LLWU_WR_PF3_WUF23(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF23_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK), LLWU_PF3_WUF23(value)))
#define LLWU_BWR_PF3_WUF23(base, value) (BME_BFI8(&LLWU_PF3_REG(base), ((uint8_t)(value) << LLWU_PF3_WUF23_SHIFT), LLWU_PF3_WUF23_SHIFT, LLWU_PF3_WUF23_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_PF4 - LLWU Pin Flag 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF4 - LLWU Pin Flag 4 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF4 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit or VLLS mode. For VLLS, this is the source causing the MCU reset
 * flow. The external wakeup flags are read-only and clearing a flag is
 * accomplished by a write of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if
 * set, will remain set if the associated WUPEx bit is cleared. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the
 * Reset Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF4 register
 */
/*@{*/
#define LLWU_RD_PF4(base)        (LLWU_PF4_REG(base))
#define LLWU_WR_PF4(base, value) (LLWU_PF4_REG(base) = (value))
#define LLWU_RMW_PF4(base, mask, value) (LLWU_WR_PF4(base, (LLWU_RD_PF4(base) & ~(mask)) | (value)))
#define LLWU_SET_PF4(base, value) (BME_OR8(&LLWU_PF4_REG(base), (uint8_t)(value)))
#define LLWU_CLR_PF4(base, value) (BME_AND8(&LLWU_PF4_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_PF4(base, value) (BME_XOR8(&LLWU_PF4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF4 bitfields
 */

/*!
 * @name Register LLWU_PF4, field WUF24[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF24.
 *
 * Values:
 * - 0b0 - LLWU_P24 input was not a wakeup source
 * - 0b1 - LLWU_P24 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF24 field. */
#define LLWU_RD_PF4_WUF24(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF24_MASK) >> LLWU_PF4_WUF24_SHIFT)
#define LLWU_BRD_PF4_WUF24(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF24_SHIFT, LLWU_PF4_WUF24_WIDTH))

/*! @brief Set the WUF24 field to a new value. */
#define LLWU_WR_PF4_WUF24(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF24(value)))
#define LLWU_BWR_PF4_WUF24(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF24_SHIFT), LLWU_PF4_WUF24_SHIFT, LLWU_PF4_WUF24_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF25[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF25.
 *
 * Values:
 * - 0b0 - LLWU_P25 input was not a wakeup source
 * - 0b1 - LLWU_P25 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF25 field. */
#define LLWU_RD_PF4_WUF25(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF25_MASK) >> LLWU_PF4_WUF25_SHIFT)
#define LLWU_BRD_PF4_WUF25(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF25_SHIFT, LLWU_PF4_WUF25_WIDTH))

/*! @brief Set the WUF25 field to a new value. */
#define LLWU_WR_PF4_WUF25(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF25(value)))
#define LLWU_BWR_PF4_WUF25(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF25_SHIFT), LLWU_PF4_WUF25_SHIFT, LLWU_PF4_WUF25_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF26[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF26.
 *
 * Values:
 * - 0b0 - LLWU_P26 input was not a wakeup source
 * - 0b1 - LLWU_P26 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF26 field. */
#define LLWU_RD_PF4_WUF26(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF26_MASK) >> LLWU_PF4_WUF26_SHIFT)
#define LLWU_BRD_PF4_WUF26(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF26_SHIFT, LLWU_PF4_WUF26_WIDTH))

/*! @brief Set the WUF26 field to a new value. */
#define LLWU_WR_PF4_WUF26(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF26(value)))
#define LLWU_BWR_PF4_WUF26(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF26_SHIFT), LLWU_PF4_WUF26_SHIFT, LLWU_PF4_WUF26_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF27[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF27.
 *
 * Values:
 * - 0b0 - LLWU_P27 input was not a wakeup source
 * - 0b1 - LLWU_P27 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF27 field. */
#define LLWU_RD_PF4_WUF27(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF27_MASK) >> LLWU_PF4_WUF27_SHIFT)
#define LLWU_BRD_PF4_WUF27(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF27_SHIFT, LLWU_PF4_WUF27_WIDTH))

/*! @brief Set the WUF27 field to a new value. */
#define LLWU_WR_PF4_WUF27(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF27(value)))
#define LLWU_BWR_PF4_WUF27(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF27_SHIFT), LLWU_PF4_WUF27_SHIFT, LLWU_PF4_WUF27_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF28[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF28.
 *
 * Values:
 * - 0b0 - LLWU_P28 input was not a wakeup source
 * - 0b1 - LLWU_P28 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF28 field. */
#define LLWU_RD_PF4_WUF28(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF28_MASK) >> LLWU_PF4_WUF28_SHIFT)
#define LLWU_BRD_PF4_WUF28(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF28_SHIFT, LLWU_PF4_WUF28_WIDTH))

/*! @brief Set the WUF28 field to a new value. */
#define LLWU_WR_PF4_WUF28(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF28(value)))
#define LLWU_BWR_PF4_WUF28(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF28_SHIFT), LLWU_PF4_WUF28_SHIFT, LLWU_PF4_WUF28_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF29[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF29.
 *
 * Values:
 * - 0b0 - LLWU_P29 input was not a wakeup source
 * - 0b1 - LLWU_P29 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF29 field. */
#define LLWU_RD_PF4_WUF29(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF29_MASK) >> LLWU_PF4_WUF29_SHIFT)
#define LLWU_BRD_PF4_WUF29(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF29_SHIFT, LLWU_PF4_WUF29_WIDTH))

/*! @brief Set the WUF29 field to a new value. */
#define LLWU_WR_PF4_WUF29(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF29(value)))
#define LLWU_BWR_PF4_WUF29(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF29_SHIFT), LLWU_PF4_WUF29_SHIFT, LLWU_PF4_WUF29_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF30[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF30.
 *
 * Values:
 * - 0b0 - LLWU_P30 input was not a wakeup source
 * - 0b1 - LLWU_P30 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF30 field. */
#define LLWU_RD_PF4_WUF30(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF30_MASK) >> LLWU_PF4_WUF30_SHIFT)
#define LLWU_BRD_PF4_WUF30(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF30_SHIFT, LLWU_PF4_WUF30_WIDTH))

/*! @brief Set the WUF30 field to a new value. */
#define LLWU_WR_PF4_WUF30(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF30(value)))
#define LLWU_BWR_PF4_WUF30(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF30_SHIFT), LLWU_PF4_WUF30_SHIFT, LLWU_PF4_WUF30_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF31[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF31.
 *
 * Values:
 * - 0b0 - LLWU_P31 input was not a wakeup source
 * - 0b1 - LLWU_P31 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF31 field. */
#define LLWU_RD_PF4_WUF31(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF31_MASK) >> LLWU_PF4_WUF31_SHIFT)
#define LLWU_BRD_PF4_WUF31(base) (BME_UBFX8(&LLWU_PF4_REG(base), LLWU_PF4_WUF31_SHIFT, LLWU_PF4_WUF31_WIDTH))

/*! @brief Set the WUF31 field to a new value. */
#define LLWU_WR_PF4_WUF31(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF31_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK), LLWU_PF4_WUF31(value)))
#define LLWU_BWR_PF4_WUF31(base, value) (BME_BFI8(&LLWU_PF4_REG(base), ((uint8_t)(value) << LLWU_PF4_WUF31_SHIFT), LLWU_PF4_WUF31_SHIFT, LLWU_PF4_WUF31_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_MF5 - LLWU Module Flag 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_MF5 - LLWU Module Flag 5 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_MF5 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit VLLS mode. For VLLS, this is the source causing the MCU
 * reset flow. For internal peripherals that are capable of running in a
 * low-leakage power mode, such as a real time clock module or CMP module, the flag from
 * the associated peripheral is accessible as the MWUFx bit. The flag will need to
 * be cleared in the peripheral instead of writing a 1 to the MWUFx bit. This
 * register is reset on Chip Reset not VLLS and by reset types that trigger Chip
 * Reset not VLLS. It is unaffected by reset types that do not trigger Chip Reset
 * not VLLS. See the IntroductionInformation found here describes the registers of
 * the Reset Control Module (RCM). The RCM implements many of the reset
 * functions for the chip. See the chip's reset chapter for more information. details for
 * more information.
 */
/*!
 * @name Constants and macros for entire LLWU_MF5 register
 */
/*@{*/
#define LLWU_RD_MF5(base)        (LLWU_MF5_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_MF5 bitfields
 */

/*!
 * @name Register LLWU_MF5, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 0 input was not a wakeup source
 * - 0b1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF0 field. */
#define LLWU_RD_MF5_MWUF0(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF0_MASK) >> LLWU_MF5_MWUF0_SHIFT)
#define LLWU_BRD_MF5_MWUF0(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF0_SHIFT, LLWU_MF5_MWUF0_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 1 input was not a wakeup source
 * - 0b1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF1 field. */
#define LLWU_RD_MF5_MWUF1(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF1_MASK) >> LLWU_MF5_MWUF1_SHIFT)
#define LLWU_BRD_MF5_MWUF1(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF1_SHIFT, LLWU_MF5_MWUF1_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 2 input was not a wakeup source
 * - 0b1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF2 field. */
#define LLWU_RD_MF5_MWUF2(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF2_MASK) >> LLWU_MF5_MWUF2_SHIFT)
#define LLWU_BRD_MF5_MWUF2(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF2_SHIFT, LLWU_MF5_MWUF2_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 3 input was not a wakeup source
 * - 0b1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF3 field. */
#define LLWU_RD_MF5_MWUF3(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF3_MASK) >> LLWU_MF5_MWUF3_SHIFT)
#define LLWU_BRD_MF5_MWUF3(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF3_SHIFT, LLWU_MF5_MWUF3_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 4 input was not a wakeup source
 * - 0b1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF4 field. */
#define LLWU_RD_MF5_MWUF4(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF4_MASK) >> LLWU_MF5_MWUF4_SHIFT)
#define LLWU_BRD_MF5_MWUF4(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF4_SHIFT, LLWU_MF5_MWUF4_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 5 input was not a wakeup source
 * - 0b1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF5 field. */
#define LLWU_RD_MF5_MWUF5(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF5_MASK) >> LLWU_MF5_MWUF5_SHIFT)
#define LLWU_BRD_MF5_MWUF5(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF5_SHIFT, LLWU_MF5_MWUF5_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 6 input was not a wakeup source
 * - 0b1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF6 field. */
#define LLWU_RD_MF5_MWUF6(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF6_MASK) >> LLWU_MF5_MWUF6_SHIFT)
#define LLWU_BRD_MF5_MWUF6(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF6_SHIFT, LLWU_MF5_MWUF6_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0b0 - Module 7 input was not a wakeup source
 * - 0b1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF7 field. */
#define LLWU_RD_MF5_MWUF7(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF7_MASK) >> LLWU_MF5_MWUF7_SHIFT)
#define LLWU_BRD_MF5_MWUF7(base) (BME_UBFX8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF7_SHIFT, LLWU_MF5_MWUF7_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (BME_OR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT1(base, value) (BME_AND8(&LLWU_FILT1_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT1(base, value) (BME_XOR8(&LLWU_FILT1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTSEL_SHIFT), LLWU_FILT1_FILTSEL_SHIFT, LLWU_FILT1_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTE_SHIFT), LLWU_FILT1_FILTE_SHIFT, LLWU_FILT1_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 1 was not a wakeup source
 * - 0b1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BME_UBFX8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BME_BFI8(&LLWU_FILT1_REG(base), ((uint8_t)(value) << LLWU_FILT1_FILTF_SHIFT), LLWU_FILT1_FILTF_SHIFT, LLWU_FILT1_FILTF_WIDTH))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (BME_OR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
#define LLWU_CLR_FILT2(base, value) (BME_AND8(&LLWU_FILT2_REG(base), (uint8_t)(~(value))))
#define LLWU_TOG_FILT2(base, value) (BME_XOR8(&LLWU_FILT2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 0b00000 - Select LLWU_P0 for filter
 * - 0b11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTSEL_SHIFT), LLWU_FILT2_FILTSEL_SHIFT, LLWU_FILT2_FILTSEL_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 0b00 - Filter disabled
 * - 0b01 - Filter posedge detect enabled
 * - 0b10 - Filter negedge detect enabled
 * - 0b11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTE_SHIFT), LLWU_FILT2_FILTE_SHIFT, LLWU_FILT2_FILTE_WIDTH))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0b0 - Pin Filter 2 was not a wakeup source
 * - 0b1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BME_UBFX8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BME_BFI8(&LLWU_FILT2_REG(base), ((uint8_t)(value) << LLWU_FILT2_FILTF_SHIFT), LLWU_FILT2_FILTF_SHIFT, LLWU_FILT2_FILTF_WIDTH))
/*@}*/

/*
 * MKV58F24 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (BME_OR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CSR(base, value) (BME_AND32(&LPTMR_CSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CSR(base, value) (BME_XOR32(&LPTMR_CSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0b0 - LPTMR is disabled and internal logic is reset.
 * - 0b1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TEN_SHIFT), LPTMR_CSR_TEN_SHIFT, LPTMR_CSR_TEN_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0b0 - Time Counter mode.
 * - 0b1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TMS_SHIFT), LPTMR_CSR_TMS_SHIFT, LPTMR_CSR_TMS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0b0 - CNR is reset whenever TCF is set.
 * - 0b1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TFC_SHIFT), LPTMR_CSR_TFC_SHIFT, LPTMR_CSR_TFC_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 0b1 - Pulse Counter input source is active-low, and the CNR will increment
 *     on the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPP_SHIFT), LPTMR_CSR_TPP_SHIFT, LPTMR_CSR_TPP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the chip-specific LPTMR information for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Pulse counter input 0 is selected.
 * - 0b01 - Pulse counter input 1 is selected.
 * - 0b10 - Pulse counter input 2 is selected.
 * - 0b11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TPS_SHIFT), LPTMR_CSR_TPS_SHIFT, LPTMR_CSR_TPS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0b0 - Timer interrupt disabled.
 * - 0b1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TIE_SHIFT), LPTMR_CSR_TIE_SHIFT, LPTMR_CSR_TIE_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0b0 - The value of CNR is not equal to CMR and increments.
 * - 0b1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BME_UBFX32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BME_BFI32(&LPTMR_CSR_REG(base), ((uint32_t)(value) << LPTMR_CSR_TCF_SHIFT), LPTMR_CSR_TCF_SHIFT, LPTMR_CSR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (BME_OR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_PSR(base, value) (BME_AND32(&LPTMR_PSR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_PSR(base, value) (BME_XOR32(&LPTMR_PSR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 0b00 - Prescaler/glitch filter clock 0 selected.
 * - 0b01 - Prescaler/glitch filter clock 1 selected.
 * - 0b10 - Prescaler/glitch filter clock 2 selected.
 * - 0b11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PCS_SHIFT), LPTMR_PSR_PCS_SHIFT, LPTMR_PSR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0b0 - Prescaler/glitch filter is enabled.
 * - 0b1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PBYP_SHIFT), LPTMR_PSR_PBYP_SHIFT, LPTMR_PSR_PBYP_WIDTH))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0b0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0b0001 - Prescaler divides the prescaler clock by 4; glitch filter
 *     recognizes change on input pin after 2 rising clock edges.
 * - 0b0010 - Prescaler divides the prescaler clock by 8; glitch filter
 *     recognizes change on input pin after 4 rising clock edges.
 * - 0b0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0b0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0b0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0b0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0b0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 0b1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 0b1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 0b1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 0b1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 0b1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 0b1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 0b1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 0b1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (BME_UBFX32(&LPTMR_PSR_REG(base), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (BME_BFI32(&LPTMR_PSR_REG(base), ((uint32_t)(value) << LPTMR_PSR_PRESCALE_SHIFT), LPTMR_PSR_PRESCALE_SHIFT, LPTMR_PSR_PRESCALE_WIDTH))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (BME_OR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CMR(base, value) (BME_AND32(&LPTMR_CMR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CMR(base, value) (BME_XOR32(&LPTMR_CMR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (LPTMR_RD_CMR_COMPARE(base))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (LPTMR_WR_CMR_COMPARE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * See LPTMR counter for details on how to read counter value.
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (BME_OR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
#define LPTMR_CLR_CNR(base, value) (BME_AND32(&LPTMR_CNR_REG(base), (uint32_t)(~(value))))
#define LPTMR_TOG_CNR(base, value) (BME_XOR32(&LPTMR_CNR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (LPTMR_RD_CNR_COUNTER(base))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (LPTMR_WR_CNR_COUNTER(base, value))
/*@}*/

/*
 * MKV58F24 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C5 - MCG Control 5 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - MCG_C8 - MCG Control 8 Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (BME_OR8(&MCG_C1_REG(base), (uint8_t)(value)))
#define MCG_CLR_C1(base, value)  (BME_AND8(&MCG_C1_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C1(base, value)  (BME_XOR8(&MCG_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0b0 - Internal reference clock is disabled in Stop mode.
 * - 0b1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFSTEN_SHIFT), MCG_C1_IREFSTEN_SHIFT, MCG_C1_IREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0b0 - MCGIRCLK inactive.
 * - 0b1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IRCLKEN_SHIFT), MCG_C1_IRCLKEN_SHIFT, MCG_C1_IRCLKEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0b0 - External reference clock is selected.
 * - 0b1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_IREFS_SHIFT), MCG_C1_IREFS_SHIFT, MCG_C1_IREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK . In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 0b000 - If RANGE = 0 , Divide Factor is 1; for all other RANGE values,
 *     Divide Factor is 32.
 * - 0b001 - If RANGE = 0 , Divide Factor is 2; for all other RANGE values,
 *     Divide Factor is 64.
 * - 0b010 - If RANGE = 0 , Divide Factor is 4; for all other RANGE values,
 *     Divide Factor is 128.
 * - 0b011 - If RANGE = 0 , Divide Factor is 8; for all other RANGE values,
 *     Divide Factor is 256.
 * - 0b100 - If RANGE = 0 , Divide Factor is 16; for all other RANGE values,
 *     Divide Factor is 512.
 * - 0b101 - If RANGE = 0 , Divide Factor is 32; for all other RANGE values,
 *     Divide Factor is 1024.
 * - 0b110 - If RANGE = 0 , Divide Factor is 64; for all other RANGE values,
 *     Divide Factor is 1280 .
 * - 0b111 - If RANGE = 0 , Divide Factor is 128; for all other RANGE values,
 *     Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_FRDIV_SHIFT), MCG_C1_FRDIV_SHIFT, MCG_C1_FRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of FLL or PLL is selected (depends on PLLS
 *     control bit).
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Encoding 3 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (BME_UBFX8(&MCG_C1_REG(base), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (BME_BFI8(&MCG_C1_REG(base), ((uint8_t)(value) << MCG_C1_CLKS_SHIFT), MCG_C1_CLKS_SHIFT, MCG_C1_CLKS_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (BME_OR8(&MCG_C2_REG(base), (uint8_t)(value)))
#define MCG_CLR_C2(base, value)  (BME_AND8(&MCG_C2_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C2(base, value)  (BME_XOR8(&MCG_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0b0 - Slow internal reference clock selected.
 * - 0b1 - Fast internal reference clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_IRCS_SHIFT), MCG_C2_IRCS_SHIFT, MCG_C2_IRCS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL or PLL is disabled in BLPI and BLPE modes. In FBE or
 * PBE modes, setting this bit to 1 will transition the MCG into BLPE mode; in
 * FBI mode, setting this bit to 1 will transition the MCG into BLPI mode. In any
 * other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0b0 - FLL or PLL is not disabled in bypass modes.
 * - 0b1 - FLL or PLL is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LP_SHIFT), MCG_C2_LP_SHIFT, MCG_C2_LP_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - External reference clock requested.
 * - 0b1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS field. */
#define MCG_RD_C2_EREFS(base) ((MCG_C2_REG(base) & MCG_C2_EREFS_MASK) >> MCG_C2_EREFS_SHIFT)
#define MCG_BRD_C2_EREFS(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))

/*! @brief Set the EREFS field to a new value. */
#define MCG_WR_C2_EREFS(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS_MASK, MCG_C2_EREFS(value)))
#define MCG_BWR_C2_EREFS(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_EREFS_SHIFT), MCG_C2_EREFS_SHIFT, MCG_C2_EREFS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0b0 - Configure crystal oscillator for low-power operation.
 * - 0b1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO field. */
#define MCG_RD_C2_HGO(base)  ((MCG_C2_REG(base) & MCG_C2_HGO_MASK) >> MCG_C2_HGO_SHIFT)
#define MCG_BRD_C2_HGO(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))

/*! @brief Set the HGO field to a new value. */
#define MCG_WR_C2_HGO(base, value) (MCG_RMW_C2(base, MCG_C2_HGO_MASK, MCG_C2_HGO(value)))
#define MCG_BWR_C2_HGO(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_HGO_SHIFT), MCG_C2_HGO_SHIFT, MCG_C2_HGO_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low frequency range selected for the crystal oscillator
 *     .
 * - 0b01 - Encoding 1 - High frequency range selected for the crystal
 *     oscillator .
 * - 0b1x - Encoding 2 - Very high frequency range selected for the crystal
 *     oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE field. */
#define MCG_RD_C2_RANGE(base) ((MCG_C2_REG(base) & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
#define MCG_BRD_C2_RANGE(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))

/*! @brief Set the RANGE field to a new value. */
#define MCG_WR_C2_RANGE(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE_MASK, MCG_C2_RANGE(value)))
#define MCG_BWR_C2_RANGE(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_RANGE_SHIFT), MCG_C2_RANGE_SHIFT, MCG_C2_RANGE_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field FCFTRIM[6] (RW)
 *
 * FCFTRIM controls the smallest adjustment of the fast internal reference clock
 * frequency. Setting FCFTRIM increases the period and clearing FCFTRIM
 * decreases the period by the smallest amount possible. If an FCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_FCFTRIM field. */
#define MCG_RD_C2_FCFTRIM(base) ((MCG_C2_REG(base) & MCG_C2_FCFTRIM_MASK) >> MCG_C2_FCFTRIM_SHIFT)
#define MCG_BRD_C2_FCFTRIM(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))

/*! @brief Set the FCFTRIM field to a new value. */
#define MCG_WR_C2_FCFTRIM(base, value) (MCG_RMW_C2(base, MCG_C2_FCFTRIM_MASK, MCG_C2_FCFTRIM(value)))
#define MCG_BWR_C2_FCFTRIM(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_FCFTRIM_SHIFT), MCG_C2_FCFTRIM_SHIFT, MCG_C2_FCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 0b1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BME_UBFX8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BME_BFI8(&MCG_C2_REG(base), ((uint8_t)(value) << MCG_C2_LOCRE0_SHIFT), MCG_C2_LOCRE0_SHIFT, MCG_C2_LOCRE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (BME_OR8(&MCG_C3_REG(base), (uint8_t)(value)))
#define MCG_CLR_C3(base, value)  (BME_AND8(&MCG_C3_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C3(base, value)  (BME_XOR8(&MCG_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (BME_OR8(&MCG_C4_REG(base), (uint8_t)(value)))
#define MCG_CLR_C4(base, value)  (BME_AND8(&MCG_C4_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C4(base, value)  (BME_XOR8(&MCG_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location. controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_SCFTRIM_SHIFT), MCG_C4_SCFTRIM_SHIFT, MCG_C4_SCFTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_FCTRIM_SHIFT), MCG_C4_FCTRIM_SHIFT, MCG_C4_FCTRIM_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 0b00 - Encoding 0 - Low range (reset default).
 * - 0b01 - Encoding 1 - Mid range.
 * - 0b10 - Encoding 2 - Mid-high range.
 * - 0b11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DRST_DRS_SHIFT), MCG_C4_DRST_DRS_SHIFT, MCG_C4_DRST_DRS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0b0 - DCO has a default range of 25%.
 * - 0b1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BME_UBFX8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BME_BFI8(&MCG_C4_REG(base), ((uint8_t)(value) << MCG_C4_DMX32_SHIFT), MCG_C4_DMX32_SHIFT, MCG_C4_DMX32_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define MCG_RD_C5(base)          (MCG_C5_REG(base))
#define MCG_WR_C5(base, value)   (MCG_C5_REG(base) = (value))
#define MCG_RMW_C5(base, mask, value) (MCG_WR_C5(base, (MCG_RD_C5(base) & ~(mask)) | (value)))
#define MCG_SET_C5(base, value)  (BME_OR8(&MCG_C5_REG(base), (uint8_t)(value)))
#define MCG_CLR_C5(base, value)  (BME_AND8(&MCG_C5_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C5(base, value)  (BME_XOR8(&MCG_C5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C5 bitfields
 */

/*!
 * @name Register MCG_C5, field PRDIV[2:0] (RW)
 *
 * Selects the amount to divide down the external reference clock for the PLL0.
 * The resulting frequency must be in the range of 8 MHz to 16 MHz. After the
 * PLL0 is enabled (by setting either PLLCLKEN0 or PLLS), the PRDIV0 value must not
 * be changed when LOCK0 is zero. PLL External Reference Divide Factor PRDIV
 * Divide Factor 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 8
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PRDIV field. */
#define MCG_RD_C5_PRDIV(base) ((MCG_C5_REG(base) & MCG_C5_PRDIV_MASK) >> MCG_C5_PRDIV_SHIFT)
#define MCG_BRD_C5_PRDIV(base) (BME_UBFX8(&MCG_C5_REG(base), MCG_C5_PRDIV_SHIFT, MCG_C5_PRDIV_WIDTH))

/*! @brief Set the PRDIV field to a new value. */
#define MCG_WR_C5_PRDIV(base, value) (MCG_RMW_C5(base, MCG_C5_PRDIV_MASK, MCG_C5_PRDIV(value)))
#define MCG_BWR_C5_PRDIV(base, value) (BME_BFI8(&MCG_C5_REG(base), ((uint8_t)(value) << MCG_C5_PRDIV_SHIFT), MCG_C5_PRDIV_SHIFT, MCG_C5_PRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLSTEN[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop (In Low Power Stop mode, the PLL
 * clock gets disabled even if PLLSTEN=1). All other power modes, PLLSTEN bit has no
 * affect and does not enable the PLL Clock to run if it is written to 1.
 *
 * Values:
 * - 0b0 - MCGPLLCLK and MCGPLLCLK2X are disabled in any of the Stop modes.
 * - 0b1 - MCGPLLCLK and MCGPLLCLK2X are enabled if system is in Normal Stop
 *     mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLSTEN field. */
#define MCG_RD_C5_PLLSTEN(base) ((MCG_C5_REG(base) & MCG_C5_PLLSTEN_MASK) >> MCG_C5_PLLSTEN_SHIFT)
#define MCG_BRD_C5_PLLSTEN(base) (BME_UBFX8(&MCG_C5_REG(base), MCG_C5_PLLSTEN_SHIFT, MCG_C5_PLLSTEN_WIDTH))

/*! @brief Set the PLLSTEN field to a new value. */
#define MCG_WR_C5_PLLSTEN(base, value) (MCG_RMW_C5(base, MCG_C5_PLLSTEN_MASK, MCG_C5_PLLSTEN(value)))
#define MCG_BWR_C5_PLLSTEN(base, value) (BME_BFI8(&MCG_C5_REG(base), ((uint8_t)(value) << MCG_C5_PLLSTEN_SHIFT), MCG_C5_PLLSTEN_SHIFT, MCG_C5_PLLSTEN_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLCLKEN[6] (RW)
 *
 * Enables PLL independent of PLLS and enables the PLL clock for use as
 * MCGPLLCLK. (PRDIV needs to be programmed to the correct divider to generate a PLL
 * reference clock in a valid reference range prior to setting the PLLCLKEN bit).
 * Setting PLLCLKEN will enable the external oscillator if not already enabled.
 * Whenever the PLL is being enabled by means of the PLLCLKEN bit, and the external
 * oscillator is being used as the reference clock, the OSCINIT 0 bit should be
 * checked to make sure it is set.
 *
 * Values:
 * - 0b0 - MCGPLLCLK is inactive.
 * - 0b1 - MCGPLLCLK is active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLCLKEN field. */
#define MCG_RD_C5_PLLCLKEN(base) ((MCG_C5_REG(base) & MCG_C5_PLLCLKEN_MASK) >> MCG_C5_PLLCLKEN_SHIFT)
#define MCG_BRD_C5_PLLCLKEN(base) (BME_UBFX8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN_SHIFT, MCG_C5_PLLCLKEN_WIDTH))

/*! @brief Set the PLLCLKEN field to a new value. */
#define MCG_WR_C5_PLLCLKEN(base, value) (MCG_RMW_C5(base, MCG_C5_PLLCLKEN_MASK, MCG_C5_PLLCLKEN(value)))
#define MCG_BWR_C5_PLLCLKEN(base, value) (BME_BFI8(&MCG_C5_REG(base), ((uint8_t)(value) << MCG_C5_PLLCLKEN_SHIFT), MCG_C5_PLLCLKEN_SHIFT, MCG_C5_PLLCLKEN_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (BME_OR8(&MCG_C6_REG(base), (uint8_t)(value)))
#define MCG_CLR_C6(base, value)  (BME_AND8(&MCG_C6_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C6(base, value)  (BME_XOR8(&MCG_C6_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field VDIV[4:0] (RW)
 *
 * Selects the amount to divide the VCO output of the PLL. The VDIV bits
 * establish the multiplication factor (M) applied to the reference clock frequency.
 * After the PLL is enabled (by setting either PLLCLKEN or PLLS), the VDIV value
 * must not be changed when LOCK is zero. PLL VCO Divide Factor VDIV Multiply Factor
 * VDIV Multiply Factor VDIV Multiply Factor VDIV Multiply Factor 00000 16 01000
 * 24 10000 32 11000 40 00001 17 01001 25 10001 33 11001 41 00010 18 01010 26
 * 10010 34 11010 42 00011 19 01011 27 10011 35 11011 43 00100 20 01100 28 10100 36
 * 11100 44 00101 21 01101 29 10101 37 11101 45 00110 22 01110 30 10110 38 11110
 * 46 00111 23 01111 31 10111 39 11111 47
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_VDIV field. */
#define MCG_RD_C6_VDIV(base) ((MCG_C6_REG(base) & MCG_C6_VDIV_MASK) >> MCG_C6_VDIV_SHIFT)
#define MCG_BRD_C6_VDIV(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_VDIV_SHIFT, MCG_C6_VDIV_WIDTH))

/*! @brief Set the VDIV field to a new value. */
#define MCG_WR_C6_VDIV(base, value) (MCG_RMW_C6(base, MCG_C6_VDIV_MASK, MCG_C6_VDIV(value)))
#define MCG_BWR_C6_VDIV(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_VDIV_SHIFT), MCG_C6_VDIV_SHIFT, MCG_C6_VDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field CME0[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the OSC0 external reference
 * mux select. The LOCRE0 bit will determine if a interrupt or a reset request is
 * generated following a loss of OSC0 indication. The CME0 bit must only be set
 * to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE) . Whenever the CME0 bit is set to a logic 1,
 * the value of the RANGE0 bits in the C2 register should not be changed. CME0
 * bit should be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur while in Stop mode. CME0 should also be set to a
 * logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0b0 - External clock monitor is disabled for OSC0.
 * - 0b1 - External clock monitor is enabled for OSC0.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME0 field. */
#define MCG_RD_C6_CME0(base) ((MCG_C6_REG(base) & MCG_C6_CME0_MASK) >> MCG_C6_CME0_SHIFT)
#define MCG_BRD_C6_CME0(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT, MCG_C6_CME0_WIDTH))

/*! @brief Set the CME0 field to a new value. */
#define MCG_WR_C6_CME0(base, value) (MCG_RMW_C6(base, MCG_C6_CME0_MASK, MCG_C6_CME0(value)))
#define MCG_BWR_C6_CME0(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_CME0_SHIFT), MCG_C6_CME0_SHIFT, MCG_C6_CME0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when
 * CLKS[1:0]=00. If the PLLS bit is cleared and PLLCLKEN 0 is not set, the PLL is
 * disabled in all modes. If the PLLS is set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0b0 - FLL is selected.
 * - 0b1 - PLL is selected (PRDIV 0 need to be programmed to the correct divider
 *     to generate a PLL reference clock in the range of 8-16 MHz prior to
 *     setting the PLLS bit).
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_PLLS field. */
#define MCG_RD_C6_PLLS(base) ((MCG_C6_REG(base) & MCG_C6_PLLS_MASK) >> MCG_C6_PLLS_SHIFT)
#define MCG_BRD_C6_PLLS(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT, MCG_C6_PLLS_WIDTH))

/*! @brief Set the PLLS field to a new value. */
#define MCG_WR_C6_PLLS(base, value) (MCG_RMW_C6(base, MCG_C6_PLLS_MASK, MCG_C6_PLLS(value)))
#define MCG_BWR_C6_PLLS(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_PLLS_SHIFT), MCG_C6_PLLS_SHIFT, MCG_C6_PLLS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_C6, field LOLIE0[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock
 * indication. This bit only has an effect when LOLS 0 is set.
 *
 * Values:
 * - 0b0 - No interrupt request is generated on loss of lock.
 * - 0b1 - Generate an interrupt request on loss of lock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_LOLIE0 field. */
#define MCG_RD_C6_LOLIE0(base) ((MCG_C6_REG(base) & MCG_C6_LOLIE0_MASK) >> MCG_C6_LOLIE0_SHIFT)
#define MCG_BRD_C6_LOLIE0(base) (BME_UBFX8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT, MCG_C6_LOLIE0_WIDTH))

/*! @brief Set the LOLIE0 field to a new value. */
#define MCG_WR_C6_LOLIE0(base, value) (MCG_RMW_C6(base, MCG_C6_LOLIE0_MASK, MCG_C6_LOLIE0(value)))
#define MCG_BWR_C6_LOLIE0(base, value) (BME_BFI8(&MCG_C6_REG(base), ((uint8_t)(value) << MCG_C6_LOLIE0_SHIFT), MCG_C6_LOLIE0_SHIFT, MCG_C6_LOLIE0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RW)
 *
 * Reset value: 0x10U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
#define MCG_WR_S(base, value)    (MCG_S_REG(base) = (value))
#define MCG_RMW_S(base, mask, value) (MCG_WR_S(base, (MCG_RD_S(base) & ~(mask)) | (value)))
#define MCG_SET_S(base, value)   (BME_OR8(&MCG_S_REG(base), (uint8_t)(value)))
#define MCG_CLR_S(base, value)   (BME_AND8(&MCG_S_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_S(base, value)   (BME_XOR8(&MCG_S_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0b0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 0b1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT, MCG_S_IRCST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT, MCG_S_OSCINIT0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 0b00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 0b01 - Encoding 1 - Internal reference clock is selected.
 * - 0b10 - Encoding 2 - External reference clock is selected.
 * - 0b11 - Encoding 3 - Output of the PLL is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_CLKST_SHIFT, MCG_S_CLKST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0b0 - Source of FLL reference clock is the external reference clock.
 * - 0b1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT, MCG_S_IREFST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not
 * update immediately after a write to the PLLS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0b0 - Source of PLLS clock is FLL clock.
 * - 0b1 - Source of PLLS clock is PLL output clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_PLLST field. */
#define MCG_RD_S_PLLST(base) ((MCG_S_REG(base) & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
#define MCG_BRD_S_PLLST(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_PLLST_SHIFT, MCG_S_PLLST_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is
 * disabled when not operating in either PBE or PEE mode unless PLLCLKEN=1 and the MCG
 * is not configured in BLPI or BLPE mode. While the PLL clock is locking to the
 * desired frequency, MCGPLLCLK and MCGPLLCLK2X will be gated off until the LOCK
 * bit gets asserted. If the lock status bit is set, changing the value of the
 * PRDIV[2:0] bits in the C5 register or the VDIV[4:0] bits in the C6 register
 * causes the lock status bit to clear and stay cleared until the PLL has reacquired
 * lock. Loss of PLL reference clock will also cause the LOCK bit to clear until
 * PLL has reacquired lock Entry into VLPS, or regular Stop with PLLSTEN=0 also
 * causes the lock status bit to clear and stay cleared until the Stop mode is
 * exited and the PLL has reacquired lock. Any time the PLL is enabled and the LOCK
 * bit is cleared, the MCGPLLCLK and MCGPLLCLK2X will be gated off until the
 * LOCK bit is asserted again.
 *
 * Values:
 * - 0b0 - PLL is currently unlocked.
 * - 0b1 - PLL is currently locked.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOCK0 field. */
#define MCG_RD_S_LOCK0(base) ((MCG_S_REG(base) & MCG_S_LOCK0_MASK) >> MCG_S_LOCK0_SHIFT)
#define MCG_BRD_S_LOCK0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_LOCK0_SHIFT, MCG_S_LOCK0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_S, field LOLS0[7] (W1C)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS is set
 * if after acquiring lock, the PLL output frequency has fallen outside the lock
 * exit frequency tolerance, D unl . LOLIE determines whether an interrupt
 * request is made when LOLS is set. LOLRE determines whether a reset request is made
 * when LOLS is set. This bit is cleared by reset or by writing a logic 1 to it
 * when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0b0 - PLL has not lost lock since LOLS 0 was last cleared.
 * - 0b1 - PLL has lost lock since LOLS 0 was last cleared.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOLS0 field. */
#define MCG_RD_S_LOLS0(base) ((MCG_S_REG(base) & MCG_S_LOLS0_MASK) >> MCG_S_LOLS0_SHIFT)
#define MCG_BRD_S_LOLS0(base) (BME_UBFX8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT, MCG_S_LOLS0_WIDTH))

/*! @brief Set the LOLS0 field to a new value. */
#define MCG_WR_S_LOLS0(base, value) (MCG_RMW_S(base, MCG_S_LOLS0_MASK, MCG_S_LOLS0(value)))
#define MCG_BWR_S_LOLS0(base, value) (BME_BFI8(&MCG_S_REG(base), ((uint8_t)(value) << MCG_S_LOLS0_SHIFT), MCG_S_LOLS0_SHIFT, MCG_S_LOLS0_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (BME_OR8(&MCG_SC_REG(base), (uint8_t)(value)))
#define MCG_CLR_SC(base, value)  (BME_AND8(&MCG_SC_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_SC(base, value)  (BME_XOR8(&MCG_SC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0b0 - Loss of OSC0 has not occurred.
 * - 0b1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, (MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_LOCS0_SHIFT), MCG_SC_LOCS0_SHIFT, MCG_SC_LOCS0_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 0b000 - Divide Factor is 1
 * - 0b001 - Divide Factor is 2.
 * - 0b010 - Divide Factor is 4.
 * - 0b011 - Divide Factor is 8.
 * - 0b100 - Divide Factor is 16
 * - 0b101 - Divide Factor is 32
 * - 0b110 - Divide Factor is 64
 * - 0b111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FCRDIV_SHIFT), MCG_SC_FCRDIV_SHIFT, MCG_SC_FCRDIV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0b0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 0b1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_FLTPRSRV_SHIFT), MCG_SC_FLTPRSRV_SHIFT, MCG_SC_FLTPRSRV_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (W1C)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0b0 - Automatic Trim Machine completed normally.
 * - 0b1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMF_SHIFT), MCG_SC_ATMF_SHIFT, MCG_SC_ATMF_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0b0 - 32 kHz Internal Reference Clock selected.
 * - 0b1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATMS_SHIFT), MCG_SC_ATMS_SHIFT, MCG_SC_ATMS_WIDTH))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0b0 - Auto Trim Machine disabled.
 * - 0b1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BME_UBFX8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BME_BFI8(&MCG_SC_REG(base), ((uint8_t)(value) << MCG_SC_ATME_SHIFT), MCG_SC_ATME_SHIFT, MCG_SC_ATME_WIDTH))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (BME_OR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVH(base, value) (BME_AND8(&MCG_ATCVH_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVH(base, value) (BME_XOR8(&MCG_ATCVH_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (BME_OR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
#define MCG_CLR_ATCVL(base, value) (BME_AND8(&MCG_ATCVL_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_ATCVL(base, value) (BME_XOR8(&MCG_ATCVL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define MCG_RD_C8(base)          (MCG_C8_REG(base))
#define MCG_WR_C8(base, value)   (MCG_C8_REG(base) = (value))
#define MCG_RMW_C8(base, mask, value) (MCG_WR_C8(base, (MCG_RD_C8(base) & ~(mask)) | (value)))
#define MCG_SET_C8(base, value)  (BME_OR8(&MCG_C8_REG(base), (uint8_t)(value)))
#define MCG_CLR_C8(base, value)  (BME_AND8(&MCG_C8_REG(base), (uint8_t)(~(value))))
#define MCG_TOG_C8(base, value)  (BME_XOR8(&MCG_C8_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Determines if an interrupt or a reset request is made following a PLL loss of
 * lock.
 *
 * Values:
 * - 0b0 - Interrupt request is generated on a PLL loss of lock indication. The
 *     PLL loss of lock interrupt enable bit must also be set to generate the
 *     interrupt request.
 * - 0b1 - Generate a reset request on a PLL loss of lock indication.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOLRE field. */
#define MCG_RD_C8_LOLRE(base) ((MCG_C8_REG(base) & MCG_C8_LOLRE_MASK) >> MCG_C8_LOLRE_SHIFT)
#define MCG_BRD_C8_LOLRE(base) (BME_UBFX8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT, MCG_C8_LOLRE_WIDTH))

/*! @brief Set the LOLRE field to a new value. */
#define MCG_WR_C8_LOLRE(base, value) (MCG_RMW_C8(base, MCG_C8_LOLRE_MASK, MCG_C8_LOLRE(value)))
#define MCG_BWR_C8_LOLRE(base, value) (BME_BFI8(&MCG_C8_REG(base), ((uint8_t)(value) << MCG_C8_LOLRE_SHIFT), MCG_C8_LOLRE_SHIFT, MCG_C8_LOLRE_WIDTH))
/*@}*/

/* MCG C5[PLLCLKEN0] backward compatibility */
#define MCG_RD_C5_PLLCLKEN0(base)         (MCG_RD_C5_PLLCLKEN(base))
#define MCG_BRD_C5_PLLCLKEN0(base)        (MCG_BRD_C5_PLLCLKEN(base))
#define MCG_WR_C5_PLLCLKEN0(base, value)  (MCG_WR_C5_PLLCLKEN((base), (value)))
#define MCG_BWR_C5_PLLCLKEN0(base, value) (MCG_BWR_C5_PLLCLKEN((base), (value)))
/* MCG C5[PLLSTEN0] backward compatibility */
#define MCG_RD_C5_PLLSTEN0(base)         (MCG_RD_C5_PLLSTEN(base))
#define MCG_BRD_C5_PLLSTEN0(base)        (MCG_BRD_C5_PLLSTEN(base))
#define MCG_WR_C5_PLLSTEN0(base, value)  (MCG_WR_C5_PLLSTEN((base), (value)))
#define MCG_BWR_C5_PLLSTEN0(base, value) (MCG_BWR_C5_PLLSTEN((base), (value)))
/* MCG C5[PRDIV0] backward compatibility */
#define MCG_RD_C5_PRDIV0(base)         (MCG_RD_C5_PRDIV(base))
#define MCG_BRD_C5_PRDIV0(base)        (MCG_BRD_C5_PRDIV(base))
#define MCG_WR_C5_PRDIV0(base, value)  (MCG_WR_C5_PRDIV((base), (value)))
#define MCG_BWR_C5_PRDIV0(base, value) (MCG_BWR_C5_PRDIV((base), (value)))
/* MCG C6[VDIV0] backward compatibility */
#define MCG_RD_C6_VDIV0(base)         (MCG_RD_C6_VDIV(base))
#define MCG_BRD_C6_VDIV0(base)        (MCG_BRD_C6_VDIV(base))
#define MCG_WR_C6_VDIV0(base, value)  (MCG_WR_C6_VDIV((base), (value)))
#define MCG_BWR_C6_VDIV0(base, value) (MCG_BWR_C6_VDIV((base), (value)))

/*
 * MKV58F24 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PCT - Processor core type
 * - MCM_CR - Control Register
 * - MCM_ISCR - Interrupt Status and Control Register
 * - MCM_CPO - Compute Only Operation Control Register
 * - MCM_LMEM - Local Memory General Descriptor Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PCT - Processor core type
 ******************************************************************************/

/*!
 * @brief MCM_PCT - Processor core type (RO)
 *
 * Reset value: 0xAC700000U
 *
 * The PCT is a 16-bit read-only register specifying the architecture of the
 * processor core within the platform in the device. The state of this register is
 * defined by a module input signal; it can only be read from the IPS programming
 * model. Any attempted write is ignored.
 */
/*!
 * @name Constants and macros for entire MCM_PCT register
 */
/*@{*/
#define MCM_RD_PCT(base)         (MCM_PCT_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PCT bitfields
 */

/*!
 * @name Register MCM_PCT, field PLREV[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_PCT_PLREV field. */
#define MCM_RD_PCT_PLREV(base) ((MCM_PCT_REG(base) & MCM_PCT_PLREV_MASK) >> MCM_PCT_PLREV_SHIFT)
#define MCM_BRD_PCT_PLREV(base) (MCM_RD_PCT_PLREV(base))
/*@}*/

/*!
 * @name Register MCM_PCT, field PCT[31:16] (RO)
 */
/*@{*/
/*! @brief Read current value of the MCM_PCT_PCT field. */
#define MCM_RD_PCT_PCT(base) ((MCM_PCT_REG(base) & MCM_PCT_PCT_MASK) >> MCM_PCT_PCT_SHIFT)
#define MCM_BRD_PCT_PCT(base) (MCM_RD_PCT_PCT(base))
/*@}*/

/*******************************************************************************
 * MCM_CR - Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * CR defines the interface priority for the TCM (Tightly Coupled Memory) RAM
 * arrays.
 */
/*!
 * @name Constants and macros for entire MCM_CR register
 */
/*@{*/
#define MCM_RD_CR(base)          (MCM_CR_REG(base))
#define MCM_WR_CR(base, value)   (MCM_CR_REG(base) = (value))
#define MCM_RMW_CR(base, mask, value) (MCM_WR_CR(base, (MCM_RD_CR(base) & ~(mask)) | (value)))
#define MCM_SET_CR(base, value)  (MCM_WR_CR(base, MCM_RD_CR(base) |  (value)))
#define MCM_CLR_CR(base, value)  (MCM_WR_CR(base, MCM_RD_CR(base) & ~(value)))
#define MCM_TOG_CR(base, value)  (MCM_WR_CR(base, MCM_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CR bitfields
 */

/*!
 * @name Register MCM_CR, field AHBSPRI[27] (RW)
 *
 * Setting the ARM AHBSCR (Cortex-M7 AHBS Prioritization Control Register)
 * bits[1:0] to x3 enables AHBSPRI to control AHBS priority boost modes. Once the ARM
 * AHBSCR[1:0] has been written to x3, AHBSPRI controls the AHBS Interface
 * priority.
 *
 * Values:
 * - 0b0 - SW accesses take priority over AHBS accesses
 * - 0b1 - AHBS accesses take priority over SW accesses
 */
/*@{*/
/*! @brief Read current value of the MCM_CR_AHBSPRI field. */
#define MCM_RD_CR_AHBSPRI(base) ((MCM_CR_REG(base) & MCM_CR_AHBSPRI_MASK) >> MCM_CR_AHBSPRI_SHIFT)
#define MCM_BRD_CR_AHBSPRI(base) (MCM_RD_CR_AHBSPRI(base))

/*! @brief Set the AHBSPRI field to a new value. */
#define MCM_WR_CR_AHBSPRI(base, value) (MCM_RMW_CR(base, MCM_CR_AHBSPRI_MASK, MCM_CR_AHBSPRI(value)))
#define MCM_BWR_CR_AHBSPRI(base, value) (MCM_WR_CR_AHBSPRI(base, value))
/*@}*/

/*******************************************************************************
 * MCM_ISCR - Interrupt Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCM_ISCR - Interrupt Status and Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCM_ISCR register defines the configuration and reports status for a
 * number of core-related interrupt exception conditions. The MCM_ISCR register
 * includes the enable and status bits associated with the core's floating-point
 * exceptions. The individual event indicators are first qualified with their
 * exception enables and then logically summed to form an interrupt request sent to the
 * core's NVIC.Bits 15-8 are read-only indicator flags based on the processor's
 * FPSCR register. Attempted writes to these bits are ignored. Once set, the flags
 * remain asserted until software clears the corresponding FPSCR bit.
 */
/*!
 * @name Constants and macros for entire MCM_ISCR register
 */
/*@{*/
#define MCM_RD_ISCR(base)        (MCM_ISCR_REG(base))
#define MCM_WR_ISCR(base, value) (MCM_ISCR_REG(base) = (value))
#define MCM_RMW_ISCR(base, mask, value) (MCM_WR_ISCR(base, (MCM_RD_ISCR(base) & ~(mask)) | (value)))
#define MCM_SET_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) |  (value)))
#define MCM_CLR_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) & ~(value)))
#define MCM_TOG_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_ISCR bitfields
 */

/*!
 * @name Register MCM_ISCR, field FIOC[8] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOC field. */
#define MCM_RD_ISCR_FIOC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOC_MASK) >> MCM_ISCR_FIOC_SHIFT)
#define MCM_BRD_ISCR_FIOC(base) (MCM_RD_ISCR_FIOC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZC[9] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZC field. */
#define MCM_RD_ISCR_FDZC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZC_MASK) >> MCM_ISCR_FDZC_SHIFT)
#define MCM_BRD_ISCR_FDZC(base) (MCM_RD_ISCR_FDZC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFC[10] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFC field. */
#define MCM_RD_ISCR_FOFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFC_MASK) >> MCM_ISCR_FOFC_SHIFT)
#define MCM_BRD_ISCR_FOFC(base) (MCM_RD_ISCR_FOFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFC[11] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFC field. */
#define MCM_RD_ISCR_FUFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFC_MASK) >> MCM_ISCR_FUFC_SHIFT)
#define MCM_BRD_ISCR_FUFC(base) (MCM_RD_ISCR_FUFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXC[12] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occured
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXC field. */
#define MCM_RD_ISCR_FIXC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXC_MASK) >> MCM_ISCR_FIXC_SHIFT)
#define MCM_BRD_ISCR_FIXC(base) (MCM_RD_ISCR_FIXC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDC[15] (RO)
 *
 * Values:
 * - 0b0 - No interrupt
 * - 0b1 - Interrupt has occured
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDC field. */
#define MCM_RD_ISCR_FIDC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDC_MASK) >> MCM_ISCR_FIDC_SHIFT)
#define MCM_BRD_ISCR_FIDC(base) (MCM_RD_ISCR_FIDC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOCE[24] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOCE field. */
#define MCM_RD_ISCR_FIOCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOCE_MASK) >> MCM_ISCR_FIOCE_SHIFT)
#define MCM_BRD_ISCR_FIOCE(base) (MCM_RD_ISCR_FIOCE(base))

/*! @brief Set the FIOCE field to a new value. */
#define MCM_WR_ISCR_FIOCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIOCE_MASK, MCM_ISCR_FIOCE(value)))
#define MCM_BWR_ISCR_FIOCE(base, value) (MCM_WR_ISCR_FIOCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZCE[25] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZCE field. */
#define MCM_RD_ISCR_FDZCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZCE_MASK) >> MCM_ISCR_FDZCE_SHIFT)
#define MCM_BRD_ISCR_FDZCE(base) (MCM_RD_ISCR_FDZCE(base))

/*! @brief Set the FDZCE field to a new value. */
#define MCM_WR_ISCR_FDZCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FDZCE_MASK, MCM_ISCR_FDZCE(value)))
#define MCM_BWR_ISCR_FDZCE(base, value) (MCM_WR_ISCR_FDZCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFCE[26] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFCE field. */
#define MCM_RD_ISCR_FOFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFCE_MASK) >> MCM_ISCR_FOFCE_SHIFT)
#define MCM_BRD_ISCR_FOFCE(base) (MCM_RD_ISCR_FOFCE(base))

/*! @brief Set the FOFCE field to a new value. */
#define MCM_WR_ISCR_FOFCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FOFCE_MASK, MCM_ISCR_FOFCE(value)))
#define MCM_BWR_ISCR_FOFCE(base, value) (MCM_WR_ISCR_FOFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFCE[27] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFCE field. */
#define MCM_RD_ISCR_FUFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFCE_MASK) >> MCM_ISCR_FUFCE_SHIFT)
#define MCM_BRD_ISCR_FUFCE(base) (MCM_RD_ISCR_FUFCE(base))

/*! @brief Set the FUFCE field to a new value. */
#define MCM_WR_ISCR_FUFCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FUFCE_MASK, MCM_ISCR_FUFCE(value)))
#define MCM_BWR_ISCR_FUFCE(base, value) (MCM_WR_ISCR_FUFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXCE[28] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXCE field. */
#define MCM_RD_ISCR_FIXCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXCE_MASK) >> MCM_ISCR_FIXCE_SHIFT)
#define MCM_BRD_ISCR_FIXCE(base) (MCM_RD_ISCR_FIXCE(base))

/*! @brief Set the FIXCE field to a new value. */
#define MCM_WR_ISCR_FIXCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIXCE_MASK, MCM_ISCR_FIXCE(value)))
#define MCM_BWR_ISCR_FIXCE(base, value) (MCM_WR_ISCR_FIXCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDCE[31] (RW)
 *
 * Values:
 * - 0b0 - Disable interrupt
 * - 0b1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDCE field. */
#define MCM_RD_ISCR_FIDCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDCE_MASK) >> MCM_ISCR_FIDCE_SHIFT)
#define MCM_BRD_ISCR_FIDCE(base) (MCM_RD_ISCR_FIDCE(base))

/*! @brief Set the FIDCE field to a new value. */
#define MCM_WR_ISCR_FIDCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIDCE_MASK, MCM_ISCR_FIDCE(value)))
#define MCM_BWR_ISCR_FIDCE(base, value) (MCM_WR_ISCR_FIDCE(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Only Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Only Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Only Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This field must be cleared to exit Compute Only Operation mode.
 *
 * Values:
 * - 0b0 - Request is cleared.
 * - 0b1 - Request Compute Only Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0b0 - Compute only operation entry has not completed or compute only
 *     operation exit has completed.
 * - 0b1 - Compute only operation entry has completed or compute only operation
 *     exit has not completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*******************************************************************************
 * MCM_LMEM - Local Memory General Descriptor Register
 ******************************************************************************/

/*!
 * @brief MCM_LMEM - Local Memory General Descriptor Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire MCM_LMEM register
 */
/*@{*/
#define MCM_RD_LMEM(base, index) (MCM_LMEM_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MCM_LMEM bitfields
 */

/*!
 * @name Register MCM_LMEM, field LMEM_Type[15:13] (RO)
 *
 * Defines the type of local memory
 *
 * Values:
 * - 0b000 - ITCM (Instruction Tightly Coupled Memory)
 * - 0b001 - DTCM (Data Tightly Coupled Memory)
 * - 0b010 - Instruction Cache
 * - 0b011 - Data Cache
 */
/*@{*/
/*! @brief Read current value of the MCM_LMEM_LMEM_Type field. */
#define MCM_RD_LMEM_LMEM_Type(base, index) ((MCM_LMEM_REG(base, index) & MCM_LMEM_LMEM_Type_MASK) >> MCM_LMEM_LMEM_Type_SHIFT)
#define MCM_BRD_LMEM_LMEM_Type(base, index) (MCM_RD_LMEM_LMEM_Type(base, index))
/*@}*/

/*!
 * @name Register MCM_LMEM, field LMEM_Width[19:17] (RO)
 *
 * Defines the local memory bit width
 *
 * Values:
 * - 0b010 - 32-bits
 * - 0b011 - 64-bits
 */
/*@{*/
/*! @brief Read current value of the MCM_LMEM_LMEM_Width field. */
#define MCM_RD_LMEM_LMEM_Width(base, index) ((MCM_LMEM_REG(base, index) & MCM_LMEM_LMEM_Width_MASK) >> MCM_LMEM_LMEM_Width_SHIFT)
#define MCM_BRD_LMEM_LMEM_Width(base, index) (MCM_RD_LMEM_LMEM_Width(base, index))
/*@}*/

/*!
 * @name Register MCM_LMEM, field LMEM_Ways[23:20] (RO)
 *
 * Defines the ways of set associative
 *
 * Values:
 * - 0b0000 - Reserved (not applicable)
 * - 0b0010 - 2-way set associative
 * - 0b0100 - 4-way set associative
 */
/*@{*/
/*! @brief Read current value of the MCM_LMEM_LMEM_Ways field. */
#define MCM_RD_LMEM_LMEM_Ways(base, index) ((MCM_LMEM_REG(base, index) & MCM_LMEM_LMEM_Ways_MASK) >> MCM_LMEM_LMEM_Ways_SHIFT)
#define MCM_BRD_LMEM_LMEM_Ways(base, index) (MCM_RD_LMEM_LMEM_Ways(base, index))
/*@}*/

/*!
 * @name Register MCM_LMEM, field LMEM_Size[27:24] (RO)
 *
 * Defines the local memory size
 *
 * Values:
 * - 0b0100 - 8KB
 * - 0b0101 - 16KB
 * - 0b0111 - 64KB
 */
/*@{*/
/*! @brief Read current value of the MCM_LMEM_LMEM_Size field. */
#define MCM_RD_LMEM_LMEM_Size(base, index) ((MCM_LMEM_REG(base, index) & MCM_LMEM_LMEM_Size_MASK) >> MCM_LMEM_LMEM_Size_SHIFT)
#define MCM_BRD_LMEM_LMEM_Size(base, index) (MCM_RD_LMEM_LMEM_Size(base, index))
/*@}*/

/*!
 * @name Register MCM_LMEM, field LMEM_Valid[31] (RO)
 *
 * Defines whether the local memory is present
 *
 * Values:
 * - 0b0 - Local memory not present
 * - 0b1 - Local memory present
 */
/*@{*/
/*! @brief Read current value of the MCM_LMEM_LMEM_Valid field. */
#define MCM_RD_LMEM_LMEM_Valid(base, index) ((MCM_LMEM_REG(base, index) & MCM_LMEM_LMEM_Valid_MASK) >> MCM_LMEM_LMEM_Valid_SHIFT)
#define MCM_BRD_LMEM_LMEM_Valid(base, index) (MCM_RD_LMEM_LMEM_Valid(base, index))
/*@}*/

/*
 * MKV58F24 MPU
 *
 * Memory protection unit
 *
 * Registers defined in this header file:
 * - MPU_CESR - Control/Error Status Register
 * - MPU_EAR - Error Address Register, slave port n
 * - MPU_EDR - Error Detail Register, slave port n
 * - MPU_WORD - Region Descriptor n, Word 0
 * - MPU_RGDAAC - Region Descriptor Alternate Access Control n
 */

#define MPU_INSTANCE_COUNT (1U) /*!< Number of instances of the MPU module. */
#define MPU_IDX (0U) /*!< Instance number for MPU. */

/*******************************************************************************
 * MPU_CESR - Control/Error Status Register
 ******************************************************************************/

/*!
 * @brief MPU_CESR - Control/Error Status Register (RW)
 *
 * Reset value: 0x00815101U
 */
/*!
 * @name Constants and macros for entire MPU_CESR register
 */
/*@{*/
#define MPU_RD_CESR(base)        (MPU_CESR_REG(base))
#define MPU_WR_CESR(base, value) (MPU_CESR_REG(base) = (value))
#define MPU_RMW_CESR(base, mask, value) (MPU_WR_CESR(base, (MPU_RD_CESR(base) & ~(mask)) | (value)))
#define MPU_SET_CESR(base, value) (BME_OR32(&MPU_CESR_REG(base), (uint32_t)(value)))
#define MPU_CLR_CESR(base, value) (BME_AND32(&MPU_CESR_REG(base), (uint32_t)(~(value))))
#define MPU_TOG_CESR(base, value) (BME_XOR32(&MPU_CESR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_CESR bitfields
 */

/*!
 * @name Register MPU_CESR, field VLD[0] (RW)
 *
 * Global enable/disable for the MPU.
 *
 * Values:
 * - 0b0 - MPU is disabled. All accesses from all bus masters are allowed.
 * - 0b1 - MPU is enabled
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_VLD field. */
#define MPU_RD_CESR_VLD(base) ((MPU_CESR_REG(base) & MPU_CESR_VLD_MASK) >> MPU_CESR_VLD_SHIFT)
#define MPU_BRD_CESR_VLD(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_VLD_SHIFT, MPU_CESR_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_CESR_VLD(base, value) (MPU_RMW_CESR(base, (MPU_CESR_VLD_MASK | MPU_CESR_SPERR_MASK), MPU_CESR_VLD(value)))
#define MPU_BWR_CESR_VLD(base, value) (BME_BFI32(&MPU_CESR_REG(base), ((uint32_t)(value) << MPU_CESR_VLD_SHIFT), MPU_CESR_VLD_SHIFT, MPU_CESR_VLD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field NRGD[11:8] (RO)
 *
 * Indicates the number of region descriptors implemented in the MPU.
 *
 * Values:
 * - 0b0000 - 8 region descriptors
 * - 0b0001 - 12 region descriptors
 * - 0b0010 - 16 region descriptors
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NRGD field. */
#define MPU_RD_CESR_NRGD(base) ((MPU_CESR_REG(base) & MPU_CESR_NRGD_MASK) >> MPU_CESR_NRGD_SHIFT)
#define MPU_BRD_CESR_NRGD(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_NRGD_SHIFT, MPU_CESR_NRGD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field NSP[15:12] (RO)
 *
 * Specifies the number of slave ports connected to the MPU.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_NSP field. */
#define MPU_RD_CESR_NSP(base) ((MPU_CESR_REG(base) & MPU_CESR_NSP_MASK) >> MPU_CESR_NSP_SHIFT)
#define MPU_BRD_CESR_NSP(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_NSP_SHIFT, MPU_CESR_NSP_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field HRL[19:16] (RO)
 *
 * Specifies the MPU's hardware and definition revision level. It can be read by
 * software to determine the functional definition of the module.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_HRL field. */
#define MPU_RD_CESR_HRL(base) ((MPU_CESR_REG(base) & MPU_CESR_HRL_MASK) >> MPU_CESR_HRL_SHIFT)
#define MPU_BRD_CESR_HRL(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_HRL_SHIFT, MPU_CESR_HRL_WIDTH))
/*@}*/

/*!
 * @name Register MPU_CESR, field SPERR[31:27] (W1C)
 *
 * Indicates a captured error in EARn and EDRn. This bit is set when the
 * hardware detects an error and records the faulting address and attributes. It is
 * cleared by writing one to it. If another error is captured at the exact same cycle
 * as the write, the flag remains set. A find-first-one instruction or
 * equivalent can detect the presence of a captured error. The following shows the
 * correspondence between the bit number and slave port number: Bit 31 corresponds to
 * slave port 0. Bit 30 corresponds to slave port 1. Bit 29 corresponds to slave
 * port 2. Bit 28 corresponds to slave port 3. Bit 27 corresponds to slave port 4.
 *
 * Values:
 * - 0b00000 - No error has occurred for slave port n.
 * - 0b00001 - An error has occurred for slave port n.
 */
/*@{*/
/*! @brief Read current value of the MPU_CESR_SPERR field. */
#define MPU_RD_CESR_SPERR(base) ((MPU_CESR_REG(base) & MPU_CESR_SPERR_MASK) >> MPU_CESR_SPERR_SHIFT)
#define MPU_BRD_CESR_SPERR(base) (BME_UBFX32(&MPU_CESR_REG(base), MPU_CESR_SPERR_SHIFT, MPU_CESR_SPERR_WIDTH))

/*! @brief Set the SPERR field to a new value. */
#define MPU_WR_CESR_SPERR(base, value) (MPU_RMW_CESR(base, MPU_CESR_SPERR_MASK, MPU_CESR_SPERR(value)))
#define MPU_BWR_CESR_SPERR(base, value) (BME_BFI32(&MPU_CESR_REG(base), ((uint32_t)(value) << MPU_CESR_SPERR_SHIFT), MPU_CESR_SPERR_SHIFT, MPU_CESR_SPERR_WIDTH))
/*@}*/

/*******************************************************************************
 * MPU_EAR - Error Address Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EAR - Error Address Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, the 32-bit reference
 * address is captured in this read-only register and the corresponding bit in
 * CESR[SPERR] set. Additional information about the faulting access is captured in
 * the corresponding EDRn at the same time. This register and the corresponding
 * EDRn contain the most recent access error; there are no hardware interlocks with
 * CESR[SPERR], as the error registers are always loaded upon the occurrence of
 * each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EAR register
 */
/*@{*/
#define MPU_RD_EAR(base, index)  (MPU_EAR_REG(base, index))
/*@}*/

/*******************************************************************************
 * MPU_EDR - Error Detail Register, slave port n
 ******************************************************************************/

/*!
 * @brief MPU_EDR - Error Detail Register, slave port n (RO)
 *
 * Reset value: 0x00000000U
 *
 * When the MPU detects an access error on slave port n, 32 bits of error detail
 * are captured in this read-only register and the corresponding bit in
 * CESR[SPERR] is set. Information on the faulting address is captured in the
 * corresponding EARn register at the same time. This register and the corresponding EARn
 * register contain the most recent access error; there are no hardware interlocks
 * with CESR[SPERR] as the error registers are always loaded upon the occurrence
 * of each protection violation.
 */
/*!
 * @name Constants and macros for entire MPU_EDR register
 */
/*@{*/
#define MPU_RD_EDR(base, index)  (MPU_EDR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MPU_EDR bitfields
 */

/*!
 * @name Register MPU_EDR, field ERW[0] (RO)
 *
 * Indicates the access type of the faulting reference.
 *
 * Values:
 * - 0b0 - Read
 * - 0b1 - Write
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_ERW field. */
#define MPU_RD_EDR_ERW(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_ERW_MASK) >> MPU_EDR_ERW_SHIFT)
#define MPU_BRD_EDR_ERW(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_ERW_SHIFT, MPU_EDR_ERW_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EATTR[3:1] (RO)
 *
 * Indicates attribute information about the faulting reference. All other
 * encodings are reserved.
 *
 * Values:
 * - 0b000 - User mode, instruction access
 * - 0b001 - User mode, data access
 * - 0b010 - Supervisor mode, instruction access
 * - 0b011 - Supervisor mode, data access
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EATTR field. */
#define MPU_RD_EDR_EATTR(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EATTR_MASK) >> MPU_EDR_EATTR_SHIFT)
#define MPU_BRD_EDR_EATTR(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EATTR_SHIFT, MPU_EDR_EATTR_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EMN[7:4] (RO)
 *
 * Indicates the bus master that generated the access error.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EMN field. */
#define MPU_RD_EDR_EMN(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EMN_MASK) >> MPU_EDR_EMN_SHIFT)
#define MPU_BRD_EDR_EMN(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EMN_SHIFT, MPU_EDR_EMN_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EPID[15:8] (RO)
 *
 * Records the process identifier of the faulting reference. The process
 * identifier is typically driven only by processor cores; for other bus masters, this
 * field is cleared.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EPID field. */
#define MPU_RD_EDR_EPID(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EPID_MASK) >> MPU_EDR_EPID_SHIFT)
#define MPU_BRD_EDR_EPID(base, index) (BME_UBFX32(&MPU_EDR_REG(base, index), MPU_EDR_EPID_SHIFT, MPU_EDR_EPID_WIDTH))
/*@}*/

/*!
 * @name Register MPU_EDR, field EACD[31:16] (RO)
 *
 * Indicates the region descriptor with the access error. If EDRn contains a
 * captured error and EACD is cleared, an access did not hit in any region
 * descriptor. If only a single EACD bit is set, the protection error was caused by a
 * single non-overlapping region descriptor. If two or more EACD bits are set, the
 * protection error was caused by an overlapping set of region descriptors.
 */
/*@{*/
/*! @brief Read current value of the MPU_EDR_EACD field. */
#define MPU_RD_EDR_EACD(base, index) ((MPU_EDR_REG(base, index) & MPU_EDR_EACD_MASK) >> MPU_EDR_EACD_SHIFT)
#define MPU_BRD_EDR_EACD(base, index) (MPU_RD_EDR_EACD(base, index))
/*@}*/

/*******************************************************************************
 * MPU_WORD - Region Descriptor n, Word 0
 ******************************************************************************/

/*!
 * @brief MPU_WORD - Region Descriptor n, Word 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The first word of the region descriptor defines the 0-modulo-32 byte start
 * address of the memory region. Writes to this register clear the region
 * descriptor's valid bit (RGDn_WORD3[VLD]).
 */
/*!
 * @name Constants and macros for entire MPU_WORD register
 */
/*@{*/
#define MPU_RD_WORD(base, index, index2) (MPU_WORD_REG(base, index, index2))
#define MPU_WR_WORD(base, index, index2, value) (MPU_WORD_REG(base, index, index2) = (value))
#define MPU_RMW_WORD(base, index, index2, mask, value) (MPU_WR_WORD(base, index, index2, (MPU_RD_WORD(base, index, index2) & ~(mask)) | (value)))
#define MPU_SET_WORD(base, index, index2, value) (BME_OR32(&MPU_WORD_REG(base, index, index2), (uint32_t)(value)))
#define MPU_CLR_WORD(base, index, index2, value) (BME_AND32(&MPU_WORD_REG(base, index, index2), (uint32_t)(~(value))))
#define MPU_TOG_WORD(base, index, index2, value) (BME_XOR32(&MPU_WORD_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_WORD bitfields
 */

/*!
 * @name Register MPU_WORD, field VLD[0] (RW)
 *
 * Signals the region descriptor is valid. Any write to RGDn_WORD0-2 clears this
 * bit.
 *
 * Values:
 * - 0b0 - Region descriptor is invalid
 * - 0b1 - Region descriptor is valid
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_VLD field. */
#define MPU_RD_WORD_VLD(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_VLD_MASK) >> MPU_WORD_VLD_SHIFT)
#define MPU_BRD_WORD_VLD(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_VLD_SHIFT, MPU_WORD_VLD_WIDTH))

/*! @brief Set the VLD field to a new value. */
#define MPU_WR_WORD_VLD(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_VLD_MASK, MPU_WORD_VLD(value)))
#define MPU_BWR_WORD_VLD(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_VLD_SHIFT), MPU_WORD_VLD_SHIFT, MPU_WORD_VLD_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0UM field. */
#define MPU_RD_WORD_M0UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0UM_MASK) >> MPU_WORD_M0UM_SHIFT)
#define MPU_BRD_WORD_M0UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0UM_SHIFT, MPU_WORD_M0UM_WIDTH))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_WORD_M0UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0UM_MASK, MPU_WORD_M0UM(value)))
#define MPU_BWR_WORD_M0UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0UM_SHIFT), MPU_WORD_M0UM_SHIFT, MPU_WORD_M0UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0SM field. */
#define MPU_RD_WORD_M0SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0SM_MASK) >> MPU_WORD_M0SM_SHIFT)
#define MPU_BRD_WORD_M0SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0SM_SHIFT, MPU_WORD_M0SM_WIDTH))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_WORD_M0SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0SM_MASK, MPU_WORD_M0SM(value)))
#define MPU_BWR_WORD_M0SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0SM_SHIFT), MPU_WORD_M0SM_SHIFT, MPU_WORD_M0SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M0PE[5] (RW)
 *
 * See M0PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M0PE field. */
#define MPU_RD_WORD_M0PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M0PE_MASK) >> MPU_WORD_M0PE_SHIFT)
#define MPU_BRD_WORD_M0PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M0PE_SHIFT, MPU_WORD_M0PE_WIDTH))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_WORD_M0PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M0PE_MASK, MPU_WORD_M0PE(value)))
#define MPU_BWR_WORD_M0PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M0PE_SHIFT), MPU_WORD_M0PE_SHIFT, MPU_WORD_M0PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field ENDADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 31-modulo-32 byte end address of the
 * memory region. The MPU does not verify that ENDADDR >= SRTADDR.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_ENDADDR field. */
#define MPU_RD_WORD_ENDADDR(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_ENDADDR_MASK) >> MPU_WORD_ENDADDR_SHIFT)
#define MPU_BRD_WORD_ENDADDR(base, index, index2) (MPU_RD_WORD_ENDADDR(base, index, index2))

/*! @brief Set the ENDADDR field to a new value. */
#define MPU_WR_WORD_ENDADDR(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_ENDADDR_MASK, MPU_WORD_ENDADDR(value)))
#define MPU_BWR_WORD_ENDADDR(base, index, index2, value) (MPU_WR_WORD_ENDADDR(base, index, index2, value))
/*@}*/

/*!
 * @name Register MPU_WORD, field SRTADDR[31:5] (RW)
 *
 * Defines the most significant bits of the 0-modulo-32 byte start address of
 * the memory region.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_SRTADDR field. */
#define MPU_RD_WORD_SRTADDR(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_SRTADDR_MASK) >> MPU_WORD_SRTADDR_SHIFT)
#define MPU_BRD_WORD_SRTADDR(base, index, index2) (MPU_RD_WORD_SRTADDR(base, index, index2))

/*! @brief Set the SRTADDR field to a new value. */
#define MPU_WR_WORD_SRTADDR(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_SRTADDR_MASK, MPU_WORD_SRTADDR(value)))
#define MPU_BWR_WORD_SRTADDR(base, index, index2, value) (MPU_WR_WORD_SRTADDR(base, index, index2, value))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1UM field. */
#define MPU_RD_WORD_M1UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1UM_MASK) >> MPU_WORD_M1UM_SHIFT)
#define MPU_BRD_WORD_M1UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1UM_SHIFT, MPU_WORD_M1UM_WIDTH))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_WORD_M1UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1UM_MASK, MPU_WORD_M1UM(value)))
#define MPU_BWR_WORD_M1UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1UM_SHIFT), MPU_WORD_M1UM_SHIFT, MPU_WORD_M1UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1SM field. */
#define MPU_RD_WORD_M1SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1SM_MASK) >> MPU_WORD_M1SM_SHIFT)
#define MPU_BRD_WORD_M1SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1SM_SHIFT, MPU_WORD_M1SM_WIDTH))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_WORD_M1SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1SM_MASK, MPU_WORD_M1SM(value)))
#define MPU_BWR_WORD_M1SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1SM_SHIFT), MPU_WORD_M1SM_SHIFT, MPU_WORD_M1SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M1PE field. */
#define MPU_RD_WORD_M1PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M1PE_MASK) >> MPU_WORD_M1PE_SHIFT)
#define MPU_BRD_WORD_M1PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M1PE_SHIFT, MPU_WORD_M1PE_WIDTH))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_WORD_M1PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M1PE_MASK, MPU_WORD_M1PE(value)))
#define MPU_BWR_WORD_M1PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M1PE_SHIFT), MPU_WORD_M1PE_SHIFT, MPU_WORD_M1PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2UM field. */
#define MPU_RD_WORD_M2UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2UM_MASK) >> MPU_WORD_M2UM_SHIFT)
#define MPU_BRD_WORD_M2UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2UM_SHIFT, MPU_WORD_M2UM_WIDTH))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_WORD_M2UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2UM_MASK, MPU_WORD_M2UM(value)))
#define MPU_BWR_WORD_M2UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2UM_SHIFT), MPU_WORD_M2UM_SHIFT, MPU_WORD_M2UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2SM field. */
#define MPU_RD_WORD_M2SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2SM_MASK) >> MPU_WORD_M2SM_SHIFT)
#define MPU_BRD_WORD_M2SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2SM_SHIFT, MPU_WORD_M2SM_WIDTH))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_WORD_M2SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2SM_MASK, MPU_WORD_M2SM(value)))
#define MPU_BWR_WORD_M2SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2SM_SHIFT), MPU_WORD_M2SM_SHIFT, MPU_WORD_M2SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field PIDMASK[23:16] (RW)
 *
 * Provides a masking capability so that multiple process identifiers can be
 * included as part of the region hit determination. If a bit in PIDMASK is set,
 * then the corresponding PID bit is ignored in the comparison. This field and PID
 * are included in the region hit determination if RGDn_WORD2[MxPE] is set. For
 * more information on the handling of the PID and PIDMASK, see "Access Evaluation
 * - Hit Determination."
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_PIDMASK field. */
#define MPU_RD_WORD_PIDMASK(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_PIDMASK_MASK) >> MPU_WORD_PIDMASK_SHIFT)
#define MPU_BRD_WORD_PIDMASK(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_PIDMASK_SHIFT, MPU_WORD_PIDMASK_WIDTH))

/*! @brief Set the PIDMASK field to a new value. */
#define MPU_WR_WORD_PIDMASK(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_PIDMASK_MASK, MPU_WORD_PIDMASK(value)))
#define MPU_BWR_WORD_PIDMASK(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_PIDMASK_SHIFT), MPU_WORD_PIDMASK_SHIFT, MPU_WORD_PIDMASK_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M2PE field. */
#define MPU_RD_WORD_M2PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M2PE_MASK) >> MPU_WORD_M2PE_SHIFT)
#define MPU_BRD_WORD_M2PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M2PE_SHIFT, MPU_WORD_M2PE_WIDTH))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_WORD_M2PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M2PE_MASK, MPU_WORD_M2PE(value)))
#define MPU_BWR_WORD_M2PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M2PE_SHIFT), MPU_WORD_M2PE_SHIFT, MPU_WORD_M2PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in User mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. In M3UM[2:0]: M3UM[2] controls read permissions, M3UM[1] controls write
 * permissions, and M3UM[0] controls execute permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3UM field. */
#define MPU_RD_WORD_M3UM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3UM_MASK) >> MPU_WORD_M3UM_SHIFT)
#define MPU_BRD_WORD_M3UM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3UM_SHIFT, MPU_WORD_M3UM_WIDTH))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_WORD_M3UM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3UM_MASK, MPU_WORD_M3UM(value)))
#define MPU_BWR_WORD_M3UM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3UM_SHIFT), MPU_WORD_M3UM_SHIFT, MPU_WORD_M3UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3SM field. */
#define MPU_RD_WORD_M3SM(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3SM_MASK) >> MPU_WORD_M3SM_SHIFT)
#define MPU_BRD_WORD_M3SM(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3SM_SHIFT, MPU_WORD_M3SM_WIDTH))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_WORD_M3SM(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3SM_MASK, MPU_WORD_M3SM(value)))
#define MPU_BWR_WORD_M3SM(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3SM_SHIFT), MPU_WORD_M3SM_SHIFT, MPU_WORD_M3SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn_WORD3) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M3PE field. */
#define MPU_RD_WORD_M3PE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M3PE_MASK) >> MPU_WORD_M3PE_SHIFT)
#define MPU_BRD_WORD_M3PE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M3PE_SHIFT, MPU_WORD_M3PE_WIDTH))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_WORD_M3PE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M3PE_MASK, MPU_WORD_M3PE(value)))
#define MPU_BWR_WORD_M3PE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M3PE_SHIFT), MPU_WORD_M3PE_SHIFT, MPU_WORD_M3PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field PID[31:24] (RW)
 *
 * Specifies the process identifier that is included in the region hit
 * determination if RGDn_WORD2[MxPE] is set. PIDMASK can mask individual bits in this
 * field.
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_PID field. */
#define MPU_RD_WORD_PID(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_PID_MASK) >> MPU_WORD_PID_SHIFT)
#define MPU_BRD_WORD_PID(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_PID_SHIFT, MPU_WORD_PID_WIDTH))

/*! @brief Set the PID field to a new value. */
#define MPU_WR_WORD_PID(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_PID_MASK, MPU_WORD_PID(value)))
#define MPU_BWR_WORD_PID(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_PID_SHIFT), MPU_WORD_PID_SHIFT, MPU_WORD_PID_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M4WE field. */
#define MPU_RD_WORD_M4WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M4WE_MASK) >> MPU_WORD_M4WE_SHIFT)
#define MPU_BRD_WORD_M4WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M4WE_SHIFT, MPU_WORD_M4WE_WIDTH))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_WORD_M4WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M4WE_MASK, MPU_WORD_M4WE(value)))
#define MPU_BWR_WORD_M4WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M4WE_SHIFT), MPU_WORD_M4WE_SHIFT, MPU_WORD_M4WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M4RE field. */
#define MPU_RD_WORD_M4RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M4RE_MASK) >> MPU_WORD_M4RE_SHIFT)
#define MPU_BRD_WORD_M4RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M4RE_SHIFT, MPU_WORD_M4RE_WIDTH))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_WORD_M4RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M4RE_MASK, MPU_WORD_M4RE(value)))
#define MPU_BWR_WORD_M4RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M4RE_SHIFT), MPU_WORD_M4RE_SHIFT, MPU_WORD_M4RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M5WE field. */
#define MPU_RD_WORD_M5WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M5WE_MASK) >> MPU_WORD_M5WE_SHIFT)
#define MPU_BRD_WORD_M5WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M5WE_SHIFT, MPU_WORD_M5WE_WIDTH))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_WORD_M5WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M5WE_MASK, MPU_WORD_M5WE(value)))
#define MPU_BWR_WORD_M5WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M5WE_SHIFT), MPU_WORD_M5WE_SHIFT, MPU_WORD_M5WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M5RE field. */
#define MPU_RD_WORD_M5RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M5RE_MASK) >> MPU_WORD_M5RE_SHIFT)
#define MPU_BRD_WORD_M5RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M5RE_SHIFT, MPU_WORD_M5RE_WIDTH))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_WORD_M5RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M5RE_MASK, MPU_WORD_M5RE(value)))
#define MPU_BWR_WORD_M5RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M5RE_SHIFT), MPU_WORD_M5RE_SHIFT, MPU_WORD_M5RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M6WE field. */
#define MPU_RD_WORD_M6WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M6WE_MASK) >> MPU_WORD_M6WE_SHIFT)
#define MPU_BRD_WORD_M6WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M6WE_SHIFT, MPU_WORD_M6WE_WIDTH))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_WORD_M6WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M6WE_MASK, MPU_WORD_M6WE(value)))
#define MPU_BWR_WORD_M6WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M6WE_SHIFT), MPU_WORD_M6WE_SHIFT, MPU_WORD_M6WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M6RE field. */
#define MPU_RD_WORD_M6RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M6RE_MASK) >> MPU_WORD_M6RE_SHIFT)
#define MPU_BRD_WORD_M6RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M6RE_SHIFT, MPU_WORD_M6RE_WIDTH))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_WORD_M6RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M6RE_MASK, MPU_WORD_M6RE(value)))
#define MPU_BWR_WORD_M6RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M6RE_SHIFT), MPU_WORD_M6RE_SHIFT, MPU_WORD_M6RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M7WE field. */
#define MPU_RD_WORD_M7WE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M7WE_MASK) >> MPU_WORD_M7WE_SHIFT)
#define MPU_BRD_WORD_M7WE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M7WE_SHIFT, MPU_WORD_M7WE_WIDTH))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_WORD_M7WE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M7WE_MASK, MPU_WORD_M7WE(value)))
#define MPU_BWR_WORD_M7WE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M7WE_SHIFT), MPU_WORD_M7WE_SHIFT, MPU_WORD_M7WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_WORD, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_WORD_M7RE field. */
#define MPU_RD_WORD_M7RE(base, index, index2) ((MPU_WORD_REG(base, index, index2) & MPU_WORD_M7RE_MASK) >> MPU_WORD_M7RE_SHIFT)
#define MPU_BRD_WORD_M7RE(base, index, index2) (BME_UBFX32(&MPU_WORD_REG(base, index, index2), MPU_WORD_M7RE_SHIFT, MPU_WORD_M7RE_WIDTH))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_WORD_M7RE(base, index, index2, value) (MPU_RMW_WORD(base, index, index2, MPU_WORD_M7RE_MASK, MPU_WORD_M7RE(value)))
#define MPU_BWR_WORD_M7RE(base, index, index2, value) (BME_BFI32(&MPU_WORD_REG(base, index, index2), ((uint32_t)(value) << MPU_WORD_M7RE_SHIFT), MPU_WORD_M7RE_SHIFT, MPU_WORD_M7RE_WIDTH))
/*@}*/

/*******************************************************************************
 * MPU_RGDAAC - Region Descriptor Alternate Access Control n
 ******************************************************************************/

/*!
 * @brief MPU_RGDAAC - Region Descriptor Alternate Access Control n (RW)
 *
 * Reset value: 0x0061F7DFU
 *
 * Because software may adjust only the access controls within a region
 * descriptor (RGDn_WORD2) as different tasks execute, an alternate programming view of
 * this 32-bit entity is available. Writing to this register does not affect the
 * descriptor's valid bit.
 */
/*!
 * @name Constants and macros for entire MPU_RGDAAC register
 */
/*@{*/
#define MPU_RD_RGDAAC(base, index) (MPU_RGDAAC_REG(base, index))
#define MPU_WR_RGDAAC(base, index, value) (MPU_RGDAAC_REG(base, index) = (value))
#define MPU_RMW_RGDAAC(base, index, mask, value) (MPU_WR_RGDAAC(base, index, (MPU_RD_RGDAAC(base, index) & ~(mask)) | (value)))
#define MPU_SET_RGDAAC(base, index, value) (BME_OR32(&MPU_RGDAAC_REG(base, index), (uint32_t)(value)))
#define MPU_CLR_RGDAAC(base, index, value) (BME_AND32(&MPU_RGDAAC_REG(base, index), (uint32_t)(~(value))))
#define MPU_TOG_RGDAAC(base, index, value) (BME_XOR32(&MPU_RGDAAC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual MPU_RGDAAC bitfields
 */

/*!
 * @name Register MPU_RGDAAC, field M0UM[2:0] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0UM field. */
#define MPU_RD_RGDAAC_M0UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0UM_MASK) >> MPU_RGDAAC_M0UM_SHIFT)
#define MPU_BRD_RGDAAC_M0UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0UM_SHIFT, MPU_RGDAAC_M0UM_WIDTH))

/*! @brief Set the M0UM field to a new value. */
#define MPU_WR_RGDAAC_M0UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0UM_MASK, MPU_RGDAAC_M0UM(value)))
#define MPU_BWR_RGDAAC_M0UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0UM_SHIFT), MPU_RGDAAC_M0UM_SHIFT, MPU_RGDAAC_M0UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M0SM[4:3] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0SM field. */
#define MPU_RD_RGDAAC_M0SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0SM_MASK) >> MPU_RGDAAC_M0SM_SHIFT)
#define MPU_BRD_RGDAAC_M0SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0SM_SHIFT, MPU_RGDAAC_M0SM_WIDTH))

/*! @brief Set the M0SM field to a new value. */
#define MPU_WR_RGDAAC_M0SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0SM_MASK, MPU_RGDAAC_M0SM(value)))
#define MPU_BWR_RGDAAC_M0SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0SM_SHIFT), MPU_RGDAAC_M0SM_SHIFT, MPU_RGDAAC_M0SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M0PE[5] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M0PE field. */
#define MPU_RD_RGDAAC_M0PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M0PE_MASK) >> MPU_RGDAAC_M0PE_SHIFT)
#define MPU_BRD_RGDAAC_M0PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M0PE_SHIFT, MPU_RGDAAC_M0PE_WIDTH))

/*! @brief Set the M0PE field to a new value. */
#define MPU_WR_RGDAAC_M0PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M0PE_MASK, MPU_RGDAAC_M0PE(value)))
#define MPU_BWR_RGDAAC_M0PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M0PE_SHIFT), MPU_RGDAAC_M0PE_SHIFT, MPU_RGDAAC_M0PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1UM[8:6] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1UM field. */
#define MPU_RD_RGDAAC_M1UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1UM_MASK) >> MPU_RGDAAC_M1UM_SHIFT)
#define MPU_BRD_RGDAAC_M1UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1UM_SHIFT, MPU_RGDAAC_M1UM_WIDTH))

/*! @brief Set the M1UM field to a new value. */
#define MPU_WR_RGDAAC_M1UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1UM_MASK, MPU_RGDAAC_M1UM(value)))
#define MPU_BWR_RGDAAC_M1UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1UM_SHIFT), MPU_RGDAAC_M1UM_SHIFT, MPU_RGDAAC_M1UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1SM[10:9] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1SM field. */
#define MPU_RD_RGDAAC_M1SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1SM_MASK) >> MPU_RGDAAC_M1SM_SHIFT)
#define MPU_BRD_RGDAAC_M1SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1SM_SHIFT, MPU_RGDAAC_M1SM_WIDTH))

/*! @brief Set the M1SM field to a new value. */
#define MPU_WR_RGDAAC_M1SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1SM_MASK, MPU_RGDAAC_M1SM(value)))
#define MPU_BWR_RGDAAC_M1SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1SM_SHIFT), MPU_RGDAAC_M1SM_SHIFT, MPU_RGDAAC_M1SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M1PE[11] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M1PE field. */
#define MPU_RD_RGDAAC_M1PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M1PE_MASK) >> MPU_RGDAAC_M1PE_SHIFT)
#define MPU_BRD_RGDAAC_M1PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M1PE_SHIFT, MPU_RGDAAC_M1PE_WIDTH))

/*! @brief Set the M1PE field to a new value. */
#define MPU_WR_RGDAAC_M1PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M1PE_MASK, MPU_RGDAAC_M1PE(value)))
#define MPU_BWR_RGDAAC_M1PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M1PE_SHIFT), MPU_RGDAAC_M1PE_SHIFT, MPU_RGDAAC_M1PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2UM[14:12] (RW)
 *
 * See M3UM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2UM field. */
#define MPU_RD_RGDAAC_M2UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2UM_MASK) >> MPU_RGDAAC_M2UM_SHIFT)
#define MPU_BRD_RGDAAC_M2UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2UM_SHIFT, MPU_RGDAAC_M2UM_WIDTH))

/*! @brief Set the M2UM field to a new value. */
#define MPU_WR_RGDAAC_M2UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2UM_MASK, MPU_RGDAAC_M2UM(value)))
#define MPU_BWR_RGDAAC_M2UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2UM_SHIFT), MPU_RGDAAC_M2UM_SHIFT, MPU_RGDAAC_M2UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2SM[16:15] (RW)
 *
 * See M3SM description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2SM field. */
#define MPU_RD_RGDAAC_M2SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2SM_MASK) >> MPU_RGDAAC_M2SM_SHIFT)
#define MPU_BRD_RGDAAC_M2SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2SM_SHIFT, MPU_RGDAAC_M2SM_WIDTH))

/*! @brief Set the M2SM field to a new value. */
#define MPU_WR_RGDAAC_M2SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2SM_MASK, MPU_RGDAAC_M2SM(value)))
#define MPU_BWR_RGDAAC_M2SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2SM_SHIFT), MPU_RGDAAC_M2SM_SHIFT, MPU_RGDAAC_M2SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M2PE[17] (RW)
 *
 * See M3PE description.
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M2PE field. */
#define MPU_RD_RGDAAC_M2PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M2PE_MASK) >> MPU_RGDAAC_M2PE_SHIFT)
#define MPU_BRD_RGDAAC_M2PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M2PE_SHIFT, MPU_RGDAAC_M2PE_WIDTH))

/*! @brief Set the M2PE field to a new value. */
#define MPU_WR_RGDAAC_M2PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M2PE_MASK, MPU_RGDAAC_M2PE(value)))
#define MPU_BWR_RGDAAC_M2PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M2PE_SHIFT), MPU_RGDAAC_M2PE_SHIFT, MPU_RGDAAC_M2PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3UM[20:18] (RW)
 *
 * Defines the access controls for bus master 3 in user mode. M3UM consists of
 * three independent bits, enabling read (r), write (w), and execute (x)
 * permissions. In M3UM[2:0]: M3UM[2] controls read permissions, M3UM[1] controls write
 * permissions, and M3UM[0] controls execute permissions.
 *
 * Values:
 * - 0b000 - An attempted access of that mode may be terminated with an access
 *     error (if not allowed by another descriptor) and the access not performed.
 * - 0b001 - Allows the given access type to occur
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3UM field. */
#define MPU_RD_RGDAAC_M3UM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3UM_MASK) >> MPU_RGDAAC_M3UM_SHIFT)
#define MPU_BRD_RGDAAC_M3UM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3UM_SHIFT, MPU_RGDAAC_M3UM_WIDTH))

/*! @brief Set the M3UM field to a new value. */
#define MPU_WR_RGDAAC_M3UM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3UM_MASK, MPU_RGDAAC_M3UM(value)))
#define MPU_BWR_RGDAAC_M3UM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3UM_SHIFT), MPU_RGDAAC_M3UM_SHIFT, MPU_RGDAAC_M3UM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3SM[22:21] (RW)
 *
 * Defines the access controls for bus master 3 in Supervisor mode.
 *
 * Values:
 * - 0b00 - r/w/x; read, write and execute allowed
 * - 0b01 - r/x; read and execute allowed, but no write
 * - 0b10 - r/w; read and write allowed, but no execute
 * - 0b11 - Same as User mode defined in M3UM
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3SM field. */
#define MPU_RD_RGDAAC_M3SM(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3SM_MASK) >> MPU_RGDAAC_M3SM_SHIFT)
#define MPU_BRD_RGDAAC_M3SM(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3SM_SHIFT, MPU_RGDAAC_M3SM_WIDTH))

/*! @brief Set the M3SM field to a new value. */
#define MPU_WR_RGDAAC_M3SM(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3SM_MASK, MPU_RGDAAC_M3SM(value)))
#define MPU_BWR_RGDAAC_M3SM(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3SM_SHIFT), MPU_RGDAAC_M3SM_SHIFT, MPU_RGDAAC_M3SM_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M3PE[23] (RW)
 *
 * Values:
 * - 0b0 - Do not include the process identifier in the evaluation
 * - 0b1 - Include the process identifier and mask (RGDn.RGDAAC) in the region
 *     hit evaluation
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M3PE field. */
#define MPU_RD_RGDAAC_M3PE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M3PE_MASK) >> MPU_RGDAAC_M3PE_SHIFT)
#define MPU_BRD_RGDAAC_M3PE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M3PE_SHIFT, MPU_RGDAAC_M3PE_WIDTH))

/*! @brief Set the M3PE field to a new value. */
#define MPU_WR_RGDAAC_M3PE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M3PE_MASK, MPU_RGDAAC_M3PE(value)))
#define MPU_BWR_RGDAAC_M3PE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M3PE_SHIFT), MPU_RGDAAC_M3PE_SHIFT, MPU_RGDAAC_M3PE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M4WE[24] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 4 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M4WE field. */
#define MPU_RD_RGDAAC_M4WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M4WE_MASK) >> MPU_RGDAAC_M4WE_SHIFT)
#define MPU_BRD_RGDAAC_M4WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M4WE_SHIFT, MPU_RGDAAC_M4WE_WIDTH))

/*! @brief Set the M4WE field to a new value. */
#define MPU_WR_RGDAAC_M4WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M4WE_MASK, MPU_RGDAAC_M4WE(value)))
#define MPU_BWR_RGDAAC_M4WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M4WE_SHIFT), MPU_RGDAAC_M4WE_SHIFT, MPU_RGDAAC_M4WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M4RE[25] (RW)
 *
 * Values:
 * - 0b0 - Bus master 4 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 4 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M4RE field. */
#define MPU_RD_RGDAAC_M4RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M4RE_MASK) >> MPU_RGDAAC_M4RE_SHIFT)
#define MPU_BRD_RGDAAC_M4RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M4RE_SHIFT, MPU_RGDAAC_M4RE_WIDTH))

/*! @brief Set the M4RE field to a new value. */
#define MPU_WR_RGDAAC_M4RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M4RE_MASK, MPU_RGDAAC_M4RE(value)))
#define MPU_BWR_RGDAAC_M4RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M4RE_SHIFT), MPU_RGDAAC_M4RE_SHIFT, MPU_RGDAAC_M4RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M5WE[26] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 5 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M5WE field. */
#define MPU_RD_RGDAAC_M5WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M5WE_MASK) >> MPU_RGDAAC_M5WE_SHIFT)
#define MPU_BRD_RGDAAC_M5WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M5WE_SHIFT, MPU_RGDAAC_M5WE_WIDTH))

/*! @brief Set the M5WE field to a new value. */
#define MPU_WR_RGDAAC_M5WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M5WE_MASK, MPU_RGDAAC_M5WE(value)))
#define MPU_BWR_RGDAAC_M5WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M5WE_SHIFT), MPU_RGDAAC_M5WE_SHIFT, MPU_RGDAAC_M5WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M5RE[27] (RW)
 *
 * Values:
 * - 0b0 - Bus master 5 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 5 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M5RE field. */
#define MPU_RD_RGDAAC_M5RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M5RE_MASK) >> MPU_RGDAAC_M5RE_SHIFT)
#define MPU_BRD_RGDAAC_M5RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M5RE_SHIFT, MPU_RGDAAC_M5RE_WIDTH))

/*! @brief Set the M5RE field to a new value. */
#define MPU_WR_RGDAAC_M5RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M5RE_MASK, MPU_RGDAAC_M5RE(value)))
#define MPU_BWR_RGDAAC_M5RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M5RE_SHIFT), MPU_RGDAAC_M5RE_SHIFT, MPU_RGDAAC_M5RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M6WE[28] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 6 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M6WE field. */
#define MPU_RD_RGDAAC_M6WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M6WE_MASK) >> MPU_RGDAAC_M6WE_SHIFT)
#define MPU_BRD_RGDAAC_M6WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M6WE_SHIFT, MPU_RGDAAC_M6WE_WIDTH))

/*! @brief Set the M6WE field to a new value. */
#define MPU_WR_RGDAAC_M6WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M6WE_MASK, MPU_RGDAAC_M6WE(value)))
#define MPU_BWR_RGDAAC_M6WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M6WE_SHIFT), MPU_RGDAAC_M6WE_SHIFT, MPU_RGDAAC_M6WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M6RE[29] (RW)
 *
 * Values:
 * - 0b0 - Bus master 6 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 6 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M6RE field. */
#define MPU_RD_RGDAAC_M6RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M6RE_MASK) >> MPU_RGDAAC_M6RE_SHIFT)
#define MPU_BRD_RGDAAC_M6RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M6RE_SHIFT, MPU_RGDAAC_M6RE_WIDTH))

/*! @brief Set the M6RE field to a new value. */
#define MPU_WR_RGDAAC_M6RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M6RE_MASK, MPU_RGDAAC_M6RE(value)))
#define MPU_BWR_RGDAAC_M6RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M6RE_SHIFT), MPU_RGDAAC_M6RE_SHIFT, MPU_RGDAAC_M6RE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M7WE[30] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 writes terminate with an access error and the write is
 *     not performed
 * - 0b1 - Bus master 7 writes allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M7WE field. */
#define MPU_RD_RGDAAC_M7WE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M7WE_MASK) >> MPU_RGDAAC_M7WE_SHIFT)
#define MPU_BRD_RGDAAC_M7WE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M7WE_SHIFT, MPU_RGDAAC_M7WE_WIDTH))

/*! @brief Set the M7WE field to a new value. */
#define MPU_WR_RGDAAC_M7WE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M7WE_MASK, MPU_RGDAAC_M7WE(value)))
#define MPU_BWR_RGDAAC_M7WE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M7WE_SHIFT), MPU_RGDAAC_M7WE_SHIFT, MPU_RGDAAC_M7WE_WIDTH))
/*@}*/

/*!
 * @name Register MPU_RGDAAC, field M7RE[31] (RW)
 *
 * Values:
 * - 0b0 - Bus master 7 reads terminate with an access error and the read is not
 *     performed
 * - 0b1 - Bus master 7 reads allowed
 */
/*@{*/
/*! @brief Read current value of the MPU_RGDAAC_M7RE field. */
#define MPU_RD_RGDAAC_M7RE(base, index) ((MPU_RGDAAC_REG(base, index) & MPU_RGDAAC_M7RE_MASK) >> MPU_RGDAAC_M7RE_SHIFT)
#define MPU_BRD_RGDAAC_M7RE(base, index) (BME_UBFX32(&MPU_RGDAAC_REG(base, index), MPU_RGDAAC_M7RE_SHIFT, MPU_RGDAAC_M7RE_WIDTH))

/*! @brief Set the M7RE field to a new value. */
#define MPU_WR_RGDAAC_M7RE(base, index, value) (MPU_RMW_RGDAAC(base, index, MPU_RGDAAC_M7RE_MASK, MPU_RGDAAC_M7RE(value)))
#define MPU_BWR_RGDAAC_M7RE(base, index, value) (BME_BFI32(&MPU_RGDAAC_REG(base, index), ((uint32_t)(value) << MPU_RGDAAC_M7RE_SHIFT), MPU_RGDAAC_M7RE_SHIFT, MPU_RGDAAC_M7RE_WIDTH))
/*@}*/

/*
 * MKV58F24 MSCM
 *
 * MSCM
 *
 * Registers defined in this header file:
 * - MSCM_TYPE - Processor X Type Register
 * - MSCM_NUM - Processor X Number Register
 * - MSCM_MASTER - Processor X Master Register
 * - MSCM_COUNT - Processor X Count Register
 * - MSCM_CFG1 - Processor X Configuration 1 Register
 * - MSCM_CFG3 - Processor X Configuration 3 Register
 * - MSCM_OCMDR - On-Chip Memory Descriptor Register
 */

#define MSCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MSCM module. */
#define MSCM_IDX (0U) /*!< Instance number for MSCM. */

/*******************************************************************************
 * MSCM_TYPE - Processor X Type Register
 ******************************************************************************/

/*!
 * @brief MSCM_TYPE - Processor X Type Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the personality of
 * the core making the access. The 32 bit response includes 3 ASCII characters
 * defining the CPU type along with a byte defining the logical revision number. The
 * logical revision number follows ARM's rYpZ nomenclature.
 */
/*!
 * @name Constants and macros for entire MSCM_TYPE register
 */
/*@{*/
#define MSCM_RD_TYPE(base, index) (MSCM_TYPE_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_TYPE bitfields
 */

/*!
 * @name Register MSCM_TYPE, field RYPZ[7:0] (RO)
 *
 * This field defines the processor revision for CPx: 0x00 corresponds to the
 * r0p0 core release. 0x01 corresponds to the r0p1 core release. ...
 */
/*@{*/
/*! @brief Read current value of the MSCM_TYPE_RYPZ field. */
#define MSCM_RD_TYPE_RYPZ(base, index) ((MSCM_TYPE_REG(base, index) & MSCM_TYPE_RYPZ_MASK) >> MSCM_TYPE_RYPZ_SHIFT)
#define MSCM_BRD_TYPE_RYPZ(base, index) (BME_UBFX32(&MSCM_TYPE_REG(base, index), MSCM_TYPE_RYPZ_SHIFT, MSCM_TYPE_RYPZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_TYPE, field PERSONALITY[31:8] (RO)
 *
 * This field defines the processor personality for CPx if CPx = Cortex-M7, then
 * PERSONALITY = 0x43_4D_37 ("CM7").
 */
/*@{*/
/*! @brief Read current value of the MSCM_TYPE_PERSONALITY field. */
#define MSCM_RD_TYPE_PERSONALITY(base, index) ((MSCM_TYPE_REG(base, index) & MSCM_TYPE_PERSONALITY_MASK) >> MSCM_TYPE_PERSONALITY_SHIFT)
#define MSCM_BRD_TYPE_PERSONALITY(base, index) (MSCM_RD_TYPE_PERSONALITY(base, index))
/*@}*/

/*******************************************************************************
 * MSCM_NUM - Processor X Number Register
 ******************************************************************************/

/*!
 * @brief MSCM_NUM - Processor X Number Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the logical
 * processor number of the core making the access. In single processor configurations,
 * the logical processor number is always zero; in dual core configurations, the
 * boot (or primary) core is assigned number 0 while the secondary core is defined
 * as number 1.
 */
/*!
 * @name Constants and macros for entire MSCM_NUM register
 */
/*@{*/
#define MSCM_RD_NUM(base, index) (MSCM_NUM_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_NUM bitfields
 */

/*!
 * @name Register MSCM_NUM, field CPN[0] (RO)
 *
 * This zero-filled word defines the logical processor number for CPx If single
 * core configuration, then CPN = 0 If dual core configuration and boot (primary)
 * core, then CPN = 0 For secondary core, CPN = 1
 */
/*@{*/
/*! @brief Read current value of the MSCM_NUM_CPN field. */
#define MSCM_RD_NUM_CPN(base, index) ((MSCM_NUM_REG(base, index) & MSCM_NUM_CPN_MASK) >> MSCM_NUM_CPN_SHIFT)
#define MSCM_BRD_NUM_CPN(base, index) (BME_UBFX32(&MSCM_NUM_REG(base, index), MSCM_NUM_CPN_SHIFT, MSCM_NUM_CPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_MASTER - Processor X Master Register
 ******************************************************************************/

/*!
 * @brief MSCM_MASTER - Processor X Master Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the physical bus
 * master number of the core making the access. The 32 bit response defines the
 * physical master number for processor x. A privileged read from the CM7 returns the
 * appropriate processor information. Reads from any other bus master return all
 * zeroes. Attempted user mode or write accesses are terminated with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_MASTER register
 */
/*@{*/
#define MSCM_RD_MASTER(base, index) (MSCM_MASTER_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_MASTER bitfields
 */

/*!
 * @name Register MSCM_MASTER, field PPN[5:0] (RO)
 *
 * This field defines the physical port number for CPUx. For CPU0, PPN = 0x00
 * For CPU1, PPN = 0x24
 */
/*@{*/
/*! @brief Read current value of the MSCM_MASTER_PPN field. */
#define MSCM_RD_MASTER_PPN(base, index) ((MSCM_MASTER_REG(base, index) & MSCM_MASTER_PPN_MASK) >> MSCM_MASTER_PPN_SHIFT)
#define MSCM_BRD_MASTER_PPN(base, index) (BME_UBFX32(&MSCM_MASTER_REG(base, index), MSCM_MASTER_PPN_SHIFT, MSCM_MASTER_PPN_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_COUNT - Processor X Count Register
 ******************************************************************************/

/*!
 * @brief MSCM_COUNT - Processor X Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response indicating the total number of
 * processor cores in the chip configuration.
 */
/*!
 * @name Constants and macros for entire MSCM_COUNT register
 */
/*@{*/
#define MSCM_RD_COUNT(base, index) (MSCM_COUNT_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_COUNT bitfields
 */

/*!
 * @name Register MSCM_COUNT, field PCNT[1:0] (RO)
 *
 * This field defines the processor count for the chip configuration: If single
 * core configuration, then PCNT = 00 If dual core configuration, then PCNT = 01
 */
/*@{*/
/*! @brief Read current value of the MSCM_COUNT_PCNT field. */
#define MSCM_RD_COUNT_PCNT(base, index) ((MSCM_COUNT_REG(base, index) & MSCM_COUNT_PCNT_MASK) >> MSCM_COUNT_PCNT_SHIFT)
#define MSCM_BRD_COUNT_PCNT(base, index) (BME_UBFX32(&MSCM_COUNT_REG(base, index), MSCM_COUNT_PCNT_SHIFT, MSCM_COUNT_PCNT_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CFG1 - Processor X Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief MSCM_CFG1 - Processor X Configuration 1 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The register provides a CPU-specific response detailing configuration
 * information, in this case, information on a Level 2 cache (if present).
 */
/*!
 * @name Constants and macros for entire MSCM_CFG1 register
 */
/*@{*/
#define MSCM_RD_CFG1(base, index) (MSCM_CFG1_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CFG1 bitfields
 */

/*!
 * @name Register MSCM_CFG1, field L2WY[23:16] (RO)
 *
 * This field provides the number of cache ways for the Level 2 Cache.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG1_L2WY field. */
#define MSCM_RD_CFG1_L2WY(base, index) ((MSCM_CFG1_REG(base, index) & MSCM_CFG1_L2WY_MASK) >> MSCM_CFG1_L2WY_SHIFT)
#define MSCM_BRD_CFG1_L2WY(base, index) (BME_UBFX32(&MSCM_CFG1_REG(base, index), MSCM_CFG1_L2WY_SHIFT, MSCM_CFG1_L2WY_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG1, field L2SZ[31:24] (RO)
 *
 * This field provides an encoded value of the Level 2 Cache size. The capacity
 * of the memory is expressed as Size [bytes] = 2(8+SZ) where SZ is non-zero; SZ
 * = 0 indicates the memory is not present. If no Level 2 Cache, then L2SZ = 0x00
 * If a 4 Kbyte Level 2 Cache, then L2SZ = 0x04 If an 8 Kbyte Level 2 Cache,
 * then L2SZ = 0x05 If a 16 Kbyte Level 2 Cache, then L2SZ = 0x06 If a 32 Kbyte
 * Level 2 Cache, then L2SZ = 0x07 If a 64 Kbyte Level 2 Cache, then L2SZ = 0x08 If a
 * 128 Kbyte Level 2 Cache, then L2SZ = 0x09 If a 256 Kbyte Level 2 Cache, then
 * L2SZ = 0x0A If a 512 Kbyte Level 2 Cache, then L2SZ = 0x0B
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG1_L2SZ field. */
#define MSCM_RD_CFG1_L2SZ(base, index) ((MSCM_CFG1_REG(base, index) & MSCM_CFG1_L2SZ_MASK) >> MSCM_CFG1_L2SZ_SHIFT)
#define MSCM_BRD_CFG1_L2SZ(base, index) (BME_UBFX32(&MSCM_CFG1_REG(base, index), MSCM_CFG1_L2SZ_SHIFT, MSCM_CFG1_L2SZ_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_CFG3 - Processor X Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief MSCM_CFG3 - Processor X Configuration 3 Register (RO)
 *
 * Reset value: 0x00000221U
 *
 * The register provides CPU-specific response detailing configuration
 * information, in this case, information on processor options. A privileged read from the
 * CM7 returns the appropriate processor information. Reads from any other bus
 * master return all zeroes. Attempted user mode or write accesses are terminated
 * with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_CFG3 register
 */
/*@{*/
#define MSCM_RD_CFG3(base, index) (MSCM_CFG3_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_CFG3 bitfields
 */

/*!
 * @name Register MSCM_CFG3, field FPU[0] (RO)
 *
 * This field indicates if hardware support for floating point capabilities are
 * supported in the processor. If FPU support is not included, then FPU = 0x0 If
 * FPU support is included, then FPU = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_FPU field. */
#define MSCM_RD_CFG3_FPU(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_FPU_MASK) >> MSCM_CFG3_FPU_SHIFT)
#define MSCM_BRD_CFG3_FPU(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_FPU_SHIFT, MSCM_CFG3_FPU_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field SIMD[1] (RO)
 *
 * This field indicates if the instruction set extensions supporting SIMD and/or
 * NEON capabilities are supported in the processor. If SIMD/NEON support is not
 * included, then SIMD = 0x0 If SIMD/NEON support is included, then SIMD = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_SIMD field. */
#define MSCM_RD_CFG3_SIMD(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_SIMD_MASK) >> MSCM_CFG3_SIMD_SHIFT)
#define MSCM_BRD_CFG3_SIMD(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_SIMD_SHIFT, MSCM_CFG3_SIMD_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field JAZ[2] (RO)
 *
 * This field indicates if Jazelle hardware is supported in the processor. If
 * Jazelle support is not included, then JAZ = 0x0 If Jazelle support is included,
 * then JAZ = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_JAZ field. */
#define MSCM_RD_CFG3_JAZ(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_JAZ_MASK) >> MSCM_CFG3_JAZ_SHIFT)
#define MSCM_BRD_CFG3_JAZ(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_JAZ_SHIFT, MSCM_CFG3_JAZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field MMU[3] (RO)
 *
 * This field indicates if the virtual memory management capabilities are
 * supported in the processor. If MMU support is not included, then MMU = 0x0 If MMU
 * support is included, then MMU = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_MMU field. */
#define MSCM_RD_CFG3_MMU(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_MMU_MASK) >> MSCM_CFG3_MMU_SHIFT)
#define MSCM_BRD_CFG3_MMU(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_MMU_SHIFT, MSCM_CFG3_MMU_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field TZ[4] (RO)
 *
 * This field indicates if the Trust Zone capabilities are supported in the
 * processor. If Trust Zone support is not included, then TZ = 0x0 If Trust Zone
 * support is included, then TZ = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_TZ field. */
#define MSCM_RD_CFG3_TZ(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_TZ_MASK) >> MSCM_CFG3_TZ_SHIFT)
#define MSCM_BRD_CFG3_TZ(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_TZ_SHIFT, MSCM_CFG3_TZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field CMP[5] (RO)
 *
 * This field indicates if the core memory protection hardware is included in
 * the processor. If core memory protection is not included, then CMP = 0x0 If core
 * memory protection is included, then CMP = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_CMP field. */
#define MSCM_RD_CFG3_CMP(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_CMP_MASK) >> MSCM_CFG3_CMP_SHIFT)
#define MSCM_BRD_CFG3_CMP(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_CMP_SHIFT, MSCM_CFG3_CMP_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field BB[6] (RO)
 *
 * This field defines if the processor supports bit banding. If bit banding is
 * not supported, then BB = 0x0 If bit banding is supported, then BB = 0x1
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_BB field. */
#define MSCM_RD_CFG3_BB(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_BB_MASK) >> MSCM_CFG3_BB_SHIFT)
#define MSCM_BRD_CFG3_BB(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_BB_SHIFT, MSCM_CFG3_BB_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_CFG3, field SBP[9:8] (RO)
 *
 * This field defines the number of physical connections to the system bus
 * fabric for this processor.
 */
/*@{*/
/*! @brief Read current value of the MSCM_CFG3_SBP field. */
#define MSCM_RD_CFG3_SBP(base, index) ((MSCM_CFG3_REG(base, index) & MSCM_CFG3_SBP_MASK) >> MSCM_CFG3_SBP_SHIFT)
#define MSCM_BRD_CFG3_SBP(base, index) (BME_UBFX32(&MSCM_CFG3_REG(base, index), MSCM_CFG3_SBP_SHIFT, MSCM_CFG3_SBP_WIDTH))
/*@}*/

/*******************************************************************************
 * MSCM_OCMDR - On-Chip Memory Descriptor Register
 ******************************************************************************/

/*!
 * @brief MSCM_OCMDR - On-Chip Memory Descriptor Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This section of the programming model is an array of 32-bit generic on-chip
 * memory descriptor registers that provide static information on the attached
 * memories as well as configurable controls (where appropriate). Privileged 32-bit
 * reads from a processor core or the debugger return the appropriate processor
 * information. Reads from any other bus master return all zeroes. Privileged
 * writes from a processor core or the debugger to writeable registers update the
 * appropriate fields. Privileged writes from other bus masters are ignored.
 * Attempted user mode accesses or any access with a size other than 32 bits are
 * terminated with an error.
 */
/*!
 * @name Constants and macros for entire MSCM_OCMDR register
 */
/*@{*/
#define MSCM_RD_OCMDR(base, index) (MSCM_OCMDR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual MSCM_OCMDR bitfields
 */

/*!
 * @name Register MSCM_OCMDR, field OCMPU[12] (RO)
 *
 * This field identifies a memory protected by a Memory Protection Unit.
 *
 * Values:
 * - 0b0 - OCMEMn is not protected by an MPU.
 * - 0b1 - OCMEMn is protected by an MPU.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMPU field. */
#define MSCM_RD_OCMDR_OCMPU(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMPU_MASK) >> MSCM_OCMDR_OCMPU_SHIFT)
#define MSCM_BRD_OCMDR_OCMPU(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMPU_SHIFT, MSCM_OCMDR_OCMPU_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMT[15:13] (RO)
 *
 * OCMEM Type. This field defines the type of the on-chip memory:
 *
 * Values:
 * - 0b000 - OCMEMn is a system RAM.
 * - 0b001 - OCMEMn is a graphics RAM.
 * - 0b010 - Reserved
 * - 0b011 - OCMEMn is a ROM.
 * - 0b100 - OCMEMn is a program flash.
 * - 0b101 - OCMEMn is a data flash.
 * - 0b110 - OCMEMn is an EEE.
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMT field. */
#define MSCM_RD_OCMDR_OCMT(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMT_MASK) >> MSCM_OCMDR_OCMT_SHIFT)
#define MSCM_BRD_OCMDR_OCMT(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMT_SHIFT, MSCM_OCMDR_OCMT_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMW[19:17] (RO)
 *
 * This field defines the width of the on-chip memory:
 *
 * Values:
 * - 0b010 - OCMEMn 32-bits wide
 * - 0b011 - OCMEMn 64-bits wide
 * - 0b100 - OCMEMn 128-bits wide
 * - 0b101 - OCMEMn 256-bits wide
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMW field. */
#define MSCM_RD_OCMDR_OCMW(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMW_MASK) >> MSCM_OCMDR_OCMW_SHIFT)
#define MSCM_BRD_OCMDR_OCMW(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMW_SHIFT, MSCM_OCMDR_OCMW_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZ[27:24] (RO)
 *
 * This field provides an encoded value of the on-chip memory size. The capacity
 * of the memory is expressed as Size [bytes] = 2(8+SZ) where SZ is non-zero; a
 * SZ = 0 indicates the memory is not present.
 *
 * Values:
 * - 0b0000 - no OCMEMn
 * - 0b0011 - 4KB OCMEMn
 * - 0b0100 - 8KB OCMEMn
 * - 0b0101 - 16KB OCMEMn
 * - 0b0110 - 32KB OCMEMn
 * - 0b0111 - 64KB OCMEMn
 * - 0b1000 - 128KB OCMEMn
 * - 0b1001 - 256KB OCMEMn
 * - 0b1010 - 512KB OCMEMn
 * - 0b1011 - 1024KB OCMEMn
 * - 0b1100 - 2048KB OCMEMn
 * - 0b1101 - 4096KB OCMEMn
 * - 0b1110 - 8192KB OCMEMn
 * - 0b1111 - 16384KB OCMEMn
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZ field. */
#define MSCM_RD_OCMDR_OCMSZ(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZ_MASK) >> MSCM_OCMDR_OCMSZ_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZ(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMSZ_SHIFT, MSCM_OCMDR_OCMSZ_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field OCMSZH[28] (RO)
 *
 * OCMEM Size "Hole". For on-chip memories that are not fully populated, that
 * is, include a memory "hole" in the upper 25% of the address range, this bit is
 * used.
 *
 * Values:
 * - 0b0 - OCMEMn is a power-of-2 capacity.
 * - 0b1 - OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_OCMSZH field. */
#define MSCM_RD_OCMDR_OCMSZH(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_OCMSZH_MASK) >> MSCM_OCMDR_OCMSZH_SHIFT)
#define MSCM_BRD_OCMDR_OCMSZH(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_OCMSZH_SHIFT, MSCM_OCMDR_OCMSZH_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field FMT[30] (RO)
 *
 * Values:
 * - 0b0 - Local
 * - 0b1 - Global
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_FMT field. */
#define MSCM_RD_OCMDR_FMT(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_FMT_MASK) >> MSCM_OCMDR_FMT_SHIFT)
#define MSCM_BRD_OCMDR_FMT(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_FMT_SHIFT, MSCM_OCMDR_FMT_WIDTH))
/*@}*/

/*!
 * @name Register MSCM_OCMDR, field V[31] (RO)
 *
 * This field defines the validity (presence) of the on-chip memory.
 *
 * Values:
 * - 0b0 - OCMEMn is not present.
 * - 0b1 - OCMEMn is present.
 */
/*@{*/
/*! @brief Read current value of the MSCM_OCMDR_V field. */
#define MSCM_RD_OCMDR_V(base, index) ((MSCM_OCMDR_REG(base, index) & MSCM_OCMDR_V_MASK) >> MSCM_OCMDR_V_SHIFT)
#define MSCM_BRD_OCMDR_V(base, index) (BME_UBFX32(&MSCM_OCMDR_REG(base, index), MSCM_OCMDR_V_SHIFT, MSCM_OCMDR_V_WIDTH))
/*@}*/

/*
 * MKV58F24 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFL_FlashConfig_IDX (0U) /*!< Instance number for FTFL_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 0b10 - MCU security status is unsecure
 * - 0b11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 0b10 - Freescale factory access denied
 * - 0b11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 0b10 - Mass erase is disabled
 * - 0b11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 0b10 - Backdoor key access enabled
 * - 0b11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT[0] (RO)
 *
 * Values:
 * - 0b0 - Low-power boot
 * - 0b1 - Normal boot
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT field. */
#define NV_RD_FOPT_LPBOOT(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT_MASK) >> NV_FOPT_LPBOOT_SHIFT)
#define NV_BRD_FOPT_LPBOOT(base) (NV_RD_FOPT_LPBOOT(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 0b0 - NMI interrupts are always blocked
 * - 0b1 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (NV_RD_FOPT_NMI_DIS(base))
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 0b0 - Slower initialization
 * - 0b1 - Fast Initialization
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define NV_RD_FOPT_FAST_INIT(base) ((NV_FOPT_REG(base) & NV_FOPT_FAST_INIT_MASK) >> NV_FOPT_FAST_INIT_SHIFT)
#define NV_BRD_FOPT_FAST_INIT(base) (NV_RD_FOPT_FAST_INIT(base))
/*@}*/

/*
 * MKV58F24 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 * - OSC_DIV - OSC_DIV
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC0_IDX (0U) /*!< Instance number for OSC0. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (BME_OR8(&OSC_CR_REG(base), (uint8_t)(value)))
#define OSC_CLR_CR(base, value)  (BME_AND8(&OSC_CR_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_CR(base, value)  (BME_XOR8(&OSC_CR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC16P_SHIFT), OSC_CR_SC16P_SHIFT, OSC_CR_SC16P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC8P_SHIFT), OSC_CR_SC8P_SHIFT, OSC_CR_SC8P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC4P_SHIFT), OSC_CR_SC4P_SHIFT, OSC_CR_SC4P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0b0 - Disable the selection.
 * - 0b1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_SC2P_SHIFT), OSC_CR_SC2P_SHIFT, OSC_CR_SC2P_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0b0 - External reference clock is disabled in Stop mode.
 * - 0b1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_EREFSTEN_SHIFT), OSC_CR_EREFSTEN_SHIFT, OSC_CR_EREFSTEN_WIDTH))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK) .
 *
 * Values:
 * - 0b0 - External reference clock is inactive.
 * - 0b1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BME_UBFX8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BME_BFI8(&OSC_CR_REG(base), ((uint8_t)(value) << OSC_CR_ERCLKEN_SHIFT), OSC_CR_ERCLKEN_SHIFT, OSC_CR_ERCLKEN_WIDTH))
/*@}*/

/*******************************************************************************
 * OSC_DIV - OSC_DIV
 ******************************************************************************/

/*!
 * @brief OSC_DIV - OSC_DIV (RW)
 *
 * Reset value: 0x00U
 *
 * OSC Clock divider register.
 */
/*!
 * @name Constants and macros for entire OSC_DIV register
 */
/*@{*/
#define OSC_RD_DIV(base)         (OSC_DIV_REG(base))
#define OSC_WR_DIV(base, value)  (OSC_DIV_REG(base) = (value))
#define OSC_RMW_DIV(base, mask, value) (OSC_WR_DIV(base, (OSC_RD_DIV(base) & ~(mask)) | (value)))
#define OSC_SET_DIV(base, value) (BME_OR8(&OSC_DIV_REG(base), (uint8_t)(value)))
#define OSC_CLR_DIV(base, value) (BME_AND8(&OSC_DIV_REG(base), (uint8_t)(~(value))))
#define OSC_TOG_DIV(base, value) (BME_XOR8(&OSC_DIV_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual OSC_DIV bitfields
 */

/*!
 * @name Register OSC_DIV, field ERPS[7:6] (RW)
 *
 * ERCLK prescaler. These two bits are used to divide the ERCLK output. The
 * un-divided ERCLK output is not affected by these two bits.
 *
 * Values:
 * - 0b00 - The divisor ratio is 1.
 * - 0b01 - The divisor ratio is 2.
 * - 0b10 - The divisor ratio is 4.
 * - 0b11 - The divisor ratio is 8.
 */
/*@{*/
/*! @brief Read current value of the OSC_DIV_ERPS field. */
#define OSC_RD_DIV_ERPS(base) ((OSC_DIV_REG(base) & OSC_DIV_ERPS_MASK) >> OSC_DIV_ERPS_SHIFT)
#define OSC_BRD_DIV_ERPS(base) (BME_UBFX8(&OSC_DIV_REG(base), OSC_DIV_ERPS_SHIFT, OSC_DIV_ERPS_WIDTH))

/*! @brief Set the ERPS field to a new value. */
#define OSC_WR_DIV_ERPS(base, value) (OSC_RMW_DIV(base, OSC_DIV_ERPS_MASK, OSC_DIV_ERPS(value)))
#define OSC_BWR_DIV_ERPS(base, value) (BME_BFI8(&OSC_DIV_REG(base), ((uint8_t)(value) << OSC_DIV_ERPS_SHIFT), OSC_DIV_ERPS_SHIFT, OSC_DIV_ERPS_WIDTH))
/*@}*/

/*
 * MKV58F24 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control register
 * - PDB_MOD - Modulus register
 * - PDB_CNT - Counter register
 * - PDB_IDLY - Interrupt Delay register
 * - PDB_C1 - Channel n Control register 1
 * - PDB_S - Channel n Status register
 * - PDB_DLY - Channel n Delay 0 register
 * - PDB_INTC - DAC Interval Trigger n Control register
 * - PDB_INT - DAC Interval n register
 * - PDB_POEN - Pulse-Out n Enable register
 * - PDB_PODLY - Pulse-Out n Delay register
 */

#define PDB_INSTANCE_COUNT (2U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */
#define PDB1_IDX (1U) /*!< Instance number for PDB1. */

/*******************************************************************************
 * PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (BME_OR32(&PDB_SC_REG(base), (uint32_t)(value)))
#define PDB_CLR_SC(base, value)  (BME_AND32(&PDB_SC_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_SC(base, value)  (BME_XOR32(&PDB_SC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to LDOK bit updates the MOD, IDLY, CHnDLYm, DACINTx, and POyDLY
 * registers with the values previously written to their internal buffers (and
 * stored there). The new values of MOD, IDLY, CHnDLYm, DACINTx, and POyDLY registers
 * will take effect according to the setting of the LDMOD field (Load Mode
 * Select). After 1 is written to the LDOK field, the values in the internal buffers of
 * these registers are not effective, and new values cannot be written to the
 * internal buffers until the existing values in the internal buffers are loaded
 * into their corresponding registers. LDOK can be written only when PDBEN is set,
 * or LDOK can be written at the same time when PDBEN is written to 1. LDOK is
 * automatically cleared when the values in the internal buffers are loaded into
 * the registers or when PDBEN bit (PDB Enable) is cleared. Writing 0 to LDOK has
 * no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDOK_SHIFT), PDB_SC_LDOK_SHIFT, PDB_SC_LDOK_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0b0 - PDB operation in One-Shot mode
 * - 0b1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_CONT_SHIFT), PDB_SC_CONT_SHIFT, PDB_SC_CONT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 0b00 - Multiplication factor is 1.
 * - 0b01 - Multiplication factor is 10.
 * - 0b10 - Multiplication factor is 20.
 * - 0b11 - Multiplication factor is 40.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_MULT_SHIFT), PDB_SC_MULT_SHIFT, PDB_SC_MULT_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0b0 - PDB interrupt disabled.
 * - 0b1 - PDB interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIE_SHIFT), PDB_SC_PDBIE_SHIFT, PDB_SC_PDBIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBIF_SHIFT), PDB_SC_PDBIF_SHIFT, PDB_SC_PDBIF_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0b0 - PDB disabled. Counter is off.
 * - 0b1 - PDB enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEN_SHIFT), PDB_SC_PDBEN_SHIFT, PDB_SC_PDBEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0b0000 - Trigger-In 0 is selected.
 * - 0b0001 - Trigger-In 1 is selected.
 * - 0b0010 - Trigger-In 2 is selected.
 * - 0b0011 - Trigger-In 3 is selected.
 * - 0b0100 - Trigger-In 4 is selected.
 * - 0b0101 - Trigger-In 5 is selected.
 * - 0b0110 - Trigger-In 6 is selected.
 * - 0b0111 - Trigger-In 7 is selected.
 * - 0b1000 - Trigger-In 8 is selected.
 * - 0b1001 - Trigger-In 9 is selected.
 * - 0b1010 - Trigger-In 10 is selected.
 * - 0b1011 - Trigger-In 11 is selected.
 * - 0b1100 - Trigger-In 12 is selected.
 * - 0b1101 - Trigger-In 13 is selected.
 * - 0b1110 - Trigger-In 14 is selected.
 * - 0b1111 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_TRGSEL_SHIFT), PDB_SC_TRGSEL_SHIFT, PDB_SC_TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 0b000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 0b001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 0b010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 0b011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 0b100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 0b101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 0b110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 0b111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PRESCALER_SHIFT), PDB_SC_PRESCALER_SHIFT, PDB_SC_PRESCALER_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0b0 - DMA disabled.
 * - 0b1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_DMAEN_SHIFT), PDB_SC_DMAEN_SHIFT, PDB_SC_DMAEN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_SWTRIG_SHIFT), PDB_SC_SWTRIG_SHIFT, PDB_SC_SWTRIG_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0b0 - PDB sequence error interrupt disabled.
 * - 0b1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_PDBEIE_SHIFT), PDB_SC_PDBEIE_SHIFT, PDB_SC_PDBEIE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 0b00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 0b01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 0b10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 0b11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (BME_UBFX32(&PDB_SC_REG(base), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (BME_BFI32(&PDB_SC_REG(base), ((uint32_t)(value) << PDB_SC_LDMOD_SHIFT), PDB_SC_LDMOD_SHIFT, PDB_SC_LDMOD_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * Note: This register is internally buffered, and any values written to the
 * register are written to its internal buffer instead; in other words, the internal
 * device bus does not write directly to this register. The value in this
 * register's internal buffer is loaded into this register only after "1" is written to
 * the SC[LDOK] bit.
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (BME_OR32(&PDB_MOD_REG(base), (uint32_t)(value)))
#define PDB_CLR_MOD(base, value) (BME_AND32(&PDB_MOD_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_MOD(base, value) (BME_XOR32(&PDB_MOD_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (PDB_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (PDB_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (PDB_RD_CNT_CNT(base))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * Note: This register is internally buffered, and any values written to the
 * register are written to its internal buffer instead; in other words, the internal
 * device bus does not write directly to this register. The value in this
 * register's internal buffer is loaded into this register only after "1" is written to
 * the SC[LDOK] bit.
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (BME_OR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
#define PDB_CLR_IDLY(base, value) (BME_AND32(&PDB_IDLY_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_IDLY(base, value) (BME_XOR32(&PDB_IDLY_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (PDB_RD_IDLY_IDLY(base))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (PDB_WR_IDLY_IDLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The bits in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_C1 register
 */
/*@{*/
#define PDB_RD_C1(base, index)   (PDB_C1_REG(base, index))
#define PDB_WR_C1(base, index, value) (PDB_C1_REG(base, index) = (value))
#define PDB_RMW_C1(base, index, mask, value) (PDB_WR_C1(base, index, (PDB_RD_C1(base, index) & ~(mask)) | (value)))
#define PDB_SET_C1(base, index, value) (BME_OR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_C1(base, index, value) (BME_AND32(&PDB_C1_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_C1(base, index, value) (BME_XOR32(&PDB_C1_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_C1 bitfields
 */

/*!
 * @name Register PDB_C1, field EN[7:0] (RW)
 *
 * These bits enable the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_EN field. */
#define PDB_RD_C1_EN(base, index) ((PDB_C1_REG(base, index) & PDB_C1_EN_MASK) >> PDB_C1_EN_SHIFT)
#define PDB_BRD_C1_EN(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_C1_EN(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_EN_MASK, PDB_C1_EN(value)))
#define PDB_BWR_C1_EN(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_EN_SHIFT), PDB_C1_EN_SHIFT, PDB_C1_EN_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field TOS[15:8] (RW)
 *
 * Selects the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger is in bypassed mode.
 *     The pre-trigger asserts one peripheral clock cycle after a rising edge is
 *     detected on selected trigger input source or software trigger is selected
 *     and SWTRIG is written with 1.
 * - 0b00000001 - PDB channel's corresponding pre-trigger asserts when the
 *     counter reaches the channel delay register and one peripheral clock cycle after
 *     a rising edge is detected on selected trigger input source or software
 *     trigger is selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_TOS field. */
#define PDB_RD_C1_TOS(base, index) ((PDB_C1_REG(base, index) & PDB_C1_TOS_MASK) >> PDB_C1_TOS_SHIFT)
#define PDB_BRD_C1_TOS(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_C1_TOS(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_TOS_MASK, PDB_C1_TOS(value)))
#define PDB_BWR_C1_TOS(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_TOS_SHIFT), PDB_C1_TOS_SHIFT, PDB_C1_TOS_WIDTH))
/*@}*/

/*!
 * @name Register PDB_C1, field BB[23:16] (RW)
 *
 * These bits enable the PDB ADC pre-trigger operation as back-to-back mode.
 * Only lower M pre-trigger bits are implemented in this MCU. Back-to-back operation
 * enables the ADC conversions complete to trigger the next PDB channel
 * pre-trigger and trigger output, so that the ADC conversions can be triggered on next
 * set of configuration and results registers. Application code must only enable
 * the back-to-back operation of the PDB pre-triggers at the leading of the
 * back-to-back connection chain.
 *
 * Values:
 * - 0b00000000 - PDB channel's corresponding pre-trigger back-to-back operation
 *     disabled.
 * - 0b00000001 - PDB channel's corresponding pre-trigger back-to-back operation
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_BB field. */
#define PDB_RD_C1_BB(base, index) ((PDB_C1_REG(base, index) & PDB_C1_BB_MASK) >> PDB_C1_BB_SHIFT)
#define PDB_BRD_C1_BB(base, index) (BME_UBFX32(&PDB_C1_REG(base, index), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_C1_BB(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_BB_MASK, PDB_C1_BB(value)))
#define PDB_BWR_C1_BB(base, index, value) (BME_BFI32(&PDB_C1_REG(base, index), ((uint32_t)(value) << PDB_C1_BB_SHIFT), PDB_C1_BB_SHIFT, PDB_C1_BB_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_S register
 */
/*@{*/
#define PDB_RD_S(base, index)    (PDB_S_REG(base, index))
#define PDB_WR_S(base, index, value) (PDB_S_REG(base, index) = (value))
#define PDB_RMW_S(base, index, mask, value) (PDB_WR_S(base, index, (PDB_RD_S(base, index) & ~(mask)) | (value)))
#define PDB_SET_S(base, index, value) (BME_OR32(&PDB_S_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_S(base, index, value) (BME_AND32(&PDB_S_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_S(base, index, value) (BME_XOR32(&PDB_S_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_S bitfields
 */

/*!
 * @name Register PDB_S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - Sequence error not detected on PDB channel's corresponding
 *     pre-trigger.
 * - 0b00000001 - Sequence error detected on PDB channel's corresponding
 *     pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from
 *     PDB channel n. When one conversion, which is triggered by one of the
 *     pre-triggers from PDB channel n, is in progress, new trigger from PDB
 *     channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is
 *     set. Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_ERR field. */
#define PDB_RD_S_ERR(base, index) ((PDB_S_REG(base, index) & PDB_S_ERR_MASK) >> PDB_S_ERR_SHIFT)
#define PDB_BRD_S_ERR(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_S_ERR(base, index, value) (PDB_RMW_S(base, index, PDB_S_ERR_MASK, PDB_S_ERR(value)))
#define PDB_BWR_S_ERR(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_ERR_SHIFT), PDB_S_ERR_SHIFT, PDB_S_ERR_WIDTH))
/*@}*/

/*!
 * @name Register PDB_S, field CF[23:16] (RW)
 *
 * The CF[m] bit is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_CF field. */
#define PDB_RD_S_CF(base, index) ((PDB_S_REG(base, index) & PDB_S_CF_MASK) >> PDB_S_CF_SHIFT)
#define PDB_BRD_S_CF(base, index) (BME_UBFX32(&PDB_S_REG(base, index), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_S_CF(base, index, value) (PDB_RMW_S(base, index, PDB_S_CF_MASK, PDB_S_CF(value)))
#define PDB_BWR_S_CF(base, index, value) (BME_BFI32(&PDB_S_REG(base, index), ((uint32_t)(value) << PDB_S_CF_SHIFT), PDB_S_CF_SHIFT, PDB_S_CF_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_DLY - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_DLY - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Note: This register is internally buffered, and any values written to the
 * register are written to its internal buffer instead; in other words, the internal
 * device bus does not write directly to this register. The value in this
 * register's internal buffer is loaded into this register only after "1" is written to
 * the SC[LDOK] bit.
 */
/*!
 * @name Constants and macros for entire PDB_DLY register
 */
/*@{*/
#define PDB_RD_DLY(base, index, index2) (PDB_DLY_REG(base, index, index2))
#define PDB_WR_DLY(base, index, index2, value) (PDB_DLY_REG(base, index, index2) = (value))
#define PDB_RMW_DLY(base, index, index2, mask, value) (PDB_WR_DLY(base, index, index2, (PDB_RD_DLY(base, index, index2) & ~(mask)) | (value)))
#define PDB_SET_DLY(base, index, index2, value) (BME_OR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
#define PDB_CLR_DLY(base, index, index2, value) (BME_AND32(&PDB_DLY_REG(base, index, index2), (uint32_t)(~(value))))
#define PDB_TOG_DLY(base, index, index2, value) (BME_XOR32(&PDB_DLY_REG(base, index, index2), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_DLY bitfields
 */

/*!
 * @name Register PDB_DLY, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_DLY_DLY field. */
#define PDB_RD_DLY_DLY(base, index, index2) ((PDB_DLY_REG(base, index, index2) & PDB_DLY_DLY_MASK) >> PDB_DLY_DLY_SHIFT)
#define PDB_BRD_DLY_DLY(base, index, index2) (PDB_RD_DLY_DLY(base, index, index2))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_DLY_DLY(base, index, index2, value) (PDB_RMW_DLY(base, index, index2, PDB_DLY_DLY_MASK, PDB_DLY_DLY(value)))
#define PDB_BWR_DLY_DLY(base, index, index2, value) (PDB_WR_DLY_DLY(base, index, index2, value))
/*@}*/

/*******************************************************************************
 * PDB_INTC - DAC Interval Trigger n Control register
 ******************************************************************************/

/*!
 * @brief PDB_INTC - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_INTC register
 */
/*@{*/
#define PDB_RD_INTC(base, index) (PDB_INTC_REG(base, index))
#define PDB_WR_INTC(base, index, value) (PDB_INTC_REG(base, index) = (value))
#define PDB_RMW_INTC(base, index, mask, value) (PDB_WR_INTC(base, index, (PDB_RD_INTC(base, index) & ~(mask)) | (value)))
#define PDB_SET_INTC(base, index, value) (BME_OR32(&PDB_INTC_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_INTC(base, index, value) (BME_AND32(&PDB_INTC_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_INTC(base, index, value) (BME_XOR32(&PDB_INTC_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INTC bitfields
 */

/*!
 * @name Register PDB_INTC, field TOE[0] (RW)
 *
 * Enables the DAC interval trigger.
 *
 * Values:
 * - 0b0 - DAC interval trigger disabled.
 * - 0b1 - DAC interval trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_TOE field. */
#define PDB_RD_INTC_TOE(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_TOE_MASK) >> PDB_INTC_TOE_SHIFT)
#define PDB_BRD_INTC_TOE(base, index) (BME_UBFX32(&PDB_INTC_REG(base, index), PDB_INTC_TOE_SHIFT, PDB_INTC_TOE_WIDTH))

/*! @brief Set the TOE field to a new value. */
#define PDB_WR_INTC_TOE(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_TOE_MASK, PDB_INTC_TOE(value)))
#define PDB_BWR_INTC_TOE(base, index, value) (BME_BFI32(&PDB_INTC_REG(base, index), ((uint32_t)(value) << PDB_INTC_TOE_SHIFT), PDB_INTC_TOE_SHIFT, PDB_INTC_TOE_WIDTH))
/*@}*/

/*!
 * @name Register PDB_INTC, field EXT[1] (RW)
 *
 * This bit enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0b0 - DAC external trigger input disabled. DAC interval counter is reset
 *     and started counting when a rising edge is detected on selected trigger
 *     input source or software trigger is selected and SWTRIG is written with 1.
 * - 0b1 - DAC external trigger input enabled. DAC interval counter is bypassed
 *     and DAC external trigger input triggers the DAC interval trigger.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_EXT field. */
#define PDB_RD_INTC_EXT(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_EXT_MASK) >> PDB_INTC_EXT_SHIFT)
#define PDB_BRD_INTC_EXT(base, index) (BME_UBFX32(&PDB_INTC_REG(base, index), PDB_INTC_EXT_SHIFT, PDB_INTC_EXT_WIDTH))

/*! @brief Set the EXT field to a new value. */
#define PDB_WR_INTC_EXT(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_EXT_MASK, PDB_INTC_EXT(value)))
#define PDB_BWR_INTC_EXT(base, index, value) (BME_BFI32(&PDB_INTC_REG(base, index), ((uint32_t)(value) << PDB_INTC_EXT_SHIFT), PDB_INTC_EXT_SHIFT, PDB_INTC_EXT_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_INT - DAC Interval n register
 ******************************************************************************/

/*!
 * @brief PDB_INT - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Note: This register is internally buffered, and any values written to the
 * register are written to its internal buffer instead; in other words, the internal
 * device bus does not write directly to this register. The value in this
 * register's internal buffer is loaded into this register only after "1" is written to
 * the SC[LDOK] bit.
 */
/*!
 * @name Constants and macros for entire PDB_INT register
 */
/*@{*/
#define PDB_RD_INT(base, index)  (PDB_INT_REG(base, index))
#define PDB_WR_INT(base, index, value) (PDB_INT_REG(base, index) = (value))
#define PDB_RMW_INT(base, index, mask, value) (PDB_WR_INT(base, index, (PDB_RD_INT(base, index) & ~(mask)) | (value)))
#define PDB_SET_INT(base, index, value) (BME_OR32(&PDB_INT_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_INT(base, index, value) (BME_AND32(&PDB_INT_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_INT(base, index, value) (BME_XOR32(&PDB_INT_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INT bitfields
 */

/*!
 * @name Register PDB_INT, field INT[15:0] (RW)
 *
 * These bits specify the interval value for DAC interval trigger. DAC interval
 * trigger triggers DAC[1:0] update when the DAC interval counter is equal to the
 * DACINT. Reading these bits returns the value of internal register that is
 * effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_INT_INT field. */
#define PDB_RD_INT_INT(base, index) ((PDB_INT_REG(base, index) & PDB_INT_INT_MASK) >> PDB_INT_INT_SHIFT)
#define PDB_BRD_INT_INT(base, index) (PDB_RD_INT_INT(base, index))

/*! @brief Set the INT field to a new value. */
#define PDB_WR_INT_INT(base, index, value) (PDB_RMW_INT(base, index, PDB_INT_INT_MASK, PDB_INT_INT(value)))
#define PDB_BWR_INT_INT(base, index, value) (PDB_WR_INT_INT(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (BME_OR32(&PDB_POEN_REG(base), (uint32_t)(value)))
#define PDB_CLR_POEN(base, value) (BME_AND32(&PDB_POEN_REG(base), (uint32_t)(~(value))))
#define PDB_TOG_POEN(base, value) (BME_XOR32(&PDB_POEN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0b00000000 - PDB Pulse-Out disabled
 * - 0b00000001 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (BME_UBFX32(&PDB_POEN_REG(base), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (BME_BFI32(&PDB_POEN_REG(base), ((uint32_t)(value) << PDB_POEN_POEN_SHIFT), PDB_POEN_POEN_SHIFT, PDB_POEN_POEN_WIDTH))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Note: This register is internally buffered, and any values written to the
 * register are written to its internal buffer instead; in other words, the internal
 * device bus does not write directly to this register. The value in this
 * register's internal buffer is loaded into this register only after "1" is written to
 * the SC[LDOK] bit.
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (BME_OR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
#define PDB_CLR_PODLY(base, index, value) (BME_AND32(&PDB_PODLY_REG(base, index), (uint32_t)(~(value))))
#define PDB_TOG_PODLY(base, index, value) (BME_XOR32(&PDB_PODLY_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 *
 * Specifies the delay 2 value for the PDB Pulse-Out. Pulse-Out goes low when
 * the PDB counter is equal to the DLY2. Reading this field returns the value of
 * internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (PDB_RD_PODLY_DLY2(base, index))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (PDB_WR_PODLY_DLY2(base, index, value))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 *
 * Specifies the delay 1 value for the PDB Pulse-Out. Pulse-Out goes high when
 * the PDB counter is equal to the DLY1. Reading this field returns the value of
 * internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (PDB_RD_PODLY_DLY1(base, index))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (PDB_WR_PODLY_DLY1(base, index, value))
/*@}*/

/*
 * MKV58F24 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - PIT_MCR - PIT Module Control Register
 * - PIT_LTMR64H - PIT Upper Lifetime Timer Register
 * - PIT_LTMR64L - PIT Lower Lifetime Timer Register
 * - PIT_LDVAL - Timer Load Value Register
 * - PIT_CVAL - Current Timer Value Register
 * - PIT_TCTRL - Timer Control Register
 * - PIT_TFLG - Timer Flag Register
 */

#define PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define PIT_IDX (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000002U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define PIT_RD_MCR(base)         (PIT_MCR_REG(base))
#define PIT_WR_MCR(base, value)  (PIT_MCR_REG(base) = (value))
#define PIT_RMW_MCR(base, mask, value) (PIT_WR_MCR(base, (PIT_RD_MCR(base) & ~(mask)) | (value)))
#define PIT_SET_MCR(base, value) (BME_OR32(&PIT_MCR_REG(base), (uint32_t)(value)))
#define PIT_CLR_MCR(base, value) (BME_AND32(&PIT_MCR_REG(base), (uint32_t)(~(value))))
#define PIT_TOG_MCR(base, value) (BME_XOR32(&PIT_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0b0 - Timers continue to run in Debug mode.
 * - 0b1 - Timers are stopped in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define PIT_RD_MCR_FRZ(base) ((PIT_MCR_REG(base) & PIT_MCR_FRZ_MASK) >> PIT_MCR_FRZ_SHIFT)
#define PIT_BRD_MCR_FRZ(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define PIT_WR_MCR_FRZ(base, value) (PIT_RMW_MCR(base, PIT_MCR_FRZ_MASK, PIT_MCR_FRZ(value)))
#define PIT_BWR_MCR_FRZ(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_FRZ_SHIFT), PIT_MCR_FRZ_SHIFT, PIT_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0b0 - Clock for standard PIT timers is enabled.
 * - 0b1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define PIT_RD_MCR_MDIS(base) ((PIT_MCR_REG(base) & PIT_MCR_MDIS_MASK) >> PIT_MCR_MDIS_SHIFT)
#define PIT_BRD_MCR_MDIS(base) (BME_UBFX32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define PIT_WR_MCR_MDIS(base, value) (PIT_RMW_MCR(base, PIT_MCR_MDIS_MASK, PIT_MCR_MDIS(value)))
#define PIT_BWR_MCR_MDIS(base, value) (BME_BFI32(&PIT_MCR_REG(base), ((uint32_t)(value) << PIT_MCR_MDIS_SHIFT), PIT_MCR_MDIS_SHIFT, PIT_MCR_MDIS_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64H - PIT Upper Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64H - PIT Upper Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64H register
 */
/*@{*/
#define PIT_RD_LTMR64H(base)     (PIT_LTMR64H_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64L - PIT Lower Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64L - PIT Lower Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. To use LTMR64H and LTMR64L, timer 0 and timer 1 need
 * to be chained. To obtain the correct value, first read LTMR64H and then
 * LTMR64L. LTMR64H will have the value of CVAL1 at the time of the first access,
 * LTMR64L will have the value of CVAL0 at the time of the first access, therefore
 * the application does not need to worry about carry-over effects of the running
 * counter. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64L register
 */
/*@{*/
#define PIT_RD_LTMR64L(base)     (PIT_LTMR64L_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LDVAL - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief PIT_LDVAL - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts. Access:
 * User read/write
 */
/*!
 * @name Constants and macros for entire PIT_LDVAL register
 */
/*@{*/
#define PIT_RD_LDVAL(base, index) (PIT_LDVAL_REG(base, index))
#define PIT_WR_LDVAL(base, index, value) (PIT_LDVAL_REG(base, index) = (value))
#define PIT_RMW_LDVAL(base, index, mask, value) (PIT_WR_LDVAL(base, index, (PIT_RD_LDVAL(base, index) & ~(mask)) | (value)))
#define PIT_SET_LDVAL(base, index, value) (BME_OR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_LDVAL(base, index, value) (BME_AND32(&PIT_LDVAL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_LDVAL(base, index, value) (BME_XOR32(&PIT_LDVAL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PIT_CVAL - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief PIT_CVAL - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_CVAL register
 */
/*@{*/
#define PIT_RD_CVAL(base, index) (PIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * PIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief PIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer. Access: User
 * read/write
 */
/*!
 * @name Constants and macros for entire PIT_TCTRL register
 */
/*@{*/
#define PIT_RD_TCTRL(base, index) (PIT_TCTRL_REG(base, index))
#define PIT_WR_TCTRL(base, index, value) (PIT_TCTRL_REG(base, index) = (value))
#define PIT_RMW_TCTRL(base, index, mask, value) (PIT_WR_TCTRL(base, index, (PIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PIT_SET_TCTRL(base, index, value) (BME_OR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TCTRL(base, index, value) (BME_AND32(&PIT_TCTRL_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TCTRL(base, index, value) (BME_XOR32(&PIT_TCTRL_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRL bitfields
 */

/*!
 * @name Register PIT_TCTRL, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0b0 - Timer n is disabled.
 * - 0b1 - Timer n is enabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TEN field. */
#define PIT_RD_TCTRL_TEN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TEN_MASK) >> PIT_TCTRL_TEN_SHIFT)
#define PIT_BRD_TCTRL_TEN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))

/*! @brief Set the TEN field to a new value. */
#define PIT_WR_TCTRL_TEN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TEN_MASK, PIT_TCTRL_TEN(value)))
#define PIT_BWR_TCTRL_TEN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TEN_SHIFT), PIT_TCTRL_TEN_SHIFT, PIT_TCTRL_TEN_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0b0 - Interrupt requests from Timer n are disabled.
 * - 0b1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TIE field. */
#define PIT_RD_TCTRL_TIE(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TIE_MASK) >> PIT_TCTRL_TIE_SHIFT)
#define PIT_BRD_TCTRL_TIE(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define PIT_WR_TCTRL_TIE(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TIE_MASK, PIT_TCTRL_TIE(value)))
#define PIT_BWR_TCTRL_TIE(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_TIE_SHIFT), PIT_TCTRL_TIE_SHIFT, PIT_TCTRL_TIE_WIDTH))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0b0 - Timer is not chained.
 * - 0b1 - Timer is chained to previous timer. For example, for Channel 2, if
 *     this field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_CHN field. */
#define PIT_RD_TCTRL_CHN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_CHN_MASK) >> PIT_TCTRL_CHN_SHIFT)
#define PIT_BRD_TCTRL_CHN(base, index) (BME_UBFX32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))

/*! @brief Set the CHN field to a new value. */
#define PIT_WR_TCTRL_CHN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_CHN_MASK, PIT_TCTRL_CHN(value)))
#define PIT_BWR_TCTRL_CHN(base, index, value) (BME_BFI32(&PIT_TCTRL_REG(base, index), ((uint32_t)(value) << PIT_TCTRL_CHN_SHIFT), PIT_TCTRL_CHN_SHIFT, PIT_TCTRL_CHN_WIDTH))
/*@}*/

/*******************************************************************************
 * PIT_TFLG - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief PIT_TFLG - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_TFLG register
 */
/*@{*/
#define PIT_RD_TFLG(base, index) (PIT_TFLG_REG(base, index))
#define PIT_WR_TFLG(base, index, value) (PIT_TFLG_REG(base, index) = (value))
#define PIT_RMW_TFLG(base, index, mask, value) (PIT_WR_TFLG(base, index, (PIT_RD_TFLG(base, index) & ~(mask)) | (value)))
#define PIT_SET_TFLG(base, index, value) (BME_OR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
#define PIT_CLR_TFLG(base, index, value) (BME_AND32(&PIT_TFLG_REG(base, index), (uint32_t)(~(value))))
#define PIT_TOG_TFLG(base, index, value) (BME_XOR32(&PIT_TFLG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLG bitfields
 */

/*!
 * @name Register PIT_TFLG, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0b0 - Timeout has not yet occurred.
 * - 0b1 - Timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the PIT_TFLG_TIF field. */
#define PIT_RD_TFLG_TIF(base, index) ((PIT_TFLG_REG(base, index) & PIT_TFLG_TIF_MASK) >> PIT_TFLG_TIF_SHIFT)
#define PIT_BRD_TFLG_TIF(base, index) (BME_UBFX32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))

/*! @brief Set the TIF field to a new value. */
#define PIT_WR_TFLG_TIF(base, index, value) (PIT_RMW_TFLG(base, index, PIT_TFLG_TIF_MASK, PIT_TFLG_TIF(value)))
#define PIT_BWR_TFLG_TIF(base, index, value) (BME_BFI32(&PIT_TFLG_REG(base, index), ((uint32_t)(value) << PIT_TFLG_TIF_SHIFT), PIT_TFLG_TIF_SHIFT, PIT_TFLG_TIF_WIDTH))
/*@}*/

/*
 * MKV58F24 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 * - PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (BME_OR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC1(base, value) (BME_AND8(&PMC_LVDSC1_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC1(base, value) (BME_XOR8(&PMC_LVDSC1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 0b00 - Low trip point selected (V LVD = V LVDL )
 * - 0b01 - High trip point selected (V LVD = V LVDH )
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDV_SHIFT), PMC_LVDSC1_LVDV_SHIFT, PMC_LVDSC1_LVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0b0 - LVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDRE_SHIFT), PMC_LVDSC1_LVDRE_SHIFT, PMC_LVDSC1_LVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDIE_SHIFT), PMC_LVDSC1_LVDIE_SHIFT, PMC_LVDSC1_LVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BME_BFI8(&PMC_LVDSC1_REG(base), ((uint8_t)(value) << PMC_LVDSC1_LVDACK_SHIFT), PMC_LVDSC1_LVDACK_SHIFT, PMC_LVDSC1_LVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0b0 - Low-voltage event not detected
 * - 0b1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BME_UBFX8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT, PMC_LVDSC1_LVDF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (BME_OR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
#define PMC_CLR_LVDSC2(base, value) (BME_AND8(&PMC_LVDSC2_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_LVDSC2(base, value) (BME_XOR8(&PMC_LVDSC2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 0b00 - Low trip point selected (VLVW = VLVW1)
 * - 0b01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 0b10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 0b11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWV_SHIFT), PMC_LVDSC2_LVWV_SHIFT, PMC_LVDSC2_LVWV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWIE_SHIFT), PMC_LVDSC2_LVWIE_SHIFT, PMC_LVDSC2_LVWIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BME_BFI8(&PMC_LVDSC2_REG(base), ((uint8_t)(value) << PMC_LVDSC2_LVWACK_SHIFT), PMC_LVDSC2_LVWACK_SHIFT, PMC_LVDSC2_LVWACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0b0 - Low-voltage warning event not detected
 * - 0b1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BME_UBFX8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT, PMC_LVDSC2_LVWF_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x24U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (BME_OR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
#define PMC_CLR_REGSC(base, value) (BME_AND8(&PMC_REGSC_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_REGSC(base, value) (BME_XOR8(&PMC_REGSC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0b0 - Bandgap buffer not enabled
 * - 0b1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGBE_SHIFT), PMC_REGSC_BGBE_SHIFT, PMC_REGSC_BGBE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0b0 - Regulator is in stop regulation or in transition to/from it
 * - 0b1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT, PMC_REGSC_REGONS_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0b0 - Peripherals and I/O pads are in normal run state.
 * - 0b1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_ACKISO_SHIFT), PMC_REGSC_ACKISO_SHIFT, PMC_REGSC_ACKISO_WIDTH))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low power
 * modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0b0 - Bandgap voltage reference is disabled in VLPx , and VLLSx modes.
 * - 0b1 - Bandgap voltage reference is enabled in VLPx , and VLLSx modes.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define PMC_RD_REGSC_BGEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGEN_MASK) >> PMC_REGSC_BGEN_SHIFT)
#define PMC_BRD_REGSC_BGEN(base) (BME_UBFX8(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))

/*! @brief Set the BGEN field to a new value. */
#define PMC_WR_REGSC_BGEN(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGEN_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGEN(value)))
#define PMC_BWR_REGSC_BGEN(base, value) (BME_BFI8(&PMC_REGSC_REG(base), ((uint8_t)(value) << PMC_REGSC_BGEN_SHIFT), PMC_REGSC_BGEN_SHIFT, PMC_REGSC_BGEN_WIDTH))
/*@}*/

/*******************************************************************************
 * PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_HVDSC1 - High Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x01U
 *
 * This register contains status and control bits to support the high voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the HVD system is disabled regardless of HVDSC1 settings. To protect
 * systems that must have HVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power
 * or low leakage modes from being enabled. See the device's data sheet for the
 * exact HVD trip voltages. This register is reset solely on a POR Only event.For
 * more information about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_HVDSC1 register
 */
/*@{*/
#define PMC_RD_HVDSC1(base)      (PMC_HVDSC1_REG(base))
#define PMC_WR_HVDSC1(base, value) (PMC_HVDSC1_REG(base) = (value))
#define PMC_RMW_HVDSC1(base, mask, value) (PMC_WR_HVDSC1(base, (PMC_RD_HVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_HVDSC1(base, value) (BME_OR8(&PMC_HVDSC1_REG(base), (uint8_t)(value)))
#define PMC_CLR_HVDSC1(base, value) (BME_AND8(&PMC_HVDSC1_REG(base), (uint8_t)(~(value))))
#define PMC_TOG_HVDSC1(base, value) (BME_XOR8(&PMC_HVDSC1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PMC_HVDSC1 bitfields
 */

/*!
 * @name Register PMC_HVDSC1, field HVDV[0] (RW)
 *
 * Selects the HVD trip point voltage (V HVD ).
 *
 * Values:
 * - 0b0 - Low trip point selected (V HVD = V HVDL )
 * - 0b1 - High trip point selected (V HVD = V HVDH )
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDV field. */
#define PMC_RD_HVDSC1_HVDV(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDV_MASK) >> PMC_HVDSC1_HVDV_SHIFT)
#define PMC_BRD_HVDSC1_HVDV(base) (BME_UBFX8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDV_SHIFT, PMC_HVDSC1_HVDV_WIDTH))

/*! @brief Set the HVDV field to a new value. */
#define PMC_WR_HVDSC1_HVDV(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDV_MASK, PMC_HVDSC1_HVDV(value)))
#define PMC_BWR_HVDSC1_HVDV(base, value) (BME_BFI8(&PMC_HVDSC1_REG(base), ((uint8_t)(value) << PMC_HVDSC1_HVDV_SHIFT), PMC_HVDSC1_HVDV_SHIFT, PMC_HVDSC1_HVDV_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDRE[4] (RW)
 *
 * This write-once bit enables HVDF events to generate a hardware reset.
 * Additional writes are ignored until the next chip reset.
 *
 * Values:
 * - 0b0 - HVDF does not generate hardware resets
 * - 0b1 - Force an MCU reset when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDRE field. */
#define PMC_RD_HVDSC1_HVDRE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDRE_MASK) >> PMC_HVDSC1_HVDRE_SHIFT)
#define PMC_BRD_HVDSC1_HVDRE(base) (BME_UBFX8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDRE_SHIFT, PMC_HVDSC1_HVDRE_WIDTH))

/*! @brief Set the HVDRE field to a new value. */
#define PMC_WR_HVDSC1_HVDRE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDRE_MASK, PMC_HVDSC1_HVDRE(value)))
#define PMC_BWR_HVDSC1_HVDRE(base, value) (BME_BFI8(&PMC_HVDSC1_REG(base), ((uint8_t)(value) << PMC_HVDSC1_HVDRE_SHIFT), PMC_HVDSC1_HVDRE_SHIFT, PMC_HVDSC1_HVDRE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for HVDF.
 *
 * Values:
 * - 0b0 - Hardware interrupt disabled (use polling)
 * - 0b1 - Request a hardware interrupt when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDIE field. */
#define PMC_RD_HVDSC1_HVDIE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDIE_MASK) >> PMC_HVDSC1_HVDIE_SHIFT)
#define PMC_BRD_HVDSC1_HVDIE(base) (BME_UBFX8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDIE_SHIFT, PMC_HVDSC1_HVDIE_WIDTH))

/*! @brief Set the HVDIE field to a new value. */
#define PMC_WR_HVDSC1_HVDIE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDIE_MASK, PMC_HVDSC1_HVDIE(value)))
#define PMC_BWR_HVDSC1_HVDIE(base, value) (BME_BFI8(&PMC_HVDSC1_REG(base), ((uint8_t)(value) << PMC_HVDSC1_HVDIE_SHIFT), PMC_HVDSC1_HVDIE_SHIFT, PMC_HVDSC1_HVDIE_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge high voltage detection errors.
 * Write 1 to clear HVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the HVDACK field to a new value. */
#define PMC_WR_HVDSC1_HVDACK(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDACK_MASK, PMC_HVDSC1_HVDACK(value)))
#define PMC_BWR_HVDSC1_HVDACK(base, value) (BME_BFI8(&PMC_HVDSC1_REG(base), ((uint8_t)(value) << PMC_HVDSC1_HVDACK_SHIFT), PMC_HVDSC1_HVDACK_SHIFT, PMC_HVDSC1_HVDACK_WIDTH))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDF[7] (RO)
 *
 * This read-only status field indicates a high-voltage detect event.
 *
 * Values:
 * - 0b0 - High-voltage event not detected
 * - 0b1 - High-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDF field. */
#define PMC_RD_HVDSC1_HVDF(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDF_MASK) >> PMC_HVDSC1_HVDF_SHIFT)
#define PMC_BRD_HVDSC1_HVDF(base) (BME_UBFX8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDF_SHIFT, PMC_HVDSC1_HVDF_WIDTH))
/*@}*/

/*
 * MKV58F24 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 * - PORT_DFER - Digital Filter Enable Register
 * - PORT_DFCR - Digital Filter Clock Register
 * - PORT_DFWR - Digital Filter Width Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000702U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (BME_OR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
#define PORT_CLR_PCR(base, index, value) (BME_AND32(&PORT_PCR_REG(base, index), (uint32_t)(~(value))))
#define PORT_TOG_PCR(base, index, value) (BME_XOR32(&PORT_PCR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pulldown resistor is enabled on the corresponding pin, if
 *     the corresponding PE field is set.
 * - 0b1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PS_SHIFT), PORT_PCR_PS_SHIFT, PORT_PCR_PS_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 0b1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PE_SHIFT), PORT_PCR_PE_SHIFT, PORT_PCR_PE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 0b1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_SRE_SHIFT), PORT_PCR_SRE_SHIFT, PORT_PCR_SRE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * Passive filter configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Passive input filter is disabled on the corresponding pin.
 * - 0b1 - Passive input filter is enabled on the corresponding pin, if the pin
 *     is configured as a digital input. Refer to the device data sheet for
 *     filter characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_PFE_SHIFT), PORT_PCR_PFE_SHIFT, PORT_PCR_PFE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Open drain output is disabled on the corresponding pin.
 * - 0b1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ODE_SHIFT), PORT_PCR_ODE_SHIFT, PORT_PCR_ODE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 0b1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_DSE_SHIFT), PORT_PCR_DSE_SHIFT, PORT_PCR_DSE_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[11:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 0b0000 - Pin disabled.
 * - 0b0001 - Alternative 1 (GPIO).
 * - 0b0010 - Alternative 2 (chip-specific).
 * - 0b0011 - Alternative 3 (chip-specific).
 * - 0b0100 - Alternative 4 (chip-specific).
 * - 0b0101 - Alternative 5 (chip-specific).
 * - 0b0110 - Alternative 6 (chip-specific).
 * - 0b0111 - Alternative 7 (chip-specific).
 * - 0b1000 - Alternative 8 (chip-specific).
 * - 0b1001 - Alternative 9 (chip-specific).
 * - 0b1010 - Alternative 10 (chip-specific).
 * - 0b1011 - Alternative 11 (chip-specific).
 * - 0b1100 - Alternative 12 (chip-specific).
 * - 0b1101 - Alternative 13 (chip-specific).
 * - 0b1110 - Alternative 14 (chip-specific).
 * - 0b1111 - Alternative 15 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_MUX_SHIFT), PORT_PCR_MUX_SHIFT, PORT_PCR_MUX_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field LK[15] (RW)
 *
 * Values:
 * - 0b0 - Pin Control Register fields [15:0] are not locked.
 * - 0b1 - Pin Control Register fields [15:0] are locked and cannot be updated
 *     until the next system reset.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_LK field. */
#define PORT_RD_PCR_LK(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_LK_MASK) >> PORT_PCR_LK_SHIFT)
#define PORT_BRD_PCR_LK(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT, PORT_PCR_LK_WIDTH))

/*! @brief Set the LK field to a new value. */
#define PORT_WR_PCR_LK(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_LK_MASK | PORT_PCR_ISF_MASK), PORT_PCR_LK(value)))
#define PORT_BWR_PCR_LK(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_LK_SHIFT), PORT_PCR_LK_SHIFT, PORT_PCR_LK_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0b0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0b0001 - ISF flag and DMA request on rising edge.
 * - 0b0010 - ISF flag and DMA request on falling edge.
 * - 0b0011 - ISF flag and DMA request on either edge.
 * - 0b0100 - Reserved.
 * - 0b0101 - Reserved.
 * - 0b0110 - Reserved.
 * - 0b0111 - Reserved.
 * - 0b1000 - ISF flag and Interrupt when logic 0.
 * - 0b1001 - ISF flag and Interrupt on rising-edge.
 * - 0b1010 - ISF flag and Interrupt on falling-edge.
 * - 0b1011 - ISF flag and Interrupt on either edge.
 * - 0b1100 - ISF flag and Interrupt when logic 1.
 * - 0b1101 - Reserved.
 * - 0b1110 - Reserved.
 * - 0b1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_IRQC_SHIFT), PORT_PCR_IRQC_SHIFT, PORT_PCR_IRQC_WIDTH))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0b0 - Configured interrupt is not detected.
 * - 0b1 - Configured interrupt is detected. If the pin is configured to
 *     generate a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured
 *     for a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BME_UBFX32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BME_BFI32(&PORT_PCR_REG(base, index), ((uint32_t)(value) << PORT_PCR_ISF_SHIFT), PORT_PCR_ISF_SHIFT, PORT_PCR_ISF_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (PORT_WR_GPCLR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (PORT_WR_GPCLR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (PORT_WR_GPCHR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0b0000000000000000 - Corresponding Pin Control Register is not updated with
 *     the value in GPWD.
 * - 0b0000000000000001 - Corresponding Pin Control Register is updated with the
 *     value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (PORT_WR_GPCHR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (BME_OR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
#define PORT_CLR_ISFR(base, value) (BME_AND32(&PORT_ISFR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_ISFR(base, value) (BME_XOR32(&PORT_ISFR_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support a digital
 * filter. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support digital filter. The digital filter configuration is valid
 * in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define PORT_RD_DFER(base)       (PORT_DFER_REG(base))
#define PORT_WR_DFER(base, value) (PORT_DFER_REG(base) = (value))
#define PORT_RMW_DFER(base, mask, value) (PORT_WR_DFER(base, (PORT_RD_DFER(base) & ~(mask)) | (value)))
#define PORT_SET_DFER(base, value) (BME_OR32(&PORT_DFER_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFER(base, value) (BME_AND32(&PORT_DFER_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFER(base, value) (BME_XOR32(&PORT_DFER_REG(base), (uint32_t)(value)))
/*@}*/

/*******************************************************************************
 * PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define PORT_RD_DFCR(base)       (PORT_DFCR_REG(base))
#define PORT_WR_DFCR(base, value) (PORT_DFCR_REG(base) = (value))
#define PORT_RMW_DFCR(base, mask, value) (PORT_WR_DFCR(base, (PORT_RD_DFCR(base) & ~(mask)) | (value)))
#define PORT_SET_DFCR(base, value) (BME_OR32(&PORT_DFCR_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFCR(base, value) (BME_AND32(&PORT_DFCR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFCR(base, value) (BME_XOR32(&PORT_DFCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source must be done only when all digital filters are disabled.
 *
 * Values:
 * - 0b0 - Digital filters are clocked by the bus clock.
 * - 0b1 - Digital filters are clocked by the LPO clock.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFCR_CS field. */
#define PORT_RD_DFCR_CS(base) ((PORT_DFCR_REG(base) & PORT_DFCR_CS_MASK) >> PORT_DFCR_CS_SHIFT)
#define PORT_BRD_DFCR_CS(base) (BME_UBFX32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT, PORT_DFCR_CS_WIDTH))

/*! @brief Set the CS field to a new value. */
#define PORT_WR_DFCR_CS(base, value) (PORT_RMW_DFCR(base, PORT_DFCR_CS_MASK, PORT_DFCR_CS(value)))
#define PORT_BWR_DFCR_CS(base, value) (BME_BFI32(&PORT_DFCR_REG(base), ((uint32_t)(value) << PORT_DFCR_CS_SHIFT), PORT_DFCR_CS_SHIFT, PORT_DFCR_CS_WIDTH))
/*@}*/

/*******************************************************************************
 * PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define PORT_RD_DFWR(base)       (PORT_DFWR_REG(base))
#define PORT_WR_DFWR(base, value) (PORT_DFWR_REG(base) = (value))
#define PORT_RMW_DFWR(base, mask, value) (PORT_WR_DFWR(base, (PORT_RD_DFWR(base) & ~(mask)) | (value)))
#define PORT_SET_DFWR(base, value) (BME_OR32(&PORT_DFWR_REG(base), (uint32_t)(value)))
#define PORT_CLR_DFWR(base, value) (BME_AND32(&PORT_DFWR_REG(base), (uint32_t)(~(value))))
#define PORT_TOG_DFWR(base, value) (BME_XOR32(&PORT_DFWR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches, in clock cycles, that the digital
 * filter absorbs for the enabled digital filters. Glitches that are longer than
 * this register setting will pass through the digital filter, and glitches that
 * are equal to or less than this register setting are filtered. Changing the
 * filter length must be done only after all filters are disabled.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define PORT_RD_DFWR_FILT(base) ((PORT_DFWR_REG(base) & PORT_DFWR_FILT_MASK) >> PORT_DFWR_FILT_SHIFT)
#define PORT_BRD_DFWR_FILT(base) (BME_UBFX32(&PORT_DFWR_REG(base), PORT_DFWR_FILT_SHIFT, PORT_DFWR_FILT_WIDTH))

/*! @brief Set the FILT field to a new value. */
#define PORT_WR_DFWR_FILT(base, value) (PORT_RMW_DFWR(base, PORT_DFWR_FILT_MASK, PORT_DFWR_FILT(value)))
#define PORT_BWR_DFWR_FILT(base, value) (BME_BFI32(&PORT_DFWR_REG(base), ((uint32_t)(value) << PORT_DFWR_FILT_SHIFT), PORT_DFWR_FILT_SHIFT, PORT_DFWR_FILT_WIDTH))
/*@}*/

/*
 * MKV58F24 PWM
 *
 * Pulse Width Modulator with nano edge placement
 *
 * Registers defined in this header file:
 * - PWM_CNT - Counter Register
 * - PWM_INIT - Initial Count Register
 * - PWM_CTRL2 - Control 2 Register
 * - PWM_CTRL - Control Register
 * - PWM_VAL0 - Value Register 0
 * - PWM_FRACVAL1 - Fractional Value Register 1
 * - PWM_VAL1 - Value Register 1
 * - PWM_FRACVAL2 - Fractional Value Register 2
 * - PWM_VAL2 - Value Register 2
 * - PWM_FRACVAL3 - Fractional Value Register 3
 * - PWM_VAL3 - Value Register 3
 * - PWM_FRACVAL4 - Fractional Value Register 4
 * - PWM_VAL4 - Value Register 4
 * - PWM_FRACVAL5 - Fractional Value Register 5
 * - PWM_VAL5 - Value Register 5
 * - PWM_FRCTRL - Fractional Control Register
 * - PWM_OCTRL - Output Control Register
 * - PWM_STS - Status Register
 * - PWM_INTEN - Interrupt Enable Register
 * - PWM_DMAEN - DMA Enable Register
 * - PWM_TCTRL - Output Trigger Control Register
 * - PWM_DISMAP - Fault Disable Mapping Register 0
 * - PWM_DTCNT0 - Deadtime Count Register 0
 * - PWM_DTCNT1 - Deadtime Count Register 1
 * - PWM_CAPTCTRLA - Capture Control A Register
 * - PWM_CAPTCOMPA - Capture Compare A Register
 * - PWM_CAPTCTRLB - Capture Control B Register
 * - PWM_CAPTCOMPB - Capture Compare B Register
 * - PWM_CAPTCTRLX - Capture Control X Register
 * - PWM_CAPTCOMPX - Capture Compare X Register
 * - PWM_CVAL0 - Capture Value 0 Register
 * - PWM_CVAL0CYC - Capture Value 0 Cycle Register
 * - PWM_CVAL1 - Capture Value 1 Register
 * - PWM_CVAL1CYC - Capture Value 1 Cycle Register
 * - PWM_CVAL2 - Capture Value 2 Register
 * - PWM_CVAL2CYC - Capture Value 2 Cycle Register
 * - PWM_CVAL3 - Capture Value 3 Register
 * - PWM_CVAL3CYC - Capture Value 3 Cycle Register
 * - PWM_CVAL4 - Capture Value 4 Register
 * - PWM_CVAL4CYC - Capture Value 4 Cycle Register
 * - PWM_CVAL5 - Capture Value 5 Register
 * - PWM_CVAL5CYC - Capture Value 5 Cycle Register
 * - PWM_OUTEN - Output Enable Register
 * - PWM_MASK - Mask Register
 * - PWM_SWCOUT - Software Controlled Output Register
 * - PWM_DTSRCSEL - PWM Source Select Register
 * - PWM_MCTRL - Master Control Register 0
 * - PWM_MCTRL2 - Master Control Register 1
 * - PWM_FCTRL - Fault Control Register
 * - PWM_FSTS - Fault Status Register
 * - PWM_FFILT - Fault Filter Register
 * - PWM_FTST - Fault Test Register
 * - PWM_FCTRL2 - Fault Control 2 Register
 */

#define PWM_INSTANCE_COUNT (2U) /*!< Number of instances of the PWM module. */
#define PWM0_IDX (0U) /*!< Instance number for PWM0. */
#define PWM1_IDX (1U) /*!< Instance number for PWM1. */

/*******************************************************************************
 * PWM_CNT - Counter Register
 ******************************************************************************/

/*!
 * @brief PWM_CNT - Counter Register (RO)
 *
 * Reset value: 0x0000U
 *
 * This read-only register displays the state of the signed 16-bit submodule
 * counter. This register is not byte accessible.
 */
/*!
 * @name Constants and macros for entire PWM_CNT register
 */
/*@{*/
#define PWM_RD_CNT(base, index)  (PWM_CNT_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_INIT - Initial Count Register
 ******************************************************************************/

/*!
 * @brief PWM_INIT - Initial Count Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The 16-bit signed value in this buffered, read/write register defines the
 * initial count value for the PWM in PWM clock periods. This is the value loaded
 * into the submodule counter when local sync, master sync, or master reload is
 * asserted (based on the value of CTRL2[INIT_SEL]) or when CTRL2[FORCE] is asserted
 * and force init is enabled. For PWM operation, the buffered contents of this
 * register are loaded into the counter at the start of every PWM cycle. This
 * register is not byte accessible. The INIT register is buffered. The value written
 * does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. This register cannot be written when MCTRL0[LDOK]
 * is set. Reading INIT reads the value in a buffer and not necessarily the value
 * the PWM generator is currently using.
 */
/*!
 * @name Constants and macros for entire PWM_INIT register
 */
/*@{*/
#define PWM_RD_INIT(base, index) (PWM_INIT_REG(base, index))
#define PWM_WR_INIT(base, index, value) (PWM_INIT_REG(base, index) = (value))
#define PWM_RMW_INIT(base, index, mask, value) (PWM_WR_INIT(base, index, (PWM_RD_INIT(base, index) & ~(mask)) | (value)))
#define PWM_SET_INIT(base, index, value) (BME_OR16(&PWM_INIT_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_INIT(base, index, value) (BME_AND16(&PWM_INIT_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_INIT(base, index, value) (BME_XOR16(&PWM_INIT_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_CTRL2 - Control 2 Register
 ******************************************************************************/

/*!
 * @brief PWM_CTRL2 - Control 2 Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CTRL2 register
 */
/*@{*/
#define PWM_RD_CTRL2(base, index) (PWM_CTRL2_REG(base, index))
#define PWM_WR_CTRL2(base, index, value) (PWM_CTRL2_REG(base, index) = (value))
#define PWM_RMW_CTRL2(base, index, mask, value) (PWM_WR_CTRL2(base, index, (PWM_RD_CTRL2(base, index) & ~(mask)) | (value)))
#define PWM_SET_CTRL2(base, index, value) (BME_OR16(&PWM_CTRL2_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CTRL2(base, index, value) (BME_AND16(&PWM_CTRL2_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CTRL2(base, index, value) (BME_XOR16(&PWM_CTRL2_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CTRL2 bitfields
 */

/*!
 * @name Register PWM_CTRL2, field CLK_SEL[1:0] (RW)
 *
 * These read/write bits determine the source of the clock signal for this
 * submodule.
 *
 * Values:
 * - 0b00 - The IPBus clock is used as the clock for the local prescaler and
 *     counter.
 * - 0b01 - EXT_CLK is used as the clock for the local prescaler and counter.
 * - 0b10 - Submodule 0's clock (AUX_CLK) is used as the source clock for the
 *     local prescaler and counter. This setting should not be used in submodule 0
 *     as it will force the clock to logic 0.
 * - 0b11 - reserved
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_CLK_SEL field. */
#define PWM_RD_CTRL2_CLK_SEL(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_CLK_SEL_MASK) >> PWM_CTRL2_CLK_SEL_SHIFT)
#define PWM_BRD_CTRL2_CLK_SEL(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_CLK_SEL_SHIFT, PWM_CTRL2_CLK_SEL_WIDTH))

/*! @brief Set the CLK_SEL field to a new value. */
#define PWM_WR_CTRL2_CLK_SEL(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_CLK_SEL_MASK, PWM_CTRL2_CLK_SEL(value)))
#define PWM_BWR_CTRL2_CLK_SEL(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_CLK_SEL_SHIFT), PWM_CTRL2_CLK_SEL_SHIFT, PWM_CTRL2_CLK_SEL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field RELOAD_SEL[2] (RW)
 *
 * This read/write bit determines the source of the RELOAD signal for this
 * submodule. When this bit is set, MCTRL0[LDOK[0]] for submodule 0 should be used
 * since the local MCTRL0[LDOK] will be ignored.
 *
 * Values:
 * - 0b0 - The local RELOAD signal is used to reload registers.
 * - 0b1 - The master RELOAD signal (from submodule 0) is used to reload
 *     registers. This setting should not be used in submodule 0 as it will force the
 *     RELOAD signal to logic 0.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_RELOAD_SEL field. */
#define PWM_RD_CTRL2_RELOAD_SEL(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_RELOAD_SEL_MASK) >> PWM_CTRL2_RELOAD_SEL_SHIFT)
#define PWM_BRD_CTRL2_RELOAD_SEL(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_RELOAD_SEL_SHIFT, PWM_CTRL2_RELOAD_SEL_WIDTH))

/*! @brief Set the RELOAD_SEL field to a new value. */
#define PWM_WR_CTRL2_RELOAD_SEL(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_RELOAD_SEL_MASK, PWM_CTRL2_RELOAD_SEL(value)))
#define PWM_BWR_CTRL2_RELOAD_SEL(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_RELOAD_SEL_SHIFT), PWM_CTRL2_RELOAD_SEL_SHIFT, PWM_CTRL2_RELOAD_SEL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field FORCE_SEL[5:3] (RW)
 *
 * Values:
 * - 0b000 - The local force signal, CTRL2[FORCE], from this submodule is used
 *     to force updates.
 * - 0b001 - The master force signal from submodule 0 is used to force updates.
 *     This setting should not be used in submodule 0 as it will hold the FORCE
 *     OUTPUT signal to logic 0.
 * - 0b010 - The local reload signal from this submodule is used to force
 *     updates without regard to the state of LDOK.
 * - 0b011 - The master reload signal from submodule0 is used to force updates
 *     if LDOK is set. This setting should not be used in submodule0 as it will
 *     hold the FORCE OUTPUT signal to logic 0.
 * - 0b100 - The local sync signal from this submodule is used to force updates.
 * - 0b101 - The master sync signal from submodule0 is used to force updates.
 *     This setting should not be used in submodule0 as it will hold the FORCE
 *     OUTPUT signal to logic 0.
 * - 0b110 - The external force signal, EXT_FORCE, from outside the PWM module
 *     causes updates.
 * - 0b111 - The external sync signal, EXT_SYNC, from outside the PWM module
 *     causes updates.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_FORCE_SEL field. */
#define PWM_RD_CTRL2_FORCE_SEL(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_FORCE_SEL_MASK) >> PWM_CTRL2_FORCE_SEL_SHIFT)
#define PWM_BRD_CTRL2_FORCE_SEL(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_FORCE_SEL_SHIFT, PWM_CTRL2_FORCE_SEL_WIDTH))

/*! @brief Set the FORCE_SEL field to a new value. */
#define PWM_WR_CTRL2_FORCE_SEL(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_FORCE_SEL_MASK, PWM_CTRL2_FORCE_SEL(value)))
#define PWM_BWR_CTRL2_FORCE_SEL(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_FORCE_SEL_SHIFT), PWM_CTRL2_FORCE_SEL_SHIFT, PWM_CTRL2_FORCE_SEL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field FORCE[6] (WORZ)
 *
 * If CTRL2[FORCE_SEL] is set to 000, writing a 1 to this bit results in a
 * FORCE_OUT event. This causes the following actions to be taken: The PWM_A and PWM_B
 * output pins will assume values based on DTSRCSEL[SMxSEL23] and
 * DTSRCSEL[SMxSEL45]. If CTRL2[FRCEN] is set, the counter value will be initialized with the
 * INIT register value.
 */
/*@{*/
/*! @brief Set the FORCE field to a new value. */
#define PWM_WR_CTRL2_FORCE(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_FORCE_MASK, PWM_CTRL2_FORCE(value)))
#define PWM_BWR_CTRL2_FORCE(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_FORCE_SHIFT), PWM_CTRL2_FORCE_SHIFT, PWM_CTRL2_FORCE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field FRCEN[7] (RW)
 *
 * This bit allows the CTRL2[FORCE] signal to initialize the counter without
 * regard to the signal selected by CTRL2[INIT_SEL]. This is a software controlled
 * initialization. A forced initialization will also assert the local reload if
 * MCTRL0[LDOK] is set.
 *
 * Values:
 * - 0b0 - Initialization from a FORCE_OUT is disabled.
 * - 0b1 - Initialization from a FORCE_OUT is enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_FRCEN field. */
#define PWM_RD_CTRL2_FRCEN(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_FRCEN_MASK) >> PWM_CTRL2_FRCEN_SHIFT)
#define PWM_BRD_CTRL2_FRCEN(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_FRCEN_SHIFT, PWM_CTRL2_FRCEN_WIDTH))

/*! @brief Set the FRCEN field to a new value. */
#define PWM_WR_CTRL2_FRCEN(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_FRCEN_MASK, PWM_CTRL2_FRCEN(value)))
#define PWM_BWR_CTRL2_FRCEN(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_FRCEN_SHIFT), PWM_CTRL2_FRCEN_SHIFT, PWM_CTRL2_FRCEN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field INIT_SEL[9:8] (RW)
 *
 * These read/write bits control the source of the INIT signal which goes to the
 * counter.
 *
 * Values:
 * - 0b00 - Local sync (PWM_X) causes initialization.
 * - 0b01 - Master reload from submodule 0 causes initialization. This setting
 *     should not be used in submodule 0 as it will force the INIT signal to logic
 *     0. The submodule counter will only reinitialize when a master reload
 *     occurs.
 * - 0b10 - Master sync from submodule 0 causes initialization. This setting
 *     should not be used in submodule 0 as it will force the INIT signal to logic 0.
 * - 0b11 - EXT_SYNC causes initialization.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_INIT_SEL field. */
#define PWM_RD_CTRL2_INIT_SEL(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_INIT_SEL_MASK) >> PWM_CTRL2_INIT_SEL_SHIFT)
#define PWM_BRD_CTRL2_INIT_SEL(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_INIT_SEL_SHIFT, PWM_CTRL2_INIT_SEL_WIDTH))

/*! @brief Set the INIT_SEL field to a new value. */
#define PWM_WR_CTRL2_INIT_SEL(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_INIT_SEL_MASK, PWM_CTRL2_INIT_SEL(value)))
#define PWM_BWR_CTRL2_INIT_SEL(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_INIT_SEL_SHIFT), PWM_CTRL2_INIT_SEL_SHIFT, PWM_CTRL2_INIT_SEL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field PWMX_INIT[10] (RW)
 *
 * This read/write bit determines the initial value for PWM_X and the value to
 * which it is forced when FORCE_INIT is asserted.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_PWMX_INIT field. */
#define PWM_RD_CTRL2_PWMX_INIT(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_PWMX_INIT_MASK) >> PWM_CTRL2_PWMX_INIT_SHIFT)
#define PWM_BRD_CTRL2_PWMX_INIT(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_PWMX_INIT_SHIFT, PWM_CTRL2_PWMX_INIT_WIDTH))

/*! @brief Set the PWMX_INIT field to a new value. */
#define PWM_WR_CTRL2_PWMX_INIT(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_PWMX_INIT_MASK, PWM_CTRL2_PWMX_INIT(value)))
#define PWM_BWR_CTRL2_PWMX_INIT(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_PWMX_INIT_SHIFT), PWM_CTRL2_PWMX_INIT_SHIFT, PWM_CTRL2_PWMX_INIT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field PWM45_INIT[11] (RW)
 *
 * This read/write bit determines the initial value for PWM45 and the value to
 * which it is forced when FORCE_INIT is asserted.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_PWM45_INIT field. */
#define PWM_RD_CTRL2_PWM45_INIT(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_PWM45_INIT_MASK) >> PWM_CTRL2_PWM45_INIT_SHIFT)
#define PWM_BRD_CTRL2_PWM45_INIT(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_PWM45_INIT_SHIFT, PWM_CTRL2_PWM45_INIT_WIDTH))

/*! @brief Set the PWM45_INIT field to a new value. */
#define PWM_WR_CTRL2_PWM45_INIT(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_PWM45_INIT_MASK, PWM_CTRL2_PWM45_INIT(value)))
#define PWM_BWR_CTRL2_PWM45_INIT(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_PWM45_INIT_SHIFT), PWM_CTRL2_PWM45_INIT_SHIFT, PWM_CTRL2_PWM45_INIT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field PWM23_INIT[12] (RW)
 *
 * This read/write bit determines the initial value for PWM23 and the value to
 * which it is forced when FORCE_INIT is asserted.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_PWM23_INIT field. */
#define PWM_RD_CTRL2_PWM23_INIT(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_PWM23_INIT_MASK) >> PWM_CTRL2_PWM23_INIT_SHIFT)
#define PWM_BRD_CTRL2_PWM23_INIT(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_PWM23_INIT_SHIFT, PWM_CTRL2_PWM23_INIT_WIDTH))

/*! @brief Set the PWM23_INIT field to a new value. */
#define PWM_WR_CTRL2_PWM23_INIT(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_PWM23_INIT_MASK, PWM_CTRL2_PWM23_INIT(value)))
#define PWM_BWR_CTRL2_PWM23_INIT(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_PWM23_INIT_SHIFT), PWM_CTRL2_PWM23_INIT_SHIFT, PWM_CTRL2_PWM23_INIT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field INDEP[13] (RW)
 *
 * This bit determines if the PWM_A and PWM_B channels will be independent PWMs
 * or a complementary PWM pair.
 *
 * Values:
 * - 0b0 - PWM_A and PWM_B form a complementary PWM pair.
 * - 0b1 - PWM_A and PWM_B outputs are independent PWMs.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_INDEP field. */
#define PWM_RD_CTRL2_INDEP(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_INDEP_MASK) >> PWM_CTRL2_INDEP_SHIFT)
#define PWM_BRD_CTRL2_INDEP(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_INDEP_SHIFT, PWM_CTRL2_INDEP_WIDTH))

/*! @brief Set the INDEP field to a new value. */
#define PWM_WR_CTRL2_INDEP(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_INDEP_MASK, PWM_CTRL2_INDEP(value)))
#define PWM_BWR_CTRL2_INDEP(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_INDEP_SHIFT), PWM_CTRL2_INDEP_SHIFT, PWM_CTRL2_INDEP_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field WAITEN[14] (RW)
 *
 * When set to one, the PWM will continue to run while the chip is in WAIT mode.
 * In this mode, the peripheral clock continues to run but the CPU clock does
 * not. If the device enters WAIT mode and this bit is zero, then the PWM outputs
 * will be disabled until WAIT mode is exited. At that point the PWM pins will
 * resume operation as programmed in the PWM registers. For certain types of motors
 * (such as 3-phase AC), it is imperative that this bit be left in its default
 * state (in which the PWM is disabled in WAIT mode). Failure to do so could result
 * in damage to the motor or inverter. For other types of motors (example: DC
 * motors), this bit might safely be set to one, enabling the PWM in WAIT mode. The
 * key point is PWM parameter updates will not occur in this mode. Any motors
 * requiring such updates should be disabled during WAIT mode. If in doubt, leave
 * this bit set to zero.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_WAITEN field. */
#define PWM_RD_CTRL2_WAITEN(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_WAITEN_MASK) >> PWM_CTRL2_WAITEN_SHIFT)
#define PWM_BRD_CTRL2_WAITEN(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_WAITEN_SHIFT, PWM_CTRL2_WAITEN_WIDTH))

/*! @brief Set the WAITEN field to a new value. */
#define PWM_WR_CTRL2_WAITEN(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_WAITEN_MASK, PWM_CTRL2_WAITEN(value)))
#define PWM_BWR_CTRL2_WAITEN(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_WAITEN_SHIFT), PWM_CTRL2_WAITEN_SHIFT, PWM_CTRL2_WAITEN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL2, field DBGEN[15] (RW)
 *
 * When set to one, the PWM will continue to run while the chip is in debug
 * mode. If the device enters debug mode and this bit is zero, then the PWM outputs
 * will be disabled until debug mode is exited. At that point the PWM pins will
 * resume operation as programmed in the PWM registers. For certain types of motors
 * (such as 3-phase AC), it is imperative that this bit be left in its default
 * state (in which the PWM is disabled in debug mode). Failure to do so could
 * result in damage to the motor or inverter. For other types of motors (example: DC
 * motors), this bit might safely be set to one, enabling the PWM in debug mode.
 * The key point is PWM parameter updates will not occur in debug mode. Any
 * motors requiring such updates should be disabled during debug mode. If in doubt,
 * leave this bit set to zero.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL2_DBGEN field. */
#define PWM_RD_CTRL2_DBGEN(base, index) ((PWM_CTRL2_REG(base, index) & PWM_CTRL2_DBGEN_MASK) >> PWM_CTRL2_DBGEN_SHIFT)
#define PWM_BRD_CTRL2_DBGEN(base, index) (BME_UBFX16(&PWM_CTRL2_REG(base, index), PWM_CTRL2_DBGEN_SHIFT, PWM_CTRL2_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define PWM_WR_CTRL2_DBGEN(base, index, value) (PWM_RMW_CTRL2(base, index, PWM_CTRL2_DBGEN_MASK, PWM_CTRL2_DBGEN(value)))
#define PWM_BWR_CTRL2_DBGEN(base, index, value) (BME_BFI16(&PWM_CTRL2_REG(base, index), ((uint16_t)(value) << PWM_CTRL2_DBGEN_SHIFT), PWM_CTRL2_DBGEN_SHIFT, PWM_CTRL2_DBGEN_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief PWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire PWM_CTRL register
 */
/*@{*/
#define PWM_RD_CTRL(base, index) (PWM_CTRL_REG(base, index))
#define PWM_WR_CTRL(base, index, value) (PWM_CTRL_REG(base, index) = (value))
#define PWM_RMW_CTRL(base, index, mask, value) (PWM_WR_CTRL(base, index, (PWM_RD_CTRL(base, index) & ~(mask)) | (value)))
#define PWM_SET_CTRL(base, index, value) (BME_OR16(&PWM_CTRL_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CTRL(base, index, value) (BME_AND16(&PWM_CTRL_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CTRL(base, index, value) (BME_XOR16(&PWM_CTRL_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CTRL bitfields
 */

/*!
 * @name Register PWM_CTRL, field DBLEN[0] (RW)
 *
 * This read/write bit enables the double switching PWM behavior(See Double
 * Switching PWMs). Double switching is not compatible with fractional PWM clock
 * generation. Make sure this bit is clear when setting FRCTRL[FRAC23_EN],
 * FRCTRL[FRAC45_EN], or FRCTRL[FRAC1_EN].
 *
 * Values:
 * - 0b0 - Double switching disabled.
 * - 0b1 - Double switching enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_DBLEN field. */
#define PWM_RD_CTRL_DBLEN(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_DBLEN_MASK) >> PWM_CTRL_DBLEN_SHIFT)
#define PWM_BRD_CTRL_DBLEN(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_DBLEN_SHIFT, PWM_CTRL_DBLEN_WIDTH))

/*! @brief Set the DBLEN field to a new value. */
#define PWM_WR_CTRL_DBLEN(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_DBLEN_MASK, PWM_CTRL_DBLEN(value)))
#define PWM_BWR_CTRL_DBLEN(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_DBLEN_SHIFT), PWM_CTRL_DBLEN_SHIFT, PWM_CTRL_DBLEN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field DBLX[1] (RW)
 *
 * This read/write bit enables the double switching behavior on PWMX. When this
 * bit is set, the PWMX output shall be the exclusive OR combination of PWM0 and
 * PWM1 prior to polarity and masking considerations.
 *
 * Values:
 * - 0b0 - PWMX double pulse disabled.
 * - 0b1 - PWMX double pulse enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_DBLX field. */
#define PWM_RD_CTRL_DBLX(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_DBLX_MASK) >> PWM_CTRL_DBLX_SHIFT)
#define PWM_BRD_CTRL_DBLX(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_DBLX_SHIFT, PWM_CTRL_DBLX_WIDTH))

/*! @brief Set the DBLX field to a new value. */
#define PWM_WR_CTRL_DBLX(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_DBLX_MASK, PWM_CTRL_DBLX(value)))
#define PWM_BWR_CTRL_DBLX(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_DBLX_SHIFT), PWM_CTRL_DBLX_SHIFT, PWM_CTRL_DBLX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field LDMOD[2] (RW)
 *
 * This read/write bit selects the timing of loading the buffered registers for
 * this submodule.
 *
 * Values:
 * - 0b0 - Buffered registers of this submodule are loaded and take effect at
 *     the next PWM reload if MCTRL0[LDOK] is set.
 * - 0b1 - Buffered registers of this submodule are loaded and take effect
 *     immediately upon MCTRL0[LDOK] being set. In this case it is not necessary to
 *     set CTRL[FULL] or CTRL[HALF].
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_LDMOD field. */
#define PWM_RD_CTRL_LDMOD(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_LDMOD_MASK) >> PWM_CTRL_LDMOD_SHIFT)
#define PWM_BRD_CTRL_LDMOD(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_LDMOD_SHIFT, PWM_CTRL_LDMOD_WIDTH))

/*! @brief Set the LDMOD field to a new value. */
#define PWM_WR_CTRL_LDMOD(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_LDMOD_MASK, PWM_CTRL_LDMOD(value)))
#define PWM_BWR_CTRL_LDMOD(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_LDMOD_SHIFT), PWM_CTRL_LDMOD_SHIFT, PWM_CTRL_LDMOD_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field PRSC[6:4] (RW)
 *
 * These buffered read/write bits select the divide ratio of the PWM clock
 * frequency selected by CTRL2[CLK_SEL]. Reading CTRL[PRSC] reads the buffered values
 * and not necessarily the values currently in effect. CTRL[PRSC] takes effect at
 * the beginning of the next PWM cycle and only when the load okay bit,
 * MCTRL0[LDOK], is set or CTRL[LDMOD] is set. This field cannot be written when
 * MCTRL0[LDOK] is set.
 *
 * Values:
 * - 0b000 - PWM clock frequency = fclk
 * - 0b001 - PWM clock frequency = fclk/2
 * - 0b010 - PWM clock frequency = fclk/4
 * - 0b011 - PWM clock frequency = fclk/8
 * - 0b100 - PWM clock frequency = fclk/16
 * - 0b101 - PWM clock frequency = fclk/32
 * - 0b110 - PWM clock frequency = fclk/64
 * - 0b111 - PWM clock frequency = fclk/128
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_PRSC field. */
#define PWM_RD_CTRL_PRSC(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_PRSC_MASK) >> PWM_CTRL_PRSC_SHIFT)
#define PWM_BRD_CTRL_PRSC(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_PRSC_SHIFT, PWM_CTRL_PRSC_WIDTH))

/*! @brief Set the PRSC field to a new value. */
#define PWM_WR_CTRL_PRSC(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_PRSC_MASK, PWM_CTRL_PRSC(value)))
#define PWM_BWR_CTRL_PRSC(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_PRSC_SHIFT), PWM_CTRL_PRSC_SHIFT, PWM_CTRL_PRSC_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field DT[9:8] (RO)
 *
 * These read only bits reflect the sampled values of the PWM_X input at the end
 * of each deadtime. Sampling occurs at the end of deadtime 0 for DT[0] and the
 * end of deadtime 1 for DT[1]. Reset clears these bits.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_DT field. */
#define PWM_RD_CTRL_DT(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_DT_MASK) >> PWM_CTRL_DT_SHIFT)
#define PWM_BRD_CTRL_DT(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_DT_SHIFT, PWM_CTRL_DT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field FULL[10] (RW)
 *
 * This read/write bit enables full-cycle reloads. A full cycle is defined by
 * when the submodule counter matches the VAL1 register. Either CTRL[HALF] or
 * CTRL[FULL] must be set in order to move the buffered data into the registers used
 * by the PWM generators or CTRL[LDMOD] must be set. If both CTRL[HALF] and
 * CTRL[FULL] are set, then reloads can occur twice per cycle.
 *
 * Values:
 * - 0b0 - Full-cycle reloads disabled.
 * - 0b1 - Full-cycle reloads enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_FULL field. */
#define PWM_RD_CTRL_FULL(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_FULL_MASK) >> PWM_CTRL_FULL_SHIFT)
#define PWM_BRD_CTRL_FULL(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_FULL_SHIFT, PWM_CTRL_FULL_WIDTH))

/*! @brief Set the FULL field to a new value. */
#define PWM_WR_CTRL_FULL(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_FULL_MASK, PWM_CTRL_FULL(value)))
#define PWM_BWR_CTRL_FULL(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_FULL_SHIFT), PWM_CTRL_FULL_SHIFT, PWM_CTRL_FULL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field HALF[11] (RW)
 *
 * This read/write bit enables half-cycle reloads. A half cycle is defined by
 * when the submodule counter matches the VAL0 register and does not have to be
 * half way through the PWM cycle.
 *
 * Values:
 * - 0b0 - Half-cycle reloads disabled.
 * - 0b1 - Half-cycle reloads enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_HALF field. */
#define PWM_RD_CTRL_HALF(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_HALF_MASK) >> PWM_CTRL_HALF_SHIFT)
#define PWM_BRD_CTRL_HALF(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_HALF_SHIFT, PWM_CTRL_HALF_WIDTH))

/*! @brief Set the HALF field to a new value. */
#define PWM_WR_CTRL_HALF(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_HALF_MASK, PWM_CTRL_HALF(value)))
#define PWM_BWR_CTRL_HALF(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_HALF_SHIFT), PWM_CTRL_HALF_SHIFT, PWM_CTRL_HALF_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CTRL, field LDFQ[15:12] (RW)
 *
 * These buffered read/write bits select the PWM load frequency. Reset clears
 * LDFQ, selecting loading every PWM opportunity. A PWM opportunity is determined
 * by HALF and FULL. LDFQ takes effect when the current load cycle is complete,
 * regardless of the state of MCTRL0[LDOK]. Reading LDFQ reads the buffered values
 * and not necessarily the values currently in effect.
 *
 * Values:
 * - 0b0000 - Every PWM opportunity
 * - 0b0001 - Every 2 PWM opportunities
 * - 0b0010 - Every 3 PWM opportunities
 * - 0b0011 - Every 4 PWM opportunities
 * - 0b0100 - Every 5 PWM opportunities
 * - 0b0101 - Every 6 PWM opportunities
 * - 0b0110 - Every 7 PWM opportunities
 * - 0b0111 - Every 8 PWM opportunities
 * - 0b1000 - Every 9 PWM opportunities
 * - 0b1001 - Every 10 PWM opportunities
 * - 0b1010 - Every 11 PWM opportunities
 * - 0b1011 - Every 12 PWM opportunities
 * - 0b1100 - Every 13 PWM opportunities
 * - 0b1101 - Every 14 PWM opportunities
 * - 0b1110 - Every 15 PWM opportunities
 * - 0b1111 - Every 16 PWM opportunities
 */
/*@{*/
/*! @brief Read current value of the PWM_CTRL_LDFQ field. */
#define PWM_RD_CTRL_LDFQ(base, index) ((PWM_CTRL_REG(base, index) & PWM_CTRL_LDFQ_MASK) >> PWM_CTRL_LDFQ_SHIFT)
#define PWM_BRD_CTRL_LDFQ(base, index) (BME_UBFX16(&PWM_CTRL_REG(base, index), PWM_CTRL_LDFQ_SHIFT, PWM_CTRL_LDFQ_WIDTH))

/*! @brief Set the LDFQ field to a new value. */
#define PWM_WR_CTRL_LDFQ(base, index, value) (PWM_RMW_CTRL(base, index, PWM_CTRL_LDFQ_MASK, PWM_CTRL_LDFQ(value)))
#define PWM_BWR_CTRL_LDFQ(base, index, value) (BME_BFI16(&PWM_CTRL_REG(base, index), ((uint16_t)(value) << PWM_CTRL_LDFQ_SHIFT), PWM_CTRL_LDFQ_SHIFT, PWM_CTRL_LDFQ_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL0 - Value Register 0
 ******************************************************************************/

/*!
 * @brief PWM_VAL0 - Value Register 0 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL0 register
 */
/*@{*/
#define PWM_RD_VAL0(base, index) (PWM_VAL0_REG(base, index))
#define PWM_WR_VAL0(base, index, value) (PWM_VAL0_REG(base, index) = (value))
#define PWM_RMW_VAL0(base, index, mask, value) (PWM_WR_VAL0(base, index, (PWM_RD_VAL0(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL0(base, index, value) (BME_OR16(&PWM_VAL0_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL0(base, index, value) (BME_AND16(&PWM_VAL0_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL0(base, index, value) (BME_XOR16(&PWM_VAL0_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRACVAL1 - Fractional Value Register 1
 ******************************************************************************/

/*!
 * @brief PWM_FRACVAL1 - Fractional Value Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRACVAL1 register
 */
/*@{*/
#define PWM_RD_FRACVAL1(base, index) (PWM_FRACVAL1_REG(base, index))
#define PWM_WR_FRACVAL1(base, index, value) (PWM_FRACVAL1_REG(base, index) = (value))
#define PWM_RMW_FRACVAL1(base, index, mask, value) (PWM_WR_FRACVAL1(base, index, (PWM_RD_FRACVAL1(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRACVAL1(base, index, value) (BME_OR16(&PWM_FRACVAL1_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRACVAL1(base, index, value) (BME_AND16(&PWM_FRACVAL1_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRACVAL1(base, index, value) (BME_XOR16(&PWM_FRACVAL1_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRACVAL1 bitfields
 */

/*!
 * @name Register PWM_FRACVAL1, field FRACVAL1[15:11] (RW)
 *
 * These bits act as a fractional addition to the value in the VAL1 register
 * which controls the PWM period width. The PWM period is computed in terms of IPBus
 * clock cycles. This fractional portion is accumulated at the end of every
 * cycle until an additional whole IPBus cycle is reached. At this time the value
 * being used for VAL1 is temporarily incremented and the PWM cycle is extended by
 * one clock period to compensate for the accumulated fractional values. The
 * FRACVAL1 register is buffered. The value written does not take effect until
 * MCTRL0[LDOK] is set and the next PWM load cycle begins or CTRL[LDMOD] is set.
 * FRACVAL1 cannot be written when MCTRL0[LDOK] is set. Reading FRACVAL1 reads the value
 * in a buffer and not necessarily the value the PWM generator is currently
 * using. If the VAL1 register defines the timer period (Local Sync is selected as
 * the counter initialization signal), a 100% duty cycle cannot be achieved on the
 * PWMX output. After the count reaches VAL1, the PWMX output is low for a
 * minimum of one count every cycle. When the Master Sync signal (only originated by
 * the Local Sync from sub-module 0) is used to control the timer period, the VAL1
 * register can be free for other functions such as PWM generation without the
 * duty cycle limitation.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRACVAL1_FRACVAL1 field. */
#define PWM_RD_FRACVAL1_FRACVAL1(base, index) ((PWM_FRACVAL1_REG(base, index) & PWM_FRACVAL1_FRACVAL1_MASK) >> PWM_FRACVAL1_FRACVAL1_SHIFT)
#define PWM_BRD_FRACVAL1_FRACVAL1(base, index) (BME_UBFX16(&PWM_FRACVAL1_REG(base, index), PWM_FRACVAL1_FRACVAL1_SHIFT, PWM_FRACVAL1_FRACVAL1_WIDTH))

/*! @brief Set the FRACVAL1 field to a new value. */
#define PWM_WR_FRACVAL1_FRACVAL1(base, index, value) (PWM_RMW_FRACVAL1(base, index, PWM_FRACVAL1_FRACVAL1_MASK, PWM_FRACVAL1_FRACVAL1(value)))
#define PWM_BWR_FRACVAL1_FRACVAL1(base, index, value) (BME_BFI16(&PWM_FRACVAL1_REG(base, index), ((uint16_t)(value) << PWM_FRACVAL1_FRACVAL1_SHIFT), PWM_FRACVAL1_FRACVAL1_SHIFT, PWM_FRACVAL1_FRACVAL1_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL1 - Value Register 1
 ******************************************************************************/

/*!
 * @brief PWM_VAL1 - Value Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL1 register
 */
/*@{*/
#define PWM_RD_VAL1(base, index) (PWM_VAL1_REG(base, index))
#define PWM_WR_VAL1(base, index, value) (PWM_VAL1_REG(base, index) = (value))
#define PWM_RMW_VAL1(base, index, mask, value) (PWM_WR_VAL1(base, index, (PWM_RD_VAL1(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL1(base, index, value) (BME_OR16(&PWM_VAL1_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL1(base, index, value) (BME_AND16(&PWM_VAL1_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL1(base, index, value) (BME_XOR16(&PWM_VAL1_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRACVAL2 - Fractional Value Register 2
 ******************************************************************************/

/*!
 * @brief PWM_FRACVAL2 - Fractional Value Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRACVAL2 register
 */
/*@{*/
#define PWM_RD_FRACVAL2(base, index) (PWM_FRACVAL2_REG(base, index))
#define PWM_WR_FRACVAL2(base, index, value) (PWM_FRACVAL2_REG(base, index) = (value))
#define PWM_RMW_FRACVAL2(base, index, mask, value) (PWM_WR_FRACVAL2(base, index, (PWM_RD_FRACVAL2(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRACVAL2(base, index, value) (BME_OR16(&PWM_FRACVAL2_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRACVAL2(base, index, value) (BME_AND16(&PWM_FRACVAL2_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRACVAL2(base, index, value) (BME_XOR16(&PWM_FRACVAL2_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRACVAL2 bitfields
 */

/*!
 * @name Register PWM_FRACVAL2, field FRACVAL2[15:11] (RW)
 *
 * These bits act as a fractional addition to the value in the VAL2 register
 * which controls the PWM_A turn on timing. It is also used to control the
 * fractional addition to the turn off delay of PWM_B when MCTRL0[IPOLx]=0 in
 * complementary mode, CTRL2[INDEP]=0. The FRACVAL2 register is buffered. The value written
 * does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRACVAL2 cannot be written when MCTRL0[LDOK] is set.
 * Reading FRACVAL2 reads the value in a buffer and not necessarily the value
 * the PWM generator is currently using. FRCTRL[FRAC23_EN] should be set to 0 when
 * the values of VAL2 and VAL3 cause the high or low time of the PWM output to be
 * 3 cycles or less.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRACVAL2_FRACVAL2 field. */
#define PWM_RD_FRACVAL2_FRACVAL2(base, index) ((PWM_FRACVAL2_REG(base, index) & PWM_FRACVAL2_FRACVAL2_MASK) >> PWM_FRACVAL2_FRACVAL2_SHIFT)
#define PWM_BRD_FRACVAL2_FRACVAL2(base, index) (BME_UBFX16(&PWM_FRACVAL2_REG(base, index), PWM_FRACVAL2_FRACVAL2_SHIFT, PWM_FRACVAL2_FRACVAL2_WIDTH))

/*! @brief Set the FRACVAL2 field to a new value. */
#define PWM_WR_FRACVAL2_FRACVAL2(base, index, value) (PWM_RMW_FRACVAL2(base, index, PWM_FRACVAL2_FRACVAL2_MASK, PWM_FRACVAL2_FRACVAL2(value)))
#define PWM_BWR_FRACVAL2_FRACVAL2(base, index, value) (BME_BFI16(&PWM_FRACVAL2_REG(base, index), ((uint16_t)(value) << PWM_FRACVAL2_FRACVAL2_SHIFT), PWM_FRACVAL2_FRACVAL2_SHIFT, PWM_FRACVAL2_FRACVAL2_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL2 - Value Register 2
 ******************************************************************************/

/*!
 * @brief PWM_VAL2 - Value Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL2 register
 */
/*@{*/
#define PWM_RD_VAL2(base, index) (PWM_VAL2_REG(base, index))
#define PWM_WR_VAL2(base, index, value) (PWM_VAL2_REG(base, index) = (value))
#define PWM_RMW_VAL2(base, index, mask, value) (PWM_WR_VAL2(base, index, (PWM_RD_VAL2(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL2(base, index, value) (BME_OR16(&PWM_VAL2_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL2(base, index, value) (BME_AND16(&PWM_VAL2_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL2(base, index, value) (BME_XOR16(&PWM_VAL2_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRACVAL3 - Fractional Value Register 3
 ******************************************************************************/

/*!
 * @brief PWM_FRACVAL3 - Fractional Value Register 3 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRACVAL3 register
 */
/*@{*/
#define PWM_RD_FRACVAL3(base, index) (PWM_FRACVAL3_REG(base, index))
#define PWM_WR_FRACVAL3(base, index, value) (PWM_FRACVAL3_REG(base, index) = (value))
#define PWM_RMW_FRACVAL3(base, index, mask, value) (PWM_WR_FRACVAL3(base, index, (PWM_RD_FRACVAL3(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRACVAL3(base, index, value) (BME_OR16(&PWM_FRACVAL3_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRACVAL3(base, index, value) (BME_AND16(&PWM_FRACVAL3_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRACVAL3(base, index, value) (BME_XOR16(&PWM_FRACVAL3_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRACVAL3 bitfields
 */

/*!
 * @name Register PWM_FRACVAL3, field FRACVAL3[15:11] (RW)
 *
 * These bits act as a fractional addition to the value in the VAL3 register
 * which controls the PWM_A turn off timing. It is also used to control the
 * fractional addition to the turn on delay of PWM_B when MCTRL0[IPOLx]=0 in
 * complementary mode, CTRL2[INDEP]=0. The FRACVAL3 register is buffered. The value written
 * does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRACVAL3 cannot be written when MCTRL0[LDOK] is set.
 * Reading FRACVAL3 reads the value in a buffer and not necessarily the value
 * the PWM generator is currently using. FRCTRL[FRAC23_EN] should be set to 0 when
 * the values of VAL2 and VAL3 cause the high or low time of the PWM output to be
 * 3 cycles or less.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRACVAL3_FRACVAL3 field. */
#define PWM_RD_FRACVAL3_FRACVAL3(base, index) ((PWM_FRACVAL3_REG(base, index) & PWM_FRACVAL3_FRACVAL3_MASK) >> PWM_FRACVAL3_FRACVAL3_SHIFT)
#define PWM_BRD_FRACVAL3_FRACVAL3(base, index) (BME_UBFX16(&PWM_FRACVAL3_REG(base, index), PWM_FRACVAL3_FRACVAL3_SHIFT, PWM_FRACVAL3_FRACVAL3_WIDTH))

/*! @brief Set the FRACVAL3 field to a new value. */
#define PWM_WR_FRACVAL3_FRACVAL3(base, index, value) (PWM_RMW_FRACVAL3(base, index, PWM_FRACVAL3_FRACVAL3_MASK, PWM_FRACVAL3_FRACVAL3(value)))
#define PWM_BWR_FRACVAL3_FRACVAL3(base, index, value) (BME_BFI16(&PWM_FRACVAL3_REG(base, index), ((uint16_t)(value) << PWM_FRACVAL3_FRACVAL3_SHIFT), PWM_FRACVAL3_FRACVAL3_SHIFT, PWM_FRACVAL3_FRACVAL3_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL3 - Value Register 3
 ******************************************************************************/

/*!
 * @brief PWM_VAL3 - Value Register 3 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL3 register
 */
/*@{*/
#define PWM_RD_VAL3(base, index) (PWM_VAL3_REG(base, index))
#define PWM_WR_VAL3(base, index, value) (PWM_VAL3_REG(base, index) = (value))
#define PWM_RMW_VAL3(base, index, mask, value) (PWM_WR_VAL3(base, index, (PWM_RD_VAL3(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL3(base, index, value) (BME_OR16(&PWM_VAL3_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL3(base, index, value) (BME_AND16(&PWM_VAL3_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL3(base, index, value) (BME_XOR16(&PWM_VAL3_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRACVAL4 - Fractional Value Register 4
 ******************************************************************************/

/*!
 * @brief PWM_FRACVAL4 - Fractional Value Register 4 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRACVAL4 register
 */
/*@{*/
#define PWM_RD_FRACVAL4(base, index) (PWM_FRACVAL4_REG(base, index))
#define PWM_WR_FRACVAL4(base, index, value) (PWM_FRACVAL4_REG(base, index) = (value))
#define PWM_RMW_FRACVAL4(base, index, mask, value) (PWM_WR_FRACVAL4(base, index, (PWM_RD_FRACVAL4(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRACVAL4(base, index, value) (BME_OR16(&PWM_FRACVAL4_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRACVAL4(base, index, value) (BME_AND16(&PWM_FRACVAL4_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRACVAL4(base, index, value) (BME_XOR16(&PWM_FRACVAL4_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRACVAL4 bitfields
 */

/*!
 * @name Register PWM_FRACVAL4, field FRACVAL4[15:11] (RW)
 *
 * These bits act as a fractional addition to the value in the VAL4 register
 * which controls the PWM_B turn on timing. It is also used to control the
 * fractional addition to the turn off delay of PWM_A when MCTRL0[IPOLx]=1 in
 * complementary mode, CTRL2[INDEP]=0. The FRACVAL4 register is buffered. The value written
 * does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRACVAL4 cannot be written when MCTRL0[LDOK] is set.
 * Reading FRACVAL4 reads the value in a buffer and not necessarily the value
 * the PWM generator is currently using. FRCTRL[FRAC45_EN] should be set to 0 when
 * the values of VAL4 and VAL5 cause the high or low time of the PWM output to be
 * 3 cycles or less.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRACVAL4_FRACVAL4 field. */
#define PWM_RD_FRACVAL4_FRACVAL4(base, index) ((PWM_FRACVAL4_REG(base, index) & PWM_FRACVAL4_FRACVAL4_MASK) >> PWM_FRACVAL4_FRACVAL4_SHIFT)
#define PWM_BRD_FRACVAL4_FRACVAL4(base, index) (BME_UBFX16(&PWM_FRACVAL4_REG(base, index), PWM_FRACVAL4_FRACVAL4_SHIFT, PWM_FRACVAL4_FRACVAL4_WIDTH))

/*! @brief Set the FRACVAL4 field to a new value. */
#define PWM_WR_FRACVAL4_FRACVAL4(base, index, value) (PWM_RMW_FRACVAL4(base, index, PWM_FRACVAL4_FRACVAL4_MASK, PWM_FRACVAL4_FRACVAL4(value)))
#define PWM_BWR_FRACVAL4_FRACVAL4(base, index, value) (BME_BFI16(&PWM_FRACVAL4_REG(base, index), ((uint16_t)(value) << PWM_FRACVAL4_FRACVAL4_SHIFT), PWM_FRACVAL4_FRACVAL4_SHIFT, PWM_FRACVAL4_FRACVAL4_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL4 - Value Register 4
 ******************************************************************************/

/*!
 * @brief PWM_VAL4 - Value Register 4 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL4 register
 */
/*@{*/
#define PWM_RD_VAL4(base, index) (PWM_VAL4_REG(base, index))
#define PWM_WR_VAL4(base, index, value) (PWM_VAL4_REG(base, index) = (value))
#define PWM_RMW_VAL4(base, index, mask, value) (PWM_WR_VAL4(base, index, (PWM_RD_VAL4(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL4(base, index, value) (BME_OR16(&PWM_VAL4_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL4(base, index, value) (BME_AND16(&PWM_VAL4_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL4(base, index, value) (BME_XOR16(&PWM_VAL4_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRACVAL5 - Fractional Value Register 5
 ******************************************************************************/

/*!
 * @brief PWM_FRACVAL5 - Fractional Value Register 5 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRACVAL5 register
 */
/*@{*/
#define PWM_RD_FRACVAL5(base, index) (PWM_FRACVAL5_REG(base, index))
#define PWM_WR_FRACVAL5(base, index, value) (PWM_FRACVAL5_REG(base, index) = (value))
#define PWM_RMW_FRACVAL5(base, index, mask, value) (PWM_WR_FRACVAL5(base, index, (PWM_RD_FRACVAL5(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRACVAL5(base, index, value) (BME_OR16(&PWM_FRACVAL5_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRACVAL5(base, index, value) (BME_AND16(&PWM_FRACVAL5_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRACVAL5(base, index, value) (BME_XOR16(&PWM_FRACVAL5_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRACVAL5 bitfields
 */

/*!
 * @name Register PWM_FRACVAL5, field FRACVAL5[15:11] (RW)
 *
 * These bits act as a fractional addition to the value in the VAL5 register
 * which controls the PWM_B turn off timing. It is also used to control the
 * fractional addition to the turn on delay of PWM_A when MCTRL0[IPOLx]=1 in
 * complementary mode, CTRL2[INDEP]=0. The FRACVAL5 register is buffered. The value written
 * does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRACVAL5 cannot be written when MCTRL0[LDOK] is set.
 * Reading FRACVAL5 reads the value in a buffer and not necessarily the value
 * the PWM generator is currently using. FRCTRL[FRAC45_EN] should be set to 0 when
 * the values of VAL4 and VAL5 cause the high or low time of the PWM output to be
 * 3 cycles or less.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRACVAL5_FRACVAL5 field. */
#define PWM_RD_FRACVAL5_FRACVAL5(base, index) ((PWM_FRACVAL5_REG(base, index) & PWM_FRACVAL5_FRACVAL5_MASK) >> PWM_FRACVAL5_FRACVAL5_SHIFT)
#define PWM_BRD_FRACVAL5_FRACVAL5(base, index) (BME_UBFX16(&PWM_FRACVAL5_REG(base, index), PWM_FRACVAL5_FRACVAL5_SHIFT, PWM_FRACVAL5_FRACVAL5_WIDTH))

/*! @brief Set the FRACVAL5 field to a new value. */
#define PWM_WR_FRACVAL5_FRACVAL5(base, index, value) (PWM_RMW_FRACVAL5(base, index, PWM_FRACVAL5_FRACVAL5_MASK, PWM_FRACVAL5_FRACVAL5(value)))
#define PWM_BWR_FRACVAL5_FRACVAL5(base, index, value) (BME_BFI16(&PWM_FRACVAL5_REG(base, index), ((uint16_t)(value) << PWM_FRACVAL5_FRACVAL5_SHIFT), PWM_FRACVAL5_FRACVAL5_SHIFT, PWM_FRACVAL5_FRACVAL5_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_VAL5 - Value Register 5
 ******************************************************************************/

/*!
 * @brief PWM_VAL5 - Value Register 5 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_VAL5 register
 */
/*@{*/
#define PWM_RD_VAL5(base, index) (PWM_VAL5_REG(base, index))
#define PWM_WR_VAL5(base, index, value) (PWM_VAL5_REG(base, index) = (value))
#define PWM_RMW_VAL5(base, index, mask, value) (PWM_WR_VAL5(base, index, (PWM_RD_VAL5(base, index) & ~(mask)) | (value)))
#define PWM_SET_VAL5(base, index, value) (BME_OR16(&PWM_VAL5_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_VAL5(base, index, value) (BME_AND16(&PWM_VAL5_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_VAL5(base, index, value) (BME_XOR16(&PWM_VAL5_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_FRCTRL - Fractional Control Register
 ******************************************************************************/

/*!
 * @brief PWM_FRCTRL - Fractional Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FRCTRL register
 */
/*@{*/
#define PWM_RD_FRCTRL(base, index) (PWM_FRCTRL_REG(base, index))
#define PWM_WR_FRCTRL(base, index, value) (PWM_FRCTRL_REG(base, index) = (value))
#define PWM_RMW_FRCTRL(base, index, mask, value) (PWM_WR_FRCTRL(base, index, (PWM_RD_FRCTRL(base, index) & ~(mask)) | (value)))
#define PWM_SET_FRCTRL(base, index, value) (BME_OR16(&PWM_FRCTRL_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_FRCTRL(base, index, value) (BME_AND16(&PWM_FRCTRL_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_FRCTRL(base, index, value) (BME_XOR16(&PWM_FRCTRL_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FRCTRL bitfields
 */

/*!
 * @name Register PWM_FRCTRL, field FRAC1_EN[1] (RW)
 *
 * This bit is used to enable the fractional cycle length of the PWM period
 * using the FRACVAL1 register. When disabled, the fractional cycle length of the PWM
 * period is bypassed. The FRAC1_EN bit is buffered. The value written does not
 * take effect until MCTRL0[LDOK] is set and the next PWM load cycle begins or
 * CTRL[LDMOD] is set. FRAC1_EN cannot be written when MCTRL0[LDOK] is set. Reading
 * FRAC1_EN reads the value in a buffer and not necessarily the value the PWM
 * generator is currently using.
 *
 * Values:
 * - 0b0 - Disable fractional cycle length for the PWM period.
 * - 0b1 - Enable fractional cycle length for the PWM period.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRCTRL_FRAC1_EN field. */
#define PWM_RD_FRCTRL_FRAC1_EN(base, index) ((PWM_FRCTRL_REG(base, index) & PWM_FRCTRL_FRAC1_EN_MASK) >> PWM_FRCTRL_FRAC1_EN_SHIFT)
#define PWM_BRD_FRCTRL_FRAC1_EN(base, index) (BME_UBFX16(&PWM_FRCTRL_REG(base, index), PWM_FRCTRL_FRAC1_EN_SHIFT, PWM_FRCTRL_FRAC1_EN_WIDTH))

/*! @brief Set the FRAC1_EN field to a new value. */
#define PWM_WR_FRCTRL_FRAC1_EN(base, index, value) (PWM_RMW_FRCTRL(base, index, PWM_FRCTRL_FRAC1_EN_MASK, PWM_FRCTRL_FRAC1_EN(value)))
#define PWM_BWR_FRCTRL_FRAC1_EN(base, index, value) (BME_BFI16(&PWM_FRCTRL_REG(base, index), ((uint16_t)(value) << PWM_FRCTRL_FRAC1_EN_SHIFT), PWM_FRCTRL_FRAC1_EN_SHIFT, PWM_FRCTRL_FRAC1_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FRCTRL, field FRAC23_EN[2] (RW)
 *
 * This bit is used to enable the fractional cycle edge placement of PWM_A using
 * the FRACVAL2 and FRACVAL3 registers. When disabled, the fractional cycle edge
 * placement of PWM_A is bypassed. The FRAC23_EN bit is buffered. The value
 * written does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRAC23_EN cannot be written when MCTRL0[LDOK]
 * is set. Reading FRAC23_EN reads the value in a buffer and not necessarily the
 * value the PWM generator is currently using.
 *
 * Values:
 * - 0b0 - Disable fractional cycle placement for PWM_A.
 * - 0b1 - Enable fractional cycle placement for PWM_A.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRCTRL_FRAC23_EN field. */
#define PWM_RD_FRCTRL_FRAC23_EN(base, index) ((PWM_FRCTRL_REG(base, index) & PWM_FRCTRL_FRAC23_EN_MASK) >> PWM_FRCTRL_FRAC23_EN_SHIFT)
#define PWM_BRD_FRCTRL_FRAC23_EN(base, index) (BME_UBFX16(&PWM_FRCTRL_REG(base, index), PWM_FRCTRL_FRAC23_EN_SHIFT, PWM_FRCTRL_FRAC23_EN_WIDTH))

/*! @brief Set the FRAC23_EN field to a new value. */
#define PWM_WR_FRCTRL_FRAC23_EN(base, index, value) (PWM_RMW_FRCTRL(base, index, PWM_FRCTRL_FRAC23_EN_MASK, PWM_FRCTRL_FRAC23_EN(value)))
#define PWM_BWR_FRCTRL_FRAC23_EN(base, index, value) (BME_BFI16(&PWM_FRCTRL_REG(base, index), ((uint16_t)(value) << PWM_FRCTRL_FRAC23_EN_SHIFT), PWM_FRCTRL_FRAC23_EN_SHIFT, PWM_FRCTRL_FRAC23_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FRCTRL, field FRAC45_EN[4] (RW)
 *
 * This bit is used to enable the fractional cycle edge placement of PWM_B using
 * the FRACVAL4 and FRACVAL5 registers. When disabled, the fractional cycle edge
 * placement of PWM_B is bypassed. The FRAC45_EN bit is buffered. The value
 * written does not take effect until MCTRL0[LDOK] is set and the next PWM load cycle
 * begins or CTRL[LDMOD] is set. FRAC45_EN cannot be written when MCTRL0[LDOK]
 * is set. Reading FRAC45_EN reads the value in a buffer and not necessarily the
 * value the PWM generator is currently using.
 *
 * Values:
 * - 0b0 - Disable fractional cycle placement for PWM_B.
 * - 0b1 - Enable fractional cycle placement for PWM_B.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRCTRL_FRAC45_EN field. */
#define PWM_RD_FRCTRL_FRAC45_EN(base, index) ((PWM_FRCTRL_REG(base, index) & PWM_FRCTRL_FRAC45_EN_MASK) >> PWM_FRCTRL_FRAC45_EN_SHIFT)
#define PWM_BRD_FRCTRL_FRAC45_EN(base, index) (BME_UBFX16(&PWM_FRCTRL_REG(base, index), PWM_FRCTRL_FRAC45_EN_SHIFT, PWM_FRCTRL_FRAC45_EN_WIDTH))

/*! @brief Set the FRAC45_EN field to a new value. */
#define PWM_WR_FRCTRL_FRAC45_EN(base, index, value) (PWM_RMW_FRCTRL(base, index, PWM_FRCTRL_FRAC45_EN_MASK, PWM_FRCTRL_FRAC45_EN(value)))
#define PWM_BWR_FRCTRL_FRAC45_EN(base, index, value) (BME_BFI16(&PWM_FRCTRL_REG(base, index), ((uint16_t)(value) << PWM_FRCTRL_FRAC45_EN_SHIFT), PWM_FRCTRL_FRAC45_EN_SHIFT, PWM_FRCTRL_FRAC45_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FRCTRL, field FRAC_PU[8] (RW)
 *
 * This bit is used to power up the fractional delay analog block. The
 * fractional delay block takes 25 us to power up after the first FRAC_PU bit in any
 * submodule is set. The fractional delay block only powers down when the FRAC_PU bits
 * in all submodules are 0. The fractional delay logic can only be used when the
 * IPBus clock is running at 100 MHz. When turned off, fractional placement is
 * disabled. After setting this bit and waiting the 25usec, load the PWM VAL*
 * registers with values to create a PWM output with greater than 0% duty cycle and
 * run for at least one PWM period. This can be done without the outputs enabled
 * and is used to clear the state of the analog block that produces the fractional
 * delays. This bit is functional only in PWMs that support nano-edge placement.
 *
 * Values:
 * - 0b0 - Turn off fractional delay logic.
 * - 0b1 - Power up fractional delay logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRCTRL_FRAC_PU field. */
#define PWM_RD_FRCTRL_FRAC_PU(base, index) ((PWM_FRCTRL_REG(base, index) & PWM_FRCTRL_FRAC_PU_MASK) >> PWM_FRCTRL_FRAC_PU_SHIFT)
#define PWM_BRD_FRCTRL_FRAC_PU(base, index) (BME_UBFX16(&PWM_FRCTRL_REG(base, index), PWM_FRCTRL_FRAC_PU_SHIFT, PWM_FRCTRL_FRAC_PU_WIDTH))

/*! @brief Set the FRAC_PU field to a new value. */
#define PWM_WR_FRCTRL_FRAC_PU(base, index, value) (PWM_RMW_FRCTRL(base, index, PWM_FRCTRL_FRAC_PU_MASK, PWM_FRCTRL_FRAC_PU(value)))
#define PWM_BWR_FRCTRL_FRAC_PU(base, index, value) (BME_BFI16(&PWM_FRCTRL_REG(base, index), ((uint16_t)(value) << PWM_FRCTRL_FRAC_PU_SHIFT), PWM_FRCTRL_FRAC_PU_SHIFT, PWM_FRCTRL_FRAC_PU_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FRCTRL, field TEST[15] (RO)
 *
 * This is a read only test bit for factory use. This bit will reset to 0 but
 * may be either 0 or 1 during PWM operation.
 */
/*@{*/
/*! @brief Read current value of the PWM_FRCTRL_TEST field. */
#define PWM_RD_FRCTRL_TEST(base, index) ((PWM_FRCTRL_REG(base, index) & PWM_FRCTRL_TEST_MASK) >> PWM_FRCTRL_TEST_SHIFT)
#define PWM_BRD_FRCTRL_TEST(base, index) (BME_UBFX16(&PWM_FRCTRL_REG(base, index), PWM_FRCTRL_TEST_SHIFT, PWM_FRCTRL_TEST_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_OCTRL - Output Control Register
 ******************************************************************************/

/*!
 * @brief PWM_OCTRL - Output Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_OCTRL register
 */
/*@{*/
#define PWM_RD_OCTRL(base, index) (PWM_OCTRL_REG(base, index))
#define PWM_WR_OCTRL(base, index, value) (PWM_OCTRL_REG(base, index) = (value))
#define PWM_RMW_OCTRL(base, index, mask, value) (PWM_WR_OCTRL(base, index, (PWM_RD_OCTRL(base, index) & ~(mask)) | (value)))
#define PWM_SET_OCTRL(base, index, value) (BME_OR16(&PWM_OCTRL_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_OCTRL(base, index, value) (BME_AND16(&PWM_OCTRL_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_OCTRL(base, index, value) (BME_XOR16(&PWM_OCTRL_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_OCTRL bitfields
 */

/*!
 * @name Register PWM_OCTRL, field PWMXFS[1:0] (RW)
 *
 * These bits determine the fault state for the PWM_X output during fault
 * conditions and STOP mode. It may also define the output state during WAIT and DEBUG
 * modes depending on the settings of CTRL2[WAITEN] and CTRL2[DBGEN].
 *
 * Values:
 * - 0b00 - Output is forced to logic 0 state prior to consideration of output
 *     polarity control.
 * - 0b01 - Output is forced to logic 1 state prior to consideration of output
 *     polarity control.
 * - 0b10 - Output is tristated.
 * - 0b11 - Output is tristated.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMXFS field. */
#define PWM_RD_OCTRL_PWMXFS(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMXFS_MASK) >> PWM_OCTRL_PWMXFS_SHIFT)
#define PWM_BRD_OCTRL_PWMXFS(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMXFS_SHIFT, PWM_OCTRL_PWMXFS_WIDTH))

/*! @brief Set the PWMXFS field to a new value. */
#define PWM_WR_OCTRL_PWMXFS(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_PWMXFS_MASK, PWM_OCTRL_PWMXFS(value)))
#define PWM_BWR_OCTRL_PWMXFS(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_PWMXFS_SHIFT), PWM_OCTRL_PWMXFS_SHIFT, PWM_OCTRL_PWMXFS_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field PWMBFS[3:2] (RW)
 *
 * These bits determine the fault state for the PWM_B output during fault
 * conditions and STOP mode. It may also define the output state during WAIT and DEBUG
 * modes depending on the settings of CTRL2[WAITEN] and CTRL2[DBGEN].
 *
 * Values:
 * - 0b00 - Output is forced to logic 0 state prior to consideration of output
 *     polarity control.
 * - 0b01 - Output is forced to logic 1 state prior to consideration of output
 *     polarity control.
 * - 0b10 - Output is tristated.
 * - 0b11 - Output is tristated.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMBFS field. */
#define PWM_RD_OCTRL_PWMBFS(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMBFS_MASK) >> PWM_OCTRL_PWMBFS_SHIFT)
#define PWM_BRD_OCTRL_PWMBFS(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMBFS_SHIFT, PWM_OCTRL_PWMBFS_WIDTH))

/*! @brief Set the PWMBFS field to a new value. */
#define PWM_WR_OCTRL_PWMBFS(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_PWMBFS_MASK, PWM_OCTRL_PWMBFS(value)))
#define PWM_BWR_OCTRL_PWMBFS(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_PWMBFS_SHIFT), PWM_OCTRL_PWMBFS_SHIFT, PWM_OCTRL_PWMBFS_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field PWMAFS[5:4] (RW)
 *
 * These bits determine the fault state for the PWM_A output during fault
 * conditions and STOP mode. It may also define the output state during WAIT and DEBUG
 * modes depending on the settings of CTRL2[WAITEN] and CTRL2[DBGEN].
 *
 * Values:
 * - 0b00 - Output is forced to logic 0 state prior to consideration of output
 *     polarity control.
 * - 0b01 - Output is forced to logic 1 state prior to consideration of output
 *     polarity control.
 * - 0b10 - Output is tristated.
 * - 0b11 - Output is tristated.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMAFS field. */
#define PWM_RD_OCTRL_PWMAFS(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMAFS_MASK) >> PWM_OCTRL_PWMAFS_SHIFT)
#define PWM_BRD_OCTRL_PWMAFS(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMAFS_SHIFT, PWM_OCTRL_PWMAFS_WIDTH))

/*! @brief Set the PWMAFS field to a new value. */
#define PWM_WR_OCTRL_PWMAFS(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_PWMAFS_MASK, PWM_OCTRL_PWMAFS(value)))
#define PWM_BWR_OCTRL_PWMAFS(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_PWMAFS_SHIFT), PWM_OCTRL_PWMAFS_SHIFT, PWM_OCTRL_PWMAFS_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field POLX[8] (RW)
 *
 * This bit inverts the PWM_X output polarity.
 *
 * Values:
 * - 0b0 - PWM_X output not inverted. A high level on the PWM_X pin represents
 *     the "on" or "active" state.
 * - 0b1 - PWM_X output inverted. A low level on the PWM_X pin represents the
 *     "on" or "active" state.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_POLX field. */
#define PWM_RD_OCTRL_POLX(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_POLX_MASK) >> PWM_OCTRL_POLX_SHIFT)
#define PWM_BRD_OCTRL_POLX(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_POLX_SHIFT, PWM_OCTRL_POLX_WIDTH))

/*! @brief Set the POLX field to a new value. */
#define PWM_WR_OCTRL_POLX(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_POLX_MASK, PWM_OCTRL_POLX(value)))
#define PWM_BWR_OCTRL_POLX(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_POLX_SHIFT), PWM_OCTRL_POLX_SHIFT, PWM_OCTRL_POLX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field POLB[9] (RW)
 *
 * This bit inverts the PWM_B output polarity.
 *
 * Values:
 * - 0b0 - PWM_B output not inverted. A high level on the PWM_B pin represents
 *     the "on" or "active" state.
 * - 0b1 - PWM_B output inverted. A low level on the PWM_B pin represents the
 *     "on" or "active" state.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_POLB field. */
#define PWM_RD_OCTRL_POLB(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_POLB_MASK) >> PWM_OCTRL_POLB_SHIFT)
#define PWM_BRD_OCTRL_POLB(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_POLB_SHIFT, PWM_OCTRL_POLB_WIDTH))

/*! @brief Set the POLB field to a new value. */
#define PWM_WR_OCTRL_POLB(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_POLB_MASK, PWM_OCTRL_POLB(value)))
#define PWM_BWR_OCTRL_POLB(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_POLB_SHIFT), PWM_OCTRL_POLB_SHIFT, PWM_OCTRL_POLB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field POLA[10] (RW)
 *
 * This bit inverts the PWM_A output polarity.
 *
 * Values:
 * - 0b0 - PWM_A output not inverted. A high level on the PWM_A pin represents
 *     the "on" or "active" state.
 * - 0b1 - PWM_A output inverted. A low level on the PWM_A pin represents the
 *     "on" or "active" state.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_POLA field. */
#define PWM_RD_OCTRL_POLA(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_POLA_MASK) >> PWM_OCTRL_POLA_SHIFT)
#define PWM_BRD_OCTRL_POLA(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_POLA_SHIFT, PWM_OCTRL_POLA_WIDTH))

/*! @brief Set the POLA field to a new value. */
#define PWM_WR_OCTRL_POLA(base, index, value) (PWM_RMW_OCTRL(base, index, PWM_OCTRL_POLA_MASK, PWM_OCTRL_POLA(value)))
#define PWM_BWR_OCTRL_POLA(base, index, value) (BME_BFI16(&PWM_OCTRL_REG(base, index), ((uint16_t)(value) << PWM_OCTRL_POLA_SHIFT), PWM_OCTRL_POLA_SHIFT, PWM_OCTRL_POLA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field PWMX_IN[13] (RO)
 *
 * This read only bit shows the logic value currently being driven into the
 * PWM_X input. The bit's reset state is undefined.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMX_IN field. */
#define PWM_RD_OCTRL_PWMX_IN(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMX_IN_MASK) >> PWM_OCTRL_PWMX_IN_SHIFT)
#define PWM_BRD_OCTRL_PWMX_IN(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMX_IN_SHIFT, PWM_OCTRL_PWMX_IN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field PWMB_IN[14] (RO)
 *
 * This read only bit shows the logic value currently being driven into the
 * PWM_B input. The bit's reset state is undefined.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMB_IN field. */
#define PWM_RD_OCTRL_PWMB_IN(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMB_IN_MASK) >> PWM_OCTRL_PWMB_IN_SHIFT)
#define PWM_BRD_OCTRL_PWMB_IN(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMB_IN_SHIFT, PWM_OCTRL_PWMB_IN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OCTRL, field PWMA_IN[15] (RO)
 *
 * This read only bit shows the logic value currently being driven into the
 * PWM_A input. The bit's reset state is undefined.
 */
/*@{*/
/*! @brief Read current value of the PWM_OCTRL_PWMA_IN field. */
#define PWM_RD_OCTRL_PWMA_IN(base, index) ((PWM_OCTRL_REG(base, index) & PWM_OCTRL_PWMA_IN_MASK) >> PWM_OCTRL_PWMA_IN_SHIFT)
#define PWM_BRD_OCTRL_PWMA_IN(base, index) (BME_UBFX16(&PWM_OCTRL_REG(base, index), PWM_OCTRL_PWMA_IN_SHIFT, PWM_OCTRL_PWMA_IN_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_STS - Status Register
 ******************************************************************************/

/*!
 * @brief PWM_STS - Status Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_STS register
 */
/*@{*/
#define PWM_RD_STS(base, index)  (PWM_STS_REG(base, index))
#define PWM_WR_STS(base, index, value) (PWM_STS_REG(base, index) = (value))
#define PWM_RMW_STS(base, index, mask, value) (PWM_WR_STS(base, index, (PWM_RD_STS(base, index) & ~(mask)) | (value)))
#define PWM_SET_STS(base, index, value) (BME_OR16(&PWM_STS_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_STS(base, index, value) (BME_AND16(&PWM_STS_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_STS(base, index, value) (BME_XOR16(&PWM_STS_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_STS bitfields
 */

/*!
 * @name Register PWM_STS, field CMPF[5:0] (W1C)
 *
 * These bits are set when the submodule counter value matches the value of one
 * of the VALx registers. Clear these bits by writing a 1 to a bit position.
 *
 * Values:
 * - 0b000000 - No compare event has occurred for a particular VALx value.
 * - 0b000001 - A compare event has occurred for a particular VALx value.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CMPF field. */
#define PWM_RD_STS_CMPF(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CMPF_MASK) >> PWM_STS_CMPF_SHIFT)
#define PWM_BRD_STS_CMPF(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CMPF_SHIFT, PWM_STS_CMPF_WIDTH))

/*! @brief Set the CMPF field to a new value. */
#define PWM_WR_STS_CMPF(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CMPF(value)))
#define PWM_BWR_STS_CMPF(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CMPF_SHIFT), PWM_STS_CMPF_SHIFT, PWM_STS_CMPF_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFX0[6] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture X0 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CX0DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CX0DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFX0 field. */
#define PWM_RD_STS_CFX0(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFX0_MASK) >> PWM_STS_CFX0_SHIFT)
#define PWM_BRD_STS_CFX0(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFX0_SHIFT, PWM_STS_CFX0_WIDTH))

/*! @brief Set the CFX0 field to a new value. */
#define PWM_WR_STS_CFX0(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFX0_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFX0(value)))
#define PWM_BWR_STS_CFX0(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFX0_SHIFT), PWM_STS_CFX0_SHIFT, PWM_STS_CFX0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFX1[7] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture X1 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CX1DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CX1DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFX1 field. */
#define PWM_RD_STS_CFX1(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFX1_MASK) >> PWM_STS_CFX1_SHIFT)
#define PWM_BRD_STS_CFX1(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFX1_SHIFT, PWM_STS_CFX1_WIDTH))

/*! @brief Set the CFX1 field to a new value. */
#define PWM_WR_STS_CFX1(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFX1_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFX1(value)))
#define PWM_BWR_STS_CFX1(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFX1_SHIFT), PWM_STS_CFX1_SHIFT, PWM_STS_CFX1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFB0[8] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture B0 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CB0DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CB0DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFB0 field. */
#define PWM_RD_STS_CFB0(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFB0_MASK) >> PWM_STS_CFB0_SHIFT)
#define PWM_BRD_STS_CFB0(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFB0_SHIFT, PWM_STS_CFB0_WIDTH))

/*! @brief Set the CFB0 field to a new value. */
#define PWM_WR_STS_CFB0(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFB0_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFB0(value)))
#define PWM_BWR_STS_CFB0(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFB0_SHIFT), PWM_STS_CFB0_SHIFT, PWM_STS_CFB0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFB1[9] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture B1 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CB1DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CB1DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFB1 field. */
#define PWM_RD_STS_CFB1(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFB1_MASK) >> PWM_STS_CFB1_SHIFT)
#define PWM_BRD_STS_CFB1(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFB1_SHIFT, PWM_STS_CFB1_WIDTH))

/*! @brief Set the CFB1 field to a new value. */
#define PWM_WR_STS_CFB1(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFB1_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFB1(value)))
#define PWM_BWR_STS_CFB1(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFB1_SHIFT), PWM_STS_CFB1_SHIFT, PWM_STS_CFB1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFA0[10] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture A0 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CA0DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CA0DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFA0 field. */
#define PWM_RD_STS_CFA0(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFA0_MASK) >> PWM_STS_CFA0_SHIFT)
#define PWM_BRD_STS_CFA0(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFA0_SHIFT, PWM_STS_CFA0_WIDTH))

/*! @brief Set the CFA0 field to a new value. */
#define PWM_WR_STS_CFA0(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFA0_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFA0(value)))
#define PWM_BWR_STS_CFA0(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFA0_SHIFT), PWM_STS_CFA0_SHIFT, PWM_STS_CFA0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field CFA1[11] (W1C)
 *
 * This bit is set when a capture event occurs on the Capture A1 circuit. This
 * bit is cleared by writing a one to this bit position if DMAEN[CA1DE] is clear
 * (non-DMA mode) or by the DMA done signal if DMAEN[CA1DE] is set (DMA mode).
 * Reset clears this bit.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_CFA1 field. */
#define PWM_RD_STS_CFA1(base, index) ((PWM_STS_REG(base, index) & PWM_STS_CFA1_MASK) >> PWM_STS_CFA1_SHIFT)
#define PWM_BRD_STS_CFA1(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_CFA1_SHIFT, PWM_STS_CFA1_WIDTH))

/*! @brief Set the CFA1 field to a new value. */
#define PWM_WR_STS_CFA1(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_CFA1_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_RF_MASK | PWM_STS_REF_MASK), PWM_STS_CFA1(value)))
#define PWM_BWR_STS_CFA1(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_CFA1_SHIFT), PWM_STS_CFA1_SHIFT, PWM_STS_CFA1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field RF[12] (W1C)
 *
 * This read/write flag is set at the beginning of every reload cycle regardless
 * of the state of MCTRL0[LDOK]. Clear this bit by writing a logic one to this
 * location when DMAEN[VALDE] is clear (non-DMA mode). This flag can also be
 * cleared by the DMA done signal when DMAEN[VALDE] is set (DMA mode). Reset clears
 * this bit.
 *
 * Values:
 * - 0b0 - No new reload cycle since last STS[RF] clearing
 * - 0b1 - New reload cycle since last STS[RF] clearing
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_RF field. */
#define PWM_RD_STS_RF(base, index) ((PWM_STS_REG(base, index) & PWM_STS_RF_MASK) >> PWM_STS_RF_SHIFT)
#define PWM_BRD_STS_RF(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_RF_SHIFT, PWM_STS_RF_WIDTH))

/*! @brief Set the RF field to a new value. */
#define PWM_WR_STS_RF(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_RF_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_REF_MASK), PWM_STS_RF(value)))
#define PWM_BWR_STS_RF(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_RF_SHIFT), PWM_STS_RF_SHIFT, PWM_STS_RF_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field REF[13] (W1C)
 *
 * This read/write flag is set when a reload cycle occurs while MCTRL0[LDOK] is
 * 0 and the double buffered registers are in a non-coherent state (STS[RUF] =
 * 1). Clear this bit by writing a logic one to this location. Reset clears this
 * bit.
 *
 * Values:
 * - 0b0 - No reload error occurred.
 * - 0b1 - Reload signal occurred with non-coherent data and MCTRL0[LDOK] = 0.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_REF field. */
#define PWM_RD_STS_REF(base, index) ((PWM_STS_REG(base, index) & PWM_STS_REF_MASK) >> PWM_STS_REF_SHIFT)
#define PWM_BRD_STS_REF(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_REF_SHIFT, PWM_STS_REF_WIDTH))

/*! @brief Set the REF field to a new value. */
#define PWM_WR_STS_REF(base, index, value) (PWM_RMW_STS(base, index, (PWM_STS_REF_MASK | PWM_STS_CMPF_MASK | PWM_STS_CFX0_MASK | PWM_STS_CFX1_MASK | PWM_STS_CFB0_MASK | PWM_STS_CFB1_MASK | PWM_STS_CFA0_MASK | PWM_STS_CFA1_MASK | PWM_STS_RF_MASK), PWM_STS_REF(value)))
#define PWM_BWR_STS_REF(base, index, value) (BME_BFI16(&PWM_STS_REG(base, index), ((uint16_t)(value) << PWM_STS_REF_SHIFT), PWM_STS_REF_SHIFT, PWM_STS_REF_WIDTH))
/*@}*/

/*!
 * @name Register PWM_STS, field RUF[14] (RO)
 *
 * This read-only flag is set when one of the INIT, VALx,FRACVALx, or CTRL[PRSC]
 * registers has been written, which indicates potentially non-coherent data in
 * the set of double buffered registers. Clear this bit by a proper reload
 * sequence consisting of a reload signal while MCTRL0[LDOK] = 1. Reset clears this bit.
 *
 * Values:
 * - 0b0 - No register update has occurred since last reload.
 * - 0b1 - At least one of the double buffered registers has been updated since
 *     the last reload.
 */
/*@{*/
/*! @brief Read current value of the PWM_STS_RUF field. */
#define PWM_RD_STS_RUF(base, index) ((PWM_STS_REG(base, index) & PWM_STS_RUF_MASK) >> PWM_STS_RUF_SHIFT)
#define PWM_BRD_STS_RUF(base, index) (BME_UBFX16(&PWM_STS_REG(base, index), PWM_STS_RUF_SHIFT, PWM_STS_RUF_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_INTEN - Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief PWM_INTEN - Interrupt Enable Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_INTEN register
 */
/*@{*/
#define PWM_RD_INTEN(base, index) (PWM_INTEN_REG(base, index))
#define PWM_WR_INTEN(base, index, value) (PWM_INTEN_REG(base, index) = (value))
#define PWM_RMW_INTEN(base, index, mask, value) (PWM_WR_INTEN(base, index, (PWM_RD_INTEN(base, index) & ~(mask)) | (value)))
#define PWM_SET_INTEN(base, index, value) (BME_OR16(&PWM_INTEN_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_INTEN(base, index, value) (BME_AND16(&PWM_INTEN_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_INTEN(base, index, value) (BME_XOR16(&PWM_INTEN_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_INTEN bitfields
 */

/*!
 * @name Register PWM_INTEN, field CMPIE[5:0] (RW)
 *
 * These bits enable the STS[CMPF] flags to cause a compare interrupt request to
 * the CPU.
 *
 * Values:
 * - 0b000000 - The corresponding STS[CMPF] bit will not cause an interrupt
 *     request.
 * - 0b000001 - The corresponding STS[CMPF] bit will cause an interrupt request.
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CMPIE field. */
#define PWM_RD_INTEN_CMPIE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CMPIE_MASK) >> PWM_INTEN_CMPIE_SHIFT)
#define PWM_BRD_INTEN_CMPIE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CMPIE_SHIFT, PWM_INTEN_CMPIE_WIDTH))

/*! @brief Set the CMPIE field to a new value. */
#define PWM_WR_INTEN_CMPIE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CMPIE_MASK, PWM_INTEN_CMPIE(value)))
#define PWM_BWR_INTEN_CMPIE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CMPIE_SHIFT), PWM_INTEN_CMPIE_SHIFT, PWM_INTEN_CMPIE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CX0IE[6] (RW)
 *
 * This bit allows the STS[CFX0] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CX0DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFX0].
 * - 0b1 - Interrupt request enabled for STS[CFX0].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CX0IE field. */
#define PWM_RD_INTEN_CX0IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CX0IE_MASK) >> PWM_INTEN_CX0IE_SHIFT)
#define PWM_BRD_INTEN_CX0IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CX0IE_SHIFT, PWM_INTEN_CX0IE_WIDTH))

/*! @brief Set the CX0IE field to a new value. */
#define PWM_WR_INTEN_CX0IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CX0IE_MASK, PWM_INTEN_CX0IE(value)))
#define PWM_BWR_INTEN_CX0IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CX0IE_SHIFT), PWM_INTEN_CX0IE_SHIFT, PWM_INTEN_CX0IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CX1IE[7] (RW)
 *
 * This bit allows the STS[CFX1] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CX1DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFX1].
 * - 0b1 - Interrupt request enabled for STS[CFX1].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CX1IE field. */
#define PWM_RD_INTEN_CX1IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CX1IE_MASK) >> PWM_INTEN_CX1IE_SHIFT)
#define PWM_BRD_INTEN_CX1IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CX1IE_SHIFT, PWM_INTEN_CX1IE_WIDTH))

/*! @brief Set the CX1IE field to a new value. */
#define PWM_WR_INTEN_CX1IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CX1IE_MASK, PWM_INTEN_CX1IE(value)))
#define PWM_BWR_INTEN_CX1IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CX1IE_SHIFT), PWM_INTEN_CX1IE_SHIFT, PWM_INTEN_CX1IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CB0IE[8] (RW)
 *
 * This bit allows the STS[CFB0] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CB0DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFB0].
 * - 0b1 - Interrupt request enabled for STS[CFB0].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CB0IE field. */
#define PWM_RD_INTEN_CB0IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CB0IE_MASK) >> PWM_INTEN_CB0IE_SHIFT)
#define PWM_BRD_INTEN_CB0IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CB0IE_SHIFT, PWM_INTEN_CB0IE_WIDTH))

/*! @brief Set the CB0IE field to a new value. */
#define PWM_WR_INTEN_CB0IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CB0IE_MASK, PWM_INTEN_CB0IE(value)))
#define PWM_BWR_INTEN_CB0IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CB0IE_SHIFT), PWM_INTEN_CB0IE_SHIFT, PWM_INTEN_CB0IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CB1IE[9] (RW)
 *
 * This bit allows the STS[CFB1] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CB1DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFB1].
 * - 0b1 - Interrupt request enabled for STS[CFB1].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CB1IE field. */
#define PWM_RD_INTEN_CB1IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CB1IE_MASK) >> PWM_INTEN_CB1IE_SHIFT)
#define PWM_BRD_INTEN_CB1IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CB1IE_SHIFT, PWM_INTEN_CB1IE_WIDTH))

/*! @brief Set the CB1IE field to a new value. */
#define PWM_WR_INTEN_CB1IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CB1IE_MASK, PWM_INTEN_CB1IE(value)))
#define PWM_BWR_INTEN_CB1IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CB1IE_SHIFT), PWM_INTEN_CB1IE_SHIFT, PWM_INTEN_CB1IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CA0IE[10] (RW)
 *
 * This bit allows the STS[CFA0] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CA0DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFA0].
 * - 0b1 - Interrupt request enabled for STS[CFA0].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CA0IE field. */
#define PWM_RD_INTEN_CA0IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CA0IE_MASK) >> PWM_INTEN_CA0IE_SHIFT)
#define PWM_BRD_INTEN_CA0IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CA0IE_SHIFT, PWM_INTEN_CA0IE_WIDTH))

/*! @brief Set the CA0IE field to a new value. */
#define PWM_WR_INTEN_CA0IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CA0IE_MASK, PWM_INTEN_CA0IE(value)))
#define PWM_BWR_INTEN_CA0IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CA0IE_SHIFT), PWM_INTEN_CA0IE_SHIFT, PWM_INTEN_CA0IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field CA1IE[11] (RW)
 *
 * This bit allows the STS[CFA1] flag to create an interrupt request to the CPU.
 * Do not set both this bit and DMAEN[CA1DE].
 *
 * Values:
 * - 0b0 - Interrupt request disabled for STS[CFA1].
 * - 0b1 - Interrupt request enabled for STS[CFA1].
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_CA1IE field. */
#define PWM_RD_INTEN_CA1IE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_CA1IE_MASK) >> PWM_INTEN_CA1IE_SHIFT)
#define PWM_BRD_INTEN_CA1IE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_CA1IE_SHIFT, PWM_INTEN_CA1IE_WIDTH))

/*! @brief Set the CA1IE field to a new value. */
#define PWM_WR_INTEN_CA1IE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_CA1IE_MASK, PWM_INTEN_CA1IE(value)))
#define PWM_BWR_INTEN_CA1IE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_CA1IE_SHIFT), PWM_INTEN_CA1IE_SHIFT, PWM_INTEN_CA1IE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field RIE[12] (RW)
 *
 * This read/write bit enables the reload flag, STS[RF], to generate CPU
 * interrupt requests. Reset clears this bit.
 *
 * Values:
 * - 0b0 - STS[RF] CPU interrupt requests disabled
 * - 0b1 - STS[RF] CPU interrupt requests enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_RIE field. */
#define PWM_RD_INTEN_RIE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_RIE_MASK) >> PWM_INTEN_RIE_SHIFT)
#define PWM_BRD_INTEN_RIE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_RIE_SHIFT, PWM_INTEN_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define PWM_WR_INTEN_RIE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_RIE_MASK, PWM_INTEN_RIE(value)))
#define PWM_BWR_INTEN_RIE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_RIE_SHIFT), PWM_INTEN_RIE_SHIFT, PWM_INTEN_RIE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_INTEN, field REIE[13] (RW)
 *
 * This read/write bit enables the reload error flag, STS[REF], to generate CPU
 * interrupt requests. Reset clears this bit.
 *
 * Values:
 * - 0b0 - STS[REF] CPU interrupt requests disabled
 * - 0b1 - STS[REF] CPU interrupt requests enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_INTEN_REIE field. */
#define PWM_RD_INTEN_REIE(base, index) ((PWM_INTEN_REG(base, index) & PWM_INTEN_REIE_MASK) >> PWM_INTEN_REIE_SHIFT)
#define PWM_BRD_INTEN_REIE(base, index) (BME_UBFX16(&PWM_INTEN_REG(base, index), PWM_INTEN_REIE_SHIFT, PWM_INTEN_REIE_WIDTH))

/*! @brief Set the REIE field to a new value. */
#define PWM_WR_INTEN_REIE(base, index, value) (PWM_RMW_INTEN(base, index, PWM_INTEN_REIE_MASK, PWM_INTEN_REIE(value)))
#define PWM_BWR_INTEN_REIE(base, index, value) (BME_BFI16(&PWM_INTEN_REG(base, index), ((uint16_t)(value) << PWM_INTEN_REIE_SHIFT), PWM_INTEN_REIE_SHIFT, PWM_INTEN_REIE_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_DMAEN - DMA Enable Register
 ******************************************************************************/

/*!
 * @brief PWM_DMAEN - DMA Enable Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_DMAEN register
 */
/*@{*/
#define PWM_RD_DMAEN(base, index) (PWM_DMAEN_REG(base, index))
#define PWM_WR_DMAEN(base, index, value) (PWM_DMAEN_REG(base, index) = (value))
#define PWM_RMW_DMAEN(base, index, mask, value) (PWM_WR_DMAEN(base, index, (PWM_RD_DMAEN(base, index) & ~(mask)) | (value)))
#define PWM_SET_DMAEN(base, index, value) (BME_OR16(&PWM_DMAEN_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_DMAEN(base, index, value) (BME_AND16(&PWM_DMAEN_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_DMAEN(base, index, value) (BME_XOR16(&PWM_DMAEN_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_DMAEN bitfields
 */

/*!
 * @name Register PWM_DMAEN, field CX0DE[0] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture X0 FIFO data
 * when STS[CFX0] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CX0IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CX0DE field. */
#define PWM_RD_DMAEN_CX0DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CX0DE_MASK) >> PWM_DMAEN_CX0DE_SHIFT)
#define PWM_BRD_DMAEN_CX0DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CX0DE_SHIFT, PWM_DMAEN_CX0DE_WIDTH))

/*! @brief Set the CX0DE field to a new value. */
#define PWM_WR_DMAEN_CX0DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CX0DE_MASK, PWM_DMAEN_CX0DE(value)))
#define PWM_BWR_DMAEN_CX0DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CX0DE_SHIFT), PWM_DMAEN_CX0DE_SHIFT, PWM_DMAEN_CX0DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CX1DE[1] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture X1 FIFO data
 * when STS[CFX1] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CX1IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CX1DE field. */
#define PWM_RD_DMAEN_CX1DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CX1DE_MASK) >> PWM_DMAEN_CX1DE_SHIFT)
#define PWM_BRD_DMAEN_CX1DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CX1DE_SHIFT, PWM_DMAEN_CX1DE_WIDTH))

/*! @brief Set the CX1DE field to a new value. */
#define PWM_WR_DMAEN_CX1DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CX1DE_MASK, PWM_DMAEN_CX1DE(value)))
#define PWM_BWR_DMAEN_CX1DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CX1DE_SHIFT), PWM_DMAEN_CX1DE_SHIFT, PWM_DMAEN_CX1DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CB0DE[2] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture B0 FIFO data
 * when STS[CFB0] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CB0IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CB0DE field. */
#define PWM_RD_DMAEN_CB0DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CB0DE_MASK) >> PWM_DMAEN_CB0DE_SHIFT)
#define PWM_BRD_DMAEN_CB0DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CB0DE_SHIFT, PWM_DMAEN_CB0DE_WIDTH))

/*! @brief Set the CB0DE field to a new value. */
#define PWM_WR_DMAEN_CB0DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CB0DE_MASK, PWM_DMAEN_CB0DE(value)))
#define PWM_BWR_DMAEN_CB0DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CB0DE_SHIFT), PWM_DMAEN_CB0DE_SHIFT, PWM_DMAEN_CB0DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CB1DE[3] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture B1 FIFO data
 * when STS[CFB1] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CB1IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CB1DE field. */
#define PWM_RD_DMAEN_CB1DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CB1DE_MASK) >> PWM_DMAEN_CB1DE_SHIFT)
#define PWM_BRD_DMAEN_CB1DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CB1DE_SHIFT, PWM_DMAEN_CB1DE_WIDTH))

/*! @brief Set the CB1DE field to a new value. */
#define PWM_WR_DMAEN_CB1DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CB1DE_MASK, PWM_DMAEN_CB1DE(value)))
#define PWM_BWR_DMAEN_CB1DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CB1DE_SHIFT), PWM_DMAEN_CB1DE_SHIFT, PWM_DMAEN_CB1DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CA0DE[4] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture A0 FIFO data
 * when STS[CFA0] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CA0IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CA0DE field. */
#define PWM_RD_DMAEN_CA0DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CA0DE_MASK) >> PWM_DMAEN_CA0DE_SHIFT)
#define PWM_BRD_DMAEN_CA0DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CA0DE_SHIFT, PWM_DMAEN_CA0DE_WIDTH))

/*! @brief Set the CA0DE field to a new value. */
#define PWM_WR_DMAEN_CA0DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CA0DE_MASK, PWM_DMAEN_CA0DE(value)))
#define PWM_BWR_DMAEN_CA0DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CA0DE_SHIFT), PWM_DMAEN_CA0DE_SHIFT, PWM_DMAEN_CA0DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CA1DE[5] (RW)
 *
 * This read/write bit enables DMA read requests for the Capture A1 FIFO data
 * when STS[CFA1] is set. Reset clears this bit. Do not set both this bit and
 * INTEN[CA1IE].
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CA1DE field. */
#define PWM_RD_DMAEN_CA1DE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CA1DE_MASK) >> PWM_DMAEN_CA1DE_SHIFT)
#define PWM_BRD_DMAEN_CA1DE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CA1DE_SHIFT, PWM_DMAEN_CA1DE_WIDTH))

/*! @brief Set the CA1DE field to a new value. */
#define PWM_WR_DMAEN_CA1DE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CA1DE_MASK, PWM_DMAEN_CA1DE(value)))
#define PWM_BWR_DMAEN_CA1DE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CA1DE_SHIFT), PWM_DMAEN_CA1DE_SHIFT, PWM_DMAEN_CA1DE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field CAPTDE[7:6] (RW)
 *
 * These read/write bits select the source of enabling the DMA read requests for
 * the capture FIFOs. Reset clears these bits.
 *
 * Values:
 * - 0b00 - Read DMA requests disabled.
 * - 0b01 - Exceeding a FIFO watermark sets the DMA read request. This requires
 *     at least one of DMAEN[CA1DE], DMAEN[CA0DE], DMAEN[CB1DE], DMAEN[CB0DE],
 *     DMAEN[CX1DE], or DMAEN[CX0DE] to also be set in order to determine to which
 *     watermark(s) the DMA request is sensitive.
 * - 0b10 - A local sync (VAL1 matches counter) sets the read DMA request.
 * - 0b11 - A local reload (STS[RF] being set) sets the read DMA request.
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_CAPTDE field. */
#define PWM_RD_DMAEN_CAPTDE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_CAPTDE_MASK) >> PWM_DMAEN_CAPTDE_SHIFT)
#define PWM_BRD_DMAEN_CAPTDE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_CAPTDE_SHIFT, PWM_DMAEN_CAPTDE_WIDTH))

/*! @brief Set the CAPTDE field to a new value. */
#define PWM_WR_DMAEN_CAPTDE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_CAPTDE_MASK, PWM_DMAEN_CAPTDE(value)))
#define PWM_BWR_DMAEN_CAPTDE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_CAPTDE_SHIFT), PWM_DMAEN_CAPTDE_SHIFT, PWM_DMAEN_CAPTDE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field FAND[8] (RW)
 *
 * This read/write bit works in conjunction with the DMAEN[CAPTDE] field when it
 * is set to watermark mode (DMAEN[CAPTDE] = 01). While DMAEN[CAxDE],
 * DMAEN[CBxDE], and DMAEN[CXxDE] determine which FIFO watermarks the DMA read request is
 * sensitive to, this bit determines if the selected watermarks are AND'ed
 * together or OR'ed together in order to create the request.
 *
 * Values:
 * - 0b0 - Selected FIFO watermarks are OR'ed together.
 * - 0b1 - Selected FIFO watermarks are AND'ed together.
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_FAND field. */
#define PWM_RD_DMAEN_FAND(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_FAND_MASK) >> PWM_DMAEN_FAND_SHIFT)
#define PWM_BRD_DMAEN_FAND(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_FAND_SHIFT, PWM_DMAEN_FAND_WIDTH))

/*! @brief Set the FAND field to a new value. */
#define PWM_WR_DMAEN_FAND(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_FAND_MASK, PWM_DMAEN_FAND(value)))
#define PWM_BWR_DMAEN_FAND(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_FAND_SHIFT), PWM_DMAEN_FAND_SHIFT, PWM_DMAEN_FAND_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DMAEN, field VALDE[9] (RW)
 *
 * This read/write bit enables DMA write requests for the VALx and FRACVALx
 * registers when STS[RF] is set. Reset clears this bit.
 *
 * Values:
 * - 0b0 - DMA write requests disabled
 * - 0b1 - DMA write requests for the VALx and FRACVALx registers enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_DMAEN_VALDE field. */
#define PWM_RD_DMAEN_VALDE(base, index) ((PWM_DMAEN_REG(base, index) & PWM_DMAEN_VALDE_MASK) >> PWM_DMAEN_VALDE_SHIFT)
#define PWM_BRD_DMAEN_VALDE(base, index) (BME_UBFX16(&PWM_DMAEN_REG(base, index), PWM_DMAEN_VALDE_SHIFT, PWM_DMAEN_VALDE_WIDTH))

/*! @brief Set the VALDE field to a new value. */
#define PWM_WR_DMAEN_VALDE(base, index, value) (PWM_RMW_DMAEN(base, index, PWM_DMAEN_VALDE_MASK, PWM_DMAEN_VALDE(value)))
#define PWM_BWR_DMAEN_VALDE(base, index, value) (BME_BFI16(&PWM_DMAEN_REG(base, index), ((uint16_t)(value) << PWM_DMAEN_VALDE_SHIFT), PWM_DMAEN_VALDE_SHIFT, PWM_DMAEN_VALDE_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_TCTRL - Output Trigger Control Register
 ******************************************************************************/

/*!
 * @brief PWM_TCTRL - Output Trigger Control Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_TCTRL register
 */
/*@{*/
#define PWM_RD_TCTRL(base, index) (PWM_TCTRL_REG(base, index))
#define PWM_WR_TCTRL(base, index, value) (PWM_TCTRL_REG(base, index) = (value))
#define PWM_RMW_TCTRL(base, index, mask, value) (PWM_WR_TCTRL(base, index, (PWM_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PWM_SET_TCTRL(base, index, value) (BME_OR16(&PWM_TCTRL_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_TCTRL(base, index, value) (BME_AND16(&PWM_TCTRL_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_TCTRL(base, index, value) (BME_XOR16(&PWM_TCTRL_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_TCTRL bitfields
 */

/*!
 * @name Register PWM_TCTRL, field OUT_TRIG_EN[5:0] (RW)
 *
 * These bits enable the generation of PWM_OUT_TRIG0 and PWM_OUT_TRIG1 outputs
 * based on the counter value matching the value in one or more of the VAL0-5
 * registers. VAL0, VAL2, and VAL4 are used to generate PWM_OUT_TRIG0, and VAL1,
 * VAL3, and VAL5 are used to generate PWM_OUT_TRIG1. The PWM_OUT_TRIGx signals are
 * only asserted as long as the counter value matches the VALx value; therefore,
 * up to six triggers can be generated (three each on PWM_OUT_TRIG0 and
 * PWM_OUT_TRIG1) per PWM cycle per submodule. Due to delays in creating the PWM outputs,
 * the output trigger signals will lead the PWM output edges by 2-3 clock cycles
 * depending on the fractional cycle value being used.
 *
 * Values:
 * - 0b000000 - PWM_OUT_TRIGx will not set when the counter value matches the
 *     VALx value.
 * - 0b000001 - PWM_OUT_TRIGx will set when the counter value matches the VALx
 *     value.
 */
/*@{*/
/*! @brief Read current value of the PWM_TCTRL_OUT_TRIG_EN field. */
#define PWM_RD_TCTRL_OUT_TRIG_EN(base, index) ((PWM_TCTRL_REG(base, index) & PWM_TCTRL_OUT_TRIG_EN_MASK) >> PWM_TCTRL_OUT_TRIG_EN_SHIFT)
#define PWM_BRD_TCTRL_OUT_TRIG_EN(base, index) (BME_UBFX16(&PWM_TCTRL_REG(base, index), PWM_TCTRL_OUT_TRIG_EN_SHIFT, PWM_TCTRL_OUT_TRIG_EN_WIDTH))

/*! @brief Set the OUT_TRIG_EN field to a new value. */
#define PWM_WR_TCTRL_OUT_TRIG_EN(base, index, value) (PWM_RMW_TCTRL(base, index, PWM_TCTRL_OUT_TRIG_EN_MASK, PWM_TCTRL_OUT_TRIG_EN(value)))
#define PWM_BWR_TCTRL_OUT_TRIG_EN(base, index, value) (BME_BFI16(&PWM_TCTRL_REG(base, index), ((uint16_t)(value) << PWM_TCTRL_OUT_TRIG_EN_SHIFT), PWM_TCTRL_OUT_TRIG_EN_SHIFT, PWM_TCTRL_OUT_TRIG_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_TCTRL, field TRGFRQ[12] (RW)
 *
 * This read/write bit allows control over the frequency of the trigger outputs
 * when using non-zero values of CTRL[LDFQ].
 *
 * Values:
 * - 0b0 - Trigger outputs are generated during every PWM period even if the PWM
 *     is not reloaded every period due to CTRL[LDFQ] being non-zero.
 * - 0b1 - Trigger outputs are generated only during the final PWM period prior
 *     to a reload opportunity when the PWM is not reloaded every period due to
 *     CTRL[LDFQ] being non-zero.
 */
/*@{*/
/*! @brief Read current value of the PWM_TCTRL_TRGFRQ field. */
#define PWM_RD_TCTRL_TRGFRQ(base, index) ((PWM_TCTRL_REG(base, index) & PWM_TCTRL_TRGFRQ_MASK) >> PWM_TCTRL_TRGFRQ_SHIFT)
#define PWM_BRD_TCTRL_TRGFRQ(base, index) (BME_UBFX16(&PWM_TCTRL_REG(base, index), PWM_TCTRL_TRGFRQ_SHIFT, PWM_TCTRL_TRGFRQ_WIDTH))

/*! @brief Set the TRGFRQ field to a new value. */
#define PWM_WR_TCTRL_TRGFRQ(base, index, value) (PWM_RMW_TCTRL(base, index, PWM_TCTRL_TRGFRQ_MASK, PWM_TCTRL_TRGFRQ(value)))
#define PWM_BWR_TCTRL_TRGFRQ(base, index, value) (BME_BFI16(&PWM_TCTRL_REG(base, index), ((uint16_t)(value) << PWM_TCTRL_TRGFRQ_SHIFT), PWM_TCTRL_TRGFRQ_SHIFT, PWM_TCTRL_TRGFRQ_WIDTH))
/*@}*/

/*!
 * @name Register PWM_TCTRL, field PWBOT1[14] (RW)
 *
 * This bit selects which signal to bring out on the PWM's PWM_OUT_TRIG1 port.
 * The output trigger port is often connected to routing logic on the chip. This
 * control bit allows the PWM1 output signal to be driven onto the output trigger
 * port so it can be sent to the chip routing logic.
 *
 * Values:
 * - 0b0 - Route the PWM_OUT_TRIG1 signal to PWM_OUT_TRIG1 port.
 * - 0b1 - Route the PWM1 output to the PWM_OUT_TRIG1 port.
 */
/*@{*/
/*! @brief Read current value of the PWM_TCTRL_PWBOT1 field. */
#define PWM_RD_TCTRL_PWBOT1(base, index) ((PWM_TCTRL_REG(base, index) & PWM_TCTRL_PWBOT1_MASK) >> PWM_TCTRL_PWBOT1_SHIFT)
#define PWM_BRD_TCTRL_PWBOT1(base, index) (BME_UBFX16(&PWM_TCTRL_REG(base, index), PWM_TCTRL_PWBOT1_SHIFT, PWM_TCTRL_PWBOT1_WIDTH))

/*! @brief Set the PWBOT1 field to a new value. */
#define PWM_WR_TCTRL_PWBOT1(base, index, value) (PWM_RMW_TCTRL(base, index, PWM_TCTRL_PWBOT1_MASK, PWM_TCTRL_PWBOT1(value)))
#define PWM_BWR_TCTRL_PWBOT1(base, index, value) (BME_BFI16(&PWM_TCTRL_REG(base, index), ((uint16_t)(value) << PWM_TCTRL_PWBOT1_SHIFT), PWM_TCTRL_PWBOT1_SHIFT, PWM_TCTRL_PWBOT1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_TCTRL, field PWAOT0[15] (RW)
 *
 * This bit selects which signal to bring out on the PWM's PWM_OUT_TRIG0 port.
 * The output trigger port is often connected to routing logic on the chip. This
 * control bit allows the PWM0 output signal to be driven onto the output trigger
 * port so it can be sent to the chip routing logic.
 *
 * Values:
 * - 0b0 - Route the PWM_OUT_TRIG0 signal to PWM_OUT_TRIG0 port.
 * - 0b1 - Route the PWM0 output to the PWM_OUT_TRIG0 port.
 */
/*@{*/
/*! @brief Read current value of the PWM_TCTRL_PWAOT0 field. */
#define PWM_RD_TCTRL_PWAOT0(base, index) ((PWM_TCTRL_REG(base, index) & PWM_TCTRL_PWAOT0_MASK) >> PWM_TCTRL_PWAOT0_SHIFT)
#define PWM_BRD_TCTRL_PWAOT0(base, index) (BME_UBFX16(&PWM_TCTRL_REG(base, index), PWM_TCTRL_PWAOT0_SHIFT, PWM_TCTRL_PWAOT0_WIDTH))

/*! @brief Set the PWAOT0 field to a new value. */
#define PWM_WR_TCTRL_PWAOT0(base, index, value) (PWM_RMW_TCTRL(base, index, PWM_TCTRL_PWAOT0_MASK, PWM_TCTRL_PWAOT0(value)))
#define PWM_BWR_TCTRL_PWAOT0(base, index, value) (BME_BFI16(&PWM_TCTRL_REG(base, index), ((uint16_t)(value) << PWM_TCTRL_PWAOT0_SHIFT), PWM_TCTRL_PWAOT0_SHIFT, PWM_TCTRL_PWAOT0_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_DISMAP - Fault Disable Mapping Register 0
 ******************************************************************************/

/*!
 * @brief PWM_DISMAP - Fault Disable Mapping Register 0 (RW)
 *
 * Reset value: 0xFFFFU
 *
 * This register determines which PWM pins are disabled by the fault protection
 * inputs. Reset sets all of the bits in the fault disable mapping register.
 */
/*!
 * @name Constants and macros for entire PWM_DISMAP register
 */
/*@{*/
#define PWM_RD_DISMAP(base, index, index2) (PWM_DISMAP_REG(base, index, index2))
#define PWM_WR_DISMAP(base, index, index2, value) (PWM_DISMAP_REG(base, index, index2) = (value))
#define PWM_RMW_DISMAP(base, index, index2, mask, value) (PWM_WR_DISMAP(base, index, index2, (PWM_RD_DISMAP(base, index, index2) & ~(mask)) | (value)))
#define PWM_SET_DISMAP(base, index, index2, value) (BME_OR16(&PWM_DISMAP_REG(base, index, index2), (uint16_t)(value)))
#define PWM_CLR_DISMAP(base, index, index2, value) (BME_AND16(&PWM_DISMAP_REG(base, index, index2), (uint16_t)(~(value))))
#define PWM_TOG_DISMAP(base, index, index2, value) (BME_XOR16(&PWM_DISMAP_REG(base, index, index2), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_DISMAP bitfields
 */

/*!
 * @name Register PWM_DISMAP, field DIS0A[3:0] (RW)
 *
 * Each of the four bits of this read/write field is one-to-one associated with
 * the four FAULTx inputs of fault channel 0. The PWM_A output is turned off if
 * there is a logic 1 on a FAULTx input and a 1 in the corresponding bit of this
 * field. A reset sets all bits in this field.
 */
/*@{*/
/*! @brief Read current value of the PWM_DISMAP_DIS0A field. */
#define PWM_RD_DISMAP_DIS0A(base, index, index2) ((PWM_DISMAP_REG(base, index, index2) & PWM_DISMAP_DIS0A_MASK) >> PWM_DISMAP_DIS0A_SHIFT)
#define PWM_BRD_DISMAP_DIS0A(base, index, index2) (BME_UBFX16(&PWM_DISMAP_REG(base, index, index2), PWM_DISMAP_DIS0A_SHIFT, PWM_DISMAP_DIS0A_WIDTH))

/*! @brief Set the DIS0A field to a new value. */
#define PWM_WR_DISMAP_DIS0A(base, index, index2, value) (PWM_RMW_DISMAP(base, index, index2, PWM_DISMAP_DIS0A_MASK, PWM_DISMAP_DIS0A(value)))
#define PWM_BWR_DISMAP_DIS0A(base, index, index2, value) (BME_BFI16(&PWM_DISMAP_REG(base, index, index2), ((uint16_t)(value) << PWM_DISMAP_DIS0A_SHIFT), PWM_DISMAP_DIS0A_SHIFT, PWM_DISMAP_DIS0A_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DISMAP, field DIS0B[7:4] (RW)
 *
 * Each of the four bits of this read/write field is one-to-one associated with
 * the four FAULTx inputs of fault channel 0. The PWM_B output is turned off if
 * there is a logic 1 on a FAULTx input and a 1 in the corresponding bit of this
 * field. A reset sets all bits in this field.
 */
/*@{*/
/*! @brief Read current value of the PWM_DISMAP_DIS0B field. */
#define PWM_RD_DISMAP_DIS0B(base, index, index2) ((PWM_DISMAP_REG(base, index, index2) & PWM_DISMAP_DIS0B_MASK) >> PWM_DISMAP_DIS0B_SHIFT)
#define PWM_BRD_DISMAP_DIS0B(base, index, index2) (BME_UBFX16(&PWM_DISMAP_REG(base, index, index2), PWM_DISMAP_DIS0B_SHIFT, PWM_DISMAP_DIS0B_WIDTH))

/*! @brief Set the DIS0B field to a new value. */
#define PWM_WR_DISMAP_DIS0B(base, index, index2, value) (PWM_RMW_DISMAP(base, index, index2, PWM_DISMAP_DIS0B_MASK, PWM_DISMAP_DIS0B(value)))
#define PWM_BWR_DISMAP_DIS0B(base, index, index2, value) (BME_BFI16(&PWM_DISMAP_REG(base, index, index2), ((uint16_t)(value) << PWM_DISMAP_DIS0B_SHIFT), PWM_DISMAP_DIS0B_SHIFT, PWM_DISMAP_DIS0B_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DISMAP, field DIS0X[11:8] (RW)
 *
 * Each of the four bits of this read/write field is one-to-one associated with
 * the four FAULTx inputs of fault channel 0. The PWM_X output is turned off if
 * there is a logic 1 on a FAULTx input and a 1 in the corresponding bit of this
 * field. A reset sets all bits in this field.
 */
/*@{*/
/*! @brief Read current value of the PWM_DISMAP_DIS0X field. */
#define PWM_RD_DISMAP_DIS0X(base, index, index2) ((PWM_DISMAP_REG(base, index, index2) & PWM_DISMAP_DIS0X_MASK) >> PWM_DISMAP_DIS0X_SHIFT)
#define PWM_BRD_DISMAP_DIS0X(base, index, index2) (BME_UBFX16(&PWM_DISMAP_REG(base, index, index2), PWM_DISMAP_DIS0X_SHIFT, PWM_DISMAP_DIS0X_WIDTH))

/*! @brief Set the DIS0X field to a new value. */
#define PWM_WR_DISMAP_DIS0X(base, index, index2, value) (PWM_RMW_DISMAP(base, index, index2, PWM_DISMAP_DIS0X_MASK, PWM_DISMAP_DIS0X(value)))
#define PWM_BWR_DISMAP_DIS0X(base, index, index2, value) (BME_BFI16(&PWM_DISMAP_REG(base, index, index2), ((uint16_t)(value) << PWM_DISMAP_DIS0X_SHIFT), PWM_DISMAP_DIS0X_SHIFT, PWM_DISMAP_DIS0X_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_DTCNT0 - Deadtime Count Register 0
 ******************************************************************************/

/*!
 * @brief PWM_DTCNT0 - Deadtime Count Register 0 (RW)
 *
 * Reset value: 0x07FFU
 *
 * Deadtime operation applies only to complementary channel operation. The
 * values written to the DTCNTx registers are in terms of IPBus clock cycles
 * regardless of the setting of CTRL[PRSC] and/or CTRL2[CLK_SEL]. Reset sets the deadtime
 * count registers to a default value of 0x07FF, selecting a deadtime of 2047
 * IPBus clock cycles. The DTCNTx registers are not byte accessible.
 */
/*!
 * @name Constants and macros for entire PWM_DTCNT0 register
 */
/*@{*/
#define PWM_RD_DTCNT0(base, index) (PWM_DTCNT0_REG(base, index))
#define PWM_WR_DTCNT0(base, index, value) (PWM_DTCNT0_REG(base, index) = (value))
#define PWM_RMW_DTCNT0(base, index, mask, value) (PWM_WR_DTCNT0(base, index, (PWM_RD_DTCNT0(base, index) & ~(mask)) | (value)))
#define PWM_SET_DTCNT0(base, index, value) (BME_OR16(&PWM_DTCNT0_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_DTCNT0(base, index, value) (BME_AND16(&PWM_DTCNT0_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_DTCNT0(base, index, value) (BME_XOR16(&PWM_DTCNT0_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_DTCNT1 - Deadtime Count Register 1
 ******************************************************************************/

/*!
 * @brief PWM_DTCNT1 - Deadtime Count Register 1 (RW)
 *
 * Reset value: 0x07FFU
 *
 * Deadtime operation applies only to complementary channel operation. The
 * values written to the DTCNTx registers are in terms of IPBus clock cycles
 * regardless of the setting of CTRL[PRSC] and/or CTRL2[CLK_SEL]. Reset sets the deadtime
 * count registers to a default value of 0x07FF, selecting a deadtime of 2047
 * IPBus clock cycles. The DTCNTx registers are not byte accessible.
 */
/*!
 * @name Constants and macros for entire PWM_DTCNT1 register
 */
/*@{*/
#define PWM_RD_DTCNT1(base, index) (PWM_DTCNT1_REG(base, index))
#define PWM_WR_DTCNT1(base, index, value) (PWM_DTCNT1_REG(base, index) = (value))
#define PWM_RMW_DTCNT1(base, index, mask, value) (PWM_WR_DTCNT1(base, index, (PWM_RD_DTCNT1(base, index) & ~(mask)) | (value)))
#define PWM_SET_DTCNT1(base, index, value) (BME_OR16(&PWM_DTCNT1_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_DTCNT1(base, index, value) (BME_AND16(&PWM_DTCNT1_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_DTCNT1(base, index, value) (BME_XOR16(&PWM_DTCNT1_REG(base, index), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCTRLA - Capture Control A Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCTRLA - Capture Control A Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCTRLA register
 */
/*@{*/
#define PWM_RD_CAPTCTRLA(base, index) (PWM_CAPTCTRLA_REG(base, index))
#define PWM_WR_CAPTCTRLA(base, index, value) (PWM_CAPTCTRLA_REG(base, index) = (value))
#define PWM_RMW_CAPTCTRLA(base, index, mask, value) (PWM_WR_CAPTCTRLA(base, index, (PWM_RD_CAPTCTRLA(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCTRLA(base, index, value) (BME_OR16(&PWM_CAPTCTRLA_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCTRLA(base, index, value) (BME_AND16(&PWM_CAPTCTRLA_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCTRLA(base, index, value) (BME_XOR16(&PWM_CAPTCTRLA_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCTRLA bitfields
 */

/*!
 * @name Register PWM_CAPTCTRLA, field ARMA[0] (RW)
 *
 * Setting this bit high starts the input capture process. This bit can be
 * cleared at any time to disable input capture operation. This bit is self-cleared
 * when in one shot mode and one or more of the enabled capture circuits has had a
 * capture event.
 *
 * Values:
 * - 0b0 - Input capture operation is disabled.
 * - 0b1 - Input capture operation as specified by CAPTCTRLA[EDGAx] is enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_ARMA field. */
#define PWM_RD_CAPTCTRLA_ARMA(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_ARMA_MASK) >> PWM_CAPTCTRLA_ARMA_SHIFT)
#define PWM_BRD_CAPTCTRLA_ARMA(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_ARMA_SHIFT, PWM_CAPTCTRLA_ARMA_WIDTH))

/*! @brief Set the ARMA field to a new value. */
#define PWM_WR_CAPTCTRLA_ARMA(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_ARMA_MASK, PWM_CAPTCTRLA_ARMA(value)))
#define PWM_BWR_CAPTCTRLA_ARMA(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_ARMA_SHIFT), PWM_CAPTCTRLA_ARMA_SHIFT, PWM_CAPTCTRLA_ARMA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field ONESHOTA[1] (RW)
 *
 * This bit selects between free running and one shot mode for the input capture
 * circuitry.
 *
 * Values:
 * - 0b0 - Free running mode is selected. If both capture circuits are enabled,
 *     then capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is
 *     armed. After capture circuit 1 performs a capture, it is disarmed and
 *     capture circuit 0 is re-armed. The process continues indefinitely. If only one
 *     of the capture circuits is enabled, then captures continue indefinitely on
 *     the enabled capture circuit.
 * - 0b1 - One shot mode is selected. If both capture circuits are enabled, then
 *     capture circuit 0 is armed first after CAPTCTRLA[ARMA] is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed.
 *     After capture circuit 1 performs a capture, it is disarmed and
 *     CAPTCTRLA[ARMA] is cleared. No further captures will be performed until
 *     CAPTCTRLA[ARMA] is set again. If only one of the capture circuits is enabled, then a
 *     single capture will occur on the enabled capture circuit and
 *     CAPTCTRLA[ARMA] is then cleared.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_ONESHOTA field. */
#define PWM_RD_CAPTCTRLA_ONESHOTA(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_ONESHOTA_MASK) >> PWM_CAPTCTRLA_ONESHOTA_SHIFT)
#define PWM_BRD_CAPTCTRLA_ONESHOTA(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_ONESHOTA_SHIFT, PWM_CAPTCTRLA_ONESHOTA_WIDTH))

/*! @brief Set the ONESHOTA field to a new value. */
#define PWM_WR_CAPTCTRLA_ONESHOTA(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_ONESHOTA_MASK, PWM_CAPTCTRLA_ONESHOTA(value)))
#define PWM_BWR_CAPTCTRLA_ONESHOTA(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_ONESHOTA_SHIFT), PWM_CAPTCTRLA_ONESHOTA_SHIFT, PWM_CAPTCTRLA_ONESHOTA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field EDGA0[3:2] (RW)
 *
 * These bits control the input capture 0 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_EDGA0 field. */
#define PWM_RD_CAPTCTRLA_EDGA0(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_EDGA0_MASK) >> PWM_CAPTCTRLA_EDGA0_SHIFT)
#define PWM_BRD_CAPTCTRLA_EDGA0(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_EDGA0_SHIFT, PWM_CAPTCTRLA_EDGA0_WIDTH))

/*! @brief Set the EDGA0 field to a new value. */
#define PWM_WR_CAPTCTRLA_EDGA0(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_EDGA0_MASK, PWM_CAPTCTRLA_EDGA0(value)))
#define PWM_BWR_CAPTCTRLA_EDGA0(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_EDGA0_SHIFT), PWM_CAPTCTRLA_EDGA0_SHIFT, PWM_CAPTCTRLA_EDGA0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field EDGA1[5:4] (RW)
 *
 * These bits control the input capture 1 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_EDGA1 field. */
#define PWM_RD_CAPTCTRLA_EDGA1(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_EDGA1_MASK) >> PWM_CAPTCTRLA_EDGA1_SHIFT)
#define PWM_BRD_CAPTCTRLA_EDGA1(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_EDGA1_SHIFT, PWM_CAPTCTRLA_EDGA1_WIDTH))

/*! @brief Set the EDGA1 field to a new value. */
#define PWM_WR_CAPTCTRLA_EDGA1(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_EDGA1_MASK, PWM_CAPTCTRLA_EDGA1(value)))
#define PWM_BWR_CAPTCTRLA_EDGA1(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_EDGA1_SHIFT), PWM_CAPTCTRLA_EDGA1_SHIFT, PWM_CAPTCTRLA_EDGA1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field INP_SELA[6] (RW)
 *
 * This bit selects between the raw PWM_A input signal and the output of the
 * edge counter/compare circuitry as the source for the input capture circuit.
 *
 * Values:
 * - 0b0 - Raw PWM_A input signal selected as source.
 * - 0b1 - Output of edge counter/compare selected as source. When this bitfield
 *     is set to 1, the internal edge counter is enabled and the rising and/or
 *     falling edges specified by the CAPTCTRLA[EDGA0] and CAPTCTRLA[EDGA1] fields
 *     are ignored. The software must still place a value other than 00 in
 *     either or both of the CAPTCTLRA[EDGA0] and/or CAPTCTRLA[EDGA1] fields in order
 *     to enable one or both of the capture registers.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_INP_SELA field. */
#define PWM_RD_CAPTCTRLA_INP_SELA(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_INP_SELA_MASK) >> PWM_CAPTCTRLA_INP_SELA_SHIFT)
#define PWM_BRD_CAPTCTRLA_INP_SELA(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_INP_SELA_SHIFT, PWM_CAPTCTRLA_INP_SELA_WIDTH))

/*! @brief Set the INP_SELA field to a new value. */
#define PWM_WR_CAPTCTRLA_INP_SELA(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_INP_SELA_MASK, PWM_CAPTCTRLA_INP_SELA(value)))
#define PWM_BWR_CAPTCTRLA_INP_SELA(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_INP_SELA_SHIFT), PWM_CAPTCTRLA_INP_SELA_SHIFT, PWM_CAPTCTRLA_INP_SELA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field EDGCNTA_EN[7] (RW)
 *
 * This bit enables the edge counter which counts rising and falling edges on
 * the PWM_A input signal.
 *
 * Values:
 * - 0b0 - Edge counter disabled and held in reset
 * - 0b1 - Edge counter enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_EDGCNTA_EN field. */
#define PWM_RD_CAPTCTRLA_EDGCNTA_EN(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_EDGCNTA_EN_MASK) >> PWM_CAPTCTRLA_EDGCNTA_EN_SHIFT)
#define PWM_BRD_CAPTCTRLA_EDGCNTA_EN(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_EDGCNTA_EN_SHIFT, PWM_CAPTCTRLA_EDGCNTA_EN_WIDTH))

/*! @brief Set the EDGCNTA_EN field to a new value. */
#define PWM_WR_CAPTCTRLA_EDGCNTA_EN(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_EDGCNTA_EN_MASK, PWM_CAPTCTRLA_EDGCNTA_EN(value)))
#define PWM_BWR_CAPTCTRLA_EDGCNTA_EN(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_EDGCNTA_EN_SHIFT), PWM_CAPTCTRLA_EDGCNTA_EN_SHIFT, PWM_CAPTCTRLA_EDGCNTA_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field CFAWM[9:8] (RW)
 *
 * This field represents the water mark level for capture A FIFOs. The capture
 * flags, STS[CFA1] and STS[CFA0], are not set until the word count of the
 * corresponding FIFO is greater than this water mark level. (FIFO depth is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_CFAWM field. */
#define PWM_RD_CAPTCTRLA_CFAWM(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_CFAWM_MASK) >> PWM_CAPTCTRLA_CFAWM_SHIFT)
#define PWM_BRD_CAPTCTRLA_CFAWM(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_CFAWM_SHIFT, PWM_CAPTCTRLA_CFAWM_WIDTH))

/*! @brief Set the CFAWM field to a new value. */
#define PWM_WR_CAPTCTRLA_CFAWM(base, index, value) (PWM_RMW_CAPTCTRLA(base, index, PWM_CAPTCTRLA_CFAWM_MASK, PWM_CAPTCTRLA_CFAWM(value)))
#define PWM_BWR_CAPTCTRLA_CFAWM(base, index, value) (BME_BFI16(&PWM_CAPTCTRLA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLA_CFAWM_SHIFT), PWM_CAPTCTRLA_CFAWM_SHIFT, PWM_CAPTCTRLA_CFAWM_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field CA0CNT[12:10] (RO)
 *
 * This field reflects the number of words in the Capture A0 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_CA0CNT field. */
#define PWM_RD_CAPTCTRLA_CA0CNT(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_CA0CNT_MASK) >> PWM_CAPTCTRLA_CA0CNT_SHIFT)
#define PWM_BRD_CAPTCTRLA_CA0CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_CA0CNT_SHIFT, PWM_CAPTCTRLA_CA0CNT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLA, field CA1CNT[15:13] (RO)
 *
 * This field reflects the number of words in the Capture A1 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLA_CA1CNT field. */
#define PWM_RD_CAPTCTRLA_CA1CNT(base, index) ((PWM_CAPTCTRLA_REG(base, index) & PWM_CAPTCTRLA_CA1CNT_MASK) >> PWM_CAPTCTRLA_CA1CNT_SHIFT)
#define PWM_BRD_CAPTCTRLA_CA1CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLA_REG(base, index), PWM_CAPTCTRLA_CA1CNT_SHIFT, PWM_CAPTCTRLA_CA1CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCOMPA - Capture Compare A Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCOMPA - Capture Compare A Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCOMPA register
 */
/*@{*/
#define PWM_RD_CAPTCOMPA(base, index) (PWM_CAPTCOMPA_REG(base, index))
#define PWM_WR_CAPTCOMPA(base, index, value) (PWM_CAPTCOMPA_REG(base, index) = (value))
#define PWM_RMW_CAPTCOMPA(base, index, mask, value) (PWM_WR_CAPTCOMPA(base, index, (PWM_RD_CAPTCOMPA(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCOMPA(base, index, value) (BME_OR16(&PWM_CAPTCOMPA_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCOMPA(base, index, value) (BME_AND16(&PWM_CAPTCOMPA_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCOMPA(base, index, value) (BME_XOR16(&PWM_CAPTCOMPA_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCOMPA bitfields
 */

/*!
 * @name Register PWM_CAPTCOMPA, field EDGCMPA[7:0] (RW)
 *
 * This read/write field is the compare value associated with the edge counter
 * for the PWM_A input capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPA_EDGCMPA field. */
#define PWM_RD_CAPTCOMPA_EDGCMPA(base, index) ((PWM_CAPTCOMPA_REG(base, index) & PWM_CAPTCOMPA_EDGCMPA_MASK) >> PWM_CAPTCOMPA_EDGCMPA_SHIFT)
#define PWM_BRD_CAPTCOMPA_EDGCMPA(base, index) (BME_UBFX16(&PWM_CAPTCOMPA_REG(base, index), PWM_CAPTCOMPA_EDGCMPA_SHIFT, PWM_CAPTCOMPA_EDGCMPA_WIDTH))

/*! @brief Set the EDGCMPA field to a new value. */
#define PWM_WR_CAPTCOMPA_EDGCMPA(base, index, value) (PWM_RMW_CAPTCOMPA(base, index, PWM_CAPTCOMPA_EDGCMPA_MASK, PWM_CAPTCOMPA_EDGCMPA(value)))
#define PWM_BWR_CAPTCOMPA_EDGCMPA(base, index, value) (BME_BFI16(&PWM_CAPTCOMPA_REG(base, index), ((uint16_t)(value) << PWM_CAPTCOMPA_EDGCMPA_SHIFT), PWM_CAPTCOMPA_EDGCMPA_SHIFT, PWM_CAPTCOMPA_EDGCMPA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCOMPA, field EDGCNTA[15:8] (RO)
 *
 * This read-only field contains the edge counter value for the PWM_A input
 * capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPA_EDGCNTA field. */
#define PWM_RD_CAPTCOMPA_EDGCNTA(base, index) ((PWM_CAPTCOMPA_REG(base, index) & PWM_CAPTCOMPA_EDGCNTA_MASK) >> PWM_CAPTCOMPA_EDGCNTA_SHIFT)
#define PWM_BRD_CAPTCOMPA_EDGCNTA(base, index) (BME_UBFX16(&PWM_CAPTCOMPA_REG(base, index), PWM_CAPTCOMPA_EDGCNTA_SHIFT, PWM_CAPTCOMPA_EDGCNTA_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCTRLB - Capture Control B Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCTRLB - Capture Control B Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCTRLB register
 */
/*@{*/
#define PWM_RD_CAPTCTRLB(base, index) (PWM_CAPTCTRLB_REG(base, index))
#define PWM_WR_CAPTCTRLB(base, index, value) (PWM_CAPTCTRLB_REG(base, index) = (value))
#define PWM_RMW_CAPTCTRLB(base, index, mask, value) (PWM_WR_CAPTCTRLB(base, index, (PWM_RD_CAPTCTRLB(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCTRLB(base, index, value) (BME_OR16(&PWM_CAPTCTRLB_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCTRLB(base, index, value) (BME_AND16(&PWM_CAPTCTRLB_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCTRLB(base, index, value) (BME_XOR16(&PWM_CAPTCTRLB_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCTRLB bitfields
 */

/*!
 * @name Register PWM_CAPTCTRLB, field ARMB[0] (RW)
 *
 * Setting this bit high starts the input capture process. This bit can be
 * cleared at any time to disable input capture operation. This bit is self-cleared
 * when in one shot mode and one or more of the enabled capture circuits has had a
 * capture event.
 *
 * Values:
 * - 0b0 - Input capture operation is disabled.
 * - 0b1 - Input capture operation as specified by CAPTCTRLB[EDGBx] is enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_ARMB field. */
#define PWM_RD_CAPTCTRLB_ARMB(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_ARMB_MASK) >> PWM_CAPTCTRLB_ARMB_SHIFT)
#define PWM_BRD_CAPTCTRLB_ARMB(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_ARMB_SHIFT, PWM_CAPTCTRLB_ARMB_WIDTH))

/*! @brief Set the ARMB field to a new value. */
#define PWM_WR_CAPTCTRLB_ARMB(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_ARMB_MASK, PWM_CAPTCTRLB_ARMB(value)))
#define PWM_BWR_CAPTCTRLB_ARMB(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_ARMB_SHIFT), PWM_CAPTCTRLB_ARMB_SHIFT, PWM_CAPTCTRLB_ARMB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field ONESHOTB[1] (RW)
 *
 * This bit selects between free running and one shot mode for the input capture
 * circuitry.
 *
 * Values:
 * - 0b0 - Free running mode is selected. If both capture circuits are enabled,
 *     then capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is
 *     armed. After capture circuit 1 performs a capture, it is disarmed and
 *     capture circuit 0 is re-armed. The process continues indefinitely. If only one
 *     of the capture circuits is enabled, then captures continue indefinitely on
 *     the enabled capture circuit.
 * - 0b1 - One shot mode is selected. If both capture circuits are enabled, then
 *     capture circuit 0 is armed first after CAPTCTRLB[ARMB] is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed.
 *     After capture circuit 1 performs a capture, it is disarmed and
 *     CAPTCTRLB[ARMB] is cleared. No further captures will be performed until
 *     CAPTCTRLB[ARMB] is set again. If only one of the capture circuits is enabled, then a
 *     single capture will occur on the enabled capture circuit and
 *     CAPTCTRLB[ARMB] is then cleared.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_ONESHOTB field. */
#define PWM_RD_CAPTCTRLB_ONESHOTB(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_ONESHOTB_MASK) >> PWM_CAPTCTRLB_ONESHOTB_SHIFT)
#define PWM_BRD_CAPTCTRLB_ONESHOTB(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_ONESHOTB_SHIFT, PWM_CAPTCTRLB_ONESHOTB_WIDTH))

/*! @brief Set the ONESHOTB field to a new value. */
#define PWM_WR_CAPTCTRLB_ONESHOTB(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_ONESHOTB_MASK, PWM_CAPTCTRLB_ONESHOTB(value)))
#define PWM_BWR_CAPTCTRLB_ONESHOTB(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_ONESHOTB_SHIFT), PWM_CAPTCTRLB_ONESHOTB_SHIFT, PWM_CAPTCTRLB_ONESHOTB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field EDGB0[3:2] (RW)
 *
 * These bits control the input capture 0 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_EDGB0 field. */
#define PWM_RD_CAPTCTRLB_EDGB0(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_EDGB0_MASK) >> PWM_CAPTCTRLB_EDGB0_SHIFT)
#define PWM_BRD_CAPTCTRLB_EDGB0(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_EDGB0_SHIFT, PWM_CAPTCTRLB_EDGB0_WIDTH))

/*! @brief Set the EDGB0 field to a new value. */
#define PWM_WR_CAPTCTRLB_EDGB0(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_EDGB0_MASK, PWM_CAPTCTRLB_EDGB0(value)))
#define PWM_BWR_CAPTCTRLB_EDGB0(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_EDGB0_SHIFT), PWM_CAPTCTRLB_EDGB0_SHIFT, PWM_CAPTCTRLB_EDGB0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field EDGB1[5:4] (RW)
 *
 * These bits control the input capture 1 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_EDGB1 field. */
#define PWM_RD_CAPTCTRLB_EDGB1(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_EDGB1_MASK) >> PWM_CAPTCTRLB_EDGB1_SHIFT)
#define PWM_BRD_CAPTCTRLB_EDGB1(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_EDGB1_SHIFT, PWM_CAPTCTRLB_EDGB1_WIDTH))

/*! @brief Set the EDGB1 field to a new value. */
#define PWM_WR_CAPTCTRLB_EDGB1(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_EDGB1_MASK, PWM_CAPTCTRLB_EDGB1(value)))
#define PWM_BWR_CAPTCTRLB_EDGB1(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_EDGB1_SHIFT), PWM_CAPTCTRLB_EDGB1_SHIFT, PWM_CAPTCTRLB_EDGB1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field INP_SELB[6] (RW)
 *
 * This bit selects between the raw PWM_B input signal and the output of the
 * edge counter/compare circuitry as the source for the input capture circuit.
 *
 * Values:
 * - 0b0 - Raw PWM_B input signal selected as source.
 * - 0b1 - Output of edge counter/compare selected as source. When this bitfield
 *     is set to 1, the internal edge counter is enabled and the rising and/or
 *     falling edges specified by the CAPTCTRLB[EDGB0] and CAPTCTRLB[EDGB1] fields
 *     are ignored. The software must still place a value other than 00 in
 *     either or both of the CAPTCTLRB[EDGB0] and/or CAPTCTRLB[EDGB1] fields in order
 *     to enable one or both of the capture registers.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_INP_SELB field. */
#define PWM_RD_CAPTCTRLB_INP_SELB(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_INP_SELB_MASK) >> PWM_CAPTCTRLB_INP_SELB_SHIFT)
#define PWM_BRD_CAPTCTRLB_INP_SELB(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_INP_SELB_SHIFT, PWM_CAPTCTRLB_INP_SELB_WIDTH))

/*! @brief Set the INP_SELB field to a new value. */
#define PWM_WR_CAPTCTRLB_INP_SELB(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_INP_SELB_MASK, PWM_CAPTCTRLB_INP_SELB(value)))
#define PWM_BWR_CAPTCTRLB_INP_SELB(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_INP_SELB_SHIFT), PWM_CAPTCTRLB_INP_SELB_SHIFT, PWM_CAPTCTRLB_INP_SELB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field EDGCNTB_EN[7] (RW)
 *
 * This bit enables the edge counter which counts rising and falling edges on
 * the PWM_B input signal.
 *
 * Values:
 * - 0b0 - Edge counter disabled and held in reset
 * - 0b1 - Edge counter enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_EDGCNTB_EN field. */
#define PWM_RD_CAPTCTRLB_EDGCNTB_EN(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_EDGCNTB_EN_MASK) >> PWM_CAPTCTRLB_EDGCNTB_EN_SHIFT)
#define PWM_BRD_CAPTCTRLB_EDGCNTB_EN(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_EDGCNTB_EN_SHIFT, PWM_CAPTCTRLB_EDGCNTB_EN_WIDTH))

/*! @brief Set the EDGCNTB_EN field to a new value. */
#define PWM_WR_CAPTCTRLB_EDGCNTB_EN(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_EDGCNTB_EN_MASK, PWM_CAPTCTRLB_EDGCNTB_EN(value)))
#define PWM_BWR_CAPTCTRLB_EDGCNTB_EN(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_EDGCNTB_EN_SHIFT), PWM_CAPTCTRLB_EDGCNTB_EN_SHIFT, PWM_CAPTCTRLB_EDGCNTB_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field CFBWM[9:8] (RW)
 *
 * This field represents the water mark level for capture B FIFOs. The capture
 * flags, STS[CFB1] and STS[CFB0], won't be set until the word count of the
 * corresponding FIFO is greater than this water mark level. (FIFO depth is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_CFBWM field. */
#define PWM_RD_CAPTCTRLB_CFBWM(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_CFBWM_MASK) >> PWM_CAPTCTRLB_CFBWM_SHIFT)
#define PWM_BRD_CAPTCTRLB_CFBWM(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_CFBWM_SHIFT, PWM_CAPTCTRLB_CFBWM_WIDTH))

/*! @brief Set the CFBWM field to a new value. */
#define PWM_WR_CAPTCTRLB_CFBWM(base, index, value) (PWM_RMW_CAPTCTRLB(base, index, PWM_CAPTCTRLB_CFBWM_MASK, PWM_CAPTCTRLB_CFBWM(value)))
#define PWM_BWR_CAPTCTRLB_CFBWM(base, index, value) (BME_BFI16(&PWM_CAPTCTRLB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLB_CFBWM_SHIFT), PWM_CAPTCTRLB_CFBWM_SHIFT, PWM_CAPTCTRLB_CFBWM_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field CB0CNT[12:10] (RO)
 *
 * This field reflects the number of words in the Capture B0 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_CB0CNT field. */
#define PWM_RD_CAPTCTRLB_CB0CNT(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_CB0CNT_MASK) >> PWM_CAPTCTRLB_CB0CNT_SHIFT)
#define PWM_BRD_CAPTCTRLB_CB0CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_CB0CNT_SHIFT, PWM_CAPTCTRLB_CB0CNT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLB, field CB1CNT[15:13] (RO)
 *
 * This field reflects the number of words in the Capture B1 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLB_CB1CNT field. */
#define PWM_RD_CAPTCTRLB_CB1CNT(base, index) ((PWM_CAPTCTRLB_REG(base, index) & PWM_CAPTCTRLB_CB1CNT_MASK) >> PWM_CAPTCTRLB_CB1CNT_SHIFT)
#define PWM_BRD_CAPTCTRLB_CB1CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLB_REG(base, index), PWM_CAPTCTRLB_CB1CNT_SHIFT, PWM_CAPTCTRLB_CB1CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCOMPB - Capture Compare B Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCOMPB - Capture Compare B Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCOMPB register
 */
/*@{*/
#define PWM_RD_CAPTCOMPB(base, index) (PWM_CAPTCOMPB_REG(base, index))
#define PWM_WR_CAPTCOMPB(base, index, value) (PWM_CAPTCOMPB_REG(base, index) = (value))
#define PWM_RMW_CAPTCOMPB(base, index, mask, value) (PWM_WR_CAPTCOMPB(base, index, (PWM_RD_CAPTCOMPB(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCOMPB(base, index, value) (BME_OR16(&PWM_CAPTCOMPB_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCOMPB(base, index, value) (BME_AND16(&PWM_CAPTCOMPB_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCOMPB(base, index, value) (BME_XOR16(&PWM_CAPTCOMPB_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCOMPB bitfields
 */

/*!
 * @name Register PWM_CAPTCOMPB, field EDGCMPB[7:0] (RW)
 *
 * This read/write field is the compare value associated with the edge counter
 * for the PWM_B input capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPB_EDGCMPB field. */
#define PWM_RD_CAPTCOMPB_EDGCMPB(base, index) ((PWM_CAPTCOMPB_REG(base, index) & PWM_CAPTCOMPB_EDGCMPB_MASK) >> PWM_CAPTCOMPB_EDGCMPB_SHIFT)
#define PWM_BRD_CAPTCOMPB_EDGCMPB(base, index) (BME_UBFX16(&PWM_CAPTCOMPB_REG(base, index), PWM_CAPTCOMPB_EDGCMPB_SHIFT, PWM_CAPTCOMPB_EDGCMPB_WIDTH))

/*! @brief Set the EDGCMPB field to a new value. */
#define PWM_WR_CAPTCOMPB_EDGCMPB(base, index, value) (PWM_RMW_CAPTCOMPB(base, index, PWM_CAPTCOMPB_EDGCMPB_MASK, PWM_CAPTCOMPB_EDGCMPB(value)))
#define PWM_BWR_CAPTCOMPB_EDGCMPB(base, index, value) (BME_BFI16(&PWM_CAPTCOMPB_REG(base, index), ((uint16_t)(value) << PWM_CAPTCOMPB_EDGCMPB_SHIFT), PWM_CAPTCOMPB_EDGCMPB_SHIFT, PWM_CAPTCOMPB_EDGCMPB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCOMPB, field EDGCNTB[15:8] (RO)
 *
 * This read-only field contains the edge counter value for the PWM_B input
 * capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPB_EDGCNTB field. */
#define PWM_RD_CAPTCOMPB_EDGCNTB(base, index) ((PWM_CAPTCOMPB_REG(base, index) & PWM_CAPTCOMPB_EDGCNTB_MASK) >> PWM_CAPTCOMPB_EDGCNTB_SHIFT)
#define PWM_BRD_CAPTCOMPB_EDGCNTB(base, index) (BME_UBFX16(&PWM_CAPTCOMPB_REG(base, index), PWM_CAPTCOMPB_EDGCNTB_SHIFT, PWM_CAPTCOMPB_EDGCNTB_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCTRLX - Capture Control X Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCTRLX - Capture Control X Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCTRLX register
 */
/*@{*/
#define PWM_RD_CAPTCTRLX(base, index) (PWM_CAPTCTRLX_REG(base, index))
#define PWM_WR_CAPTCTRLX(base, index, value) (PWM_CAPTCTRLX_REG(base, index) = (value))
#define PWM_RMW_CAPTCTRLX(base, index, mask, value) (PWM_WR_CAPTCTRLX(base, index, (PWM_RD_CAPTCTRLX(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCTRLX(base, index, value) (BME_OR16(&PWM_CAPTCTRLX_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCTRLX(base, index, value) (BME_AND16(&PWM_CAPTCTRLX_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCTRLX(base, index, value) (BME_XOR16(&PWM_CAPTCTRLX_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCTRLX bitfields
 */

/*!
 * @name Register PWM_CAPTCTRLX, field ARMX[0] (RW)
 *
 * Setting this bit high starts the input capture process. This bit can be
 * cleared at any time to disable input capture operation. This bit is self-cleared
 * when in one shot mode and one or more of the enabled capture circuits has had a
 * capture event.
 *
 * Values:
 * - 0b0 - Input capture operation is disabled.
 * - 0b1 - Input capture operation as specified by CAPTCTRLX[EDGXx] is enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_ARMX field. */
#define PWM_RD_CAPTCTRLX_ARMX(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_ARMX_MASK) >> PWM_CAPTCTRLX_ARMX_SHIFT)
#define PWM_BRD_CAPTCTRLX_ARMX(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_ARMX_SHIFT, PWM_CAPTCTRLX_ARMX_WIDTH))

/*! @brief Set the ARMX field to a new value. */
#define PWM_WR_CAPTCTRLX_ARMX(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_ARMX_MASK, PWM_CAPTCTRLX_ARMX(value)))
#define PWM_BWR_CAPTCTRLX_ARMX(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_ARMX_SHIFT), PWM_CAPTCTRLX_ARMX_SHIFT, PWM_CAPTCTRLX_ARMX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field ONESHOTX[1] (RW)
 *
 * This bit selects between free running and one shot mode for the input capture
 * circuitry.
 *
 * Values:
 * - 0b0 - Free running mode is selected. If both capture circuits are enabled,
 *     then capture circuit 0 is armed first after the ARMX bit is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is
 *     armed. After capture circuit 1 performs a capture, it is disarmed and capture
 *     circuit 0 is re-armed. The process continues indefinitely. If only one of
 *     the capture circuits is enabled, then captures continue indefinitely on the
 *     enabled capture circuit.
 * - 0b1 - One shot mode is selected. If both capture circuits are enabled, then
 *     capture circuit 0 is armed first after the ARMX bit is set. Once a
 *     capture occurs, capture circuit 0 is disarmed and capture circuit 1 is armed.
 *     After capture circuit 1 performs a capture, it is disarmed and the ARMX bit
 *     is cleared. No further captures will be performed until the ARMX bit is
 *     set again. If only one of the capture circuits is enabled, then a single
 *     capture will occur on the enabled capture circuit and the ARMX bit is then
 *     cleared.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_ONESHOTX field. */
#define PWM_RD_CAPTCTRLX_ONESHOTX(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_ONESHOTX_MASK) >> PWM_CAPTCTRLX_ONESHOTX_SHIFT)
#define PWM_BRD_CAPTCTRLX_ONESHOTX(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_ONESHOTX_SHIFT, PWM_CAPTCTRLX_ONESHOTX_WIDTH))

/*! @brief Set the ONESHOTX field to a new value. */
#define PWM_WR_CAPTCTRLX_ONESHOTX(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_ONESHOTX_MASK, PWM_CAPTCTRLX_ONESHOTX(value)))
#define PWM_BWR_CAPTCTRLX_ONESHOTX(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_ONESHOTX_SHIFT), PWM_CAPTCTRLX_ONESHOTX_SHIFT, PWM_CAPTCTRLX_ONESHOTX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field EDGX0[3:2] (RW)
 *
 * These bits control the input capture 0 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_EDGX0 field. */
#define PWM_RD_CAPTCTRLX_EDGX0(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_EDGX0_MASK) >> PWM_CAPTCTRLX_EDGX0_SHIFT)
#define PWM_BRD_CAPTCTRLX_EDGX0(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_EDGX0_SHIFT, PWM_CAPTCTRLX_EDGX0_WIDTH))

/*! @brief Set the EDGX0 field to a new value. */
#define PWM_WR_CAPTCTRLX_EDGX0(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_EDGX0_MASK, PWM_CAPTCTRLX_EDGX0(value)))
#define PWM_BWR_CAPTCTRLX_EDGX0(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_EDGX0_SHIFT), PWM_CAPTCTRLX_EDGX0_SHIFT, PWM_CAPTCTRLX_EDGX0_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field EDGX1[5:4] (RW)
 *
 * These bits control the input capture 1 circuitry by determining which input
 * edges cause a capture event.
 *
 * Values:
 * - 0b00 - Disabled
 * - 0b01 - Capture falling edges
 * - 0b10 - Capture rising edges
 * - 0b11 - Capture any edge
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_EDGX1 field. */
#define PWM_RD_CAPTCTRLX_EDGX1(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_EDGX1_MASK) >> PWM_CAPTCTRLX_EDGX1_SHIFT)
#define PWM_BRD_CAPTCTRLX_EDGX1(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_EDGX1_SHIFT, PWM_CAPTCTRLX_EDGX1_WIDTH))

/*! @brief Set the EDGX1 field to a new value. */
#define PWM_WR_CAPTCTRLX_EDGX1(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_EDGX1_MASK, PWM_CAPTCTRLX_EDGX1(value)))
#define PWM_BWR_CAPTCTRLX_EDGX1(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_EDGX1_SHIFT), PWM_CAPTCTRLX_EDGX1_SHIFT, PWM_CAPTCTRLX_EDGX1_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field INP_SELX[6] (RW)
 *
 * This bit selects between the raw PWM_X input signal and the output of the
 * edge counter/compare circuitry as the source for the input capture circuit.
 *
 * Values:
 * - 0b0 - Raw PWM_X input signal selected as source.
 * - 0b1 - Output of edge counter/compare selected as source. When this bitfield
 *     is set to 1, the internal edge counter is enabled and the rising and/or
 *     falling edges specified by the CAPTCTRLX[EDGX0] and CAPTCTRLX[EDGX1] fields
 *     are ignored. The software must still place a value other than 00 in
 *     either or both of the CAPTCTLRX[EDGX0] and/or CAPTCTRLX[EDGX1] fields in order
 *     to enable one or both of the capture registers.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_INP_SELX field. */
#define PWM_RD_CAPTCTRLX_INP_SELX(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_INP_SELX_MASK) >> PWM_CAPTCTRLX_INP_SELX_SHIFT)
#define PWM_BRD_CAPTCTRLX_INP_SELX(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_INP_SELX_SHIFT, PWM_CAPTCTRLX_INP_SELX_WIDTH))

/*! @brief Set the INP_SELX field to a new value. */
#define PWM_WR_CAPTCTRLX_INP_SELX(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_INP_SELX_MASK, PWM_CAPTCTRLX_INP_SELX(value)))
#define PWM_BWR_CAPTCTRLX_INP_SELX(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_INP_SELX_SHIFT), PWM_CAPTCTRLX_INP_SELX_SHIFT, PWM_CAPTCTRLX_INP_SELX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field EDGCNTX_EN[7] (RW)
 *
 * This bit enables the edge counter which counts rising and falling edges on
 * the PWM_X input signal.
 *
 * Values:
 * - 0b0 - Edge counter disabled and held in reset
 * - 0b1 - Edge counter enabled
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_EDGCNTX_EN field. */
#define PWM_RD_CAPTCTRLX_EDGCNTX_EN(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_EDGCNTX_EN_MASK) >> PWM_CAPTCTRLX_EDGCNTX_EN_SHIFT)
#define PWM_BRD_CAPTCTRLX_EDGCNTX_EN(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_EDGCNTX_EN_SHIFT, PWM_CAPTCTRLX_EDGCNTX_EN_WIDTH))

/*! @brief Set the EDGCNTX_EN field to a new value. */
#define PWM_WR_CAPTCTRLX_EDGCNTX_EN(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_EDGCNTX_EN_MASK, PWM_CAPTCTRLX_EDGCNTX_EN(value)))
#define PWM_BWR_CAPTCTRLX_EDGCNTX_EN(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_EDGCNTX_EN_SHIFT), PWM_CAPTCTRLX_EDGCNTX_EN_SHIFT, PWM_CAPTCTRLX_EDGCNTX_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field CFXWM[9:8] (RW)
 *
 * This field represents the water mark level for capture X FIFOs. The capture
 * flags, STS[CFX1] and STS[CFX0], won't be set until the word count of the
 * corresponding FIFO is greater than this water mark level. (FIFO depth is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_CFXWM field. */
#define PWM_RD_CAPTCTRLX_CFXWM(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_CFXWM_MASK) >> PWM_CAPTCTRLX_CFXWM_SHIFT)
#define PWM_BRD_CAPTCTRLX_CFXWM(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_CFXWM_SHIFT, PWM_CAPTCTRLX_CFXWM_WIDTH))

/*! @brief Set the CFXWM field to a new value. */
#define PWM_WR_CAPTCTRLX_CFXWM(base, index, value) (PWM_RMW_CAPTCTRLX(base, index, PWM_CAPTCTRLX_CFXWM_MASK, PWM_CAPTCTRLX_CFXWM(value)))
#define PWM_BWR_CAPTCTRLX_CFXWM(base, index, value) (BME_BFI16(&PWM_CAPTCTRLX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCTRLX_CFXWM_SHIFT), PWM_CAPTCTRLX_CFXWM_SHIFT, PWM_CAPTCTRLX_CFXWM_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field CX0CNT[12:10] (RO)
 *
 * This field reflects the number of words in the Capture X0 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_CX0CNT field. */
#define PWM_RD_CAPTCTRLX_CX0CNT(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_CX0CNT_MASK) >> PWM_CAPTCTRLX_CX0CNT_SHIFT)
#define PWM_BRD_CAPTCTRLX_CX0CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_CX0CNT_SHIFT, PWM_CAPTCTRLX_CX0CNT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCTRLX, field CX1CNT[15:13] (RO)
 *
 * This field reflects the number of words in the Capture X1 FIFO. (FIFO depth
 * is 1)
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCTRLX_CX1CNT field. */
#define PWM_RD_CAPTCTRLX_CX1CNT(base, index) ((PWM_CAPTCTRLX_REG(base, index) & PWM_CAPTCTRLX_CX1CNT_MASK) >> PWM_CAPTCTRLX_CX1CNT_SHIFT)
#define PWM_BRD_CAPTCTRLX_CX1CNT(base, index) (BME_UBFX16(&PWM_CAPTCTRLX_REG(base, index), PWM_CAPTCTRLX_CX1CNT_SHIFT, PWM_CAPTCTRLX_CX1CNT_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CAPTCOMPX - Capture Compare X Register
 ******************************************************************************/

/*!
 * @brief PWM_CAPTCOMPX - Capture Compare X Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CAPTCOMPX register
 */
/*@{*/
#define PWM_RD_CAPTCOMPX(base, index) (PWM_CAPTCOMPX_REG(base, index))
#define PWM_WR_CAPTCOMPX(base, index, value) (PWM_CAPTCOMPX_REG(base, index) = (value))
#define PWM_RMW_CAPTCOMPX(base, index, mask, value) (PWM_WR_CAPTCOMPX(base, index, (PWM_RD_CAPTCOMPX(base, index) & ~(mask)) | (value)))
#define PWM_SET_CAPTCOMPX(base, index, value) (BME_OR16(&PWM_CAPTCOMPX_REG(base, index), (uint16_t)(value)))
#define PWM_CLR_CAPTCOMPX(base, index, value) (BME_AND16(&PWM_CAPTCOMPX_REG(base, index), (uint16_t)(~(value))))
#define PWM_TOG_CAPTCOMPX(base, index, value) (BME_XOR16(&PWM_CAPTCOMPX_REG(base, index), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_CAPTCOMPX bitfields
 */

/*!
 * @name Register PWM_CAPTCOMPX, field EDGCMPX[7:0] (RW)
 *
 * This read/write field is the compare value associated with the edge counter
 * for the PWM_X input capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPX_EDGCMPX field. */
#define PWM_RD_CAPTCOMPX_EDGCMPX(base, index) ((PWM_CAPTCOMPX_REG(base, index) & PWM_CAPTCOMPX_EDGCMPX_MASK) >> PWM_CAPTCOMPX_EDGCMPX_SHIFT)
#define PWM_BRD_CAPTCOMPX_EDGCMPX(base, index) (BME_UBFX16(&PWM_CAPTCOMPX_REG(base, index), PWM_CAPTCOMPX_EDGCMPX_SHIFT, PWM_CAPTCOMPX_EDGCMPX_WIDTH))

/*! @brief Set the EDGCMPX field to a new value. */
#define PWM_WR_CAPTCOMPX_EDGCMPX(base, index, value) (PWM_RMW_CAPTCOMPX(base, index, PWM_CAPTCOMPX_EDGCMPX_MASK, PWM_CAPTCOMPX_EDGCMPX(value)))
#define PWM_BWR_CAPTCOMPX_EDGCMPX(base, index, value) (BME_BFI16(&PWM_CAPTCOMPX_REG(base, index), ((uint16_t)(value) << PWM_CAPTCOMPX_EDGCMPX_SHIFT), PWM_CAPTCOMPX_EDGCMPX_SHIFT, PWM_CAPTCOMPX_EDGCMPX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_CAPTCOMPX, field EDGCNTX[15:8] (RO)
 *
 * This read-only field contains the edge counter value for the PWM_X input
 * capture circuitry.
 */
/*@{*/
/*! @brief Read current value of the PWM_CAPTCOMPX_EDGCNTX field. */
#define PWM_RD_CAPTCOMPX_EDGCNTX(base, index) ((PWM_CAPTCOMPX_REG(base, index) & PWM_CAPTCOMPX_EDGCNTX_MASK) >> PWM_CAPTCOMPX_EDGCNTX_SHIFT)
#define PWM_BRD_CAPTCOMPX_EDGCNTX(base, index) (BME_UBFX16(&PWM_CAPTCOMPX_REG(base, index), PWM_CAPTCOMPX_EDGCNTX_SHIFT, PWM_CAPTCOMPX_EDGCNTX_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL0 - Capture Value 0 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL0 - Capture Value 0 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL0 register
 */
/*@{*/
#define PWM_RD_CVAL0(base, index) (PWM_CVAL0_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL0CYC - Capture Value 0 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL0CYC - Capture Value 0 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL0CYC register
 */
/*@{*/
#define PWM_RD_CVAL0CYC(base, index) (PWM_CVAL0CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL0CYC bitfields
 */

/*!
 * @name Register PWM_CVAL0CYC, field CVAL0CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL0. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL0CYC_CVAL0CYC field. */
#define PWM_RD_CVAL0CYC_CVAL0CYC(base, index) ((PWM_CVAL0CYC_REG(base, index) & PWM_CVAL0CYC_CVAL0CYC_MASK) >> PWM_CVAL0CYC_CVAL0CYC_SHIFT)
#define PWM_BRD_CVAL0CYC_CVAL0CYC(base, index) (BME_UBFX16(&PWM_CVAL0CYC_REG(base, index), PWM_CVAL0CYC_CVAL0CYC_SHIFT, PWM_CVAL0CYC_CVAL0CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL1 - Capture Value 1 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL1 - Capture Value 1 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL1 register
 */
/*@{*/
#define PWM_RD_CVAL1(base, index) (PWM_CVAL1_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL1CYC - Capture Value 1 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL1CYC - Capture Value 1 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL1CYC register
 */
/*@{*/
#define PWM_RD_CVAL1CYC(base, index) (PWM_CVAL1CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL1CYC bitfields
 */

/*!
 * @name Register PWM_CVAL1CYC, field CVAL1CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL1. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL1CYC_CVAL1CYC field. */
#define PWM_RD_CVAL1CYC_CVAL1CYC(base, index) ((PWM_CVAL1CYC_REG(base, index) & PWM_CVAL1CYC_CVAL1CYC_MASK) >> PWM_CVAL1CYC_CVAL1CYC_SHIFT)
#define PWM_BRD_CVAL1CYC_CVAL1CYC(base, index) (BME_UBFX16(&PWM_CVAL1CYC_REG(base, index), PWM_CVAL1CYC_CVAL1CYC_SHIFT, PWM_CVAL1CYC_CVAL1CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL2 - Capture Value 2 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL2 - Capture Value 2 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL2 register
 */
/*@{*/
#define PWM_RD_CVAL2(base, index) (PWM_CVAL2_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL2CYC - Capture Value 2 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL2CYC - Capture Value 2 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL2CYC register
 */
/*@{*/
#define PWM_RD_CVAL2CYC(base, index) (PWM_CVAL2CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL2CYC bitfields
 */

/*!
 * @name Register PWM_CVAL2CYC, field CVAL2CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL2. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL2CYC_CVAL2CYC field. */
#define PWM_RD_CVAL2CYC_CVAL2CYC(base, index) ((PWM_CVAL2CYC_REG(base, index) & PWM_CVAL2CYC_CVAL2CYC_MASK) >> PWM_CVAL2CYC_CVAL2CYC_SHIFT)
#define PWM_BRD_CVAL2CYC_CVAL2CYC(base, index) (BME_UBFX16(&PWM_CVAL2CYC_REG(base, index), PWM_CVAL2CYC_CVAL2CYC_SHIFT, PWM_CVAL2CYC_CVAL2CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL3 - Capture Value 3 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL3 - Capture Value 3 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL3 register
 */
/*@{*/
#define PWM_RD_CVAL3(base, index) (PWM_CVAL3_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL3CYC - Capture Value 3 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL3CYC - Capture Value 3 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL3CYC register
 */
/*@{*/
#define PWM_RD_CVAL3CYC(base, index) (PWM_CVAL3CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL3CYC bitfields
 */

/*!
 * @name Register PWM_CVAL3CYC, field CVAL3CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL3. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL3CYC_CVAL3CYC field. */
#define PWM_RD_CVAL3CYC_CVAL3CYC(base, index) ((PWM_CVAL3CYC_REG(base, index) & PWM_CVAL3CYC_CVAL3CYC_MASK) >> PWM_CVAL3CYC_CVAL3CYC_SHIFT)
#define PWM_BRD_CVAL3CYC_CVAL3CYC(base, index) (BME_UBFX16(&PWM_CVAL3CYC_REG(base, index), PWM_CVAL3CYC_CVAL3CYC_SHIFT, PWM_CVAL3CYC_CVAL3CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL4 - Capture Value 4 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL4 - Capture Value 4 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL4 register
 */
/*@{*/
#define PWM_RD_CVAL4(base, index) (PWM_CVAL4_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL4CYC - Capture Value 4 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL4CYC - Capture Value 4 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL4CYC register
 */
/*@{*/
#define PWM_RD_CVAL4CYC(base, index) (PWM_CVAL4CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL4CYC bitfields
 */

/*!
 * @name Register PWM_CVAL4CYC, field CVAL4CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL4. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL4CYC_CVAL4CYC field. */
#define PWM_RD_CVAL4CYC_CVAL4CYC(base, index) ((PWM_CVAL4CYC_REG(base, index) & PWM_CVAL4CYC_CVAL4CYC_MASK) >> PWM_CVAL4CYC_CVAL4CYC_SHIFT)
#define PWM_BRD_CVAL4CYC_CVAL4CYC(base, index) (BME_UBFX16(&PWM_CVAL4CYC_REG(base, index), PWM_CVAL4CYC_CVAL4CYC_SHIFT, PWM_CVAL4CYC_CVAL4CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_CVAL5 - Capture Value 5 Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL5 - Capture Value 5 Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL5 register
 */
/*@{*/
#define PWM_RD_CVAL5(base, index) (PWM_CVAL5_REG(base, index))
/*@}*/

/*******************************************************************************
 * PWM_CVAL5CYC - Capture Value 5 Cycle Register
 ******************************************************************************/

/*!
 * @brief PWM_CVAL5CYC - Capture Value 5 Cycle Register (RO)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_CVAL5CYC register
 */
/*@{*/
#define PWM_RD_CVAL5CYC(base, index) (PWM_CVAL5CYC_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual PWM_CVAL5CYC bitfields
 */

/*!
 * @name Register PWM_CVAL5CYC, field CVAL5CYC[3:0] (RO)
 *
 * This read-only register stores the cycle number corresponding to the value
 * captured in CVAL5. This register is incremented each time the counter is loaded
 * with the INIT value at the end of a PWM modulo cycle.
 */
/*@{*/
/*! @brief Read current value of the PWM_CVAL5CYC_CVAL5CYC field. */
#define PWM_RD_CVAL5CYC_CVAL5CYC(base, index) ((PWM_CVAL5CYC_REG(base, index) & PWM_CVAL5CYC_CVAL5CYC_MASK) >> PWM_CVAL5CYC_CVAL5CYC_SHIFT)
#define PWM_BRD_CVAL5CYC_CVAL5CYC(base, index) (BME_UBFX16(&PWM_CVAL5CYC_REG(base, index), PWM_CVAL5CYC_CVAL5CYC_SHIFT, PWM_CVAL5CYC_CVAL5CYC_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_OUTEN - Output Enable Register
 ******************************************************************************/

/*!
 * @brief PWM_OUTEN - Output Enable Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_OUTEN register
 */
/*@{*/
#define PWM_RD_OUTEN(base)       (PWM_OUTEN_REG(base))
#define PWM_WR_OUTEN(base, value) (PWM_OUTEN_REG(base) = (value))
#define PWM_RMW_OUTEN(base, mask, value) (PWM_WR_OUTEN(base, (PWM_RD_OUTEN(base) & ~(mask)) | (value)))
#define PWM_SET_OUTEN(base, value) (BME_OR16(&PWM_OUTEN_REG(base), (uint16_t)(value)))
#define PWM_CLR_OUTEN(base, value) (BME_AND16(&PWM_OUTEN_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_OUTEN(base, value) (BME_XOR16(&PWM_OUTEN_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_OUTEN bitfields
 */

/*!
 * @name Register PWM_OUTEN, field PWMX_EN[3:0] (RW)
 *
 * The four bits of this field enable the PWM_X outputs of submodules 3-0,
 * respectively. These bits should be set to 0 (output disabled) when a PWM_X pin is
 * being used for input capture or deadtime correction.
 *
 * Values:
 * - 0b0000 - PWM_X output disabled.
 * - 0b0001 - PWM_X output enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_OUTEN_PWMX_EN field. */
#define PWM_RD_OUTEN_PWMX_EN(base) ((PWM_OUTEN_REG(base) & PWM_OUTEN_PWMX_EN_MASK) >> PWM_OUTEN_PWMX_EN_SHIFT)
#define PWM_BRD_OUTEN_PWMX_EN(base) (BME_UBFX16(&PWM_OUTEN_REG(base), PWM_OUTEN_PWMX_EN_SHIFT, PWM_OUTEN_PWMX_EN_WIDTH))

/*! @brief Set the PWMX_EN field to a new value. */
#define PWM_WR_OUTEN_PWMX_EN(base, value) (PWM_RMW_OUTEN(base, PWM_OUTEN_PWMX_EN_MASK, PWM_OUTEN_PWMX_EN(value)))
#define PWM_BWR_OUTEN_PWMX_EN(base, value) (BME_BFI16(&PWM_OUTEN_REG(base), ((uint16_t)(value) << PWM_OUTEN_PWMX_EN_SHIFT), PWM_OUTEN_PWMX_EN_SHIFT, PWM_OUTEN_PWMX_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OUTEN, field PWMB_EN[7:4] (RW)
 *
 * The four bits of this field enable the PWM_B outputs of submodules 3-0,
 * respectively. These bits should be set to 0 (output disabled) when a PWM_B pin is
 * being used for input capture.
 *
 * Values:
 * - 0b0000 - PWM_B output disabled.
 * - 0b0001 - PWM_B output enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_OUTEN_PWMB_EN field. */
#define PWM_RD_OUTEN_PWMB_EN(base) ((PWM_OUTEN_REG(base) & PWM_OUTEN_PWMB_EN_MASK) >> PWM_OUTEN_PWMB_EN_SHIFT)
#define PWM_BRD_OUTEN_PWMB_EN(base) (BME_UBFX16(&PWM_OUTEN_REG(base), PWM_OUTEN_PWMB_EN_SHIFT, PWM_OUTEN_PWMB_EN_WIDTH))

/*! @brief Set the PWMB_EN field to a new value. */
#define PWM_WR_OUTEN_PWMB_EN(base, value) (PWM_RMW_OUTEN(base, PWM_OUTEN_PWMB_EN_MASK, PWM_OUTEN_PWMB_EN(value)))
#define PWM_BWR_OUTEN_PWMB_EN(base, value) (BME_BFI16(&PWM_OUTEN_REG(base), ((uint16_t)(value) << PWM_OUTEN_PWMB_EN_SHIFT), PWM_OUTEN_PWMB_EN_SHIFT, PWM_OUTEN_PWMB_EN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_OUTEN, field PWMA_EN[11:8] (RW)
 *
 * The four bits of this field enable the PWM_A outputs of submodules 3-0,
 * respectively. These bits should be set to 0 (output disabled) when a PWM_A pin is
 * being used for input capture.
 *
 * Values:
 * - 0b0000 - PWM_A output disabled.
 * - 0b0001 - PWM_A output enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_OUTEN_PWMA_EN field. */
#define PWM_RD_OUTEN_PWMA_EN(base) ((PWM_OUTEN_REG(base) & PWM_OUTEN_PWMA_EN_MASK) >> PWM_OUTEN_PWMA_EN_SHIFT)
#define PWM_BRD_OUTEN_PWMA_EN(base) (BME_UBFX16(&PWM_OUTEN_REG(base), PWM_OUTEN_PWMA_EN_SHIFT, PWM_OUTEN_PWMA_EN_WIDTH))

/*! @brief Set the PWMA_EN field to a new value. */
#define PWM_WR_OUTEN_PWMA_EN(base, value) (PWM_RMW_OUTEN(base, PWM_OUTEN_PWMA_EN_MASK, PWM_OUTEN_PWMA_EN(value)))
#define PWM_BWR_OUTEN_PWMA_EN(base, value) (BME_BFI16(&PWM_OUTEN_REG(base), ((uint16_t)(value) << PWM_OUTEN_PWMA_EN_SHIFT), PWM_OUTEN_PWMA_EN_SHIFT, PWM_OUTEN_PWMA_EN_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_MASK - Mask Register
 ******************************************************************************/

/*!
 * @brief PWM_MASK - Mask Register (RW)
 *
 * Reset value: 0x0000U
 *
 * MASK is double buffered and does not take effect until a FORCE_OUT event
 * occurs within the appropriate submodule. Reading MASK reads the buffered values
 * and not necessarily the values currently in effect. This double buffering can be
 * overridden by setting the UPDATE_MASK bits.
 */
/*!
 * @name Constants and macros for entire PWM_MASK register
 */
/*@{*/
#define PWM_RD_MASK(base)        (PWM_MASK_REG(base))
#define PWM_WR_MASK(base, value) (PWM_MASK_REG(base) = (value))
#define PWM_RMW_MASK(base, mask, value) (PWM_WR_MASK(base, (PWM_RD_MASK(base) & ~(mask)) | (value)))
#define PWM_SET_MASK(base, value) (BME_OR16(&PWM_MASK_REG(base), (uint16_t)(value)))
#define PWM_CLR_MASK(base, value) (BME_AND16(&PWM_MASK_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_MASK(base, value) (BME_XOR16(&PWM_MASK_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_MASK bitfields
 */

/*!
 * @name Register PWM_MASK, field MASKX[3:0] (RW)
 *
 * The four bits of this field mask the PWM_X outputs of submodules 3-0,
 * respectively, forcing the output to logic 0 prior to consideration of the output
 * polarity.
 *
 * Values:
 * - 0b0000 - PWM_X output normal.
 * - 0b0001 - PWM_X output masked.
 */
/*@{*/
/*! @brief Read current value of the PWM_MASK_MASKX field. */
#define PWM_RD_MASK_MASKX(base) ((PWM_MASK_REG(base) & PWM_MASK_MASKX_MASK) >> PWM_MASK_MASKX_SHIFT)
#define PWM_BRD_MASK_MASKX(base) (BME_UBFX16(&PWM_MASK_REG(base), PWM_MASK_MASKX_SHIFT, PWM_MASK_MASKX_WIDTH))

/*! @brief Set the MASKX field to a new value. */
#define PWM_WR_MASK_MASKX(base, value) (PWM_RMW_MASK(base, PWM_MASK_MASKX_MASK, PWM_MASK_MASKX(value)))
#define PWM_BWR_MASK_MASKX(base, value) (BME_BFI16(&PWM_MASK_REG(base), ((uint16_t)(value) << PWM_MASK_MASKX_SHIFT), PWM_MASK_MASKX_SHIFT, PWM_MASK_MASKX_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MASK, field MASKB[7:4] (RW)
 *
 * The four bits of this field mask the PWM_B outputs of submodules 3-0,
 * respectively, forcing the output to logic 0 prior to consideration of the output
 * polarity.
 *
 * Values:
 * - 0b0000 - PWM_B output normal.
 * - 0b0001 - PWM_B output masked.
 */
/*@{*/
/*! @brief Read current value of the PWM_MASK_MASKB field. */
#define PWM_RD_MASK_MASKB(base) ((PWM_MASK_REG(base) & PWM_MASK_MASKB_MASK) >> PWM_MASK_MASKB_SHIFT)
#define PWM_BRD_MASK_MASKB(base) (BME_UBFX16(&PWM_MASK_REG(base), PWM_MASK_MASKB_SHIFT, PWM_MASK_MASKB_WIDTH))

/*! @brief Set the MASKB field to a new value. */
#define PWM_WR_MASK_MASKB(base, value) (PWM_RMW_MASK(base, PWM_MASK_MASKB_MASK, PWM_MASK_MASKB(value)))
#define PWM_BWR_MASK_MASKB(base, value) (BME_BFI16(&PWM_MASK_REG(base), ((uint16_t)(value) << PWM_MASK_MASKB_SHIFT), PWM_MASK_MASKB_SHIFT, PWM_MASK_MASKB_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MASK, field MASKA[11:8] (RW)
 *
 * The four bits of this field mask the PWM_A outputs of submodules 3-0,
 * respectively, forcing the output to logic 0 prior to consideration of the output
 * polarity.
 *
 * Values:
 * - 0b0000 - PWM_A output normal.
 * - 0b0001 - PWM_A output masked.
 */
/*@{*/
/*! @brief Read current value of the PWM_MASK_MASKA field. */
#define PWM_RD_MASK_MASKA(base) ((PWM_MASK_REG(base) & PWM_MASK_MASKA_MASK) >> PWM_MASK_MASKA_SHIFT)
#define PWM_BRD_MASK_MASKA(base) (BME_UBFX16(&PWM_MASK_REG(base), PWM_MASK_MASKA_SHIFT, PWM_MASK_MASKA_WIDTH))

/*! @brief Set the MASKA field to a new value. */
#define PWM_WR_MASK_MASKA(base, value) (PWM_RMW_MASK(base, PWM_MASK_MASKA_MASK, PWM_MASK_MASKA(value)))
#define PWM_BWR_MASK_MASKA(base, value) (BME_BFI16(&PWM_MASK_REG(base), ((uint16_t)(value) << PWM_MASK_MASKA_SHIFT), PWM_MASK_MASKA_SHIFT, PWM_MASK_MASKA_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MASK, field UPDATE_MASK[15:12] (WO)
 *
 * The four bits mask the PWM_X outputs of submodules 3-0, respectively, The
 * four bits of this field force the MASK* bits to be immediately updated within
 * submodules 3-0, respectively, without waiting for a FORCE_OUT event. These
 * self-clearing bits always read as zero. Software may write to any or all of these
 * bits and may set these bits in the same write operation that updates the MASKA,
 * MASKB, and MASKX fields of this register.
 *
 * Values:
 * - 0b0000 - Normal operation. MASK* bits within the corresponding submodule
 *     are not updated until a FORCE_OUT event occurs within the submodule.
 * - 0b0001 - Immediate operation. MASK* bits within the corresponding submodule
 *     are updated on the following clock edge after setting this bit.
 */
/*@{*/
/*! @brief Set the UPDATE_MASK field to a new value. */
#define PWM_WR_MASK_UPDATE_MASK(base, value) (PWM_RMW_MASK(base, PWM_MASK_UPDATE_MASK_MASK, PWM_MASK_UPDATE_MASK(value)))
#define PWM_BWR_MASK_UPDATE_MASK(base, value) (PWM_WR_MASK_UPDATE_MASK(base, value))
/*@}*/

/*******************************************************************************
 * PWM_SWCOUT - Software Controlled Output Register
 ******************************************************************************/

/*!
 * @brief PWM_SWCOUT - Software Controlled Output Register (RW)
 *
 * Reset value: 0x0000U
 *
 * These bits are double buffered and do not take effect until a FORCE_OUT event
 * occurs within the appropriate submodule. Reading these bits reads the
 * buffered value and not necessarily the value currently in effect.
 */
/*!
 * @name Constants and macros for entire PWM_SWCOUT register
 */
/*@{*/
#define PWM_RD_SWCOUT(base)      (PWM_SWCOUT_REG(base))
#define PWM_WR_SWCOUT(base, value) (PWM_SWCOUT_REG(base) = (value))
#define PWM_RMW_SWCOUT(base, mask, value) (PWM_WR_SWCOUT(base, (PWM_RD_SWCOUT(base) & ~(mask)) | (value)))
#define PWM_SET_SWCOUT(base, value) (BME_OR16(&PWM_SWCOUT_REG(base), (uint16_t)(value)))
#define PWM_CLR_SWCOUT(base, value) (BME_AND16(&PWM_SWCOUT_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_SWCOUT(base, value) (BME_XOR16(&PWM_SWCOUT_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_SWCOUT bitfields
 */

/*!
 * @name Register PWM_SWCOUT, field SM0OUT45[0] (RW)
 *
 * This bit is only used when DTSRCSEL[SM0SEL45] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 0
 *     instead of PWM45.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 0
 *     instead of PWM45.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM0OUT45 field. */
#define PWM_RD_SWCOUT_SM0OUT45(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM0OUT45_MASK) >> PWM_SWCOUT_SM0OUT45_SHIFT)
#define PWM_BRD_SWCOUT_SM0OUT45(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM0OUT45_SHIFT, PWM_SWCOUT_SM0OUT45_WIDTH))

/*! @brief Set the SM0OUT45 field to a new value. */
#define PWM_WR_SWCOUT_SM0OUT45(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM0OUT45_MASK, PWM_SWCOUT_SM0OUT45(value)))
#define PWM_BWR_SWCOUT_SM0OUT45(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM0OUT45_SHIFT), PWM_SWCOUT_SM0OUT45_SHIFT, PWM_SWCOUT_SM0OUT45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM0OUT23[1] (RW)
 *
 * This bit is only used when DTSRCSEL[SM0SEL23] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 0
 *     instead of PWM23.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 0
 *     instead of PWM23.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM0OUT23 field. */
#define PWM_RD_SWCOUT_SM0OUT23(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM0OUT23_MASK) >> PWM_SWCOUT_SM0OUT23_SHIFT)
#define PWM_BRD_SWCOUT_SM0OUT23(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM0OUT23_SHIFT, PWM_SWCOUT_SM0OUT23_WIDTH))

/*! @brief Set the SM0OUT23 field to a new value. */
#define PWM_WR_SWCOUT_SM0OUT23(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM0OUT23_MASK, PWM_SWCOUT_SM0OUT23(value)))
#define PWM_BWR_SWCOUT_SM0OUT23(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM0OUT23_SHIFT), PWM_SWCOUT_SM0OUT23_SHIFT, PWM_SWCOUT_SM0OUT23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM1OUT45[2] (RW)
 *
 * This bit is only used when DTSRCSEL[SM1SEL45] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 1
 *     instead of PWM45.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 1
 *     instead of PWM45.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM1OUT45 field. */
#define PWM_RD_SWCOUT_SM1OUT45(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM1OUT45_MASK) >> PWM_SWCOUT_SM1OUT45_SHIFT)
#define PWM_BRD_SWCOUT_SM1OUT45(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM1OUT45_SHIFT, PWM_SWCOUT_SM1OUT45_WIDTH))

/*! @brief Set the SM1OUT45 field to a new value. */
#define PWM_WR_SWCOUT_SM1OUT45(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM1OUT45_MASK, PWM_SWCOUT_SM1OUT45(value)))
#define PWM_BWR_SWCOUT_SM1OUT45(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM1OUT45_SHIFT), PWM_SWCOUT_SM1OUT45_SHIFT, PWM_SWCOUT_SM1OUT45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM1OUT23[3] (RW)
 *
 * This bit is only used when DTSRCSEL[SM1SEL23] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 1
 *     instead of PWM23.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 1
 *     instead of PWM23.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM1OUT23 field. */
#define PWM_RD_SWCOUT_SM1OUT23(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM1OUT23_MASK) >> PWM_SWCOUT_SM1OUT23_SHIFT)
#define PWM_BRD_SWCOUT_SM1OUT23(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM1OUT23_SHIFT, PWM_SWCOUT_SM1OUT23_WIDTH))

/*! @brief Set the SM1OUT23 field to a new value. */
#define PWM_WR_SWCOUT_SM1OUT23(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM1OUT23_MASK, PWM_SWCOUT_SM1OUT23(value)))
#define PWM_BWR_SWCOUT_SM1OUT23(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM1OUT23_SHIFT), PWM_SWCOUT_SM1OUT23_SHIFT, PWM_SWCOUT_SM1OUT23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM2OUT45[4] (RW)
 *
 * This bit is only used when DTSRCSEL[SM2SEL45] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 2
 *     instead of PWM45.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 2
 *     instead of PWM45.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM2OUT45 field. */
#define PWM_RD_SWCOUT_SM2OUT45(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM2OUT45_MASK) >> PWM_SWCOUT_SM2OUT45_SHIFT)
#define PWM_BRD_SWCOUT_SM2OUT45(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM2OUT45_SHIFT, PWM_SWCOUT_SM2OUT45_WIDTH))

/*! @brief Set the SM2OUT45 field to a new value. */
#define PWM_WR_SWCOUT_SM2OUT45(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM2OUT45_MASK, PWM_SWCOUT_SM2OUT45(value)))
#define PWM_BWR_SWCOUT_SM2OUT45(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM2OUT45_SHIFT), PWM_SWCOUT_SM2OUT45_SHIFT, PWM_SWCOUT_SM2OUT45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM2OUT23[5] (RW)
 *
 * This bit is only used when DTSRCSEL[SM2SEL23] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 2
 *     instead of PWM23.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 2
 *     instead of PWM23.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM2OUT23 field. */
#define PWM_RD_SWCOUT_SM2OUT23(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM2OUT23_MASK) >> PWM_SWCOUT_SM2OUT23_SHIFT)
#define PWM_BRD_SWCOUT_SM2OUT23(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM2OUT23_SHIFT, PWM_SWCOUT_SM2OUT23_WIDTH))

/*! @brief Set the SM2OUT23 field to a new value. */
#define PWM_WR_SWCOUT_SM2OUT23(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM2OUT23_MASK, PWM_SWCOUT_SM2OUT23(value)))
#define PWM_BWR_SWCOUT_SM2OUT23(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM2OUT23_SHIFT), PWM_SWCOUT_SM2OUT23_SHIFT, PWM_SWCOUT_SM2OUT23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM3OUT45[6] (RW)
 *
 * This bit is only used when DTSRCSEL[SM3SEL45] is set to b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 3
 *     instead of PWM45.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 3
 *     instead of PWM45.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM3OUT45 field. */
#define PWM_RD_SWCOUT_SM3OUT45(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM3OUT45_MASK) >> PWM_SWCOUT_SM3OUT45_SHIFT)
#define PWM_BRD_SWCOUT_SM3OUT45(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM3OUT45_SHIFT, PWM_SWCOUT_SM3OUT45_WIDTH))

/*! @brief Set the SM3OUT45 field to a new value. */
#define PWM_WR_SWCOUT_SM3OUT45(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM3OUT45_MASK, PWM_SWCOUT_SM3OUT45(value)))
#define PWM_BWR_SWCOUT_SM3OUT45(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM3OUT45_SHIFT), PWM_SWCOUT_SM3OUT45_SHIFT, PWM_SWCOUT_SM3OUT45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_SWCOUT, field SM3OUT23[7] (RW)
 *
 * This bit is only used when DTSRCSEL[SM3SEL23] is set to 0b10. It allows
 * software control of which signal is supplied to the deadtime generator of that
 * submodule.
 *
 * Values:
 * - 0b0 - A logic 0 is supplied to the deadtime generator of submodule 3
 *     instead of PWM23.
 * - 0b1 - A logic 1 is supplied to the deadtime generator of submodule 3
 *     instead of PWM23.
 */
/*@{*/
/*! @brief Read current value of the PWM_SWCOUT_SM3OUT23 field. */
#define PWM_RD_SWCOUT_SM3OUT23(base) ((PWM_SWCOUT_REG(base) & PWM_SWCOUT_SM3OUT23_MASK) >> PWM_SWCOUT_SM3OUT23_SHIFT)
#define PWM_BRD_SWCOUT_SM3OUT23(base) (BME_UBFX16(&PWM_SWCOUT_REG(base), PWM_SWCOUT_SM3OUT23_SHIFT, PWM_SWCOUT_SM3OUT23_WIDTH))

/*! @brief Set the SM3OUT23 field to a new value. */
#define PWM_WR_SWCOUT_SM3OUT23(base, value) (PWM_RMW_SWCOUT(base, PWM_SWCOUT_SM3OUT23_MASK, PWM_SWCOUT_SM3OUT23(value)))
#define PWM_BWR_SWCOUT_SM3OUT23(base, value) (BME_BFI16(&PWM_SWCOUT_REG(base), ((uint16_t)(value) << PWM_SWCOUT_SM3OUT23_SHIFT), PWM_SWCOUT_SM3OUT23_SHIFT, PWM_SWCOUT_SM3OUT23_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_DTSRCSEL - PWM Source Select Register
 ******************************************************************************/

/*!
 * @brief PWM_DTSRCSEL - PWM Source Select Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The PWM source select bits are double buffered and do not take effect until a
 * FORCE_OUT event occurs within the appropriate submodule. Reading these bits
 * reads the buffered value and not necessarily the value currently in effect.
 */
/*!
 * @name Constants and macros for entire PWM_DTSRCSEL register
 */
/*@{*/
#define PWM_RD_DTSRCSEL(base)    (PWM_DTSRCSEL_REG(base))
#define PWM_WR_DTSRCSEL(base, value) (PWM_DTSRCSEL_REG(base) = (value))
#define PWM_RMW_DTSRCSEL(base, mask, value) (PWM_WR_DTSRCSEL(base, (PWM_RD_DTSRCSEL(base) & ~(mask)) | (value)))
#define PWM_SET_DTSRCSEL(base, value) (BME_OR16(&PWM_DTSRCSEL_REG(base), (uint16_t)(value)))
#define PWM_CLR_DTSRCSEL(base, value) (BME_AND16(&PWM_DTSRCSEL_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_DTSRCSEL(base, value) (BME_XOR16(&PWM_DTSRCSEL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_DTSRCSEL bitfields
 */

/*!
 * @name Register PWM_DTSRCSEL, field SM0SEL45[1:0] (RW)
 *
 * This field selects possible over-rides to the generated SM0PWM45 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM0PWM45 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM0PWM45 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM0OUT45] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTB0 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM0SEL45 field. */
#define PWM_RD_DTSRCSEL_SM0SEL45(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM0SEL45_MASK) >> PWM_DTSRCSEL_SM0SEL45_SHIFT)
#define PWM_BRD_DTSRCSEL_SM0SEL45(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM0SEL45_SHIFT, PWM_DTSRCSEL_SM0SEL45_WIDTH))

/*! @brief Set the SM0SEL45 field to a new value. */
#define PWM_WR_DTSRCSEL_SM0SEL45(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM0SEL45_MASK, PWM_DTSRCSEL_SM0SEL45(value)))
#define PWM_BWR_DTSRCSEL_SM0SEL45(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM0SEL45_SHIFT), PWM_DTSRCSEL_SM0SEL45_SHIFT, PWM_DTSRCSEL_SM0SEL45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM0SEL23[3:2] (RW)
 *
 * This field selects possible over-rides to the generated SM0PWM23 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM0PWM23 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM0PWM23 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM0OUT23] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTA0 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM0SEL23 field. */
#define PWM_RD_DTSRCSEL_SM0SEL23(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM0SEL23_MASK) >> PWM_DTSRCSEL_SM0SEL23_SHIFT)
#define PWM_BRD_DTSRCSEL_SM0SEL23(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM0SEL23_SHIFT, PWM_DTSRCSEL_SM0SEL23_WIDTH))

/*! @brief Set the SM0SEL23 field to a new value. */
#define PWM_WR_DTSRCSEL_SM0SEL23(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM0SEL23_MASK, PWM_DTSRCSEL_SM0SEL23(value)))
#define PWM_BWR_DTSRCSEL_SM0SEL23(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM0SEL23_SHIFT), PWM_DTSRCSEL_SM0SEL23_SHIFT, PWM_DTSRCSEL_SM0SEL23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM1SEL45[5:4] (RW)
 *
 * This field selects possible over-rides to the generated SM1PWM45 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM1PWM45 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM1PWM45 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM1OUT45] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTB1 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM1SEL45 field. */
#define PWM_RD_DTSRCSEL_SM1SEL45(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM1SEL45_MASK) >> PWM_DTSRCSEL_SM1SEL45_SHIFT)
#define PWM_BRD_DTSRCSEL_SM1SEL45(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM1SEL45_SHIFT, PWM_DTSRCSEL_SM1SEL45_WIDTH))

/*! @brief Set the SM1SEL45 field to a new value. */
#define PWM_WR_DTSRCSEL_SM1SEL45(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM1SEL45_MASK, PWM_DTSRCSEL_SM1SEL45(value)))
#define PWM_BWR_DTSRCSEL_SM1SEL45(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM1SEL45_SHIFT), PWM_DTSRCSEL_SM1SEL45_SHIFT, PWM_DTSRCSEL_SM1SEL45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM1SEL23[7:6] (RW)
 *
 * This field selects possible over-rides to the generated SM1PWM23 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM1PWM23 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM1PWM23 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM1OUT23] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTA1 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM1SEL23 field. */
#define PWM_RD_DTSRCSEL_SM1SEL23(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM1SEL23_MASK) >> PWM_DTSRCSEL_SM1SEL23_SHIFT)
#define PWM_BRD_DTSRCSEL_SM1SEL23(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM1SEL23_SHIFT, PWM_DTSRCSEL_SM1SEL23_WIDTH))

/*! @brief Set the SM1SEL23 field to a new value. */
#define PWM_WR_DTSRCSEL_SM1SEL23(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM1SEL23_MASK, PWM_DTSRCSEL_SM1SEL23(value)))
#define PWM_BWR_DTSRCSEL_SM1SEL23(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM1SEL23_SHIFT), PWM_DTSRCSEL_SM1SEL23_SHIFT, PWM_DTSRCSEL_SM1SEL23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM2SEL45[9:8] (RW)
 *
 * This field selects possible over-rides to the generated SM2PWM45 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that sudeadtime logic upon the occurrence of a FORCE_OUT event in that
 * submodule.
 *
 * Values:
 * - 0b00 - Generated SM2PWM45 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM2PWM45 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM2OUT45] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTB2 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM2SEL45 field. */
#define PWM_RD_DTSRCSEL_SM2SEL45(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM2SEL45_MASK) >> PWM_DTSRCSEL_SM2SEL45_SHIFT)
#define PWM_BRD_DTSRCSEL_SM2SEL45(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM2SEL45_SHIFT, PWM_DTSRCSEL_SM2SEL45_WIDTH))

/*! @brief Set the SM2SEL45 field to a new value. */
#define PWM_WR_DTSRCSEL_SM2SEL45(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM2SEL45_MASK, PWM_DTSRCSEL_SM2SEL45(value)))
#define PWM_BWR_DTSRCSEL_SM2SEL45(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM2SEL45_SHIFT), PWM_DTSRCSEL_SM2SEL45_SHIFT, PWM_DTSRCSEL_SM2SEL45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM2SEL23[11:10] (RW)
 *
 * This field selects possible over-rides to the generated SM2PWM23 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM2PWM23 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM2PWM23 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM2OUT23] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTA2 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM2SEL23 field. */
#define PWM_RD_DTSRCSEL_SM2SEL23(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM2SEL23_MASK) >> PWM_DTSRCSEL_SM2SEL23_SHIFT)
#define PWM_BRD_DTSRCSEL_SM2SEL23(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM2SEL23_SHIFT, PWM_DTSRCSEL_SM2SEL23_WIDTH))

/*! @brief Set the SM2SEL23 field to a new value. */
#define PWM_WR_DTSRCSEL_SM2SEL23(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM2SEL23_MASK, PWM_DTSRCSEL_SM2SEL23(value)))
#define PWM_BWR_DTSRCSEL_SM2SEL23(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM2SEL23_SHIFT), PWM_DTSRCSEL_SM2SEL23_SHIFT, PWM_DTSRCSEL_SM2SEL23_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM3SEL45[13:12] (RW)
 *
 * This field selects possible over-rides to the generated SM3PWM45 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM3PWM45 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM3PWM45 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM3OUT45] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTB3 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM3SEL45 field. */
#define PWM_RD_DTSRCSEL_SM3SEL45(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM3SEL45_MASK) >> PWM_DTSRCSEL_SM3SEL45_SHIFT)
#define PWM_BRD_DTSRCSEL_SM3SEL45(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM3SEL45_SHIFT, PWM_DTSRCSEL_SM3SEL45_WIDTH))

/*! @brief Set the SM3SEL45 field to a new value. */
#define PWM_WR_DTSRCSEL_SM3SEL45(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM3SEL45_MASK, PWM_DTSRCSEL_SM3SEL45(value)))
#define PWM_BWR_DTSRCSEL_SM3SEL45(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM3SEL45_SHIFT), PWM_DTSRCSEL_SM3SEL45_SHIFT, PWM_DTSRCSEL_SM3SEL45_WIDTH))
/*@}*/

/*!
 * @name Register PWM_DTSRCSEL, field SM3SEL23[15:14] (RW)
 *
 * This field selects possible over-rides to the generated SM3PWM23 signal that
 * will be passed to the deadtime logic upon the occurrence of a FORCE_OUT event
 * in that submodule.
 *
 * Values:
 * - 0b00 - Generated SM3PWM23 signal is used by the deadtime logic.
 * - 0b01 - Inverted generated SM3PWM23 signal is used by the deadtime logic.
 * - 0b10 - SWCOUT[SM3OUT23] is used by the deadtime logic.
 * - 0b11 - PWMx_EXTA3 signal is used by the deadtime logic.
 */
/*@{*/
/*! @brief Read current value of the PWM_DTSRCSEL_SM3SEL23 field. */
#define PWM_RD_DTSRCSEL_SM3SEL23(base) ((PWM_DTSRCSEL_REG(base) & PWM_DTSRCSEL_SM3SEL23_MASK) >> PWM_DTSRCSEL_SM3SEL23_SHIFT)
#define PWM_BRD_DTSRCSEL_SM3SEL23(base) (BME_UBFX16(&PWM_DTSRCSEL_REG(base), PWM_DTSRCSEL_SM3SEL23_SHIFT, PWM_DTSRCSEL_SM3SEL23_WIDTH))

/*! @brief Set the SM3SEL23 field to a new value. */
#define PWM_WR_DTSRCSEL_SM3SEL23(base, value) (PWM_RMW_DTSRCSEL(base, PWM_DTSRCSEL_SM3SEL23_MASK, PWM_DTSRCSEL_SM3SEL23(value)))
#define PWM_BWR_DTSRCSEL_SM3SEL23(base, value) (BME_BFI16(&PWM_DTSRCSEL_REG(base), ((uint16_t)(value) << PWM_DTSRCSEL_SM3SEL23_SHIFT), PWM_DTSRCSEL_SM3SEL23_SHIFT, PWM_DTSRCSEL_SM3SEL23_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_MCTRL - Master Control Register 0
 ******************************************************************************/

/*!
 * @brief PWM_MCTRL - Master Control Register 0 (RW)
 *
 * Reset value: 0x0000U
 *
 * In every 4-bit field in this register, each bit acts on a separate submodule.
 * Accordingly, the description of every bitfield refers to the effect of an
 * individual bit.
 */
/*!
 * @name Constants and macros for entire PWM_MCTRL register
 */
/*@{*/
#define PWM_RD_MCTRL(base)       (PWM_MCTRL_REG(base))
#define PWM_WR_MCTRL(base, value) (PWM_MCTRL_REG(base) = (value))
#define PWM_RMW_MCTRL(base, mask, value) (PWM_WR_MCTRL(base, (PWM_RD_MCTRL(base) & ~(mask)) | (value)))
#define PWM_SET_MCTRL(base, value) (BME_OR16(&PWM_MCTRL_REG(base), (uint16_t)(value)))
#define PWM_CLR_MCTRL(base, value) (BME_AND16(&PWM_MCTRL_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_MCTRL(base, value) (BME_XOR16(&PWM_MCTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_MCTRL bitfields
 */

/*!
 * @name Register PWM_MCTRL, field LDOK[3:0] (RW)
 *
 * The 4 bits of LDOK field correspond to submodules 3-0, respectively. Each
 * read/set bit loads CTRL[PRSC] and the INIT, FRACVALx, and VALx registers of the
 * corresponding submodule into a set of buffers. The buffered prescaler divisor,
 * submodule counter modulus value, and PWM pulse width take effect at the next
 * PWM reload if CTRL[LDMOD] is clear or immediately if CTRL[LDMOD] is set. Set
 * the corresponding MCTRL0[LDOK] bit by reading it when it is logic zero and then
 * writing a logic one to it. The VALx, FRACVALx,INIT, and CTRL[PRSC] registers
 * of the corresponding submodule cannot be written while the the corresponding
 * MCTRL0[LDOK] bit is set. In Master Reload Mode (CTRL2[RELOAD_SEL]=1), it is only
 * necessary to set the LDOK bit corresponding to submodule0; however, it is
 * recommended to also set the LDOK bit of the slave submodules, to prevent unwanted
 * writes to the registers in the slave submodules. The MCTRL0[LDOK] bit is
 * automatically cleared after the new values are loaded, or it can be manually
 * cleared before a reload by writing a logic 1 to the appropriate MCTRL0[CLDOK] bit.
 * LDOK bits cannot be written with a zero. MCTRL0[LDOK] can be set in DMA mode
 * when the DMA indicates that it has completed the update of all CTRL[PRSC],
 * INIT,FRACVALx, and VALx registers in the corresponding submodule. Reset clears
 * LDOK field.
 *
 * Values:
 * - 0b0000 - Do not load new values.
 * - 0b0001 - Load prescaler, modulus, and PWM values of the corresponding
 *     submodule.
 */
/*@{*/
/*! @brief Read current value of the PWM_MCTRL_LDOK field. */
#define PWM_RD_MCTRL_LDOK(base) ((PWM_MCTRL_REG(base) & PWM_MCTRL_LDOK_MASK) >> PWM_MCTRL_LDOK_SHIFT)
#define PWM_BRD_MCTRL_LDOK(base) (BME_UBFX16(&PWM_MCTRL_REG(base), PWM_MCTRL_LDOK_SHIFT, PWM_MCTRL_LDOK_WIDTH))

/*! @brief Set the LDOK field to a new value. */
#define PWM_WR_MCTRL_LDOK(base, value) (PWM_RMW_MCTRL(base, PWM_MCTRL_LDOK_MASK, PWM_MCTRL_LDOK(value)))
#define PWM_BWR_MCTRL_LDOK(base, value) (BME_BFI16(&PWM_MCTRL_REG(base), ((uint16_t)(value) << PWM_MCTRL_LDOK_SHIFT), PWM_MCTRL_LDOK_SHIFT, PWM_MCTRL_LDOK_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MCTRL, field CLDOK[7:4] (WORZ)
 *
 * The 4 bits of CLDOK field correspond to submodules 3-0, respectively. Each
 * write-only bit is used to clear the corresponding bit of MCTRL0[LDOK]. Write a 1
 * to CLDOK to clear the corresponding MCTRL0[LDOK] bit. If a reload occurs
 * within a submodule with the corresponding MCTRL0[LDOK] bit set at the same time
 * that MCTRL0[CLDOK] is written, then the reload in that submodule will not be
 * performed and MCTRL0[LDOK] will be cleared. CLDOK bit is self-clearing and always
 * reads as a 0.
 */
/*@{*/
/*! @brief Set the CLDOK field to a new value. */
#define PWM_WR_MCTRL_CLDOK(base, value) (PWM_RMW_MCTRL(base, PWM_MCTRL_CLDOK_MASK, PWM_MCTRL_CLDOK(value)))
#define PWM_BWR_MCTRL_CLDOK(base, value) (BME_BFI16(&PWM_MCTRL_REG(base), ((uint16_t)(value) << PWM_MCTRL_CLDOK_SHIFT), PWM_MCTRL_CLDOK_SHIFT, PWM_MCTRL_CLDOK_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MCTRL, field RUN[11:8] (RW)
 *
 * The four read/write bits of this field enable the clocks to the PWM generator
 * of submodules 3-0, respectively. The corresponding MCTRL0[RUN] bit must be
 * set for each submodule that is using its input capture functions or is using the
 * local reload as its reload source. When this bit equals zero, the submodule
 * counter is reset. A reset clears this field.
 *
 * Values:
 * - 0b0000 - PWM generator is disabled in the corresponding submodule.
 * - 0b0001 - PWM generator is enabled in the corresponding submodule.
 */
/*@{*/
/*! @brief Read current value of the PWM_MCTRL_RUN field. */
#define PWM_RD_MCTRL_RUN(base) ((PWM_MCTRL_REG(base) & PWM_MCTRL_RUN_MASK) >> PWM_MCTRL_RUN_SHIFT)
#define PWM_BRD_MCTRL_RUN(base) (BME_UBFX16(&PWM_MCTRL_REG(base), PWM_MCTRL_RUN_SHIFT, PWM_MCTRL_RUN_WIDTH))

/*! @brief Set the RUN field to a new value. */
#define PWM_WR_MCTRL_RUN(base, value) (PWM_RMW_MCTRL(base, PWM_MCTRL_RUN_MASK, PWM_MCTRL_RUN(value)))
#define PWM_BWR_MCTRL_RUN(base, value) (BME_BFI16(&PWM_MCTRL_REG(base), ((uint16_t)(value) << PWM_MCTRL_RUN_SHIFT), PWM_MCTRL_RUN_SHIFT, PWM_MCTRL_RUN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_MCTRL, field IPOL[15:12] (RW)
 *
 * The four buffered read/write bits of this field correspond to submodules 3-0,
 * respectively. Each bit selects between PWM23 and PWM45 as the source for the
 * generation of the complementary PWM pair output for the corresponding
 * submodule. MCTRL0[IPOL] is ignored in independent mode. MCTRL0[IPOL] does not take
 * effect until a FORCE_OUT event takes place in the appropriate submodule. Reading
 * MCTRL0[IPOL] reads the buffered value and not necessarily the value currently
 * in effect.
 *
 * Values:
 * - 0b0000 - PWM23 is used to generate complementary PWM pair in the
 *     corresponding submodule.
 * - 0b0001 - PWM45 is used to generate complementary PWM pair in the
 *     corresponding submodule.
 */
/*@{*/
/*! @brief Read current value of the PWM_MCTRL_IPOL field. */
#define PWM_RD_MCTRL_IPOL(base) ((PWM_MCTRL_REG(base) & PWM_MCTRL_IPOL_MASK) >> PWM_MCTRL_IPOL_SHIFT)
#define PWM_BRD_MCTRL_IPOL(base) (BME_UBFX16(&PWM_MCTRL_REG(base), PWM_MCTRL_IPOL_SHIFT, PWM_MCTRL_IPOL_WIDTH))

/*! @brief Set the IPOL field to a new value. */
#define PWM_WR_MCTRL_IPOL(base, value) (PWM_RMW_MCTRL(base, PWM_MCTRL_IPOL_MASK, PWM_MCTRL_IPOL(value)))
#define PWM_BWR_MCTRL_IPOL(base, value) (BME_BFI16(&PWM_MCTRL_REG(base), ((uint16_t)(value) << PWM_MCTRL_IPOL_SHIFT), PWM_MCTRL_IPOL_SHIFT, PWM_MCTRL_IPOL_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_MCTRL2 - Master Control Register 1
 ******************************************************************************/

/*!
 * @brief PWM_MCTRL2 - Master Control Register 1 (RW)
 *
 * Reset value: 0x0000U
 *
 * This register is optional and may not be available on all PWM instances. See
 * the chip-specific information for details.
 */
/*!
 * @name Constants and macros for entire PWM_MCTRL2 register
 */
/*@{*/
#define PWM_RD_MCTRL2(base)      (PWM_MCTRL2_REG(base))
#define PWM_WR_MCTRL2(base, value) (PWM_MCTRL2_REG(base) = (value))
#define PWM_RMW_MCTRL2(base, mask, value) (PWM_WR_MCTRL2(base, (PWM_RD_MCTRL2(base) & ~(mask)) | (value)))
#define PWM_SET_MCTRL2(base, value) (BME_OR16(&PWM_MCTRL2_REG(base), (uint16_t)(value)))
#define PWM_CLR_MCTRL2(base, value) (BME_AND16(&PWM_MCTRL2_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_MCTRL2(base, value) (BME_XOR16(&PWM_MCTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_MCTRL2 bitfields
 */

/*!
 * @name Register PWM_MCTRL2, field MONPLL[1:0] (RW)
 *
 * These bits are used to control disabling of the fractional delay block when
 * the chip PLL is unlocked and/or missing its input reference. The fractional
 * delay block requires a continuous MHz clock from the PLL. If this clock turns off
 * when the fractional delay block is being used, then the output of the
 * fractional delay block can be stuck high or low even if the PLL restarts. When this
 * control bit is set, PLL problems cause the fractional delay block to be
 * disabled until the PLL returns to a locked state. Once the PLL is receiving a proper
 * reference and is locked, the fractional delay block requires a 25 us startup
 * time just as if the FRCTRL[FRAC*_EN] bits had been turned off and turned on
 * again. If PLL monitoring is disabled, then software should manually clear and
 * then set the FRCTRL[FRAC*_EN] bits when the PLL loses its reference or loses
 * lock. This will cause the fractional delay block to be disabled and restarted. If
 * the fractional delay block is not being used, then the value of these bits do
 * not matter.
 *
 * Values:
 * - 0b00 - Not locked. Do not monitor PLL operation. Resetting of the
 *     fractional delay block in case of PLL losing lock will be controlled by software.
 * - 0b01 - Not locked. Monitor PLL operation to automatically disable the
 *     fractional delay block when the PLL encounters problems.
 * - 0b10 - Locked. Do not monitor PLL operation. Resetting of the fractional
 *     delay block in case of PLL losing lock will be controlled by software. These
 *     bits are write protected until the next reset.
 * - 0b11 - Locked. Monitor PLL operation to automatically disable the
 *     fractional delay block when the PLL encounters problems. These bits are write
 *     protected until the next reset.
 */
/*@{*/
/*! @brief Read current value of the PWM_MCTRL2_MONPLL field. */
#define PWM_RD_MCTRL2_MONPLL(base) ((PWM_MCTRL2_REG(base) & PWM_MCTRL2_MONPLL_MASK) >> PWM_MCTRL2_MONPLL_SHIFT)
#define PWM_BRD_MCTRL2_MONPLL(base) (BME_UBFX16(&PWM_MCTRL2_REG(base), PWM_MCTRL2_MONPLL_SHIFT, PWM_MCTRL2_MONPLL_WIDTH))

/*! @brief Set the MONPLL field to a new value. */
#define PWM_WR_MCTRL2_MONPLL(base, value) (PWM_RMW_MCTRL2(base, PWM_MCTRL2_MONPLL_MASK, PWM_MCTRL2_MONPLL(value)))
#define PWM_BWR_MCTRL2_MONPLL(base, value) (BME_BFI16(&PWM_MCTRL2_REG(base), ((uint16_t)(value) << PWM_MCTRL2_MONPLL_SHIFT), PWM_MCTRL2_MONPLL_SHIFT, PWM_MCTRL2_MONPLL_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_FCTRL - Fault Control Register
 ******************************************************************************/

/*!
 * @brief PWM_FCTRL - Fault Control Register (RW)
 *
 * Reset value: 0x0000U
 *
 * For every 4-bit field in this register, the bits act on the fault inputs in
 * order. For example, FLVL bits 15-12 act on faults 3-0, respectively.
 */
/*!
 * @name Constants and macros for entire PWM_FCTRL register
 */
/*@{*/
#define PWM_RD_FCTRL(base)       (PWM_FCTRL_REG(base))
#define PWM_WR_FCTRL(base, value) (PWM_FCTRL_REG(base) = (value))
#define PWM_RMW_FCTRL(base, mask, value) (PWM_WR_FCTRL(base, (PWM_RD_FCTRL(base) & ~(mask)) | (value)))
#define PWM_SET_FCTRL(base, value) (BME_OR16(&PWM_FCTRL_REG(base), (uint16_t)(value)))
#define PWM_CLR_FCTRL(base, value) (BME_AND16(&PWM_FCTRL_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_FCTRL(base, value) (BME_XOR16(&PWM_FCTRL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FCTRL bitfields
 */

/*!
 * @name Register PWM_FCTRL, field FIE[3:0] (RW)
 *
 * This read/write field enables CPU interrupt requests generated by the FAULTx
 * pins. A reset clears this field. The fault protection circuit is independent
 * of the FIEx bit and is always active. If a fault is detected, the PWM outputs
 * are disabled according to the disable mapping register.
 *
 * Values:
 * - 0b0000 - FAULTx CPU interrupt requests disabled.
 * - 0b0001 - FAULTx CPU interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the PWM_FCTRL_FIE field. */
#define PWM_RD_FCTRL_FIE(base) ((PWM_FCTRL_REG(base) & PWM_FCTRL_FIE_MASK) >> PWM_FCTRL_FIE_SHIFT)
#define PWM_BRD_FCTRL_FIE(base) (BME_UBFX16(&PWM_FCTRL_REG(base), PWM_FCTRL_FIE_SHIFT, PWM_FCTRL_FIE_WIDTH))

/*! @brief Set the FIE field to a new value. */
#define PWM_WR_FCTRL_FIE(base, value) (PWM_RMW_FCTRL(base, PWM_FCTRL_FIE_MASK, PWM_FCTRL_FIE(value)))
#define PWM_BWR_FCTRL_FIE(base, value) (BME_BFI16(&PWM_FCTRL_REG(base), ((uint16_t)(value) << PWM_FCTRL_FIE_SHIFT), PWM_FCTRL_FIE_SHIFT, PWM_FCTRL_FIE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FCTRL, field FSAFE[7:4] (RW)
 *
 * These read/write bits select the safety mode during manual fault clearing. A
 * reset clears this field. FSTS[FFPINx] may indicate a fault condition still
 * exists even though the actual fault signal at the FAULTx pin is clear due to the
 * fault filter latency.
 *
 * Values:
 * - 0b0000 - Normal mode. PWM outputs disabled by this fault are not enabled
 *     until FSTS[FFLAGx] is clear at the start of a half cycle or full cycle
 *     depending on the state of FSTS[FFULL] without regard to the state of
 *     FSTS[FFPINx]. The PWM outputs disabled by this fault input will not be re-enabled
 *     until the actual FAULTx input signal de-asserts since the fault input will
 *     combinationally disable the PWM outputs (as programmed in DISMAPn).
 * - 0b0001 - Safe mode. PWM outputs disabled by this fault are not enabled
 *     until FSTS[FFLAGx] is clear and FSTS[FFPINx] is clear at the start of a half
 *     cycle or full cycle depending on the state of FSTS[FFULL].
 */
/*@{*/
/*! @brief Read current value of the PWM_FCTRL_FSAFE field. */
#define PWM_RD_FCTRL_FSAFE(base) ((PWM_FCTRL_REG(base) & PWM_FCTRL_FSAFE_MASK) >> PWM_FCTRL_FSAFE_SHIFT)
#define PWM_BRD_FCTRL_FSAFE(base) (BME_UBFX16(&PWM_FCTRL_REG(base), PWM_FCTRL_FSAFE_SHIFT, PWM_FCTRL_FSAFE_WIDTH))

/*! @brief Set the FSAFE field to a new value. */
#define PWM_WR_FCTRL_FSAFE(base, value) (PWM_RMW_FCTRL(base, PWM_FCTRL_FSAFE_MASK, PWM_FCTRL_FSAFE(value)))
#define PWM_BWR_FCTRL_FSAFE(base, value) (BME_BFI16(&PWM_FCTRL_REG(base), ((uint16_t)(value) << PWM_FCTRL_FSAFE_SHIFT), PWM_FCTRL_FSAFE_SHIFT, PWM_FCTRL_FSAFE_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FCTRL, field FAUTO[11:8] (RW)
 *
 * The four read/write bits of this field select automatic or manual clearing of
 * faults 3-0, respectively. A reset clears this field.
 *
 * Values:
 * - 0b0000 - Manual fault clearing. PWM outputs disabled by this fault are not
 *     enabled until FSTS[FFLAGx] is clear at the start of a half cycle or full
 *     cycle depending the state of FSTS[FFULL]. This is further controlled by
 *     FCTRL[FSAFE].
 * - 0b0001 - Automatic fault clearing. PWM outputs disabled by this fault are
 *     enabled when FSTS[FFPINx] is clear at the start of a half cycle or full
 *     cycle depending on the state of FSTS[FFULL] without regard to the state of
 *     FSTS[FFLAGx].
 */
/*@{*/
/*! @brief Read current value of the PWM_FCTRL_FAUTO field. */
#define PWM_RD_FCTRL_FAUTO(base) ((PWM_FCTRL_REG(base) & PWM_FCTRL_FAUTO_MASK) >> PWM_FCTRL_FAUTO_SHIFT)
#define PWM_BRD_FCTRL_FAUTO(base) (BME_UBFX16(&PWM_FCTRL_REG(base), PWM_FCTRL_FAUTO_SHIFT, PWM_FCTRL_FAUTO_WIDTH))

/*! @brief Set the FAUTO field to a new value. */
#define PWM_WR_FCTRL_FAUTO(base, value) (PWM_RMW_FCTRL(base, PWM_FCTRL_FAUTO_MASK, PWM_FCTRL_FAUTO(value)))
#define PWM_BWR_FCTRL_FAUTO(base, value) (BME_BFI16(&PWM_FCTRL_REG(base), ((uint16_t)(value) << PWM_FCTRL_FAUTO_SHIFT), PWM_FCTRL_FAUTO_SHIFT, PWM_FCTRL_FAUTO_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FCTRL, field FLVL[15:12] (RW)
 *
 * The four read/write bits of this field select the active logic level of the
 * individual fault inputs 3-0, respectively. A reset clears this field.
 *
 * Values:
 * - 0b0000 - A logic 0 on the fault input indicates a fault condition.
 * - 0b0001 - A logic 1 on the fault input indicates a fault condition.
 */
/*@{*/
/*! @brief Read current value of the PWM_FCTRL_FLVL field. */
#define PWM_RD_FCTRL_FLVL(base) ((PWM_FCTRL_REG(base) & PWM_FCTRL_FLVL_MASK) >> PWM_FCTRL_FLVL_SHIFT)
#define PWM_BRD_FCTRL_FLVL(base) (BME_UBFX16(&PWM_FCTRL_REG(base), PWM_FCTRL_FLVL_SHIFT, PWM_FCTRL_FLVL_WIDTH))

/*! @brief Set the FLVL field to a new value. */
#define PWM_WR_FCTRL_FLVL(base, value) (PWM_RMW_FCTRL(base, PWM_FCTRL_FLVL_MASK, PWM_FCTRL_FLVL(value)))
#define PWM_BWR_FCTRL_FLVL(base, value) (BME_BFI16(&PWM_FCTRL_REG(base), ((uint16_t)(value) << PWM_FCTRL_FLVL_SHIFT), PWM_FCTRL_FLVL_SHIFT, PWM_FCTRL_FLVL_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_FSTS - Fault Status Register
 ******************************************************************************/

/*!
 * @brief PWM_FSTS - Fault Status Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FSTS register
 */
/*@{*/
#define PWM_RD_FSTS(base)        (PWM_FSTS_REG(base))
#define PWM_WR_FSTS(base, value) (PWM_FSTS_REG(base) = (value))
#define PWM_RMW_FSTS(base, mask, value) (PWM_WR_FSTS(base, (PWM_RD_FSTS(base) & ~(mask)) | (value)))
#define PWM_SET_FSTS(base, value) (BME_OR16(&PWM_FSTS_REG(base), (uint16_t)(value)))
#define PWM_CLR_FSTS(base, value) (BME_AND16(&PWM_FSTS_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_FSTS(base, value) (BME_XOR16(&PWM_FSTS_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FSTS bitfields
 */

/*!
 * @name Register PWM_FSTS, field FFLAG[3:0] (W1C)
 *
 * These read-only flag is set within two CPU cycles after a transition to
 * active on the FAULTx pin. Clear this bit by writing a logic one to it. A reset
 * clears this field. While the reset value is 0, these bits may be set to 1 by the
 * time they can be read depending on the state of the fault input signals.
 *
 * Values:
 * - 0b0000 - No fault on the FAULTx pin.
 * - 0b0001 - Fault on the FAULTx pin.
 */
/*@{*/
/*! @brief Read current value of the PWM_FSTS_FFLAG field. */
#define PWM_RD_FSTS_FFLAG(base) ((PWM_FSTS_REG(base) & PWM_FSTS_FFLAG_MASK) >> PWM_FSTS_FFLAG_SHIFT)
#define PWM_BRD_FSTS_FFLAG(base) (BME_UBFX16(&PWM_FSTS_REG(base), PWM_FSTS_FFLAG_SHIFT, PWM_FSTS_FFLAG_WIDTH))

/*! @brief Set the FFLAG field to a new value. */
#define PWM_WR_FSTS_FFLAG(base, value) (PWM_RMW_FSTS(base, PWM_FSTS_FFLAG_MASK, PWM_FSTS_FFLAG(value)))
#define PWM_BWR_FSTS_FFLAG(base, value) (BME_BFI16(&PWM_FSTS_REG(base), ((uint16_t)(value) << PWM_FSTS_FFLAG_SHIFT), PWM_FSTS_FFLAG_SHIFT, PWM_FSTS_FFLAG_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FSTS, field FFULL[7:4] (RW)
 *
 * These read/write bits are used to control the timing for re-enabling the PWM
 * outputs after a fault condition. These bits apply to both automatic and manual
 * clearing of a fault condition. Both FHALF and FFULL can be set so that the
 * fault recovery occurs at the start of a full cycle and at the start of a half
 * cycle (as defined by VAL0). If neither FHALF nor FFULL is set, then no fault
 * recovery is possible.
 *
 * Values:
 * - 0b0000 - PWM outputs are not re-enabled at the start of a full cycle
 * - 0b0001 - PWM outputs are re-enabled at the start of a full cycle
 */
/*@{*/
/*! @brief Read current value of the PWM_FSTS_FFULL field. */
#define PWM_RD_FSTS_FFULL(base) ((PWM_FSTS_REG(base) & PWM_FSTS_FFULL_MASK) >> PWM_FSTS_FFULL_SHIFT)
#define PWM_BRD_FSTS_FFULL(base) (BME_UBFX16(&PWM_FSTS_REG(base), PWM_FSTS_FFULL_SHIFT, PWM_FSTS_FFULL_WIDTH))

/*! @brief Set the FFULL field to a new value. */
#define PWM_WR_FSTS_FFULL(base, value) (PWM_RMW_FSTS(base, (PWM_FSTS_FFULL_MASK | PWM_FSTS_FFLAG_MASK), PWM_FSTS_FFULL(value)))
#define PWM_BWR_FSTS_FFULL(base, value) (BME_BFI16(&PWM_FSTS_REG(base), ((uint16_t)(value) << PWM_FSTS_FFULL_SHIFT), PWM_FSTS_FFULL_SHIFT, PWM_FSTS_FFULL_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FSTS, field FFPIN[11:8] (RO)
 *
 * These read-only bits reflect the current state of the filtered FAULTx pins
 * converted to high polarity. A logic 1 indicates a fault condition exists on the
 * filtered FAULTx pin. A reset has no effect on this field.
 */
/*@{*/
/*! @brief Read current value of the PWM_FSTS_FFPIN field. */
#define PWM_RD_FSTS_FFPIN(base) ((PWM_FSTS_REG(base) & PWM_FSTS_FFPIN_MASK) >> PWM_FSTS_FFPIN_SHIFT)
#define PWM_BRD_FSTS_FFPIN(base) (BME_UBFX16(&PWM_FSTS_REG(base), PWM_FSTS_FFPIN_SHIFT, PWM_FSTS_FFPIN_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FSTS, field FHALF[15:12] (RW)
 *
 * These read/write bits are used to control the timing for re-enabling the PWM
 * outputs after a fault condition. These bits apply to both automatic and manual
 * clearing of a fault condition. Both FHALF and FFULL can be set so that the
 * fault recovery occurs at the start of a full cycle and at the start of a half
 * cycle (as defined by VAL0). If neither FHALF nor FFULL is set, then no fault
 * recovery is possible.
 *
 * Values:
 * - 0b0000 - PWM outputs are not re-enabled at the start of a half cycle.
 * - 0b0001 - PWM outputs are re-enabled at the start of a half cycle (as
 *     defined by VAL0).
 */
/*@{*/
/*! @brief Read current value of the PWM_FSTS_FHALF field. */
#define PWM_RD_FSTS_FHALF(base) ((PWM_FSTS_REG(base) & PWM_FSTS_FHALF_MASK) >> PWM_FSTS_FHALF_SHIFT)
#define PWM_BRD_FSTS_FHALF(base) (BME_UBFX16(&PWM_FSTS_REG(base), PWM_FSTS_FHALF_SHIFT, PWM_FSTS_FHALF_WIDTH))

/*! @brief Set the FHALF field to a new value. */
#define PWM_WR_FSTS_FHALF(base, value) (PWM_RMW_FSTS(base, (PWM_FSTS_FHALF_MASK | PWM_FSTS_FFLAG_MASK), PWM_FSTS_FHALF(value)))
#define PWM_BWR_FSTS_FHALF(base, value) (BME_BFI16(&PWM_FSTS_REG(base), ((uint16_t)(value) << PWM_FSTS_FHALF_SHIFT), PWM_FSTS_FHALF_SHIFT, PWM_FSTS_FHALF_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_FFILT - Fault Filter Register
 ******************************************************************************/

/*!
 * @brief PWM_FFILT - Fault Filter Register (RW)
 *
 * Reset value: 0x0000U
 *
 * The settings in this register are shared among each of the fault input
 * filters within the fault channel. Input filter considerations include: The FILT_PER
 * value should be set such that the sampling period is larger than the period of
 * the expected noise. This way a noise spike will only corrupt one sample. The
 * FILT_CNT value should be chosen to reduce the probability of noisy samples
 * causing an incorrect transition to be recognized. The probability of an incorrect
 * transition is defined as the probability of an incorrect sample raised to the
 * FILT_CNT+3 power. The values of FILT_PER and FILT_CNT must also be traded off
 * against the desire for minimal latency in recognizing input transitions.
 * Turning on the input filter (setting FILT_PER to a non-zero value) introduces a
 * latency of ((FILT_CNT+4) x FILT_PER x IPBus clock period). Note that even when
 * the filter is enabled, there is a combinational path to disable the PWM
 * outputs. This is to ensure rapid response to fault conditions and also to ensure
 * fault response if the PWM module loses its clock. The latency induced by the
 * filter will be seen in the time to set FSTS[FFLAG] and FSTS[FFPIN].
 */
/*!
 * @name Constants and macros for entire PWM_FFILT register
 */
/*@{*/
#define PWM_RD_FFILT(base)       (PWM_FFILT_REG(base))
#define PWM_WR_FFILT(base, value) (PWM_FFILT_REG(base) = (value))
#define PWM_RMW_FFILT(base, mask, value) (PWM_WR_FFILT(base, (PWM_RD_FFILT(base) & ~(mask)) | (value)))
#define PWM_SET_FFILT(base, value) (BME_OR16(&PWM_FFILT_REG(base), (uint16_t)(value)))
#define PWM_CLR_FFILT(base, value) (BME_AND16(&PWM_FFILT_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_FFILT(base, value) (BME_XOR16(&PWM_FFILT_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FFILT bitfields
 */

/*!
 * @name Register PWM_FFILT, field FILT_PER[7:0] (RW)
 *
 * This 8-bit field applies universally to all fault inputs. These bits
 * represent the sampling period (in IPBus clock cycles) of the fault pin input filter.
 * Each input is sampled multiple times at the rate specified by this field. If
 * FILT_PER is 0x00 (default), then the input filter is bypassed. The value of
 * FILT_PER affects the input latency. When changing values for FILT_PER from one
 * non-zero value to another non-zero value, first write a value of zero to clear
 * the filter.
 */
/*@{*/
/*! @brief Read current value of the PWM_FFILT_FILT_PER field. */
#define PWM_RD_FFILT_FILT_PER(base) ((PWM_FFILT_REG(base) & PWM_FFILT_FILT_PER_MASK) >> PWM_FFILT_FILT_PER_SHIFT)
#define PWM_BRD_FFILT_FILT_PER(base) (BME_UBFX16(&PWM_FFILT_REG(base), PWM_FFILT_FILT_PER_SHIFT, PWM_FFILT_FILT_PER_WIDTH))

/*! @brief Set the FILT_PER field to a new value. */
#define PWM_WR_FFILT_FILT_PER(base, value) (PWM_RMW_FFILT(base, PWM_FFILT_FILT_PER_MASK, PWM_FFILT_FILT_PER(value)))
#define PWM_BWR_FFILT_FILT_PER(base, value) (BME_BFI16(&PWM_FFILT_REG(base), ((uint16_t)(value) << PWM_FFILT_FILT_PER_SHIFT), PWM_FFILT_FILT_PER_SHIFT, PWM_FFILT_FILT_PER_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FFILT, field FILT_CNT[10:8] (RW)
 *
 * These bits represent the number of consecutive samples that must agree prior
 * to the input filter accepting an input transition. The number of samples is
 * the decimal value of this field plus three: the bitfield value of 0-7 represents
 * 3-10 samples, respectively. The value of FILT_CNT affects the input latency.
 */
/*@{*/
/*! @brief Read current value of the PWM_FFILT_FILT_CNT field. */
#define PWM_RD_FFILT_FILT_CNT(base) ((PWM_FFILT_REG(base) & PWM_FFILT_FILT_CNT_MASK) >> PWM_FFILT_FILT_CNT_SHIFT)
#define PWM_BRD_FFILT_FILT_CNT(base) (BME_UBFX16(&PWM_FFILT_REG(base), PWM_FFILT_FILT_CNT_SHIFT, PWM_FFILT_FILT_CNT_WIDTH))

/*! @brief Set the FILT_CNT field to a new value. */
#define PWM_WR_FFILT_FILT_CNT(base, value) (PWM_RMW_FFILT(base, PWM_FFILT_FILT_CNT_MASK, PWM_FFILT_FILT_CNT(value)))
#define PWM_BWR_FFILT_FILT_CNT(base, value) (BME_BFI16(&PWM_FFILT_REG(base), ((uint16_t)(value) << PWM_FFILT_FILT_CNT_SHIFT), PWM_FFILT_FILT_CNT_SHIFT, PWM_FFILT_FILT_CNT_WIDTH))
/*@}*/

/*!
 * @name Register PWM_FFILT, field GSTR[15] (RW)
 *
 * This bit is used to enable the fault glitch stretching logic. This logic
 * ensures that narrow fault glitches are stretched to be at least 2 IPBus clock
 * cycles wide. In some cases a narrow fault input can cause problems due to the
 * short PWM output shutdown/re-activation time. The stretching logic ensures that a
 * glitch on the fault input, when the fault filter is disabled, will be
 * registered in the fault flags.
 *
 * Values:
 * - 0b0 - Fault input glitch stretching is disabled.
 * - 0b1 - Input fault signals will be stretched to at least 2 IPBus clock
 *     cycles.
 */
/*@{*/
/*! @brief Read current value of the PWM_FFILT_GSTR field. */
#define PWM_RD_FFILT_GSTR(base) ((PWM_FFILT_REG(base) & PWM_FFILT_GSTR_MASK) >> PWM_FFILT_GSTR_SHIFT)
#define PWM_BRD_FFILT_GSTR(base) (BME_UBFX16(&PWM_FFILT_REG(base), PWM_FFILT_GSTR_SHIFT, PWM_FFILT_GSTR_WIDTH))

/*! @brief Set the GSTR field to a new value. */
#define PWM_WR_FFILT_GSTR(base, value) (PWM_RMW_FFILT(base, PWM_FFILT_GSTR_MASK, PWM_FFILT_GSTR(value)))
#define PWM_BWR_FFILT_GSTR(base, value) (BME_BFI16(&PWM_FFILT_REG(base), ((uint16_t)(value) << PWM_FFILT_GSTR_SHIFT), PWM_FFILT_GSTR_SHIFT, PWM_FFILT_GSTR_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_FTST - Fault Test Register
 ******************************************************************************/

/*!
 * @brief PWM_FTST - Fault Test Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FTST register
 */
/*@{*/
#define PWM_RD_FTST(base)        (PWM_FTST_REG(base))
#define PWM_WR_FTST(base, value) (PWM_FTST_REG(base) = (value))
#define PWM_RMW_FTST(base, mask, value) (PWM_WR_FTST(base, (PWM_RD_FTST(base) & ~(mask)) | (value)))
#define PWM_SET_FTST(base, value) (BME_OR16(&PWM_FTST_REG(base), (uint16_t)(value)))
#define PWM_CLR_FTST(base, value) (BME_AND16(&PWM_FTST_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_FTST(base, value) (BME_XOR16(&PWM_FTST_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FTST bitfields
 */

/*!
 * @name Register PWM_FTST, field FTEST[0] (RW)
 *
 * This read/write bit is used to simulate a fault condition. Setting this bit
 * causes a simulated fault to be sent into all of the fault filters. The
 * condition propagates to the fault flags and possibly the PWM outputs depending on the
 * DISMAPn settings. Clearing this bit removes the simulated fault condition.
 *
 * Values:
 * - 0b0 - No fault
 * - 0b1 - Cause a simulated fault
 */
/*@{*/
/*! @brief Read current value of the PWM_FTST_FTEST field. */
#define PWM_RD_FTST_FTEST(base) ((PWM_FTST_REG(base) & PWM_FTST_FTEST_MASK) >> PWM_FTST_FTEST_SHIFT)
#define PWM_BRD_FTST_FTEST(base) (BME_UBFX16(&PWM_FTST_REG(base), PWM_FTST_FTEST_SHIFT, PWM_FTST_FTEST_WIDTH))

/*! @brief Set the FTEST field to a new value. */
#define PWM_WR_FTST_FTEST(base, value) (PWM_RMW_FTST(base, PWM_FTST_FTEST_MASK, PWM_FTST_FTEST(value)))
#define PWM_BWR_FTST_FTEST(base, value) (BME_BFI16(&PWM_FTST_REG(base), ((uint16_t)(value) << PWM_FTST_FTEST_SHIFT), PWM_FTST_FTEST_SHIFT, PWM_FTST_FTEST_WIDTH))
/*@}*/

/*******************************************************************************
 * PWM_FCTRL2 - Fault Control 2 Register
 ******************************************************************************/

/*!
 * @brief PWM_FCTRL2 - Fault Control 2 Register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire PWM_FCTRL2 register
 */
/*@{*/
#define PWM_RD_FCTRL2(base)      (PWM_FCTRL2_REG(base))
#define PWM_WR_FCTRL2(base, value) (PWM_FCTRL2_REG(base) = (value))
#define PWM_RMW_FCTRL2(base, mask, value) (PWM_WR_FCTRL2(base, (PWM_RD_FCTRL2(base) & ~(mask)) | (value)))
#define PWM_SET_FCTRL2(base, value) (BME_OR16(&PWM_FCTRL2_REG(base), (uint16_t)(value)))
#define PWM_CLR_FCTRL2(base, value) (BME_AND16(&PWM_FCTRL2_REG(base), (uint16_t)(~(value))))
#define PWM_TOG_FCTRL2(base, value) (BME_XOR16(&PWM_FCTRL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual PWM_FCTRL2 bitfields
 */

/*!
 * @name Register PWM_FCTRL2, field NOCOMB[3:0] (RW)
 *
 * This read/write field is used to control the combinational path from the
 * fault inputs to the PWM outputs. When these bits are low (default), the
 * corresponding fault inputs have a combinational path to the PWM outputs that are
 * sensitive to these fault inputs (as defined by DISMAP0 and DISMAP1). This
 * combinational path is a safety feature that ensures the output is disabled even if the
 * SOC has a failure of its clocking system. The combinational path also means that
 * a pulse on the fault input can cause a brief disable of the PWM output even
 * if the fault pulse is not wide enaough to get through the input filter and be
 * latched in the fault logic. Setting these bits removes the combinational path
 * and uses the filterred and latched fault signals as the fault source to disable
 * the PWM outputs. This eliminates fault glitches from creating PWM output
 * glitches but also increases the latency to respond to a real fault.
 *
 * Values:
 * - 0b0000 - There is a combinational link from the fault inputs to the PWM
 *     outputs. The fault inputs are combined with the filtered and latched fault
 *     signals to disable the PWM outputs.
 * - 0b0001 - The direct combinational path from the fault inputs to the PWM
 *     outputs is disabled and the filtered and latched fault signals are used to
 *     disable the PWM outputs.
 */
/*@{*/
/*! @brief Read current value of the PWM_FCTRL2_NOCOMB field. */
#define PWM_RD_FCTRL2_NOCOMB(base) ((PWM_FCTRL2_REG(base) & PWM_FCTRL2_NOCOMB_MASK) >> PWM_FCTRL2_NOCOMB_SHIFT)
#define PWM_BRD_FCTRL2_NOCOMB(base) (BME_UBFX16(&PWM_FCTRL2_REG(base), PWM_FCTRL2_NOCOMB_SHIFT, PWM_FCTRL2_NOCOMB_WIDTH))

/*! @brief Set the NOCOMB field to a new value. */
#define PWM_WR_FCTRL2_NOCOMB(base, value) (PWM_RMW_FCTRL2(base, PWM_FCTRL2_NOCOMB_MASK, PWM_FCTRL2_NOCOMB(value)))
#define PWM_BWR_FCTRL2_NOCOMB(base, value) (BME_BFI16(&PWM_FCTRL2_REG(base), ((uint16_t)(value) << PWM_FCTRL2_NOCOMB_SHIFT), PWM_FCTRL2_NOCOMB_SHIFT, PWM_FCTRL2_NOCOMB_WIDTH))
/*@}*/

/*
 * MKV58F24 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control register
 * - RCM_RPFW - Reset Pin Filter Width register
 * - RCM_SSRS0 - Sticky System Reset Status Register 0
 * - RCM_SSRS1 - Sticky System Reset Status Register 1
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0b0 - Reset not caused by LLWU module wakeup source
 * - 0b1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT, RCM_SRS0_WAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT, RCM_SRS0_LVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT, RCM_SRS0_LOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOL field. */
#define RCM_RD_SRS0_LOL(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOL_MASK) >> RCM_SRS0_LOL_SHIFT)
#define RCM_BRD_SRS0_LOL(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_LOL_SHIFT, RCM_SRS0_LOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT, RCM_SRS0_WDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT, RCM_SRS0_PIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BME_UBFX8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT, RCM_SRS0_POR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field JTAG[0] (RO)
 *
 * Indicates a reset has been caused by JTAG selection of certain IR codes:
 * EXTEST, HIGHZ, and CLAMP.
 *
 * Values:
 * - 0b0 - Reset not caused by JTAG
 * - 0b1 - Reset caused by JTAG
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_JTAG field. */
#define RCM_RD_SRS1_JTAG(base) ((RCM_SRS1_REG(base) & RCM_SRS1_JTAG_MASK) >> RCM_SRS1_JTAG_SHIFT)
#define RCM_BRD_SRS1_JTAG(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_JTAG_SHIFT, RCM_SRS1_JTAG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT, RCM_SRS1_LOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT, RCM_SRS1_SW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0b0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 0b1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT, RCM_SRS1_MDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BME_UBFX8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT, RCM_SRS1_SACKERR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (BME_OR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFC(base, value) (BME_AND8(&RCM_RPFC_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFC(base, value) (BME_XOR8(&RCM_RPFC_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 0b00 - All filtering disabled
 * - 0b01 - Bus clock filter enabled for normal operation
 * - 0b10 - LPO clock filter enabled for normal operation
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSRW_SHIFT), RCM_RPFC_RSTFLTSRW_SHIFT, RCM_RPFC_RSTFLTSRW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during VLLS mode. On exit from VLLS mode, this bit should be reconfigured
 * before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0b0 - All filtering disabled
 * - 0b1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BME_UBFX8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BME_BFI8(&RCM_RPFC_REG(base), ((uint8_t)(value) << RCM_RPFC_RSTFLTSS_SHIFT), RCM_RPFC_RSTFLTSS_SHIFT, RCM_RPFC_RSTFLTSS_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (BME_OR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
#define RCM_CLR_RPFW(base, value) (BME_AND8(&RCM_RPFW_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_RPFW(base, value) (BME_XOR8(&RCM_RPFW_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 0b00000 - Bus clock filter count is 1
 * - 0b00001 - Bus clock filter count is 2
 * - 0b00010 - Bus clock filter count is 3
 * - 0b00011 - Bus clock filter count is 4
 * - 0b00100 - Bus clock filter count is 5
 * - 0b00101 - Bus clock filter count is 6
 * - 0b00110 - Bus clock filter count is 7
 * - 0b00111 - Bus clock filter count is 8
 * - 0b01000 - Bus clock filter count is 9
 * - 0b01001 - Bus clock filter count is 10
 * - 0b01010 - Bus clock filter count is 11
 * - 0b01011 - Bus clock filter count is 12
 * - 0b01100 - Bus clock filter count is 13
 * - 0b01101 - Bus clock filter count is 14
 * - 0b01110 - Bus clock filter count is 15
 * - 0b01111 - Bus clock filter count is 16
 * - 0b10000 - Bus clock filter count is 17
 * - 0b10001 - Bus clock filter count is 18
 * - 0b10010 - Bus clock filter count is 19
 * - 0b10011 - Bus clock filter count is 20
 * - 0b10100 - Bus clock filter count is 21
 * - 0b10101 - Bus clock filter count is 22
 * - 0b10110 - Bus clock filter count is 23
 * - 0b10111 - Bus clock filter count is 24
 * - 0b11000 - Bus clock filter count is 25
 * - 0b11001 - Bus clock filter count is 26
 * - 0b11010 - Bus clock filter count is 27
 * - 0b11011 - Bus clock filter count is 28
 * - 0b11100 - Bus clock filter count is 29
 * - 0b11101 - Bus clock filter count is 30
 * - 0b11110 - Bus clock filter count is 31
 * - 0b11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (BME_UBFX8(&RCM_RPFW_REG(base), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (BME_BFI8(&RCM_RPFW_REG(base), ((uint8_t)(value) << RCM_RPFW_RSTFLTSEL_SHIFT), RCM_RPFW_RSTFLTSEL_SHIFT, RCM_RPFW_RSTFLTSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SSRS0 - Sticky System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SSRS0 - Sticky System Reset Status Register 0 (RW)
 *
 * Reset value: 0x82U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS0 register
 */
/*@{*/
#define RCM_RD_SSRS0(base)       (RCM_SSRS0_REG(base))
#define RCM_WR_SSRS0(base, value) (RCM_SSRS0_REG(base) = (value))
#define RCM_RMW_SSRS0(base, mask, value) (RCM_WR_SSRS0(base, (RCM_RD_SSRS0(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS0(base, value) (BME_OR8(&RCM_SSRS0_REG(base), (uint8_t)(value)))
#define RCM_CLR_SSRS0(base, value) (BME_AND8(&RCM_SSRS0_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_SSRS0(base, value) (BME_XOR8(&RCM_SSRS0_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS0 bitfields
 */

/*!
 * @name Register RCM_SSRS0, field SWAKEUP[0] (W1C)
 *
 * Indicates a reset has been caused by an enabled LLWU modulewakeup source
 * while the chip was in a low leakage mode. Any enabled wakeup source in a VLLSx
 * mode causes a reset.
 *
 * Values:
 * - 0b0 - Reset not caused by LLWU module wakeup source
 * - 0b1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWAKEUP field. */
#define RCM_RD_SSRS0_SWAKEUP(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWAKEUP_MASK) >> RCM_SSRS0_SWAKEUP_SHIFT)
#define RCM_BRD_SSRS0_SWAKEUP(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWAKEUP_SHIFT, RCM_SSRS0_SWAKEUP_WIDTH))

/*! @brief Set the SWAKEUP field to a new value. */
#define RCM_WR_SSRS0_SWAKEUP(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWAKEUP(value)))
#define RCM_BWR_SSRS0_SWAKEUP(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SWAKEUP_SHIFT), RCM_SSRS0_SWAKEUP_SHIFT, RCM_SSRS0_SWAKEUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0b0 - Reset not caused by LVD trip or POR
 * - 0b1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLVD field. */
#define RCM_RD_SSRS0_SLVD(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLVD_MASK) >> RCM_SSRS0_SLVD_SHIFT)
#define RCM_BRD_SSRS0_SLVD(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLVD_SHIFT, RCM_SSRS0_SLVD_WIDTH))

/*! @brief Set the SLVD field to a new value. */
#define RCM_WR_SSRS0_SLVD(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLVD(value)))
#define RCM_BWR_SSRS0_SLVD(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SLVD_SHIFT), RCM_SSRS0_SLVD_SHIFT, RCM_SSRS0_SLVD_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLOC[2] (W1C)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of external clock.
 * - 0b1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLOC field. */
#define RCM_RD_SSRS0_SLOC(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLOC_MASK) >> RCM_SSRS0_SLOC_SHIFT)
#define RCM_BRD_SSRS0_SLOC(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOC_SHIFT, RCM_SSRS0_SLOC_WIDTH))

/*! @brief Set the SLOC field to a new value. */
#define RCM_WR_SSRS0_SLOC(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLOC(value)))
#define RCM_BWR_SSRS0_SLOC(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SLOC_SHIFT), RCM_SSRS0_SLOC_SHIFT, RCM_SSRS0_SLOC_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLOL[3] (W1C)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0b0 - Reset not caused by a loss of lock in the PLL
 * - 0b1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLOL field. */
#define RCM_RD_SSRS0_SLOL(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLOL_MASK) >> RCM_SSRS0_SLOL_SHIFT)
#define RCM_BRD_SSRS0_SLOL(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOL_SHIFT, RCM_SSRS0_SLOL_WIDTH))

/*! @brief Set the SLOL field to a new value. */
#define RCM_WR_SSRS0_SLOL(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLOL(value)))
#define RCM_BWR_SSRS0_SLOL(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SLOL_SHIFT), RCM_SSRS0_SLOL_SHIFT, RCM_SSRS0_SLOL_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0b0 - Reset not caused by watchdog timeout
 * - 0b1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWDOG field. */
#define RCM_RD_SSRS0_SWDOG(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWDOG_MASK) >> RCM_SSRS0_SWDOG_SHIFT)
#define RCM_BRD_SSRS0_SWDOG(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWDOG_SHIFT, RCM_SSRS0_SWDOG_WIDTH))

/*! @brief Set the SWDOG field to a new value. */
#define RCM_WR_SSRS0_SWDOG(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWDOG(value)))
#define RCM_BWR_SSRS0_SWDOG(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SWDOG_SHIFT), RCM_SSRS0_SWDOG_SHIFT, RCM_SSRS0_SWDOG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0b0 - Reset not caused by external reset pin
 * - 0b1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPIN field. */
#define RCM_RD_SSRS0_SPIN(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPIN_MASK) >> RCM_SSRS0_SPIN_SHIFT)
#define RCM_BRD_SSRS0_SPIN(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPIN_SHIFT, RCM_SSRS0_SPIN_WIDTH))

/*! @brief Set the SPIN field to a new value. */
#define RCM_WR_SSRS0_SPIN(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SPIN(value)))
#define RCM_BWR_SSRS0_SPIN(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SPIN_SHIFT), RCM_SSRS0_SPIN_SHIFT, RCM_SSRS0_SPIN_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0b0 - Reset not caused by POR
 * - 0b1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPOR field. */
#define RCM_RD_SSRS0_SPOR(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPOR_MASK) >> RCM_SSRS0_SPOR_SHIFT)
#define RCM_BRD_SSRS0_SPOR(base) (BME_UBFX8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPOR_SHIFT, RCM_SSRS0_SPOR_WIDTH))

/*! @brief Set the SPOR field to a new value. */
#define RCM_WR_SSRS0_SPOR(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPOR_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK), RCM_SSRS0_SPOR(value)))
#define RCM_BWR_SSRS0_SPOR(base, value) (BME_BFI8(&RCM_SSRS0_REG(base), ((uint8_t)(value) << RCM_SSRS0_SPOR_SHIFT), RCM_SSRS0_SPOR_SHIFT, RCM_SSRS0_SPOR_WIDTH))
/*@}*/

/*******************************************************************************
 * RCM_SSRS1 - Sticky System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SSRS1 - Sticky System Reset Status Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS1 register
 */
/*@{*/
#define RCM_RD_SSRS1(base)       (RCM_SSRS1_REG(base))
#define RCM_WR_SSRS1(base, value) (RCM_SSRS1_REG(base) = (value))
#define RCM_RMW_SSRS1(base, mask, value) (RCM_WR_SSRS1(base, (RCM_RD_SSRS1(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS1(base, value) (BME_OR8(&RCM_SSRS1_REG(base), (uint8_t)(value)))
#define RCM_CLR_SSRS1(base, value) (BME_AND8(&RCM_SSRS1_REG(base), (uint8_t)(~(value))))
#define RCM_TOG_SSRS1(base, value) (BME_XOR8(&RCM_SSRS1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS1 bitfields
 */

/*!
 * @name Register RCM_SSRS1, field SJTAG[0] (W1C)
 *
 * Indicates a reset has been caused by JTAG selection of certain IR codes:
 * EXTEST, HIGHZ, and CLAMP.
 *
 * Values:
 * - 0b0 - Reset not caused by JTAG
 * - 0b1 - Reset caused by JTAG
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SJTAG field. */
#define RCM_RD_SSRS1_SJTAG(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SJTAG_MASK) >> RCM_SSRS1_SJTAG_SHIFT)
#define RCM_BRD_SSRS1_SJTAG(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SJTAG_SHIFT, RCM_SSRS1_SJTAG_WIDTH))

/*! @brief Set the SJTAG field to a new value. */
#define RCM_WR_SSRS1_SJTAG(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SJTAG(value)))
#define RCM_BWR_SSRS1_SJTAG(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SJTAG_SHIFT), RCM_SSRS1_SJTAG_SHIFT, RCM_SSRS1_SJTAG_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SLOCKUP[1] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0b0 - Reset not caused by core LOCKUP event
 * - 0b1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SLOCKUP field. */
#define RCM_RD_SSRS1_SLOCKUP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SLOCKUP_MASK) >> RCM_SSRS1_SLOCKUP_SHIFT)
#define RCM_BRD_SSRS1_SLOCKUP(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SLOCKUP_SHIFT, RCM_SSRS1_SLOCKUP_WIDTH))

/*! @brief Set the SLOCKUP field to a new value. */
#define RCM_WR_SSRS1_SLOCKUP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SLOCKUP(value)))
#define RCM_BWR_SSRS1_SLOCKUP(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SLOCKUP_SHIFT), RCM_SSRS1_SLOCKUP_SHIFT, RCM_SSRS1_SLOCKUP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSW[2] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0b0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 0b1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSW field. */
#define RCM_RD_SSRS1_SSW(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSW_MASK) >> RCM_SSRS1_SSW_SHIFT)
#define RCM_BRD_SSRS1_SSW(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSW_SHIFT, RCM_SSRS1_SSW_WIDTH))

/*! @brief Set the SSW field to a new value. */
#define RCM_WR_SSRS1_SSW(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSW_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SSW(value)))
#define RCM_BWR_SSRS1_SSW(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SSW_SHIFT), RCM_SSRS1_SSW_SHIFT, RCM_SSRS1_SSW_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SMDM_AP[3] (W1C)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0b0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 0b1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SMDM_AP field. */
#define RCM_RD_SSRS1_SMDM_AP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SMDM_AP_MASK) >> RCM_SSRS1_SMDM_AP_SHIFT)
#define RCM_BRD_SSRS1_SMDM_AP(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SMDM_AP_SHIFT, RCM_SSRS1_SMDM_AP_WIDTH))

/*! @brief Set the SMDM_AP field to a new value. */
#define RCM_WR_SSRS1_SMDM_AP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SMDM_AP(value)))
#define RCM_BWR_SSRS1_SMDM_AP(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SMDM_AP_SHIFT), RCM_SSRS1_SMDM_AP_SHIFT, RCM_SSRS1_SMDM_AP_WIDTH))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSACKERR[5] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0b0 - Reset not caused by peripheral failure to acknowledge attempt to
 *     enter stop mode
 * - 0b1 - Reset caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSACKERR field. */
#define RCM_RD_SSRS1_SSACKERR(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSACKERR_MASK) >> RCM_SSRS1_SSACKERR_SHIFT)
#define RCM_BRD_SSRS1_SSACKERR(base) (BME_UBFX8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSACKERR_SHIFT, RCM_SSRS1_SSACKERR_WIDTH))

/*! @brief Set the SSACKERR field to a new value. */
#define RCM_WR_SSRS1_SSACKERR(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSACKERR_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK), RCM_SSRS1_SSACKERR(value)))
#define RCM_BWR_SSRS1_SSACKERR(base, value) (BME_BFI8(&RCM_SSRS1_REG(base), ((uint8_t)(value) << RCM_SSRS1_SSACKERR_SHIFT), RCM_SSRS1_SSACKERR_SHIFT, RCM_SSRS1_SSACKERR_WIDTH))
/*@}*/

/*
 * MKV58F24 RFSYS
 *
 * System register file
 *
 * Registers defined in this header file:
 * - RFSYS_REG - Register file register
 */

#define RFSYS_INSTANCE_COUNT (1U) /*!< Number of instances of the RFSYS module. */
#define RFSYS_IDX (0U) /*!< Instance number for RFSYS. */

/*******************************************************************************
 * RFSYS_REG - Register file register
 ******************************************************************************/

/*!
 * @brief RFSYS_REG - Register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFSYS_REG register
 */
/*@{*/
#define RFSYS_RD_REG(base, index) (RFSYS_REG_REG(base, index))
#define RFSYS_WR_REG(base, index, value) (RFSYS_REG_REG(base, index) = (value))
#define RFSYS_RMW_REG(base, index, mask, value) (RFSYS_WR_REG(base, index, (RFSYS_RD_REG(base, index) & ~(mask)) | (value)))
#define RFSYS_SET_REG(base, index, value) (BME_OR32(&RFSYS_REG_REG(base, index), (uint32_t)(value)))
#define RFSYS_CLR_REG(base, index, value) (BME_AND32(&RFSYS_REG_REG(base, index), (uint32_t)(~(value))))
#define RFSYS_TOG_REG(base, index, value) (BME_XOR32(&RFSYS_REG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RFSYS_REG bitfields
 */

/*!
 * @name Register RFSYS_REG, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LL field. */
#define RFSYS_RD_REG_LL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LL_MASK) >> RFSYS_REG_LL_SHIFT)
#define RFSYS_BRD_REG_LL(base, index) (BME_UBFX32(&RFSYS_REG_REG(base, index), RFSYS_REG_LL_SHIFT, RFSYS_REG_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define RFSYS_WR_REG_LL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LL_MASK, RFSYS_REG_LL(value)))
#define RFSYS_BWR_REG_LL(base, index, value) (BME_BFI32(&RFSYS_REG_REG(base, index), ((uint32_t)(value) << RFSYS_REG_LL_SHIFT), RFSYS_REG_LL_SHIFT, RFSYS_REG_LL_WIDTH))
/*@}*/

/*!
 * @name Register RFSYS_REG, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LH field. */
#define RFSYS_RD_REG_LH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LH_MASK) >> RFSYS_REG_LH_SHIFT)
#define RFSYS_BRD_REG_LH(base, index) (BME_UBFX32(&RFSYS_REG_REG(base, index), RFSYS_REG_LH_SHIFT, RFSYS_REG_LH_WIDTH))

/*! @brief Set the LH field to a new value. */
#define RFSYS_WR_REG_LH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LH_MASK, RFSYS_REG_LH(value)))
#define RFSYS_BWR_REG_LH(base, index, value) (BME_BFI32(&RFSYS_REG_REG(base, index), ((uint32_t)(value) << RFSYS_REG_LH_SHIFT), RFSYS_REG_LH_SHIFT, RFSYS_REG_LH_WIDTH))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HL field. */
#define RFSYS_RD_REG_HL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HL_MASK) >> RFSYS_REG_HL_SHIFT)
#define RFSYS_BRD_REG_HL(base, index) (BME_UBFX32(&RFSYS_REG_REG(base, index), RFSYS_REG_HL_SHIFT, RFSYS_REG_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define RFSYS_WR_REG_HL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HL_MASK, RFSYS_REG_HL(value)))
#define RFSYS_BWR_REG_HL(base, index, value) (BME_BFI32(&RFSYS_REG_REG(base, index), ((uint32_t)(value) << RFSYS_REG_HL_SHIFT), RFSYS_REG_HL_SHIFT, RFSYS_REG_HL_WIDTH))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HH field. */
#define RFSYS_RD_REG_HH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HH_MASK) >> RFSYS_REG_HH_SHIFT)
#define RFSYS_BRD_REG_HH(base, index) (BME_UBFX32(&RFSYS_REG_REG(base, index), RFSYS_REG_HH_SHIFT, RFSYS_REG_HH_WIDTH))

/*! @brief Set the HH field to a new value. */
#define RFSYS_WR_REG_HH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HH_MASK, RFSYS_REG_HH(value)))
#define RFSYS_BWR_REG_HH(base, index, value) (BME_BFI32(&RFSYS_REG_REG(base, index), ((uint32_t)(value) << RFSYS_REG_HH_SHIFT), RFSYS_REG_HH_SHIFT, RFSYS_REG_HH_WIDTH))
/*@}*/

/*
 * MKV58F24 RFVBAT
 *
 * VBAT register file
 *
 * Registers defined in this header file:
 * - RFVBAT_REG - VBAT register file register
 */

#define RFVBAT_INSTANCE_COUNT (1U) /*!< Number of instances of the RFVBAT module. */
#define RFVBAT_IDX (0U) /*!< Instance number for RFVBAT. */

/*******************************************************************************
 * RFVBAT_REG - VBAT register file register
 ******************************************************************************/

/*!
 * @brief RFVBAT_REG - VBAT register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFVBAT_REG register
 */
/*@{*/
#define RFVBAT_RD_REG(base, index) (RFVBAT_REG_REG(base, index))
#define RFVBAT_WR_REG(base, index, value) (RFVBAT_REG_REG(base, index) = (value))
#define RFVBAT_RMW_REG(base, index, mask, value) (RFVBAT_WR_REG(base, index, (RFVBAT_RD_REG(base, index) & ~(mask)) | (value)))
#define RFVBAT_SET_REG(base, index, value) (BME_OR32(&RFVBAT_REG_REG(base, index), (uint32_t)(value)))
#define RFVBAT_CLR_REG(base, index, value) (BME_AND32(&RFVBAT_REG_REG(base, index), (uint32_t)(~(value))))
#define RFVBAT_TOG_REG(base, index, value) (BME_XOR32(&RFVBAT_REG_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual RFVBAT_REG bitfields
 */

/*!
 * @name Register RFVBAT_REG, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LL field. */
#define RFVBAT_RD_REG_LL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LL_MASK) >> RFVBAT_REG_LL_SHIFT)
#define RFVBAT_BRD_REG_LL(base, index) (BME_UBFX32(&RFVBAT_REG_REG(base, index), RFVBAT_REG_LL_SHIFT, RFVBAT_REG_LL_WIDTH))

/*! @brief Set the LL field to a new value. */
#define RFVBAT_WR_REG_LL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LL_MASK, RFVBAT_REG_LL(value)))
#define RFVBAT_BWR_REG_LL(base, index, value) (BME_BFI32(&RFVBAT_REG_REG(base, index), ((uint32_t)(value) << RFVBAT_REG_LL_SHIFT), RFVBAT_REG_LL_SHIFT, RFVBAT_REG_LL_WIDTH))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LH field. */
#define RFVBAT_RD_REG_LH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LH_MASK) >> RFVBAT_REG_LH_SHIFT)
#define RFVBAT_BRD_REG_LH(base, index) (BME_UBFX32(&RFVBAT_REG_REG(base, index), RFVBAT_REG_LH_SHIFT, RFVBAT_REG_LH_WIDTH))

/*! @brief Set the LH field to a new value. */
#define RFVBAT_WR_REG_LH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LH_MASK, RFVBAT_REG_LH(value)))
#define RFVBAT_BWR_REG_LH(base, index, value) (BME_BFI32(&RFVBAT_REG_REG(base, index), ((uint32_t)(value) << RFVBAT_REG_LH_SHIFT), RFVBAT_REG_LH_SHIFT, RFVBAT_REG_LH_WIDTH))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HL field. */
#define RFVBAT_RD_REG_HL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HL_MASK) >> RFVBAT_REG_HL_SHIFT)
#define RFVBAT_BRD_REG_HL(base, index) (BME_UBFX32(&RFVBAT_REG_REG(base, index), RFVBAT_REG_HL_SHIFT, RFVBAT_REG_HL_WIDTH))

/*! @brief Set the HL field to a new value. */
#define RFVBAT_WR_REG_HL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HL_MASK, RFVBAT_REG_HL(value)))
#define RFVBAT_BWR_REG_HL(base, index, value) (BME_BFI32(&RFVBAT_REG_REG(base, index), ((uint32_t)(value) << RFVBAT_REG_HL_SHIFT), RFVBAT_REG_HL_SHIFT, RFVBAT_REG_HL_WIDTH))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HH field. */
#define RFVBAT_RD_REG_HH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HH_MASK) >> RFVBAT_REG_HH_SHIFT)
#define RFVBAT_BRD_REG_HH(base, index) (BME_UBFX32(&RFVBAT_REG_REG(base, index), RFVBAT_REG_HH_SHIFT, RFVBAT_REG_HH_WIDTH))

/*! @brief Set the HH field to a new value. */
#define RFVBAT_WR_REG_HH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HH_MASK, RFVBAT_REG_HH(value)))
#define RFVBAT_BWR_REG_HH(base, index, value) (BME_BFI32(&RFVBAT_REG_REG(base, index), ((uint32_t)(value) << RFVBAT_REG_HH_SHIFT), RFVBAT_REG_HH_SHIFT, RFVBAT_REG_HH_WIDTH))
/*@}*/

/*
 * MKV58F24 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT2 - System Options Register 2
 * - SIM_SOPT4 - System Options Register 4
 * - SIM_SOPT5 - System Options Register 5
 * - SIM_SOPT7 - System Options Register 7
 * - SIM_SOPT8 - System Options Register 8
 * - SIM_SOPT9 - System Options Register 9
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC1 - System Clock Gating Control Register 1
 * - SIM_SCGC2 - System Clock Gating Control Register 2
 * - SIM_SCGC3 - System Clock Gating Control Register 3
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDH - Unique Identification Register High
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_CLKDIV4 - System Clock Divider Register 4
 * - SIM_MISCTRL0 - Miscellaneous Control Register 0
 * - SIM_MISCTRL1 - Miscellaneous Control Register 1
 * - SIM_WDOGC - WDOG Control Register
 * - SIM_PWRC - Power Control Register
 * - SIM_ADCOPT - ADC Additional Option Register
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (BME_OR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT1(base, value) (BME_AND32(&SIM_SOPT1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT1(base, value) (BME_XOR32(&SIM_SOPT1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field RAMSIZE[15:12] (RO)
 *
 * This field specifies the amount of system RAM available on the device.
 *
 * Values:
 * - 0b0001 - Reserved
 * - 0b0011 - Reserved
 * - 0b0100 - Reserved
 * - 0b0101 - Reserved
 * - 0b0110 - Reserved
 * - 0b0111 - Reserved
 * - 0b1000 - Reserved
 * - 0b1001 - 128 KB
 * - 0b1011 - 256 KB
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_RAMSIZE field. */
#define SIM_RD_SOPT1_RAMSIZE(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_RAMSIZE_MASK) >> SIM_SOPT1_RAMSIZE_SHIFT)
#define SIM_BRD_SOPT1_RAMSIZE(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_RAMSIZE_SHIFT, SIM_SOPT1_RAMSIZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for LPTMR. This field is reset
 * only on POR/LVD.
 *
 * Values:
 * - 0b00 - System oscillator (OSC32KCLK)
 * - 0b01 - Reserved
 * - 0b10 - Reserved
 * - 0b11 - LPO 1 kHz
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (BME_UBFX32(&SIM_SOPT1_REG(base), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (BME_BFI32(&SIM_SOPT1_REG(base), ((uint32_t)(value) << SIM_SOPT1_OSC32KSEL_SHIFT), SIM_SOPT1_OSC32KSEL_SHIFT, SIM_SOPT1_OSC32KSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00001000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define SIM_RD_SOPT2(base)       (SIM_SOPT2_REG(base))
#define SIM_WR_SOPT2(base, value) (SIM_SOPT2_REG(base) = (value))
#define SIM_RMW_SOPT2(base, mask, value) (SIM_WR_SOPT2(base, (SIM_RD_SOPT2(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT2(base, value) (BME_OR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT2(base, value) (BME_AND32(&SIM_SOPT2_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT2(base, value) (BME_XOR32(&SIM_SOPT2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 0b000 - FlexBus CLKOUT
 * - 0b001 - Reserved
 * - 0b010 - Flash clock
 * - 0b011 - LPO clock (1 kHz)
 * - 0b100 - MCGIRCLK
 * - 0b101 - OSCERCLK_UNDIV
 * - 0b110 - OSCERCLK
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define SIM_RD_SOPT2_CLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_CLKOUTSEL_MASK) >> SIM_SOPT2_CLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_CLKOUTSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_CLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_CLKOUTSEL_MASK, SIM_SOPT2_CLKOUTSEL(value)))
#define SIM_BWR_SOPT2_CLKOUTSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_CLKOUTSEL_SHIFT), SIM_SOPT2_CLKOUTSEL_SHIFT, SIM_SOPT2_CLKOUTSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field FBSL[9:8] (RW)
 *
 * If flash security is enabled, then this field affects what CPU operations can
 * access off-chip via the FlexBus interface. This field has no effect if flash
 * security is not enabled.
 *
 * Values:
 * - 0b00 - All off-chip accesses (instruction and data) via the FlexBus are
 *     disallowed.
 * - 0b01 - All off-chip accesses (instruction and data) via the FlexBus are
 *     disallowed.
 * - 0b10 - Off-chip instruction accesses are disallowed. Data accesses are
 *     allowed.
 * - 0b11 - Off-chip instruction accesses and data accesses are allowed.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_FBSL field. */
#define SIM_RD_SOPT2_FBSL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_FBSL_MASK) >> SIM_SOPT2_FBSL_SHIFT)
#define SIM_BRD_SOPT2_FBSL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_FBSL_SHIFT, SIM_SOPT2_FBSL_WIDTH))

/*! @brief Set the FBSL field to a new value. */
#define SIM_WR_SOPT2_FBSL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_FBSL_MASK, SIM_SOPT2_FBSL(value)))
#define SIM_BWR_SOPT2_FBSL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_FBSL_SHIFT), SIM_SOPT2_FBSL_SHIFT, SIM_SOPT2_FBSL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TRACECLKSEL[12] (RW)
 *
 * Selects the core/system clock or MCG output clock (MCGOUTCLK) as the trace
 * clock source.
 *
 * Values:
 * - 0b0 - MCGOUTCLK
 * - 0b1 - Core/system clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TRACECLKSEL field. */
#define SIM_RD_SOPT2_TRACECLKSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TRACECLKSEL_MASK) >> SIM_SOPT2_TRACECLKSEL_SHIFT)
#define SIM_BRD_SOPT2_TRACECLKSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_TRACECLKSEL_SHIFT, SIM_SOPT2_TRACECLKSEL_WIDTH))

/*! @brief Set the TRACECLKSEL field to a new value. */
#define SIM_WR_SOPT2_TRACECLKSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TRACECLKSEL_MASK, SIM_SOPT2_TRACECLKSEL(value)))
#define SIM_BWR_SOPT2_TRACECLKSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_TRACECLKSEL_SHIFT), SIM_SOPT2_TRACECLKSEL_SHIFT, SIM_SOPT2_TRACECLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PLLFLLSEL[17:16] (RW)
 *
 * Selects the high frequency clock for ethernet clocking options.
 *
 * Values:
 * - 0b00 - MCGFLLCLK clock
 * - 0b01 - MCGPLLCLK clock
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_PLLFLLSEL field. */
#define SIM_RD_SOPT2_PLLFLLSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHIFT)
#define SIM_BRD_SOPT2_PLLFLLSEL(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_PLLFLLSEL_SHIFT, SIM_SOPT2_PLLFLLSEL_WIDTH))

/*! @brief Set the PLLFLLSEL field to a new value. */
#define SIM_WR_SOPT2_PLLFLLSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_PLLFLLSEL_MASK, SIM_SOPT2_PLLFLLSEL(value)))
#define SIM_BWR_SOPT2_PLLFLLSEL(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_PLLFLLSEL_SHIFT), SIM_SOPT2_PLLFLLSEL_SHIFT, SIM_SOPT2_PLLFLLSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field RMIISRC[19] (RW)
 *
 * Selects the clock source for the Ethernet RMII interface
 *
 * Values:
 * - 0b0 - EXTAL clock
 * - 0b1 - External bypass clock (ENET_1588_CLKIN).
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_RMIISRC field. */
#define SIM_RD_SOPT2_RMIISRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_RMIISRC_MASK) >> SIM_SOPT2_RMIISRC_SHIFT)
#define SIM_BRD_SOPT2_RMIISRC(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_RMIISRC_SHIFT, SIM_SOPT2_RMIISRC_WIDTH))

/*! @brief Set the RMIISRC field to a new value. */
#define SIM_WR_SOPT2_RMIISRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_RMIISRC_MASK, SIM_SOPT2_RMIISRC(value)))
#define SIM_BWR_SOPT2_RMIISRC(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_RMIISRC_SHIFT), SIM_SOPT2_RMIISRC_SHIFT, SIM_SOPT2_RMIISRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TIMESRC[21:20] (RW)
 *
 * Selects the clock source for the Ethernet timestamp clock.
 *
 * Values:
 * - 0b00 - Core/system clock
 * - 0b01 - MCGFLLCLK , or MCGPLLCLK as selected by SOPT2[PLLFLLSEL].
 * - 0b10 - OSCERCLK clock
 * - 0b11 - External bypass clock (ENET_1588_CLKIN)
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TIMESRC field. */
#define SIM_RD_SOPT2_TIMESRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TIMESRC_MASK) >> SIM_SOPT2_TIMESRC_SHIFT)
#define SIM_BRD_SOPT2_TIMESRC(base) (BME_UBFX32(&SIM_SOPT2_REG(base), SIM_SOPT2_TIMESRC_SHIFT, SIM_SOPT2_TIMESRC_WIDTH))

/*! @brief Set the TIMESRC field to a new value. */
#define SIM_WR_SOPT2_TIMESRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TIMESRC_MASK, SIM_SOPT2_TIMESRC(value)))
#define SIM_BWR_SOPT2_TIMESRC(base, value) (BME_BFI32(&SIM_SOPT2_REG(base), ((uint32_t)(value) << SIM_SOPT2_TIMESRC_SHIFT), SIM_SOPT2_TIMESRC_SHIFT, SIM_SOPT2_TIMESRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT4 - System Options Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SOPT4 - System Options Register 4 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT4 register
 */
/*@{*/
#define SIM_RD_SOPT4(base)       (SIM_SOPT4_REG(base))
#define SIM_WR_SOPT4(base, value) (SIM_SOPT4_REG(base) = (value))
#define SIM_RMW_SOPT4(base, mask, value) (SIM_WR_SOPT4(base, (SIM_RD_SOPT4(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT4(base, value) (BME_OR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT4(base, value) (BME_AND32(&SIM_SOPT4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT4(base, value) (BME_XOR32(&SIM_SOPT4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT4 bitfields
 */

/*!
 * @name Register SIM_SOPT4, field FTM0FLT0[0] (RW)
 *
 * Selects the source of FTM0 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM0_FLT0 pin
 * - 0b1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT0 field. */
#define SIM_RD_SOPT4_FTM0FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT0_MASK) >> SIM_SOPT4_FTM0FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT0_SHIFT, SIM_SOPT4_FTM0FLT0_WIDTH))

/*! @brief Set the FTM0FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT0_MASK, SIM_SOPT4_FTM0FLT0(value)))
#define SIM_BWR_SOPT4_FTM0FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT0_SHIFT), SIM_SOPT4_FTM0FLT0_SHIFT, SIM_SOPT4_FTM0FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT1[1] (RW)
 *
 * Selects the source of FTM0 fault 1. The pin source for fault 1 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM0_FLT1 pin
 * - 0b1 - CMP1 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT1 field. */
#define SIM_RD_SOPT4_FTM0FLT1(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT1_MASK) >> SIM_SOPT4_FTM0FLT1_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT1(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT1_SHIFT, SIM_SOPT4_FTM0FLT1_WIDTH))

/*! @brief Set the FTM0FLT1 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT1(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT1_MASK, SIM_SOPT4_FTM0FLT1(value)))
#define SIM_BWR_SOPT4_FTM0FLT1(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT1_SHIFT), SIM_SOPT4_FTM0FLT1_SHIFT, SIM_SOPT4_FTM0FLT1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT2[2] (RW)
 *
 * Selects the source of FTM0 fault 2. The pin source for fault 2 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM0_FLT2 pin
 * - 0b1 - CMP2 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT2 field. */
#define SIM_RD_SOPT4_FTM0FLT2(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT2_MASK) >> SIM_SOPT4_FTM0FLT2_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT2(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT2_SHIFT, SIM_SOPT4_FTM0FLT2_WIDTH))

/*! @brief Set the FTM0FLT2 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT2(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT2_MASK, SIM_SOPT4_FTM0FLT2(value)))
#define SIM_BWR_SOPT4_FTM0FLT2(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT2_SHIFT), SIM_SOPT4_FTM0FLT2_SHIFT, SIM_SOPT4_FTM0FLT2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0FLT3[3] (RW)
 *
 * Selects the source of FTM0 fault 3. The pin source for fault 3 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM0_FLT3 pin
 * - 0b1 - XBARA output 49
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0FLT3 field. */
#define SIM_RD_SOPT4_FTM0FLT3(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0FLT3_MASK) >> SIM_SOPT4_FTM0FLT3_SHIFT)
#define SIM_BRD_SOPT4_FTM0FLT3(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0FLT3_SHIFT, SIM_SOPT4_FTM0FLT3_WIDTH))

/*! @brief Set the FTM0FLT3 field to a new value. */
#define SIM_WR_SOPT4_FTM0FLT3(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0FLT3_MASK, SIM_SOPT4_FTM0FLT3(value)))
#define SIM_BWR_SOPT4_FTM0FLT3(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0FLT3_SHIFT), SIM_SOPT4_FTM0FLT3_SHIFT, SIM_SOPT4_FTM0FLT3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1FLT0[4] (RW)
 *
 * Selects the source of FTM1 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM1_FLT0 pin
 * - 0b1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1FLT0 field. */
#define SIM_RD_SOPT4_FTM1FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1FLT0_MASK) >> SIM_SOPT4_FTM1FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM1FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1FLT0_SHIFT, SIM_SOPT4_FTM1FLT0_WIDTH))

/*! @brief Set the FTM1FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM1FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1FLT0_MASK, SIM_SOPT4_FTM1FLT0(value)))
#define SIM_BWR_SOPT4_FTM1FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1FLT0_SHIFT), SIM_SOPT4_FTM1FLT0_SHIFT, SIM_SOPT4_FTM1FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2FLT0[8] (RW)
 *
 * Selects the source of FTM2 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM2_FLT0 pin
 * - 0b1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2FLT0 field. */
#define SIM_RD_SOPT4_FTM2FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2FLT0_MASK) >> SIM_SOPT4_FTM2FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM2FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2FLT0_SHIFT, SIM_SOPT4_FTM2FLT0_WIDTH))

/*! @brief Set the FTM2FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM2FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2FLT0_MASK, SIM_SOPT4_FTM2FLT0(value)))
#define SIM_BWR_SOPT4_FTM2FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2FLT0_SHIFT), SIM_SOPT4_FTM2FLT0_SHIFT, SIM_SOPT4_FTM2FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3FLT0[12] (RW)
 *
 * Selects the source of FTM3 fault 0. The pin source for fault 0 must be
 * configured for the FTM module fault function through the appropriate pin control
 * register in the port control module.
 *
 * Values:
 * - 0b0 - FTM3_FLT0 pin
 * - 0b1 - CMP0 out
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM3FLT0 field. */
#define SIM_RD_SOPT4_FTM3FLT0(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM3FLT0_MASK) >> SIM_SOPT4_FTM3FLT0_SHIFT)
#define SIM_BRD_SOPT4_FTM3FLT0(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM3FLT0_SHIFT, SIM_SOPT4_FTM3FLT0_WIDTH))

/*! @brief Set the FTM3FLT0 field to a new value. */
#define SIM_WR_SOPT4_FTM3FLT0(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM3FLT0_MASK, SIM_SOPT4_FTM3FLT0(value)))
#define SIM_BWR_SOPT4_FTM3FLT0(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM3FLT0_SHIFT), SIM_SOPT4_FTM3FLT0_SHIFT, SIM_SOPT4_FTM3FLT0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG0SRC[16] (RW)
 *
 * Selects the source of FTM0 hardware trigger 0. Also in parallel
 * SIM_OPT8[FTM0_SYNCBIT] will be fed to FTM0 Hardware Trigger 0.
 *
 * Values:
 * - 0b0 - CMP0 output drives FTM0 hardware trigger 0
 * - 0b1 - FTM1 channel match drives FTM0 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG0SRC field. */
#define SIM_RD_SOPT4_FTM0TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG0SRC_MASK) >> SIM_SOPT4_FTM0TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG0SRC_SHIFT, SIM_SOPT4_FTM0TRG0SRC_WIDTH))

/*! @brief Set the FTM0TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG0SRC_MASK, SIM_SOPT4_FTM0TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG0SRC_SHIFT), SIM_SOPT4_FTM0TRG0SRC_SHIFT, SIM_SOPT4_FTM0TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG1SRC[17] (RW)
 *
 * Selects the source of FTM0 hardware trigger 1.
 *
 * Values:
 * - 0b0 - PDB0 channel 1 output trigger drives FTM0 hardware trigger 1
 * - 0b1 - FTM1 channel match drives FTM0 hardware trigger 1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG1SRC field. */
#define SIM_RD_SOPT4_FTM0TRG1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG1SRC_MASK) >> SIM_SOPT4_FTM0TRG1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG1SRC_SHIFT, SIM_SOPT4_FTM0TRG1SRC_WIDTH))

/*! @brief Set the FTM0TRG1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG1SRC_MASK, SIM_SOPT4_FTM0TRG1SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG1SRC_SHIFT), SIM_SOPT4_FTM0TRG1SRC_SHIFT, SIM_SOPT4_FTM0TRG1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM0TRG2SRC[18] (RW)
 *
 * Selects the source of FTM0 hardware trigger 2.
 *
 * Values:
 * - 0b0 - FTM0_FLT0 pin drives FTM0 hardware trigger 2
 * - 0b1 - XBARA output 34 drives FTM0 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM0TRG2SRC field. */
#define SIM_RD_SOPT4_FTM0TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM0TRG2SRC_MASK) >> SIM_SOPT4_FTM0TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM0TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM0TRG2SRC_SHIFT, SIM_SOPT4_FTM0TRG2SRC_WIDTH))

/*! @brief Set the FTM0TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM0TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM0TRG2SRC_MASK, SIM_SOPT4_FTM0TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM0TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM0TRG2SRC_SHIFT), SIM_SOPT4_FTM0TRG2SRC_SHIFT, SIM_SOPT4_FTM0TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1TRG0SRC[20] (RW)
 *
 * Selects the source of FTM1 hardware trigger 0. Also in parallel
 * SIM_OPT8[FTM1_SYNCBIT] will be fed to FTM1 Hardware Trigger 0.
 *
 * Values:
 * - 0b0 - CMP0 output drives FTM1 hardware trigger 0
 * - 0b1 - FTM0 channel match drives FTM1 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1TRG0SRC field. */
#define SIM_RD_SOPT4_FTM1TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1TRG0SRC_MASK) >> SIM_SOPT4_FTM1TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1TRG0SRC_SHIFT, SIM_SOPT4_FTM1TRG0SRC_WIDTH))

/*! @brief Set the FTM1TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1TRG0SRC_MASK, SIM_SOPT4_FTM1TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM1TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1TRG0SRC_SHIFT), SIM_SOPT4_FTM1TRG0SRC_SHIFT, SIM_SOPT4_FTM1TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM1TRG2SRC[22] (RW)
 *
 * Selects the source of FTM1 hardware trigger 2.
 *
 * Values:
 * - 0b0 - FTM1_FLT0 pin drives FTM1 hardware trigger 2
 * - 0b1 - XBARA output 35 drives FTM1 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM1TRG2SRC field. */
#define SIM_RD_SOPT4_FTM1TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM1TRG2SRC_MASK) >> SIM_SOPT4_FTM1TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM1TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM1TRG2SRC_SHIFT, SIM_SOPT4_FTM1TRG2SRC_WIDTH))

/*! @brief Set the FTM1TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM1TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM1TRG2SRC_MASK, SIM_SOPT4_FTM1TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM1TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM1TRG2SRC_SHIFT), SIM_SOPT4_FTM1TRG2SRC_SHIFT, SIM_SOPT4_FTM1TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2TRG0SRC[24] (RW)
 *
 * Selects the source of FTM2 hardware trigger 0. Also in parallel
 * SIM_OPT8[FTM2_SYNCBIT] will be fed to FTM2 Hardware Trigger 0.
 *
 * Values:
 * - 0b0 - CMP0 output drives FTM2 hardware trigger 0
 * - 0b1 - FTM0 channel match drives FTM2 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2TRG0SRC field. */
#define SIM_RD_SOPT4_FTM2TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2TRG0SRC_MASK) >> SIM_SOPT4_FTM2TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2TRG0SRC_SHIFT, SIM_SOPT4_FTM2TRG0SRC_WIDTH))

/*! @brief Set the FTM2TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2TRG0SRC_MASK, SIM_SOPT4_FTM2TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM2TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2TRG0SRC_SHIFT), SIM_SOPT4_FTM2TRG0SRC_SHIFT, SIM_SOPT4_FTM2TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM2TRG2SRC[26] (RW)
 *
 * Selects the source of FTM2 hardware trigger 2.
 *
 * Values:
 * - 0b0 - FTM2_FLT0 pin drives FTM2 hardware trigger 2
 * - 0b1 - XBARA output 36 drives FTM2 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM2TRG2SRC field. */
#define SIM_RD_SOPT4_FTM2TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM2TRG2SRC_MASK) >> SIM_SOPT4_FTM2TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM2TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM2TRG2SRC_SHIFT, SIM_SOPT4_FTM2TRG2SRC_WIDTH))

/*! @brief Set the FTM2TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM2TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM2TRG2SRC_MASK, SIM_SOPT4_FTM2TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM2TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM2TRG2SRC_SHIFT), SIM_SOPT4_FTM2TRG2SRC_SHIFT, SIM_SOPT4_FTM2TRG2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3TRG0SRC[28] (RW)
 *
 * Selects the source of FTM3 hardware trigger 0. Also in parallel
 * SIM_OPT8[FTM3_SYNCBIT] will be fed to FTM3 Hardware Trigger 0.
 *
 * Values:
 * - 0b0 - CMP0 output drives FTM3 hardware trigger 0
 * - 0b1 - FTM1 channel match drives FTM3 hardware trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM3TRG0SRC field. */
#define SIM_RD_SOPT4_FTM3TRG0SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM3TRG0SRC_MASK) >> SIM_SOPT4_FTM3TRG0SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM3TRG0SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM3TRG0SRC_SHIFT, SIM_SOPT4_FTM3TRG0SRC_WIDTH))

/*! @brief Set the FTM3TRG0SRC field to a new value. */
#define SIM_WR_SOPT4_FTM3TRG0SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM3TRG0SRC_MASK, SIM_SOPT4_FTM3TRG0SRC(value)))
#define SIM_BWR_SOPT4_FTM3TRG0SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM3TRG0SRC_SHIFT), SIM_SOPT4_FTM3TRG0SRC_SHIFT, SIM_SOPT4_FTM3TRG0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3TRG1SRC[29] (RW)
 *
 * Selects the source of FTM3 hardware trigger 1.
 *
 * Values:
 * - 0b0 - PDB1 channel 1 output trigger drives FTM3 hardware trigger 1
 * - 0b1 - FTM1 channel match drives FTM3 hardware trigger 1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM3TRG1SRC field. */
#define SIM_RD_SOPT4_FTM3TRG1SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM3TRG1SRC_MASK) >> SIM_SOPT4_FTM3TRG1SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM3TRG1SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM3TRG1SRC_SHIFT, SIM_SOPT4_FTM3TRG1SRC_WIDTH))

/*! @brief Set the FTM3TRG1SRC field to a new value. */
#define SIM_WR_SOPT4_FTM3TRG1SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM3TRG1SRC_MASK, SIM_SOPT4_FTM3TRG1SRC(value)))
#define SIM_BWR_SOPT4_FTM3TRG1SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM3TRG1SRC_SHIFT), SIM_SOPT4_FTM3TRG1SRC_SHIFT, SIM_SOPT4_FTM3TRG1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT4, field FTM3TRG2SRC[30] (RW)
 *
 * Selects the source of FTM3 hardware trigger 2.
 *
 * Values:
 * - 0b0 - FTM3_FLT0 pin drives FTM3 hardware trigger 2
 * - 0b1 - XBARA output 37 drives FTM3 hardware trigger 2
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT4_FTM3TRG2SRC field. */
#define SIM_RD_SOPT4_FTM3TRG2SRC(base) ((SIM_SOPT4_REG(base) & SIM_SOPT4_FTM3TRG2SRC_MASK) >> SIM_SOPT4_FTM3TRG2SRC_SHIFT)
#define SIM_BRD_SOPT4_FTM3TRG2SRC(base) (BME_UBFX32(&SIM_SOPT4_REG(base), SIM_SOPT4_FTM3TRG2SRC_SHIFT, SIM_SOPT4_FTM3TRG2SRC_WIDTH))

/*! @brief Set the FTM3TRG2SRC field to a new value. */
#define SIM_WR_SOPT4_FTM3TRG2SRC(base, value) (SIM_RMW_SOPT4(base, SIM_SOPT4_FTM3TRG2SRC_MASK, SIM_SOPT4_FTM3TRG2SRC(value)))
#define SIM_BWR_SOPT4_FTM3TRG2SRC(base, value) (BME_BFI32(&SIM_SOPT4_REG(base), ((uint32_t)(value) << SIM_SOPT4_FTM3TRG2SRC_SHIFT), SIM_SOPT4_FTM3TRG2SRC_SHIFT, SIM_SOPT4_FTM3TRG2SRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define SIM_RD_SOPT5(base)       (SIM_SOPT5_REG(base))
#define SIM_WR_SOPT5(base, value) (SIM_SOPT5_REG(base) = (value))
#define SIM_RMW_SOPT5(base, mask, value) (SIM_WR_SOPT5(base, (SIM_RD_SOPT5(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT5(base, value) (BME_OR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT5(base, value) (BME_AND32(&SIM_SOPT5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT5(base, value) (BME_XOR32(&SIM_SOPT5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field UART0TXSRC[1:0] (RW)
 *
 * Selects the source for the UART 0 transmit data.
 *
 * Values:
 * - 0b00 - UART0_TX pin
 * - 0b01 - UART0_TX pin modulated with FTM1 channel 0 output
 * - 0b10 - UART0_TX pin modulated with FTM2 channel 0 output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0TXSRC field. */
#define SIM_RD_SOPT5_UART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0TXSRC_MASK) >> SIM_SOPT5_UART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0TXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0TXSRC_SHIFT, SIM_SOPT5_UART0TXSRC_WIDTH))

/*! @brief Set the UART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0TXSRC_MASK, SIM_SOPT5_UART0TXSRC(value)))
#define SIM_BWR_SOPT5_UART0TXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART0TXSRC_SHIFT), SIM_SOPT5_UART0TXSRC_SHIFT, SIM_SOPT5_UART0TXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0RXSRC[3:2] (RW)
 *
 * Selects the source for the UART 0 receive data.
 *
 * Values:
 * - 0b00 - UART0_RX pin
 * - 0b01 - CMP0
 * - 0b10 - CMP1
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0RXSRC field. */
#define SIM_RD_SOPT5_UART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0RXSRC_MASK) >> SIM_SOPT5_UART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0RXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART0RXSRC_SHIFT, SIM_SOPT5_UART0RXSRC_WIDTH))

/*! @brief Set the UART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0RXSRC_MASK, SIM_SOPT5_UART0RXSRC(value)))
#define SIM_BWR_SOPT5_UART0RXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART0RXSRC_SHIFT), SIM_SOPT5_UART0RXSRC_SHIFT, SIM_SOPT5_UART0RXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1TXSRC[5:4] (RW)
 *
 * Selects the source for the UART 1 transmit data.
 *
 * Values:
 * - 0b00 - UART1_TX pin
 * - 0b01 - UART1_TX pin modulated with FTM1 channel 0 output
 * - 0b10 - UART1_TX pin modulated with FTM2 channel 0 output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1TXSRC field. */
#define SIM_RD_SOPT5_UART1TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1TXSRC_MASK) >> SIM_SOPT5_UART1TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1TXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1TXSRC_SHIFT, SIM_SOPT5_UART1TXSRC_WIDTH))

/*! @brief Set the UART1TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1TXSRC_MASK, SIM_SOPT5_UART1TXSRC(value)))
#define SIM_BWR_SOPT5_UART1TXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART1TXSRC_SHIFT), SIM_SOPT5_UART1TXSRC_SHIFT, SIM_SOPT5_UART1TXSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1RXSRC[7:6] (RW)
 *
 * Selects the source for the UART 1 receive data.
 *
 * Values:
 * - 0b00 - UART1_RX pin
 * - 0b01 - CMP0
 * - 0b10 - CMP1
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1RXSRC field. */
#define SIM_RD_SOPT5_UART1RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1RXSRC_MASK) >> SIM_SOPT5_UART1RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1RXSRC(base) (BME_UBFX32(&SIM_SOPT5_REG(base), SIM_SOPT5_UART1RXSRC_SHIFT, SIM_SOPT5_UART1RXSRC_WIDTH))

/*! @brief Set the UART1RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1RXSRC_MASK, SIM_SOPT5_UART1RXSRC(value)))
#define SIM_BWR_SOPT5_UART1RXSRC(base, value) (BME_BFI32(&SIM_SOPT5_REG(base), ((uint32_t)(value) << SIM_SOPT5_UART1RXSRC_SHIFT), SIM_SOPT5_UART1RXSRC_SHIFT, SIM_SOPT5_UART1RXSRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define SIM_RD_SOPT7(base)       (SIM_SOPT7_REG(base))
#define SIM_WR_SOPT7(base, value) (SIM_SOPT7_REG(base) = (value))
#define SIM_RMW_SOPT7(base, mask, value) (SIM_WR_SOPT7(base, (SIM_RD_SOPT7(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT7(base, value) (BME_OR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT7(base, value) (BME_AND32(&SIM_SOPT7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT7(base, value) (BME_XOR32(&SIM_SOPT7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field HSADC0ATRGSEL[3:0] (RW)
 *
 * Selects the HSADC0A trigger source when alternative triggers are functional
 * in stop modes.
 *
 * Values:
 * - 0b0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0b0001 - High speed comparator 0 output
 * - 0b0010 - High speed comparator 1 output
 * - 0b0011 - High speed comparator 2 output
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - PIT trigger 2
 * - 0b0111 - PIT trigger 3
 * - 0b1000 - FTM0 trigger
 * - 0b1001 - FTM1 trigger
 * - 0b1010 - FTM2 trigger
 * - 0b1011 - FTM3 trigger
 * - 0b1100 - XBARA output 38
 * - 0b1101 - Reserved
 * - 0b1110 - Low-power timer trigger
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC0ATRGSEL field. */
#define SIM_RD_SOPT7_HSADC0ATRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC0ATRGSEL_MASK) >> SIM_SOPT7_HSADC0ATRGSEL_SHIFT)
#define SIM_BRD_SOPT7_HSADC0ATRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC0ATRGSEL_SHIFT, SIM_SOPT7_HSADC0ATRGSEL_WIDTH))

/*! @brief Set the HSADC0ATRGSEL field to a new value. */
#define SIM_WR_SOPT7_HSADC0ATRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC0ATRGSEL_MASK, SIM_SOPT7_HSADC0ATRGSEL(value)))
#define SIM_BWR_SOPT7_HSADC0ATRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC0ATRGSEL_SHIFT), SIM_SOPT7_HSADC0ATRGSEL_SHIFT, SIM_SOPT7_HSADC0ATRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC0AALTTRGEN[7:6] (RW)
 *
 * Enable alternative conversion triggers for HSADC0A.
 *
 * Values:
 * - 0b00 - XBARA output 12.
 * - 0b01 - PDB0 channel0 trigger selected for HSADC0A.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC0AALTTRGEN field. */
#define SIM_RD_SOPT7_HSADC0AALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC0AALTTRGEN_MASK) >> SIM_SOPT7_HSADC0AALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_HSADC0AALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC0AALTTRGEN_SHIFT, SIM_SOPT7_HSADC0AALTTRGEN_WIDTH))

/*! @brief Set the HSADC0AALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_HSADC0AALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC0AALTTRGEN_MASK, SIM_SOPT7_HSADC0AALTTRGEN(value)))
#define SIM_BWR_SOPT7_HSADC0AALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC0AALTTRGEN_SHIFT), SIM_SOPT7_HSADC0AALTTRGEN_SHIFT, SIM_SOPT7_HSADC0AALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC0BTRGSEL[11:8] (RW)
 *
 * Selects the HSADC0B trigger source when alternative triggers are functional
 * in stop modes.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - High speed comparator 0 output
 * - 0b0010 - High speed comparator 1 output
 * - 0b0011 - High speed comparator 2 output
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - PIT trigger 2
 * - 0b0111 - PIT trigger 3
 * - 0b1000 - FTM0 trigger
 * - 0b1001 - FTM1 trigger
 * - 0b1010 - FTM2 trigger
 * - 0b1011 - FTM3 trigger
 * - 0b1100 - XBARA output 41
 * - 0b1101 - Reserved
 * - 0b1110 - Low-power timer trigger
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC0BTRGSEL field. */
#define SIM_RD_SOPT7_HSADC0BTRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC0BTRGSEL_MASK) >> SIM_SOPT7_HSADC0BTRGSEL_SHIFT)
#define SIM_BRD_SOPT7_HSADC0BTRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC0BTRGSEL_SHIFT, SIM_SOPT7_HSADC0BTRGSEL_WIDTH))

/*! @brief Set the HSADC0BTRGSEL field to a new value. */
#define SIM_WR_SOPT7_HSADC0BTRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC0BTRGSEL_MASK, SIM_SOPT7_HSADC0BTRGSEL(value)))
#define SIM_BWR_SOPT7_HSADC0BTRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC0BTRGSEL_SHIFT), SIM_SOPT7_HSADC0BTRGSEL_SHIFT, SIM_SOPT7_HSADC0BTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC0BALTTRGEN[15:14] (RW)
 *
 * Enable alternative conversion triggers for HSADC0B.
 *
 * Values:
 * - 0b00 - XBARA output 13.
 * - 0b01 - PDB1 channel0 trigger selected for HSADC0B
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC0BALTTRGEN field. */
#define SIM_RD_SOPT7_HSADC0BALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC0BALTTRGEN_MASK) >> SIM_SOPT7_HSADC0BALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_HSADC0BALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC0BALTTRGEN_SHIFT, SIM_SOPT7_HSADC0BALTTRGEN_WIDTH))

/*! @brief Set the HSADC0BALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_HSADC0BALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC0BALTTRGEN_MASK, SIM_SOPT7_HSADC0BALTTRGEN(value)))
#define SIM_BWR_SOPT7_HSADC0BALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC0BALTTRGEN_SHIFT), SIM_SOPT7_HSADC0BALTTRGEN_SHIFT, SIM_SOPT7_HSADC0BALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC1ATRGSEL[19:16] (RW)
 *
 * Selects the HSADC1A trigger source when alternative triggers are functional
 * in stop modes.
 *
 * Values:
 * - 0b0000 - Reserved
 * - 0b0001 - High speed comparator 0 output
 * - 0b0010 - High speed comparator 1 output
 * - 0b0011 - High speed comparator 2 output
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - PIT trigger 2
 * - 0b0111 - PIT trigger 3
 * - 0b1000 - FTM0 trigger
 * - 0b1001 - FTM1 trigger
 * - 0b1010 - FTM2 trigger
 * - 0b1011 - FTM3 trigger
 * - 0b1100 - XBARA output 41
 * - 0b1101 - Reserved
 * - 0b1110 - Low-power timer trigger
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC1ATRGSEL field. */
#define SIM_RD_SOPT7_HSADC1ATRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC1ATRGSEL_MASK) >> SIM_SOPT7_HSADC1ATRGSEL_SHIFT)
#define SIM_BRD_SOPT7_HSADC1ATRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC1ATRGSEL_SHIFT, SIM_SOPT7_HSADC1ATRGSEL_WIDTH))

/*! @brief Set the HSADC1ATRGSEL field to a new value. */
#define SIM_WR_SOPT7_HSADC1ATRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC1ATRGSEL_MASK, SIM_SOPT7_HSADC1ATRGSEL(value)))
#define SIM_BWR_SOPT7_HSADC1ATRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC1ATRGSEL_SHIFT), SIM_SOPT7_HSADC1ATRGSEL_SHIFT, SIM_SOPT7_HSADC1ATRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC1AALTTRGEN[23:22] (RW)
 *
 * Enable alternative conversion triggers for SYNCA input of HSADC1A.
 *
 * Values:
 * - 0b00 - XBARA output 42.
 * - 0b01 - PDB1 channel 1 trigger selected for HSADC1A.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC1AALTTRGEN field. */
#define SIM_RD_SOPT7_HSADC1AALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC1AALTTRGEN_MASK) >> SIM_SOPT7_HSADC1AALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_HSADC1AALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC1AALTTRGEN_SHIFT, SIM_SOPT7_HSADC1AALTTRGEN_WIDTH))

/*! @brief Set the HSADC1AALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_HSADC1AALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC1AALTTRGEN_MASK, SIM_SOPT7_HSADC1AALTTRGEN(value)))
#define SIM_BWR_SOPT7_HSADC1AALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC1AALTTRGEN_SHIFT), SIM_SOPT7_HSADC1AALTTRGEN_SHIFT, SIM_SOPT7_HSADC1AALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC1BTRGSEL[27:24] (RW)
 *
 * Selects the HSADC1B trigger source when alternative triggers are functional
 * in stop modes.
 *
 * Values:
 * - 0b0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0b0001 - High speed comparator 0 output
 * - 0b0010 - High speed comparator 1 output
 * - 0b0011 - High speed comparator 2 output
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - PIT trigger 2
 * - 0b0111 - PIT trigger 3
 * - 0b1000 - FTM0 trigger
 * - 0b1001 - FTM1 trigger
 * - 0b1010 - FTM2 trigger
 * - 0b1011 - FTM3 trigger
 * - 0b1100 - XBARA output 38
 * - 0b1101 - Reserved
 * - 0b1110 - Low-power timer trigger
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC1BTRGSEL field. */
#define SIM_RD_SOPT7_HSADC1BTRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC1BTRGSEL_MASK) >> SIM_SOPT7_HSADC1BTRGSEL_SHIFT)
#define SIM_BRD_SOPT7_HSADC1BTRGSEL(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC1BTRGSEL_SHIFT, SIM_SOPT7_HSADC1BTRGSEL_WIDTH))

/*! @brief Set the HSADC1BTRGSEL field to a new value. */
#define SIM_WR_SOPT7_HSADC1BTRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC1BTRGSEL_MASK, SIM_SOPT7_HSADC1BTRGSEL(value)))
#define SIM_BWR_SOPT7_HSADC1BTRGSEL(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC1BTRGSEL_SHIFT), SIM_SOPT7_HSADC1BTRGSEL_SHIFT, SIM_SOPT7_HSADC1BTRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field HSADC1BALTTRGEN[31:30] (RW)
 *
 * Enable alternative conversion triggers for SYNCB input for triggering HSADC1B
 * conversions.
 *
 * Values:
 * - 0b00 - XBARA output 43.
 * - 0b01 - PDB0 channel 1 trigger selected for HSADC1B
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_HSADC1BALTTRGEN field. */
#define SIM_RD_SOPT7_HSADC1BALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_HSADC1BALTTRGEN_MASK) >> SIM_SOPT7_HSADC1BALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_HSADC1BALTTRGEN(base) (BME_UBFX32(&SIM_SOPT7_REG(base), SIM_SOPT7_HSADC1BALTTRGEN_SHIFT, SIM_SOPT7_HSADC1BALTTRGEN_WIDTH))

/*! @brief Set the HSADC1BALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_HSADC1BALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_HSADC1BALTTRGEN_MASK, SIM_SOPT7_HSADC1BALTTRGEN(value)))
#define SIM_BWR_SOPT7_HSADC1BALTTRGEN(base, value) (BME_BFI32(&SIM_SOPT7_REG(base), ((uint32_t)(value) << SIM_SOPT7_HSADC1BALTTRGEN_SHIFT), SIM_SOPT7_HSADC1BALTTRGEN_SHIFT, SIM_SOPT7_HSADC1BALTTRGEN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT8 - System Options Register 8
 ******************************************************************************/

/*!
 * @brief SIM_SOPT8 - System Options Register 8 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT8 register
 */
/*@{*/
#define SIM_RD_SOPT8(base)       (SIM_SOPT8_REG(base))
#define SIM_WR_SOPT8(base, value) (SIM_SOPT8_REG(base) = (value))
#define SIM_RMW_SOPT8(base, mask, value) (SIM_WR_SOPT8(base, (SIM_RD_SOPT8(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT8(base, value) (BME_OR32(&SIM_SOPT8_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT8(base, value) (BME_AND32(&SIM_SOPT8_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT8(base, value) (BME_XOR32(&SIM_SOPT8_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT8 bitfields
 */

/*!
 * @name Register SIM_SOPT8, field FTM0SYNCBIT[0] (RW)
 *
 * Values:
 * - 0b0 - No effect
 * - 0b1 - Write 1 to assert the TRIG0 input to FTM0, software must clear this
 *     bit to allow other trigger sources to assert.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0SYNCBIT field. */
#define SIM_RD_SOPT8_FTM0SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0SYNCBIT_MASK) >> SIM_SOPT8_FTM0SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM0SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0SYNCBIT_SHIFT, SIM_SOPT8_FTM0SYNCBIT_WIDTH))

/*! @brief Set the FTM0SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM0SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0SYNCBIT_MASK, SIM_SOPT8_FTM0SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM0SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0SYNCBIT_SHIFT), SIM_SOPT8_FTM0SYNCBIT_SHIFT, SIM_SOPT8_FTM0SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM1SYNCBIT[1] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Write 1 to assert the TRIG0 input to FTM1, software must clear this
 *     bit to allow other trigger sources to assert.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM1SYNCBIT field. */
#define SIM_RD_SOPT8_FTM1SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM1SYNCBIT_MASK) >> SIM_SOPT8_FTM1SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM1SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM1SYNCBIT_SHIFT, SIM_SOPT8_FTM1SYNCBIT_WIDTH))

/*! @brief Set the FTM1SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM1SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM1SYNCBIT_MASK, SIM_SOPT8_FTM1SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM1SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM1SYNCBIT_SHIFT), SIM_SOPT8_FTM1SYNCBIT_SHIFT, SIM_SOPT8_FTM1SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM2SYNCBIT[2] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Write 1 to assert the TRIG0 input to FTM2, software must clear this
 *     bit to allow other trigger sources to assert.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM2SYNCBIT field. */
#define SIM_RD_SOPT8_FTM2SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM2SYNCBIT_MASK) >> SIM_SOPT8_FTM2SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM2SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM2SYNCBIT_SHIFT, SIM_SOPT8_FTM2SYNCBIT_WIDTH))

/*! @brief Set the FTM2SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM2SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM2SYNCBIT_MASK, SIM_SOPT8_FTM2SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM2SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM2SYNCBIT_SHIFT), SIM_SOPT8_FTM2SYNCBIT_SHIFT, SIM_SOPT8_FTM2SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3SYNCBIT[3] (RW)
 *
 * Values:
 * - 0b0 - No effect.
 * - 0b1 - Write 1 to assert the TRIG0 input to FTM3, software must clear this
 *     bit to allow other trigger sources to assert.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3SYNCBIT field. */
#define SIM_RD_SOPT8_FTM3SYNCBIT(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3SYNCBIT_MASK) >> SIM_SOPT8_FTM3SYNCBIT_SHIFT)
#define SIM_BRD_SOPT8_FTM3SYNCBIT(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3SYNCBIT_SHIFT, SIM_SOPT8_FTM3SYNCBIT_WIDTH))

/*! @brief Set the FTM3SYNCBIT field to a new value. */
#define SIM_WR_SOPT8_FTM3SYNCBIT(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3SYNCBIT_MASK, SIM_SOPT8_FTM3SYNCBIT(value)))
#define SIM_BWR_SOPT8_FTM3SYNCBIT(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3SYNCBIT_SHIFT), SIM_SOPT8_FTM3SYNCBIT_SHIFT, SIM_SOPT8_FTM3SYNCBIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0CFSEL[8] (RW)
 *
 * Values:
 * - 0b0 - FTM1 channel 1 output provides the carrier signal for FTM0 Timer
 *     Modulation mode.
 * - 0b1 - LPTMR0 prescaler output provides the carrier signal for FTM0 Timer
 *     Modulation mode.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0CFSEL field. */
#define SIM_RD_SOPT8_FTM0CFSEL(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0CFSEL_MASK) >> SIM_SOPT8_FTM0CFSEL_SHIFT)
#define SIM_BRD_SOPT8_FTM0CFSEL(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0CFSEL_SHIFT, SIM_SOPT8_FTM0CFSEL_WIDTH))

/*! @brief Set the FTM0CFSEL field to a new value. */
#define SIM_WR_SOPT8_FTM0CFSEL(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0CFSEL_MASK, SIM_SOPT8_FTM0CFSEL(value)))
#define SIM_BWR_SOPT8_FTM0CFSEL(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0CFSEL_SHIFT), SIM_SOPT8_FTM0CFSEL_SHIFT, SIM_SOPT8_FTM0CFSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3CFSEL[9] (RW)
 *
 * Values:
 * - 0b0 - FTM1 channel 1 output provides the carrier signal for FTM3 Timer
 *     Modulation mode.
 * - 0b1 - LPTMR0 prescaler output provides the carrier signal for FTM3 Timer
 *     Modulation mode.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3CFSEL field. */
#define SIM_RD_SOPT8_FTM3CFSEL(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3CFSEL_MASK) >> SIM_SOPT8_FTM3CFSEL_SHIFT)
#define SIM_BRD_SOPT8_FTM3CFSEL(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3CFSEL_SHIFT, SIM_SOPT8_FTM3CFSEL_WIDTH))

/*! @brief Set the FTM3CFSEL field to a new value. */
#define SIM_WR_SOPT8_FTM3CFSEL(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3CFSEL_MASK, SIM_SOPT8_FTM3CFSEL(value)))
#define SIM_BWR_SOPT8_FTM3CFSEL(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3CFSEL_SHIFT), SIM_SOPT8_FTM3CFSEL_SHIFT, SIM_SOPT8_FTM3CFSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH0SRC[16] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH0 pin is output of FTM0 channel 0 output
 * - 0b1 - FTM0_CH0 pin is output of FTM0 channel 0 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH0SRC field. */
#define SIM_RD_SOPT8_FTM0OCH0SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH0SRC_MASK) >> SIM_SOPT8_FTM0OCH0SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH0SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH0SRC_SHIFT, SIM_SOPT8_FTM0OCH0SRC_WIDTH))

/*! @brief Set the FTM0OCH0SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH0SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH0SRC_MASK, SIM_SOPT8_FTM0OCH0SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH0SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH0SRC_SHIFT), SIM_SOPT8_FTM0OCH0SRC_SHIFT, SIM_SOPT8_FTM0OCH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH1SRC[17] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH1 pin is output of FTM0 channel 1 output
 * - 0b1 - FTM0_CH1 pin is output of FTM0 channel 1 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH1SRC field. */
#define SIM_RD_SOPT8_FTM0OCH1SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH1SRC_MASK) >> SIM_SOPT8_FTM0OCH1SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH1SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH1SRC_SHIFT, SIM_SOPT8_FTM0OCH1SRC_WIDTH))

/*! @brief Set the FTM0OCH1SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH1SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH1SRC_MASK, SIM_SOPT8_FTM0OCH1SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH1SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH1SRC_SHIFT), SIM_SOPT8_FTM0OCH1SRC_SHIFT, SIM_SOPT8_FTM0OCH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH2SRC[18] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH2 pin is output of FTM0 channel 2 output
 * - 0b1 - FTM0_CH2 pin is output of FTM0 channel 2 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH2SRC field. */
#define SIM_RD_SOPT8_FTM0OCH2SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH2SRC_MASK) >> SIM_SOPT8_FTM0OCH2SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH2SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH2SRC_SHIFT, SIM_SOPT8_FTM0OCH2SRC_WIDTH))

/*! @brief Set the FTM0OCH2SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH2SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH2SRC_MASK, SIM_SOPT8_FTM0OCH2SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH2SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH2SRC_SHIFT), SIM_SOPT8_FTM0OCH2SRC_SHIFT, SIM_SOPT8_FTM0OCH2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH3SRC[19] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH3 pin is output of FTM0 channel 3 output
 * - 0b1 - FTM0_CH3 pin is output of FTM0 channel 3 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH3SRC field. */
#define SIM_RD_SOPT8_FTM0OCH3SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH3SRC_MASK) >> SIM_SOPT8_FTM0OCH3SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH3SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH3SRC_SHIFT, SIM_SOPT8_FTM0OCH3SRC_WIDTH))

/*! @brief Set the FTM0OCH3SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH3SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH3SRC_MASK, SIM_SOPT8_FTM0OCH3SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH3SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH3SRC_SHIFT), SIM_SOPT8_FTM0OCH3SRC_SHIFT, SIM_SOPT8_FTM0OCH3SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH4SRC[20] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH4 pin is output of FTM0 channel 4 output
 * - 0b1 - FTM0_CH4 pin is output of FTM0 channel 4 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH4SRC field. */
#define SIM_RD_SOPT8_FTM0OCH4SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH4SRC_MASK) >> SIM_SOPT8_FTM0OCH4SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH4SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH4SRC_SHIFT, SIM_SOPT8_FTM0OCH4SRC_WIDTH))

/*! @brief Set the FTM0OCH4SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH4SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH4SRC_MASK, SIM_SOPT8_FTM0OCH4SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH4SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH4SRC_SHIFT), SIM_SOPT8_FTM0OCH4SRC_SHIFT, SIM_SOPT8_FTM0OCH4SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH5SRC[21] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH5 pin is output of FTM0 channel 5 output
 * - 0b1 - FTM0_CH5 pin is output of FTM0 channel 5 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH5SRC field. */
#define SIM_RD_SOPT8_FTM0OCH5SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH5SRC_MASK) >> SIM_SOPT8_FTM0OCH5SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH5SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH5SRC_SHIFT, SIM_SOPT8_FTM0OCH5SRC_WIDTH))

/*! @brief Set the FTM0OCH5SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH5SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH5SRC_MASK, SIM_SOPT8_FTM0OCH5SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH5SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH5SRC_SHIFT), SIM_SOPT8_FTM0OCH5SRC_SHIFT, SIM_SOPT8_FTM0OCH5SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH6SRC[22] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH6 pin is output of FTM0 channel 6 output
 * - 0b1 - FTM0_CH6 pin is output of FTM0 channel 6 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH6SRC field. */
#define SIM_RD_SOPT8_FTM0OCH6SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH6SRC_MASK) >> SIM_SOPT8_FTM0OCH6SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH6SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH6SRC_SHIFT, SIM_SOPT8_FTM0OCH6SRC_WIDTH))

/*! @brief Set the FTM0OCH6SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH6SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH6SRC_MASK, SIM_SOPT8_FTM0OCH6SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH6SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH6SRC_SHIFT), SIM_SOPT8_FTM0OCH6SRC_SHIFT, SIM_SOPT8_FTM0OCH6SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM0OCH7SRC[23] (RW)
 *
 * Values:
 * - 0b0 - FTM0_CH7 pin is output of FTM0 channel 7 output
 * - 0b1 - FTM0_CH7 pin is output of FTM0 channel 7 output, modulated by carrier
 *     frequency clock, as per FTM0CFSEL
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM0OCH7SRC field. */
#define SIM_RD_SOPT8_FTM0OCH7SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM0OCH7SRC_MASK) >> SIM_SOPT8_FTM0OCH7SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM0OCH7SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM0OCH7SRC_SHIFT, SIM_SOPT8_FTM0OCH7SRC_WIDTH))

/*! @brief Set the FTM0OCH7SRC field to a new value. */
#define SIM_WR_SOPT8_FTM0OCH7SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM0OCH7SRC_MASK, SIM_SOPT8_FTM0OCH7SRC(value)))
#define SIM_BWR_SOPT8_FTM0OCH7SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM0OCH7SRC_SHIFT), SIM_SOPT8_FTM0OCH7SRC_SHIFT, SIM_SOPT8_FTM0OCH7SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH0SRC[24] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH0 pin is output of FTM3 channel 0 output
 * - 0b1 - FTM3_CH0 pin is output of FTM3 channel 0 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH0SRC field. */
#define SIM_RD_SOPT8_FTM3OCH0SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH0SRC_MASK) >> SIM_SOPT8_FTM3OCH0SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH0SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH0SRC_SHIFT, SIM_SOPT8_FTM3OCH0SRC_WIDTH))

/*! @brief Set the FTM3OCH0SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH0SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH0SRC_MASK, SIM_SOPT8_FTM3OCH0SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH0SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH0SRC_SHIFT), SIM_SOPT8_FTM3OCH0SRC_SHIFT, SIM_SOPT8_FTM3OCH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH1SRC[25] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH1 pin is output of FTM3 channel 1 output
 * - 0b1 - FTM3_CH1 pin is output of FTM3 channel 1 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH1SRC field. */
#define SIM_RD_SOPT8_FTM3OCH1SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH1SRC_MASK) >> SIM_SOPT8_FTM3OCH1SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH1SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH1SRC_SHIFT, SIM_SOPT8_FTM3OCH1SRC_WIDTH))

/*! @brief Set the FTM3OCH1SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH1SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH1SRC_MASK, SIM_SOPT8_FTM3OCH1SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH1SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH1SRC_SHIFT), SIM_SOPT8_FTM3OCH1SRC_SHIFT, SIM_SOPT8_FTM3OCH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH2SRC[26] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH2 pin is output of FTM3 channel 2 output
 * - 0b1 - FTM3_CH2 pin is output of FTM3 channel 2 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH2SRC field. */
#define SIM_RD_SOPT8_FTM3OCH2SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH2SRC_MASK) >> SIM_SOPT8_FTM3OCH2SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH2SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH2SRC_SHIFT, SIM_SOPT8_FTM3OCH2SRC_WIDTH))

/*! @brief Set the FTM3OCH2SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH2SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH2SRC_MASK, SIM_SOPT8_FTM3OCH2SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH2SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH2SRC_SHIFT), SIM_SOPT8_FTM3OCH2SRC_SHIFT, SIM_SOPT8_FTM3OCH2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH3SRC[27] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH3 pin is output of FTM3 channel 3 output
 * - 0b1 - FTM3_CH3 pin is output of FTM3 channel 3 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH3SRC field. */
#define SIM_RD_SOPT8_FTM3OCH3SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH3SRC_MASK) >> SIM_SOPT8_FTM3OCH3SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH3SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH3SRC_SHIFT, SIM_SOPT8_FTM3OCH3SRC_WIDTH))

/*! @brief Set the FTM3OCH3SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH3SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH3SRC_MASK, SIM_SOPT8_FTM3OCH3SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH3SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH3SRC_SHIFT), SIM_SOPT8_FTM3OCH3SRC_SHIFT, SIM_SOPT8_FTM3OCH3SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH4SRC[28] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH4 pin is output of FTM3 channel 4 output
 * - 0b1 - FTM3_CH4 pin is output of FTM3 channel 4 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH4SRC field. */
#define SIM_RD_SOPT8_FTM3OCH4SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH4SRC_MASK) >> SIM_SOPT8_FTM3OCH4SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH4SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH4SRC_SHIFT, SIM_SOPT8_FTM3OCH4SRC_WIDTH))

/*! @brief Set the FTM3OCH4SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH4SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH4SRC_MASK, SIM_SOPT8_FTM3OCH4SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH4SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH4SRC_SHIFT), SIM_SOPT8_FTM3OCH4SRC_SHIFT, SIM_SOPT8_FTM3OCH4SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH5SRC[29] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH5 pin is output of FTM3 channel 5 output
 * - 0b1 - FTM3_CH5 pin is output of FTM3 channel 5 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH5SRC field. */
#define SIM_RD_SOPT8_FTM3OCH5SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH5SRC_MASK) >> SIM_SOPT8_FTM3OCH5SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH5SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH5SRC_SHIFT, SIM_SOPT8_FTM3OCH5SRC_WIDTH))

/*! @brief Set the FTM3OCH5SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH5SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH5SRC_MASK, SIM_SOPT8_FTM3OCH5SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH5SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH5SRC_SHIFT), SIM_SOPT8_FTM3OCH5SRC_SHIFT, SIM_SOPT8_FTM3OCH5SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH6SRC[30] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH6 pin is output of FTM3 channel 6 output
 * - 0b1 - FTM3_CH6 pin is output of FTM3 channel 6 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH6SRC field. */
#define SIM_RD_SOPT8_FTM3OCH6SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH6SRC_MASK) >> SIM_SOPT8_FTM3OCH6SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH6SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH6SRC_SHIFT, SIM_SOPT8_FTM3OCH6SRC_WIDTH))

/*! @brief Set the FTM3OCH6SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH6SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH6SRC_MASK, SIM_SOPT8_FTM3OCH6SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH6SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH6SRC_SHIFT), SIM_SOPT8_FTM3OCH6SRC_SHIFT, SIM_SOPT8_FTM3OCH6SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT8, field FTM3OCH7SRC[31] (RW)
 *
 * Values:
 * - 0b0 - FTM3_CH7 pin is output of FTM3 channel 7 output
 * - 0b1 - FTM3_CH7 pin is output of FTM3 channel 7 output modulated by carrier
 *     frequency clock, as per FTM3CFSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT8_FTM3OCH7SRC field. */
#define SIM_RD_SOPT8_FTM3OCH7SRC(base) ((SIM_SOPT8_REG(base) & SIM_SOPT8_FTM3OCH7SRC_MASK) >> SIM_SOPT8_FTM3OCH7SRC_SHIFT)
#define SIM_BRD_SOPT8_FTM3OCH7SRC(base) (BME_UBFX32(&SIM_SOPT8_REG(base), SIM_SOPT8_FTM3OCH7SRC_SHIFT, SIM_SOPT8_FTM3OCH7SRC_WIDTH))

/*! @brief Set the FTM3OCH7SRC field to a new value. */
#define SIM_WR_SOPT8_FTM3OCH7SRC(base, value) (SIM_RMW_SOPT8(base, SIM_SOPT8_FTM3OCH7SRC_MASK, SIM_SOPT8_FTM3OCH7SRC(value)))
#define SIM_BWR_SOPT8_FTM3OCH7SRC(base, value) (BME_BFI32(&SIM_SOPT8_REG(base), ((uint32_t)(value) << SIM_SOPT8_FTM3OCH7SRC_SHIFT), SIM_SOPT8_FTM3OCH7SRC_SHIFT, SIM_SOPT8_FTM3OCH7SRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SOPT9 - System Options Register 9
 ******************************************************************************/

/*!
 * @brief SIM_SOPT9 - System Options Register 9 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT9 register
 */
/*@{*/
#define SIM_RD_SOPT9(base)       (SIM_SOPT9_REG(base))
#define SIM_WR_SOPT9(base, value) (SIM_SOPT9_REG(base) = (value))
#define SIM_RMW_SOPT9(base, mask, value) (SIM_WR_SOPT9(base, (SIM_RD_SOPT9(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT9(base, value) (BME_OR32(&SIM_SOPT9_REG(base), (uint32_t)(value)))
#define SIM_CLR_SOPT9(base, value) (BME_AND32(&SIM_SOPT9_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SOPT9(base, value) (BME_XOR32(&SIM_SOPT9_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT9 bitfields
 */

/*!
 * @name Register SIM_SOPT9, field FTM1ICH0SRC[5:4] (RW)
 *
 * Selects the source for FTM1 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b00 - FTM1_CH0 signal
 * - 0b01 - CMP0 output
 * - 0b10 - CMP1 output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM1ICH0SRC field. */
#define SIM_RD_SOPT9_FTM1ICH0SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM1ICH0SRC_MASK) >> SIM_SOPT9_FTM1ICH0SRC_SHIFT)
#define SIM_BRD_SOPT9_FTM1ICH0SRC(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM1ICH0SRC_SHIFT, SIM_SOPT9_FTM1ICH0SRC_WIDTH))

/*! @brief Set the FTM1ICH0SRC field to a new value. */
#define SIM_WR_SOPT9_FTM1ICH0SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM1ICH0SRC_MASK, SIM_SOPT9_FTM1ICH0SRC(value)))
#define SIM_BWR_SOPT9_FTM1ICH0SRC(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM1ICH0SRC_SHIFT), SIM_SOPT9_FTM1ICH0SRC_SHIFT, SIM_SOPT9_FTM1ICH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM1ICH1SRC[6] (RW)
 *
 * Selects the source for FTM1 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b0 - FTM1_CH1 signal
 * - 0b1 - Exclusive OR of FTM1_CH1, FTM1_CH0, and XBARA output 42 (XBARA output
 *     42 can also trigger HSADC1A sync0)
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM1ICH1SRC field. */
#define SIM_RD_SOPT9_FTM1ICH1SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM1ICH1SRC_MASK) >> SIM_SOPT9_FTM1ICH1SRC_SHIFT)
#define SIM_BRD_SOPT9_FTM1ICH1SRC(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM1ICH1SRC_SHIFT, SIM_SOPT9_FTM1ICH1SRC_WIDTH))

/*! @brief Set the FTM1ICH1SRC field to a new value. */
#define SIM_WR_SOPT9_FTM1ICH1SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM1ICH1SRC_MASK, SIM_SOPT9_FTM1ICH1SRC(value)))
#define SIM_BWR_SOPT9_FTM1ICH1SRC(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM1ICH1SRC_SHIFT), SIM_SOPT9_FTM1ICH1SRC_SHIFT, SIM_SOPT9_FTM1ICH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM2ICH0SRC[9:8] (RW)
 *
 * Selects the source for FTM2 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b00 - FTM2_CH0 signal
 * - 0b01 - CMP0 output
 * - 0b10 - CMP1 output
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM2ICH0SRC field. */
#define SIM_RD_SOPT9_FTM2ICH0SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM2ICH0SRC_MASK) >> SIM_SOPT9_FTM2ICH0SRC_SHIFT)
#define SIM_BRD_SOPT9_FTM2ICH0SRC(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM2ICH0SRC_SHIFT, SIM_SOPT9_FTM2ICH0SRC_WIDTH))

/*! @brief Set the FTM2ICH0SRC field to a new value. */
#define SIM_WR_SOPT9_FTM2ICH0SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM2ICH0SRC_MASK, SIM_SOPT9_FTM2ICH0SRC(value)))
#define SIM_BWR_SOPT9_FTM2ICH0SRC(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM2ICH0SRC_SHIFT), SIM_SOPT9_FTM2ICH0SRC_SHIFT, SIM_SOPT9_FTM2ICH0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM2ICH1SRC[10] (RW)
 *
 * Selects the source for FTM2 channel 0 input capture. When the FTM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 0b0 - FTM2_CH1 signal
 * - 0b1 - Exclusive OR of FTM2_CH1, FTM2_CH0 and FTM1_CH1
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM2ICH1SRC field. */
#define SIM_RD_SOPT9_FTM2ICH1SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM2ICH1SRC_MASK) >> SIM_SOPT9_FTM2ICH1SRC_SHIFT)
#define SIM_BRD_SOPT9_FTM2ICH1SRC(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM2ICH1SRC_SHIFT, SIM_SOPT9_FTM2ICH1SRC_WIDTH))

/*! @brief Set the FTM2ICH1SRC field to a new value. */
#define SIM_WR_SOPT9_FTM2ICH1SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM2ICH1SRC_MASK, SIM_SOPT9_FTM2ICH1SRC(value)))
#define SIM_BWR_SOPT9_FTM2ICH1SRC(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM2ICH1SRC_SHIFT), SIM_SOPT9_FTM2ICH1SRC_SHIFT, SIM_SOPT9_FTM2ICH1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM0CLKSEL[25:24] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM0 module. The
 * selected pin must also be configured for the FTM0 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b00 - FTM0 external clock driven by FTM_CLK0 pin
 * - 0b01 - FTM0 external clock driven by FTM_CLK1 pin
 * - 0b10 - FTM0 external clock driven by FTM_CLK2 pin
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM0CLKSEL field. */
#define SIM_RD_SOPT9_FTM0CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM0CLKSEL_MASK) >> SIM_SOPT9_FTM0CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_FTM0CLKSEL(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM0CLKSEL_SHIFT, SIM_SOPT9_FTM0CLKSEL_WIDTH))

/*! @brief Set the FTM0CLKSEL field to a new value. */
#define SIM_WR_SOPT9_FTM0CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM0CLKSEL_MASK, SIM_SOPT9_FTM0CLKSEL(value)))
#define SIM_BWR_SOPT9_FTM0CLKSEL(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM0CLKSEL_SHIFT), SIM_SOPT9_FTM0CLKSEL_SHIFT, SIM_SOPT9_FTM0CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM1CLKSEL[27:26] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM1 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b00 - FTM1 external clock driven by FTM_CLK0 pin
 * - 0b01 - FTM1 external clock driven by FTM_CLK1 pin
 * - 0b10 - FTM1 external clock driven by FTM_CLK2 pin
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM1CLKSEL field. */
#define SIM_RD_SOPT9_FTM1CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM1CLKSEL_MASK) >> SIM_SOPT9_FTM1CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_FTM1CLKSEL(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM1CLKSEL_SHIFT, SIM_SOPT9_FTM1CLKSEL_WIDTH))

/*! @brief Set the FTM1CLKSEL field to a new value. */
#define SIM_WR_SOPT9_FTM1CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM1CLKSEL_MASK, SIM_SOPT9_FTM1CLKSEL(value)))
#define SIM_BWR_SOPT9_FTM1CLKSEL(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM1CLKSEL_SHIFT), SIM_SOPT9_FTM1CLKSEL_SHIFT, SIM_SOPT9_FTM1CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM2CLKSEL[29:28] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM1 module. The
 * selected pin must also be configured for the FTM1 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b00 - FTM2 external clock driven by FTM_CLK0 pin
 * - 0b01 - FTM2 external clock driven by FTM_CLK1 pin
 * - 0b10 - FTM2 external clock driven by FTM_CLK2 pin
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM2CLKSEL field. */
#define SIM_RD_SOPT9_FTM2CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM2CLKSEL_MASK) >> SIM_SOPT9_FTM2CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_FTM2CLKSEL(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM2CLKSEL_SHIFT, SIM_SOPT9_FTM2CLKSEL_WIDTH))

/*! @brief Set the FTM2CLKSEL field to a new value. */
#define SIM_WR_SOPT9_FTM2CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM2CLKSEL_MASK, SIM_SOPT9_FTM2CLKSEL(value)))
#define SIM_BWR_SOPT9_FTM2CLKSEL(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM2CLKSEL_SHIFT), SIM_SOPT9_FTM2CLKSEL_SHIFT, SIM_SOPT9_FTM2CLKSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field FTM3CLKSEL[31:30] (RW)
 *
 * Selects the external pin used to drive the clock to the FTM3 module. The
 * selected pin must also be configured for the FTM3 module external clock function
 * through the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0b00 - FTM3 external clock driven by FTM_CLK0 pin
 * - 0b01 - FTM3 external clock driven by FTM_CLK1 pin
 * - 0b10 - FTM3 external clock driven by FTM_CLK2 pin
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_FTM3CLKSEL field. */
#define SIM_RD_SOPT9_FTM3CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_FTM3CLKSEL_MASK) >> SIM_SOPT9_FTM3CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_FTM3CLKSEL(base) (BME_UBFX32(&SIM_SOPT9_REG(base), SIM_SOPT9_FTM3CLKSEL_SHIFT, SIM_SOPT9_FTM3CLKSEL_WIDTH))

/*! @brief Set the FTM3CLKSEL field to a new value. */
#define SIM_WR_SOPT9_FTM3CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_FTM3CLKSEL_MASK, SIM_SOPT9_FTM3CLKSEL(value)))
#define SIM_BWR_SOPT9_FTM3CLKSEL(base, value) (BME_BFI32(&SIM_SOPT9_REG(base), ((uint32_t)(value) << SIM_SOPT9_FTM3CLKSEL_SHIFT), SIM_SOPT9_FTM3CLKSEL_SHIFT, SIM_SOPT9_FTM3CLKSEL_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00600180U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0b1000 - 100-pin
 * - 0b1001 - Reserved
 * - 0b1010 - 144-pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_PINID_SHIFT, SIM_SDID_PINID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon implementation number for the device.
 *
 * Values:
 * - 0b00011 - KV5x
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_DIEID_SHIFT, SIM_SDID_DIEID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_REVID_SHIFT, SIM_SDID_REVID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis series of the device.
 *
 * Values:
 * - 0b0110 - Kinetis V series
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SERIESID_SHIFT, SIM_SDID_SERIESID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0b0110 - KVx6 Subfamily (eFlexPWM with FlexTimer and HSADC)
 * - 0b0111 - Reserved
 * - 0b1000 - KVx8 Subfamily (eFlexPWM with FlexTimer, HSADC, and Ethernet)
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_SUBFAMID_SHIFT, SIM_SDID_SUBFAMID_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMILYID[31:28] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0b0101 - This is the KV5x series
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMILYID field. */
#define SIM_RD_SDID_FAMILYID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMILYID_MASK) >> SIM_SDID_FAMILYID_SHIFT)
#define SIM_BRD_SDID_FAMILYID(base) (BME_UBFX32(&SIM_SDID_REG(base), SIM_SDID_FAMILYID_SHIFT, SIM_SDID_FAMILYID_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC1 - System Clock Gating Control Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SCGC1 - System Clock Gating Control Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC1 register
 */
/*@{*/
#define SIM_RD_SCGC1(base)       (SIM_SCGC1_REG(base))
#define SIM_WR_SCGC1(base, value) (SIM_SCGC1_REG(base) = (value))
#define SIM_RMW_SCGC1(base, mask, value) (SIM_WR_SCGC1(base, (SIM_RD_SCGC1(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC1(base, value) (BME_OR32(&SIM_SCGC1_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC1(base, value) (BME_AND32(&SIM_SCGC1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC1(base, value) (BME_XOR32(&SIM_SCGC1_REG(base), (uint32_t)(value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC1_REG(base) + (((uint32_t)(index) >> 5) - 0U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BME_UBFX32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index), 1))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BME_BFI32(&SIM_SCGC_BIT_REG((base), (index)), ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)), SIM_SCGC_BIT_SHIFT(index), 1))

/*
 * Constants & macros for individual SIM_SCGC1 bitfields
 */

/*!
 * @name Register SIM_SCGC1, field UART4[10] (RW)
 *
 * This bit controls the clock gate to the UART4 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_UART4 field. */
#define SIM_RD_SCGC1_UART4(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_UART4_MASK) >> SIM_SCGC1_UART4_SHIFT)
#define SIM_BRD_SCGC1_UART4(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_UART4_SHIFT, SIM_SCGC1_UART4_WIDTH))

/*! @brief Set the UART4 field to a new value. */
#define SIM_WR_SCGC1_UART4(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_UART4_MASK, SIM_SCGC1_UART4(value)))
#define SIM_BWR_SCGC1_UART4(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_UART4_SHIFT), SIM_SCGC1_UART4_SHIFT, SIM_SCGC1_UART4_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field UART5[11] (RW)
 *
 * This bit controls the clock gate to the UART5 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_UART5 field. */
#define SIM_RD_SCGC1_UART5(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_UART5_MASK) >> SIM_SCGC1_UART5_SHIFT)
#define SIM_BRD_SCGC1_UART5(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_UART5_SHIFT, SIM_SCGC1_UART5_WIDTH))

/*! @brief Set the UART5 field to a new value. */
#define SIM_WR_SCGC1_UART5(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_UART5_MASK, SIM_SCGC1_UART5(value)))
#define SIM_BWR_SCGC1_UART5(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_UART5_SHIFT), SIM_SCGC1_UART5_SHIFT, SIM_SCGC1_UART5_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field PWM1_SM0[24] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 0.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_PWM1_SM0 field. */
#define SIM_RD_SCGC1_PWM1_SM0(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_PWM1_SM0_MASK) >> SIM_SCGC1_PWM1_SM0_SHIFT)
#define SIM_BRD_SCGC1_PWM1_SM0(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_PWM1_SM0_SHIFT, SIM_SCGC1_PWM1_SM0_WIDTH))

/*! @brief Set the PWM1_SM0 field to a new value. */
#define SIM_WR_SCGC1_PWM1_SM0(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_PWM1_SM0_MASK, SIM_SCGC1_PWM1_SM0(value)))
#define SIM_BWR_SCGC1_PWM1_SM0(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_PWM1_SM0_SHIFT), SIM_SCGC1_PWM1_SM0_SHIFT, SIM_SCGC1_PWM1_SM0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field PWM1_SM1[25] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 1.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_PWM1_SM1 field. */
#define SIM_RD_SCGC1_PWM1_SM1(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_PWM1_SM1_MASK) >> SIM_SCGC1_PWM1_SM1_SHIFT)
#define SIM_BRD_SCGC1_PWM1_SM1(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_PWM1_SM1_SHIFT, SIM_SCGC1_PWM1_SM1_WIDTH))

/*! @brief Set the PWM1_SM1 field to a new value. */
#define SIM_WR_SCGC1_PWM1_SM1(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_PWM1_SM1_MASK, SIM_SCGC1_PWM1_SM1(value)))
#define SIM_BWR_SCGC1_PWM1_SM1(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_PWM1_SM1_SHIFT), SIM_SCGC1_PWM1_SM1_SHIFT, SIM_SCGC1_PWM1_SM1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field PWM1_SM2[26] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 2.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_PWM1_SM2 field. */
#define SIM_RD_SCGC1_PWM1_SM2(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_PWM1_SM2_MASK) >> SIM_SCGC1_PWM1_SM2_SHIFT)
#define SIM_BRD_SCGC1_PWM1_SM2(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_PWM1_SM2_SHIFT, SIM_SCGC1_PWM1_SM2_WIDTH))

/*! @brief Set the PWM1_SM2 field to a new value. */
#define SIM_WR_SCGC1_PWM1_SM2(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_PWM1_SM2_MASK, SIM_SCGC1_PWM1_SM2(value)))
#define SIM_BWR_SCGC1_PWM1_SM2(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_PWM1_SM2_SHIFT), SIM_SCGC1_PWM1_SM2_SHIFT, SIM_SCGC1_PWM1_SM2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC1, field PWM1_SM3[27] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 3.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC1_PWM1_SM3 field. */
#define SIM_RD_SCGC1_PWM1_SM3(base) ((SIM_SCGC1_REG(base) & SIM_SCGC1_PWM1_SM3_MASK) >> SIM_SCGC1_PWM1_SM3_SHIFT)
#define SIM_BRD_SCGC1_PWM1_SM3(base) (BME_UBFX32(&SIM_SCGC1_REG(base), SIM_SCGC1_PWM1_SM3_SHIFT, SIM_SCGC1_PWM1_SM3_WIDTH))

/*! @brief Set the PWM1_SM3 field to a new value. */
#define SIM_WR_SCGC1_PWM1_SM3(base, value) (SIM_RMW_SCGC1(base, SIM_SCGC1_PWM1_SM3_MASK, SIM_SCGC1_PWM1_SM3(value)))
#define SIM_BWR_SCGC1_PWM1_SM3(base, value) (BME_BFI32(&SIM_SCGC1_REG(base), ((uint32_t)(value) << SIM_SCGC1_PWM1_SM3_SHIFT), SIM_SCGC1_PWM1_SM3_SHIFT, SIM_SCGC1_PWM1_SM3_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC2 - System Clock Gating Control Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SCGC2 - System Clock Gating Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC2 register
 */
/*@{*/
#define SIM_RD_SCGC2(base)       (SIM_SCGC2_REG(base))
#define SIM_WR_SCGC2(base, value) (SIM_SCGC2_REG(base) = (value))
#define SIM_RMW_SCGC2(base, mask, value) (SIM_WR_SCGC2(base, (SIM_RD_SCGC2(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC2(base, value) (BME_OR32(&SIM_SCGC2_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC2(base, value) (BME_AND32(&SIM_SCGC2_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC2(base, value) (BME_XOR32(&SIM_SCGC2_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC2 bitfields
 */

/*!
 * @name Register SIM_SCGC2, field ENET[0] (RW)
 *
 * This bit controls the clock gate to the ENET module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC2_ENET field. */
#define SIM_RD_SCGC2_ENET(base) ((SIM_SCGC2_REG(base) & SIM_SCGC2_ENET_MASK) >> SIM_SCGC2_ENET_SHIFT)
#define SIM_BRD_SCGC2_ENET(base) (BME_UBFX32(&SIM_SCGC2_REG(base), SIM_SCGC2_ENET_SHIFT, SIM_SCGC2_ENET_WIDTH))

/*! @brief Set the ENET field to a new value. */
#define SIM_WR_SCGC2_ENET(base, value) (SIM_RMW_SCGC2(base, SIM_SCGC2_ENET_MASK, SIM_SCGC2_ENET(value)))
#define SIM_BWR_SCGC2_ENET(base, value) (BME_BFI32(&SIM_SCGC2_REG(base), ((uint32_t)(value) << SIM_SCGC2_ENET_SHIFT), SIM_SCGC2_ENET_SHIFT, SIM_SCGC2_ENET_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC2, field HSADC1[28] (RW)
 *
 * This bit controls the clock gate to the HSADC1A and HSADC1B module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC2_HSADC1 field. */
#define SIM_RD_SCGC2_HSADC1(base) ((SIM_SCGC2_REG(base) & SIM_SCGC2_HSADC1_MASK) >> SIM_SCGC2_HSADC1_SHIFT)
#define SIM_BRD_SCGC2_HSADC1(base) (BME_UBFX32(&SIM_SCGC2_REG(base), SIM_SCGC2_HSADC1_SHIFT, SIM_SCGC2_HSADC1_WIDTH))

/*! @brief Set the HSADC1 field to a new value. */
#define SIM_WR_SCGC2_HSADC1(base, value) (SIM_RMW_SCGC2(base, SIM_SCGC2_HSADC1_MASK, SIM_SCGC2_HSADC1(value)))
#define SIM_BWR_SCGC2_HSADC1(base, value) (BME_BFI32(&SIM_SCGC2_REG(base), ((uint32_t)(value) << SIM_SCGC2_HSADC1_SHIFT), SIM_SCGC2_HSADC1_SHIFT, SIM_SCGC2_HSADC1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC3 - System Clock Gating Control Register 3
 ******************************************************************************/

/*!
 * @brief SIM_SCGC3 - System Clock Gating Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC3 register
 */
/*@{*/
#define SIM_RD_SCGC3(base)       (SIM_SCGC3_REG(base))
#define SIM_WR_SCGC3(base, value) (SIM_SCGC3_REG(base) = (value))
#define SIM_RMW_SCGC3(base, mask, value) (SIM_WR_SCGC3(base, (SIM_RD_SCGC3(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC3(base, value) (BME_OR32(&SIM_SCGC3_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC3(base, value) (BME_AND32(&SIM_SCGC3_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC3(base, value) (BME_XOR32(&SIM_SCGC3_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC3 bitfields
 */

/*!
 * @name Register SIM_SCGC3, field TRNG[0] (RW)
 *
 * This bit controls the clock gate to the TRNG module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC3_TRNG field. */
#define SIM_RD_SCGC3_TRNG(base) ((SIM_SCGC3_REG(base) & SIM_SCGC3_TRNG_MASK) >> SIM_SCGC3_TRNG_SHIFT)
#define SIM_BRD_SCGC3_TRNG(base) (BME_UBFX32(&SIM_SCGC3_REG(base), SIM_SCGC3_TRNG_SHIFT, SIM_SCGC3_TRNG_WIDTH))

/*! @brief Set the TRNG field to a new value. */
#define SIM_WR_SCGC3_TRNG(base, value) (SIM_RMW_SCGC3(base, SIM_SCGC3_TRNG_MASK, SIM_SCGC3_TRNG(value)))
#define SIM_BWR_SCGC3_TRNG(base, value) (BME_BFI32(&SIM_SCGC3_REG(base), ((uint32_t)(value) << SIM_SCGC3_TRNG_SHIFT), SIM_SCGC3_TRNG_SHIFT, SIM_SCGC3_TRNG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field FLEXCAN2[4] (RW)
 *
 * This bit controls the clock gate to the FlexCAN1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC3_FLEXCAN2 field. */
#define SIM_RD_SCGC3_FLEXCAN2(base) ((SIM_SCGC3_REG(base) & SIM_SCGC3_FLEXCAN2_MASK) >> SIM_SCGC3_FLEXCAN2_SHIFT)
#define SIM_BRD_SCGC3_FLEXCAN2(base) (BME_UBFX32(&SIM_SCGC3_REG(base), SIM_SCGC3_FLEXCAN2_SHIFT, SIM_SCGC3_FLEXCAN2_WIDTH))

/*! @brief Set the FLEXCAN2 field to a new value. */
#define SIM_WR_SCGC3_FLEXCAN2(base, value) (SIM_RMW_SCGC3(base, SIM_SCGC3_FLEXCAN2_MASK, SIM_SCGC3_FLEXCAN2(value)))
#define SIM_BWR_SCGC3_FLEXCAN2(base, value) (BME_BFI32(&SIM_SCGC3_REG(base), ((uint32_t)(value) << SIM_SCGC3_FLEXCAN2_SHIFT), SIM_SCGC3_FLEXCAN2_SHIFT, SIM_SCGC3_FLEXCAN2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC3, field SPI2[12] (RW)
 *
 * This bit controls the clock gate to the SPI2 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC3_SPI2 field. */
#define SIM_RD_SCGC3_SPI2(base) ((SIM_SCGC3_REG(base) & SIM_SCGC3_SPI2_MASK) >> SIM_SCGC3_SPI2_SHIFT)
#define SIM_BRD_SCGC3_SPI2(base) (BME_UBFX32(&SIM_SCGC3_REG(base), SIM_SCGC3_SPI2_SHIFT, SIM_SCGC3_SPI2_WIDTH))

/*! @brief Set the SPI2 field to a new value. */
#define SIM_WR_SCGC3_SPI2(base, value) (SIM_RMW_SCGC3(base, SIM_SCGC3_SPI2_MASK, SIM_SCGC3_SPI2(value)))
#define SIM_BWR_SCGC3_SPI2(base, value) (BME_BFI32(&SIM_SCGC3_REG(base), ((uint32_t)(value) << SIM_SCGC3_SPI2_SHIFT), SIM_SCGC3_SPI2_SHIFT, SIM_SCGC3_SPI2_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0000030U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (BME_OR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC4(base, value) (BME_AND32(&SIM_SCGC4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC4(base, value) (BME_XOR32(&SIM_SCGC4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define SIM_RD_SCGC4_EWM(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_EWM_MASK) >> SIM_SCGC4_EWM_SHIFT)
#define SIM_BRD_SCGC4_EWM(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))

/*! @brief Set the EWM field to a new value. */
#define SIM_WR_SCGC4_EWM(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_EWM_MASK, SIM_SCGC4_EWM(value)))
#define SIM_BWR_SCGC4_EWM(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_EWM_SHIFT), SIM_SCGC4_EWM_SHIFT, SIM_SCGC4_EWM_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C0[6] (RW)
 *
 * This bit controls the clock gate to the I 2 C0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C0 field. */
#define SIM_RD_SCGC4_I2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C0_MASK) >> SIM_SCGC4_I2C0_SHIFT)
#define SIM_BRD_SCGC4_I2C0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))

/*! @brief Set the I2C0 field to a new value. */
#define SIM_WR_SCGC4_I2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C0_MASK, SIM_SCGC4_I2C0(value)))
#define SIM_BWR_SCGC4_I2C0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C0_SHIFT), SIM_SCGC4_I2C0_SHIFT, SIM_SCGC4_I2C0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field I2C1[7] (RW)
 *
 * This bit controls the clock gate to the I 2 C1 module.
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_I2C1 field. */
#define SIM_RD_SCGC4_I2C1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_I2C1_MASK) >> SIM_SCGC4_I2C1_SHIFT)
#define SIM_BRD_SCGC4_I2C1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))

/*! @brief Set the I2C1 field to a new value. */
#define SIM_WR_SCGC4_I2C1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_I2C1_MASK, SIM_SCGC4_I2C1(value)))
#define SIM_BWR_SCGC4_I2C1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_I2C1_SHIFT), SIM_SCGC4_I2C1_SHIFT, SIM_SCGC4_I2C1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define SIM_RD_SCGC4_UART0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART0_MASK) >> SIM_SCGC4_UART0_SHIFT)
#define SIM_BRD_SCGC4_UART0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))

/*! @brief Set the UART0 field to a new value. */
#define SIM_WR_SCGC4_UART0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART0_MASK, SIM_SCGC4_UART0(value)))
#define SIM_BWR_SCGC4_UART0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART0_SHIFT), SIM_SCGC4_UART0_SHIFT, SIM_SCGC4_UART0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define SIM_RD_SCGC4_UART1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART1_MASK) >> SIM_SCGC4_UART1_SHIFT)
#define SIM_BRD_SCGC4_UART1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))

/*! @brief Set the UART1 field to a new value. */
#define SIM_WR_SCGC4_UART1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART1_MASK, SIM_SCGC4_UART1(value)))
#define SIM_BWR_SCGC4_UART1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART1_SHIFT), SIM_SCGC4_UART1_SHIFT, SIM_SCGC4_UART1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * This bit controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define SIM_RD_SCGC4_UART2(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART2_MASK) >> SIM_SCGC4_UART2_SHIFT)
#define SIM_BRD_SCGC4_UART2(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT, SIM_SCGC4_UART2_WIDTH))

/*! @brief Set the UART2 field to a new value. */
#define SIM_WR_SCGC4_UART2(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART2_MASK, SIM_SCGC4_UART2(value)))
#define SIM_BWR_SCGC4_UART2(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART2_SHIFT), SIM_SCGC4_UART2_SHIFT, SIM_SCGC4_UART2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART3[13] (RW)
 *
 * This bit controls the clock gate to the UART3 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART3 field. */
#define SIM_RD_SCGC4_UART3(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART3_MASK) >> SIM_SCGC4_UART3_SHIFT)
#define SIM_BRD_SCGC4_UART3(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART3_SHIFT, SIM_SCGC4_UART3_WIDTH))

/*! @brief Set the UART3 field to a new value. */
#define SIM_WR_SCGC4_UART3(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART3_MASK, SIM_SCGC4_UART3(value)))
#define SIM_BWR_SCGC4_UART3(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_UART3_SHIFT), SIM_SCGC4_UART3_SHIFT, SIM_SCGC4_UART3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * This bit controls the clock gate to the comparator module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_CMP_SHIFT), SIM_SCGC4_CMP_SHIFT, SIM_SCGC4_CMP_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field PWM0_SM0[24] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 0.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_PWM0_SM0 field. */
#define SIM_RD_SCGC4_PWM0_SM0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_PWM0_SM0_MASK) >> SIM_SCGC4_PWM0_SM0_SHIFT)
#define SIM_BRD_SCGC4_PWM0_SM0(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_PWM0_SM0_SHIFT, SIM_SCGC4_PWM0_SM0_WIDTH))

/*! @brief Set the PWM0_SM0 field to a new value. */
#define SIM_WR_SCGC4_PWM0_SM0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_PWM0_SM0_MASK, SIM_SCGC4_PWM0_SM0(value)))
#define SIM_BWR_SCGC4_PWM0_SM0(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_PWM0_SM0_SHIFT), SIM_SCGC4_PWM0_SM0_SHIFT, SIM_SCGC4_PWM0_SM0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field PWM0_SM1[25] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 1.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_PWM0_SM1 field. */
#define SIM_RD_SCGC4_PWM0_SM1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_PWM0_SM1_MASK) >> SIM_SCGC4_PWM0_SM1_SHIFT)
#define SIM_BRD_SCGC4_PWM0_SM1(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_PWM0_SM1_SHIFT, SIM_SCGC4_PWM0_SM1_WIDTH))

/*! @brief Set the PWM0_SM1 field to a new value. */
#define SIM_WR_SCGC4_PWM0_SM1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_PWM0_SM1_MASK, SIM_SCGC4_PWM0_SM1(value)))
#define SIM_BWR_SCGC4_PWM0_SM1(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_PWM0_SM1_SHIFT), SIM_SCGC4_PWM0_SM1_SHIFT, SIM_SCGC4_PWM0_SM1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field PWM0_SM2[26] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 2.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_PWM0_SM2 field. */
#define SIM_RD_SCGC4_PWM0_SM2(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_PWM0_SM2_MASK) >> SIM_SCGC4_PWM0_SM2_SHIFT)
#define SIM_BRD_SCGC4_PWM0_SM2(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_PWM0_SM2_SHIFT, SIM_SCGC4_PWM0_SM2_WIDTH))

/*! @brief Set the PWM0_SM2 field to a new value. */
#define SIM_WR_SCGC4_PWM0_SM2(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_PWM0_SM2_MASK, SIM_SCGC4_PWM0_SM2(value)))
#define SIM_BWR_SCGC4_PWM0_SM2(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_PWM0_SM2_SHIFT), SIM_SCGC4_PWM0_SM2_SHIFT, SIM_SCGC4_PWM0_SM2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field PWM0_SM3[27] (RW)
 *
 * This bit controls the clock gate to the PWM submodule 3.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_PWM0_SM3 field. */
#define SIM_RD_SCGC4_PWM0_SM3(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_PWM0_SM3_MASK) >> SIM_SCGC4_PWM0_SM3_SHIFT)
#define SIM_BRD_SCGC4_PWM0_SM3(base) (BME_UBFX32(&SIM_SCGC4_REG(base), SIM_SCGC4_PWM0_SM3_SHIFT, SIM_SCGC4_PWM0_SM3_WIDTH))

/*! @brief Set the PWM0_SM3 field to a new value. */
#define SIM_WR_SCGC4_PWM0_SM3(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_PWM0_SM3_MASK, SIM_SCGC4_PWM0_SM3(value)))
#define SIM_BWR_SCGC4_PWM0_SM3(base, value) (BME_BFI32(&SIM_SCGC4_REG(base), ((uint32_t)(value) << SIM_SCGC4_PWM0_SM3_SHIFT), SIM_SCGC4_PWM0_SM3_SHIFT, SIM_SCGC4_PWM0_SM3_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00040182U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (BME_OR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC5(base, value) (BME_AND32(&SIM_SCGC5_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC5(base, value) (BME_XOR32(&SIM_SCGC5_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * This bit controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0b0 - Access disabled
 * - 0b1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define SIM_RD_SCGC5_LPTMR(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPTMR_MASK) >> SIM_SCGC5_LPTMR_SHIFT)
#define SIM_BRD_SCGC5_LPTMR(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))

/*! @brief Set the LPTMR field to a new value. */
#define SIM_WR_SCGC5_LPTMR(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPTMR_MASK, SIM_SCGC5_LPTMR(value)))
#define SIM_BWR_SCGC5_LPTMR(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_LPTMR_SHIFT), SIM_SCGC5_LPTMR_SHIFT, SIM_SCGC5_LPTMR_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * This bit controls the clock gate to the Port A module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTA_SHIFT), SIM_SCGC5_PORTA_SHIFT, SIM_SCGC5_PORTA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * This bit controls the clock gate to the Port B module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTB_SHIFT), SIM_SCGC5_PORTB_SHIFT, SIM_SCGC5_PORTB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * This bit controls the clock gate to the Port C module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTC_SHIFT), SIM_SCGC5_PORTC_SHIFT, SIM_SCGC5_PORTC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * This bit controls the clock gate to the Port D module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define SIM_RD_SCGC5_PORTD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTD_MASK) >> SIM_SCGC5_PORTD_SHIFT)
#define SIM_BRD_SCGC5_PORTD(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))

/*! @brief Set the PORTD field to a new value. */
#define SIM_WR_SCGC5_PORTD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTD_MASK, SIM_SCGC5_PORTD(value)))
#define SIM_BWR_SCGC5_PORTD(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTD_SHIFT), SIM_SCGC5_PORTD_SHIFT, SIM_SCGC5_PORTD_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * This bit controls the clock gate to the Port E module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define SIM_RD_SCGC5_PORTE(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTE_MASK) >> SIM_SCGC5_PORTE_SHIFT)
#define SIM_BRD_SCGC5_PORTE(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))

/*! @brief Set the PORTE field to a new value. */
#define SIM_WR_SCGC5_PORTE(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTE_MASK, SIM_SCGC5_PORTE(value)))
#define SIM_BWR_SCGC5_PORTE(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_PORTE_SHIFT), SIM_SCGC5_PORTE_SHIFT, SIM_SCGC5_PORTE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field ENC[21] (RW)
 *
 * This bit controls the clock gate to the ENC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_ENC field. */
#define SIM_RD_SCGC5_ENC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_ENC_MASK) >> SIM_SCGC5_ENC_SHIFT)
#define SIM_BRD_SCGC5_ENC(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_ENC_SHIFT, SIM_SCGC5_ENC_WIDTH))

/*! @brief Set the ENC field to a new value. */
#define SIM_WR_SCGC5_ENC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_ENC_MASK, SIM_SCGC5_ENC(value)))
#define SIM_BWR_SCGC5_ENC(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_ENC_SHIFT), SIM_SCGC5_ENC_SHIFT, SIM_SCGC5_ENC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field XBARA[25] (RW)
 *
 * This bit controls the clock gate to the XBARA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_XBARA field. */
#define SIM_RD_SCGC5_XBARA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_XBARA_MASK) >> SIM_SCGC5_XBARA_SHIFT)
#define SIM_BRD_SCGC5_XBARA(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_XBARA_SHIFT, SIM_SCGC5_XBARA_WIDTH))

/*! @brief Set the XBARA field to a new value. */
#define SIM_WR_SCGC5_XBARA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_XBARA_MASK, SIM_SCGC5_XBARA(value)))
#define SIM_BWR_SCGC5_XBARA(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_XBARA_SHIFT), SIM_SCGC5_XBARA_SHIFT, SIM_SCGC5_XBARA_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field XBARB[26] (RW)
 *
 * This bit controls the clock gate to the XBARB module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_XBARB field. */
#define SIM_RD_SCGC5_XBARB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_XBARB_MASK) >> SIM_SCGC5_XBARB_SHIFT)
#define SIM_BRD_SCGC5_XBARB(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_XBARB_SHIFT, SIM_SCGC5_XBARB_WIDTH))

/*! @brief Set the XBARB field to a new value. */
#define SIM_WR_SCGC5_XBARB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_XBARB_MASK, SIM_SCGC5_XBARB(value)))
#define SIM_BWR_SCGC5_XBARB(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_XBARB_SHIFT), SIM_SCGC5_XBARB_SHIFT, SIM_SCGC5_XBARB_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field AOI[27] (RW)
 *
 * This bit controls the clock gate to the AOI module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_AOI field. */
#define SIM_RD_SCGC5_AOI(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_AOI_MASK) >> SIM_SCGC5_AOI_SHIFT)
#define SIM_BRD_SCGC5_AOI(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_AOI_SHIFT, SIM_SCGC5_AOI_WIDTH))

/*! @brief Set the AOI field to a new value. */
#define SIM_WR_SCGC5_AOI(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_AOI_MASK, SIM_SCGC5_AOI(value)))
#define SIM_BWR_SCGC5_AOI(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_AOI_SHIFT), SIM_SCGC5_AOI_SHIFT, SIM_SCGC5_AOI_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field HSADC0[28] (RW)
 *
 * This bit controls the clock gate to the HSADC0A and HSADC0B module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_HSADC0 field. */
#define SIM_RD_SCGC5_HSADC0(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_HSADC0_MASK) >> SIM_SCGC5_HSADC0_SHIFT)
#define SIM_BRD_SCGC5_HSADC0(base) (BME_UBFX32(&SIM_SCGC5_REG(base), SIM_SCGC5_HSADC0_SHIFT, SIM_SCGC5_HSADC0_WIDTH))

/*! @brief Set the HSADC0 field to a new value. */
#define SIM_WR_SCGC5_HSADC0(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_HSADC0_MASK, SIM_SCGC5_HSADC0(value)))
#define SIM_BWR_SCGC5_HSADC0(base, value) (BME_BFI32(&SIM_SCGC5_REG(base), ((uint32_t)(value) << SIM_SCGC5_HSADC0_SHIFT), SIM_SCGC5_HSADC0_SHIFT, SIM_SCGC5_HSADC0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (BME_OR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC6(base, value) (BME_AND32(&SIM_SCGC6_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC6(base, value) (BME_XOR32(&SIM_SCGC6_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * This bit controls the clock gate to the flash memory. Flash reads are still
 * supported while the flash memory is clock gated, but entry into low power modes
 * is blocked.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define SIM_RD_SCGC6_FTF(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTF_MASK) >> SIM_SCGC6_FTF_SHIFT)
#define SIM_BRD_SCGC6_FTF(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))

/*! @brief Set the FTF field to a new value. */
#define SIM_WR_SCGC6_FTF(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTF_MASK, SIM_SCGC6_FTF(value)))
#define SIM_BWR_SCGC6_FTF(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTF_SHIFT), SIM_SCGC6_FTF_SHIFT, SIM_SCGC6_FTF_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * This bit controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define SIM_RD_SCGC6_DMAMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMAMUX_MASK) >> SIM_SCGC6_DMAMUX_SHIFT)
#define SIM_BRD_SCGC6_DMAMUX(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))

/*! @brief Set the DMAMUX field to a new value. */
#define SIM_WR_SCGC6_DMAMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMAMUX_MASK, SIM_SCGC6_DMAMUX(value)))
#define SIM_BWR_SCGC6_DMAMUX(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DMAMUX_SHIFT), SIM_SCGC6_DMAMUX_SHIFT, SIM_SCGC6_DMAMUX_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FLEXCAN0[4] (RW)
 *
 * This bit controls the clock gate to the FlexCAN0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FLEXCAN0 field. */
#define SIM_RD_SCGC6_FLEXCAN0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FLEXCAN0_MASK) >> SIM_SCGC6_FLEXCAN0_SHIFT)
#define SIM_BRD_SCGC6_FLEXCAN0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN0_SHIFT, SIM_SCGC6_FLEXCAN0_WIDTH))

/*! @brief Set the FLEXCAN0 field to a new value. */
#define SIM_WR_SCGC6_FLEXCAN0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FLEXCAN0_MASK, SIM_SCGC6_FLEXCAN0(value)))
#define SIM_BWR_SCGC6_FLEXCAN0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FLEXCAN0_SHIFT), SIM_SCGC6_FLEXCAN0_SHIFT, SIM_SCGC6_FLEXCAN0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FLEXCAN1[5] (RW)
 *
 * This bit controls the clock gate to the FlexCAN1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FLEXCAN1 field. */
#define SIM_RD_SCGC6_FLEXCAN1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FLEXCAN1_MASK) >> SIM_SCGC6_FLEXCAN1_SHIFT)
#define SIM_BRD_SCGC6_FLEXCAN1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN1_SHIFT, SIM_SCGC6_FLEXCAN1_WIDTH))

/*! @brief Set the FLEXCAN1 field to a new value. */
#define SIM_WR_SCGC6_FLEXCAN1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FLEXCAN1_MASK, SIM_SCGC6_FLEXCAN1(value)))
#define SIM_BWR_SCGC6_FLEXCAN1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FLEXCAN1_SHIFT), SIM_SCGC6_FLEXCAN1_SHIFT, SIM_SCGC6_FLEXCAN1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM3[6] (RW)
 *
 * This bit controls the clock gate to the FTM3 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM3 field. */
#define SIM_RD_SCGC6_FTM3(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM3_MASK) >> SIM_SCGC6_FTM3_SHIFT)
#define SIM_BRD_SCGC6_FTM3(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM3_SHIFT, SIM_SCGC6_FTM3_WIDTH))

/*! @brief Set the FTM3 field to a new value. */
#define SIM_WR_SCGC6_FTM3(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM3_MASK, SIM_SCGC6_FTM3(value)))
#define SIM_BWR_SCGC6_FTM3(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM3_SHIFT), SIM_SCGC6_FTM3_SHIFT, SIM_SCGC6_FTM3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * This bit controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define SIM_RD_SCGC6_SPI0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI0_MASK) >> SIM_SCGC6_SPI0_SHIFT)
#define SIM_BRD_SCGC6_SPI0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC6_SPI0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI0_MASK, SIM_SCGC6_SPI0(value)))
#define SIM_BWR_SCGC6_SPI0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_SPI0_SHIFT), SIM_SCGC6_SPI0_SHIFT, SIM_SCGC6_SPI0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI1[13] (RW)
 *
 * This bit controls the clock gate to the SPI1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI1 field. */
#define SIM_RD_SCGC6_SPI1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI1_MASK) >> SIM_SCGC6_SPI1_SHIFT)
#define SIM_BRD_SCGC6_SPI1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI1_SHIFT, SIM_SCGC6_SPI1_WIDTH))

/*! @brief Set the SPI1 field to a new value. */
#define SIM_WR_SCGC6_SPI1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI1_MASK, SIM_SCGC6_SPI1(value)))
#define SIM_BWR_SCGC6_SPI1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_SPI1_SHIFT), SIM_SCGC6_SPI1_SHIFT, SIM_SCGC6_SPI1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB1[17] (RW)
 *
 * This bit controls the clock gate to the PDB1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB1 field. */
#define SIM_RD_SCGC6_PDB1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB1_MASK) >> SIM_SCGC6_PDB1_SHIFT)
#define SIM_BRD_SCGC6_PDB1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB1_SHIFT, SIM_SCGC6_PDB1_WIDTH))

/*! @brief Set the PDB1 field to a new value. */
#define SIM_WR_SCGC6_PDB1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB1_MASK, SIM_SCGC6_PDB1(value)))
#define SIM_BWR_SCGC6_PDB1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PDB1_SHIFT), SIM_SCGC6_PDB1_SHIFT, SIM_SCGC6_PDB1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[18] (RW)
 *
 * This bit controls the clock gate to the CRC module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define SIM_RD_SCGC6_CRC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_CRC_MASK) >> SIM_SCGC6_CRC_SHIFT)
#define SIM_BRD_SCGC6_CRC(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))

/*! @brief Set the CRC field to a new value. */
#define SIM_WR_SCGC6_CRC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_CRC_MASK, SIM_SCGC6_CRC(value)))
#define SIM_BWR_SCGC6_CRC(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_CRC_SHIFT), SIM_SCGC6_CRC_SHIFT, SIM_SCGC6_CRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB0[22] (RW)
 *
 * This bit controls the clock gate to the PDB0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB0 field. */
#define SIM_RD_SCGC6_PDB0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB0_MASK) >> SIM_SCGC6_PDB0_SHIFT)
#define SIM_BRD_SCGC6_PDB0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB0_SHIFT, SIM_SCGC6_PDB0_WIDTH))

/*! @brief Set the PDB0 field to a new value. */
#define SIM_WR_SCGC6_PDB0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB0_MASK, SIM_SCGC6_PDB0(value)))
#define SIM_BWR_SCGC6_PDB0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PDB0_SHIFT), SIM_SCGC6_PDB0_SHIFT, SIM_SCGC6_PDB0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define SIM_RD_SCGC6_PIT(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT_MASK) >> SIM_SCGC6_PIT_SHIFT)
#define SIM_BRD_SCGC6_PIT(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT, SIM_SCGC6_PIT_WIDTH))

/*! @brief Set the PIT field to a new value. */
#define SIM_WR_SCGC6_PIT(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT_MASK, SIM_SCGC6_PIT(value)))
#define SIM_BWR_SCGC6_PIT(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_PIT_SHIFT), SIM_SCGC6_PIT_SHIFT, SIM_SCGC6_PIT_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM0[24] (RW)
 *
 * This bit controls the clock gate to the FTM0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM0 field. */
#define SIM_RD_SCGC6_FTM0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM0_MASK) >> SIM_SCGC6_FTM0_SHIFT)
#define SIM_BRD_SCGC6_FTM0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM0_SHIFT, SIM_SCGC6_FTM0_WIDTH))

/*! @brief Set the FTM0 field to a new value. */
#define SIM_WR_SCGC6_FTM0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM0_MASK, SIM_SCGC6_FTM0(value)))
#define SIM_BWR_SCGC6_FTM0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM0_SHIFT), SIM_SCGC6_FTM0_SHIFT, SIM_SCGC6_FTM0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM1[25] (RW)
 *
 * This bit controls the clock gate to the FTM1 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM1 field. */
#define SIM_RD_SCGC6_FTM1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM1_MASK) >> SIM_SCGC6_FTM1_SHIFT)
#define SIM_BRD_SCGC6_FTM1(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM1_SHIFT, SIM_SCGC6_FTM1_WIDTH))

/*! @brief Set the FTM1 field to a new value. */
#define SIM_WR_SCGC6_FTM1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM1_MASK, SIM_SCGC6_FTM1(value)))
#define SIM_BWR_SCGC6_FTM1(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM1_SHIFT), SIM_SCGC6_FTM1_SHIFT, SIM_SCGC6_FTM1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FTM2[26] (RW)
 *
 * This bit controls the clock gate to the FTM2 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTM2 field. */
#define SIM_RD_SCGC6_FTM2(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTM2_MASK) >> SIM_SCGC6_FTM2_SHIFT)
#define SIM_BRD_SCGC6_FTM2(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTM2_SHIFT, SIM_SCGC6_FTM2_WIDTH))

/*! @brief Set the FTM2 field to a new value. */
#define SIM_WR_SCGC6_FTM2(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTM2_MASK, SIM_SCGC6_FTM2(value)))
#define SIM_BWR_SCGC6_FTM2(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_FTM2_SHIFT), SIM_SCGC6_FTM2_SHIFT, SIM_SCGC6_FTM2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * This bit controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define SIM_RD_SCGC6_ADC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC0_MASK) >> SIM_SCGC6_ADC0_SHIFT)
#define SIM_BRD_SCGC6_ADC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))

/*! @brief Set the ADC0 field to a new value. */
#define SIM_WR_SCGC6_ADC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC0_MASK, SIM_SCGC6_ADC0(value)))
#define SIM_BWR_SCGC6_ADC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_ADC0_SHIFT), SIM_SCGC6_ADC0_SHIFT, SIM_SCGC6_ADC0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define SIM_RD_SCGC6_DAC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DAC0_MASK) >> SIM_SCGC6_DAC0_SHIFT)
#define SIM_BRD_SCGC6_DAC0(base) (BME_UBFX32(&SIM_SCGC6_REG(base), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))

/*! @brief Set the DAC0 field to a new value. */
#define SIM_WR_SCGC6_DAC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DAC0_MASK, SIM_SCGC6_DAC0(value)))
#define SIM_BWR_SCGC6_DAC0(base, value) (BME_BFI32(&SIM_SCGC6_REG(base), ((uint32_t)(value) << SIM_SCGC6_DAC0_SHIFT), SIM_SCGC6_DAC0_SHIFT, SIM_SCGC6_DAC0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000104U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (BME_OR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
#define SIM_CLR_SCGC7(base, value) (BME_AND32(&SIM_SCGC7_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_SCGC7(base, value) (BME_XOR32(&SIM_SCGC7_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field FLEXBUS[0] (RW)
 *
 * This bit controls the clock gate to the FlexBus module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_FLEXBUS field. */
#define SIM_RD_SCGC7_FLEXBUS(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_FLEXBUS_MASK) >> SIM_SCGC7_FLEXBUS_SHIFT)
#define SIM_BRD_SCGC7_FLEXBUS(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_FLEXBUS_SHIFT, SIM_SCGC7_FLEXBUS_WIDTH))

/*! @brief Set the FLEXBUS field to a new value. */
#define SIM_WR_SCGC7_FLEXBUS(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_FLEXBUS_MASK, SIM_SCGC7_FLEXBUS(value)))
#define SIM_BWR_SCGC7_FLEXBUS(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_FLEXBUS_SHIFT), SIM_SCGC7_FLEXBUS_SHIFT, SIM_SCGC7_FLEXBUS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field SMPU[2] (RW)
 *
 * This bit controls the clock gate to the SMPU module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_SMPU field. */
#define SIM_RD_SCGC7_SMPU(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_SMPU_MASK) >> SIM_SCGC7_SMPU_SHIFT)
#define SIM_BRD_SCGC7_SMPU(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_SMPU_SHIFT, SIM_SCGC7_SMPU_WIDTH))

/*! @brief Set the SMPU field to a new value. */
#define SIM_WR_SCGC7_SMPU(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_SMPU_MASK, SIM_SCGC7_SMPU(value)))
#define SIM_BWR_SCGC7_SMPU(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_SMPU_SHIFT), SIM_SCGC7_SMPU_SHIFT, SIM_SCGC7_SMPU_WIDTH))
/*@}*/

/*!
 * @name Register SIM_SCGC7, field DMA[8] (RW)
 *
 * This bit controls the clock gate to the DMA module.
 *
 * Values:
 * - 0b0 - Clock disabled
 * - 0b1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BME_UBFX32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BME_BFI32(&SIM_SCGC7_REG(base), ((uint32_t)(value) << SIM_SCGC7_DMA_SHIFT), SIM_SCGC7_DMA_SHIFT, SIM_SCGC7_DMA_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00010000U
 *
 * When updating CLKDIV1, update all fields using the one write command.
 * Attempting to write an invalid clock ratio to the CLKDIV1 register will cause the
 * write to be ignored. The maximum divide ratio that can be programmed between
 * core/system clock and the other divided clocks is divide by 8. When OUTDIV1 equals
 * 0000 (divide by 1), the other dividers cannot be set higher than 0111 (divide
 * by 8). The CLKDIV1 register cannot be written to when the device is in VLPR
 * mode.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (BME_OR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
#define SIM_CLR_CLKDIV1(base, value) (BME_AND32(&SIM_CLKDIV1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CLKDIV1(base, value) (BME_XOR32(&SIM_CLKDIV1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[19:16] (RW)
 *
 * This field sets the divide value for the bus/flash clock from MCGOUTCLK. At
 * the end of reset, it is loaded with either 0001 or 1111 depending on
 * FTF_FOPT[LPBOOT]. The flash clock frequency must be an integer divide of the system
 * clock frequency.
 *
 * Values:
 * - 0b0000 - Divide-by-1.
 * - 0b0001 - Divide-by-2.
 * - 0b0010 - Divide-by-3.
 * - 0b0011 - Divide-by-4.
 * - 0b0100 - Divide-by-5.
 * - 0b0101 - Divide-by-6.
 * - 0b0110 - Divide-by-7.
 * - 0b0111 - Divide-by-8.
 * - 0b1000 - Divide-by-9.
 * - 0b1001 - Divide-by-10.
 * - 0b1010 - Divide-by-11.
 * - 0b1011 - Divide-by-12.
 * - 0b1100 - Divide-by-13.
 * - 0b1101 - Divide-by-14.
 * - 0b1110 - Divide-by-15.
 * - 0b1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define SIM_RD_CLKDIV1_OUTDIV4(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV4(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))

/*! @brief Set the OUTDIV4 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV4(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV4_MASK, SIM_CLKDIV1_OUTDIV4(value)))
#define SIM_BWR_CLKDIV1_OUTDIV4(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV4_SHIFT), SIM_CLKDIV1_OUTDIV4_SHIFT, SIM_CLKDIV1_OUTDIV4_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV3[23:20] (RW)
 *
 * This field sets the divide value for the FlexBus clock (external pin FB_CLK)
 * from MCGOUTCLK. At the end of reset, it is loaded with either 0001 or 1111
 * depending on FTF_FOPT[LPBOOT]. The FlexBus clock frequency must be an integer
 * divide of the system clock frequency.
 *
 * Values:
 * - 0b0000 - Divide-by-1.
 * - 0b0001 - Divide-by-2.
 * - 0b0010 - Divide-by-3.
 * - 0b0011 - Divide-by-4.
 * - 0b0100 - Divide-by-5.
 * - 0b0101 - Divide-by-6.
 * - 0b0110 - Divide-by-7.
 * - 0b0111 - Divide-by-8.
 * - 0b1000 - Divide-by-9.
 * - 0b1001 - Divide-by-10.
 * - 0b1010 - Divide-by-11.
 * - 0b1011 - Divide-by-12.
 * - 0b1100 - Divide-by-13.
 * - 0b1101 - Divide-by-14.
 * - 0b1110 - Divide-by-15.
 * - 0b1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV3 field. */
#define SIM_RD_CLKDIV1_OUTDIV3(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV3_MASK) >> SIM_CLKDIV1_OUTDIV3_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV3(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV3_SHIFT, SIM_CLKDIV1_OUTDIV3_WIDTH))

/*! @brief Set the OUTDIV3 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV3(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV3_MASK, SIM_CLKDIV1_OUTDIV3(value)))
#define SIM_BWR_CLKDIV1_OUTDIV3(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV3_SHIFT), SIM_CLKDIV1_OUTDIV3_SHIFT, SIM_CLKDIV1_OUTDIV3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV2[27:24] (RW)
 *
 * This field sets the divide value for the fast bus clock from MCGOUTCLK. At
 * the end of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT]. The fast bus clock frequency must be an integer divide or multiple of
 * the core/system clock frequency.
 *
 * Values:
 * - 0b0000 - Divide-by-1.
 * - 0b0001 - Divide-by-2.
 * - 0b0010 - Divide-by-3.
 * - 0b0011 - Divide-by-4.
 * - 0b0100 - Divide-by-5.
 * - 0b0101 - Divide-by-6.
 * - 0b0110 - Divide-by-7.
 * - 0b0111 - Divide-by-8.
 * - 0b1000 - Divide-by-9.
 * - 0b1001 - Divide-by-10.
 * - 0b1010 - Divide-by-11.
 * - 0b1011 - Divide-by-12.
 * - 0b1100 - Divide-by-13.
 * - 0b1101 - Divide-by-14.
 * - 0b1110 - Divide-by-15.
 * - 0b1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV2 field. */
#define SIM_RD_CLKDIV1_OUTDIV2(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV2(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV2_SHIFT, SIM_CLKDIV1_OUTDIV2_WIDTH))

/*! @brief Set the OUTDIV2 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV2(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV2_MASK, SIM_CLKDIV1_OUTDIV2(value)))
#define SIM_BWR_CLKDIV1_OUTDIV2(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV2_SHIFT), SIM_CLKDIV1_OUTDIV2_SHIFT, SIM_CLKDIV1_OUTDIV2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * This field sets the divide value for the core/system clock from MCGOUTCLK. At
 * the end of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT].
 *
 * Values:
 * - 0b0000 - Divide-by-1.
 * - 0b0001 - Divide-by-2.
 * - 0b0010 - Divide-by-3.
 * - 0b0011 - Divide-by-4.
 * - 0b0100 - Divide-by-5.
 * - 0b0101 - Divide-by-6.
 * - 0b0110 - Divide-by-7.
 * - 0b0111 - Divide-by-8.
 * - 0b1000 - Divide-by-9.
 * - 0b1001 - Divide-by-10.
 * - 0b1010 - Divide-by-11.
 * - 0b1011 - Divide-by-12.
 * - 0b1100 - Divide-by-13.
 * - 0b1101 - Divide-by-14.
 * - 0b1110 - Divide-by-15.
 * - 0b1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define SIM_RD_CLKDIV1_OUTDIV1(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV1(base) (BME_UBFX32(&SIM_CLKDIV1_REG(base), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))

/*! @brief Set the OUTDIV1 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV1(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV1_MASK, SIM_CLKDIV1_OUTDIV1(value)))
#define SIM_BWR_CLKDIV1_OUTDIV1(base, value) (BME_BFI32(&SIM_CLKDIV1_REG(base), ((uint32_t)(value) << SIM_CLKDIV1_OUTDIV1_SHIFT), SIM_CLKDIV1_OUTDIV1_SHIFT, SIM_CLKDIV1_OUTDIV1_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0xF00F0F00U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (BME_OR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
#define SIM_CLR_FCFG1(base, value) (BME_AND32(&SIM_FCFG1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_FCFG1(base, value) (BME_XOR32(&SIM_FCFG1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0b0 - Flash is enabled
 * - 0b1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDIS_SHIFT), SIM_FCFG1_FLASHDIS_SHIFT, SIM_FCFG1_FLASHDIS_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0b0 - Flash remains enabled during Wait mode
 * - 0b1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BME_BFI32(&SIM_FCFG1_REG(base), ((uint32_t)(value) << SIM_FCFG1_FLASHDOZE_SHIFT), SIM_FCFG1_FLASHDOZE_SHIFT, SIM_FCFG1_FLASHDOZE_WIDTH))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device, as set by IFR bits. These bits are used for device testing only and are
 * read-only.
 *
 * Values:
 * - 0b1011 - 512 KB of program flash memory
 * - 0b1101 - 1024 KB of program flash memory
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (BME_UBFX32(&SIM_FCFG1_REG(base), SIM_FCFG1_PFSIZE_SHIFT, SIM_FCFG1_PFSIZE_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x00800000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 14 trailing zeros indicates the first invalid
 * address of flash block 0 (program flash 0). For example, if MAXADDR0 = 0x20 the
 * first invalid address of flash block 0 is 0x0008_0000. This would be the
 * MAXADDR0 value for a device with 512 KB program flash in flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (BME_UBFX32(&SIM_FCFG2_REG(base), SIM_FCFG2_MAXADDR0_SHIFT, SIM_FCFG2_MAXADDR0_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define SIM_RD_UIDH(base)        (SIM_UIDH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV4 - System Clock Divider Register 4
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV4 - System Clock Divider Register 4 (RW)
 *
 * Reset value: 0x10000000U
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV4 register
 */
/*@{*/
#define SIM_RD_CLKDIV4(base)     (SIM_CLKDIV4_REG(base))
#define SIM_WR_CLKDIV4(base, value) (SIM_CLKDIV4_REG(base) = (value))
#define SIM_RMW_CLKDIV4(base, mask, value) (SIM_WR_CLKDIV4(base, (SIM_RD_CLKDIV4(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV4(base, value) (BME_OR32(&SIM_CLKDIV4_REG(base), (uint32_t)(value)))
#define SIM_CLR_CLKDIV4(base, value) (BME_AND32(&SIM_CLKDIV4_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_CLKDIV4(base, value) (BME_XOR32(&SIM_CLKDIV4_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV4 bitfields
 */

/*!
 * @name Register SIM_CLKDIV4, field TRACEFRAC[0] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for trace clock. The source clock for the fractional clock divider is
 * set by the SOPT2 TRACECLKSEL register bit. Divider output clock = Divider input
 * clock*((TRACEFRAC+1)/(TRACEDIV+1))
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEFRAC field. */
#define SIM_RD_CLKDIV4_TRACEFRAC(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEFRAC_MASK) >> SIM_CLKDIV4_TRACEFRAC_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEFRAC(base) (BME_UBFX32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEFRAC_SHIFT, SIM_CLKDIV4_TRACEFRAC_WIDTH))

/*! @brief Set the TRACEFRAC field to a new value. */
#define SIM_WR_CLKDIV4_TRACEFRAC(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEFRAC_MASK, SIM_CLKDIV4_TRACEFRAC(value)))
#define SIM_BWR_CLKDIV4_TRACEFRAC(base, value) (BME_BFI32(&SIM_CLKDIV4_REG(base), ((uint32_t)(value) << SIM_CLKDIV4_TRACEFRAC_SHIFT), SIM_CLKDIV4_TRACEFRAC_SHIFT, SIM_CLKDIV4_TRACEFRAC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV4, field TRACEDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for trace clock. The source clock for the fractional clock divider is
 * set by the SOPT2 TRACECLKSEL register bit. Divider output clock = Divider input
 * clock * ((TRACEFRAC+1)/(TRACEDIV+1))
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEDIV field. */
#define SIM_RD_CLKDIV4_TRACEDIV(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEDIV_MASK) >> SIM_CLKDIV4_TRACEDIV_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEDIV(base) (BME_UBFX32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEDIV_SHIFT, SIM_CLKDIV4_TRACEDIV_WIDTH))

/*! @brief Set the TRACEDIV field to a new value. */
#define SIM_WR_CLKDIV4_TRACEDIV(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEDIV_MASK, SIM_CLKDIV4_TRACEDIV(value)))
#define SIM_BWR_CLKDIV4_TRACEDIV(base, value) (BME_BFI32(&SIM_CLKDIV4_REG(base), ((uint32_t)(value) << SIM_CLKDIV4_TRACEDIV_SHIFT), SIM_CLKDIV4_TRACEDIV_SHIFT, SIM_CLKDIV4_TRACEDIV_WIDTH))
/*@}*/

/*!
 * @name Register SIM_CLKDIV4, field TRACEDIVEN[28] (RW)
 *
 * This bit controls the Debug Trace Divider.
 *
 * Values:
 * - 0b0 - Debug trace divider disabled
 * - 0b1 - Debug trace divider enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV4_TRACEDIVEN field. */
#define SIM_RD_CLKDIV4_TRACEDIVEN(base) ((SIM_CLKDIV4_REG(base) & SIM_CLKDIV4_TRACEDIVEN_MASK) >> SIM_CLKDIV4_TRACEDIVEN_SHIFT)
#define SIM_BRD_CLKDIV4_TRACEDIVEN(base) (BME_UBFX32(&SIM_CLKDIV4_REG(base), SIM_CLKDIV4_TRACEDIVEN_SHIFT, SIM_CLKDIV4_TRACEDIVEN_WIDTH))

/*! @brief Set the TRACEDIVEN field to a new value. */
#define SIM_WR_CLKDIV4_TRACEDIVEN(base, value) (SIM_RMW_CLKDIV4(base, SIM_CLKDIV4_TRACEDIVEN_MASK, SIM_CLKDIV4_TRACEDIVEN(value)))
#define SIM_BWR_CLKDIV4_TRACEDIVEN(base, value) (BME_BFI32(&SIM_CLKDIV4_REG(base), ((uint32_t)(value) << SIM_CLKDIV4_TRACEDIVEN_SHIFT), SIM_CLKDIV4_TRACEDIVEN_SHIFT, SIM_CLKDIV4_TRACEDIVEN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_MISCTRL0 - Miscellaneous Control Register 0
 ******************************************************************************/

/*!
 * @brief SIM_MISCTRL0 - Miscellaneous Control Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_MISCTRL0 register
 */
/*@{*/
#define SIM_RD_MISCTRL0(base)    (SIM_MISCTRL0_REG(base))
#define SIM_WR_MISCTRL0(base, value) (SIM_MISCTRL0_REG(base) = (value))
#define SIM_RMW_MISCTRL0(base, mask, value) (SIM_WR_MISCTRL0(base, (SIM_RD_MISCTRL0(base) & ~(mask)) | (value)))
#define SIM_SET_MISCTRL0(base, value) (BME_OR32(&SIM_MISCTRL0_REG(base), (uint32_t)(value)))
#define SIM_CLR_MISCTRL0(base, value) (BME_AND32(&SIM_MISCTRL0_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_MISCTRL0(base, value) (BME_XOR32(&SIM_MISCTRL0_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_MISCTRL0 bitfields
 */

/*!
 * @name Register SIM_MISCTRL0, field CMPWIN0SRC[9:8] (RW)
 *
 * Values:
 * - 0b00 - XBARA output 16.
 * - 0b01 - CMP0 Sample/Window input is driven by both PDB0 and PDB1 pluse-out
 *     channel 0.
 * - 0b10 - PDB0 pluse-out channel 0.
 * - 0b11 - PDB1 pluse-out channel 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_CMPWIN0SRC field. */
#define SIM_RD_MISCTRL0_CMPWIN0SRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_CMPWIN0SRC_MASK) >> SIM_MISCTRL0_CMPWIN0SRC_SHIFT)
#define SIM_BRD_MISCTRL0_CMPWIN0SRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_CMPWIN0SRC_SHIFT, SIM_MISCTRL0_CMPWIN0SRC_WIDTH))

/*! @brief Set the CMPWIN0SRC field to a new value. */
#define SIM_WR_MISCTRL0_CMPWIN0SRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_CMPWIN0SRC_MASK, SIM_MISCTRL0_CMPWIN0SRC(value)))
#define SIM_BWR_MISCTRL0_CMPWIN0SRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_CMPWIN0SRC_SHIFT), SIM_MISCTRL0_CMPWIN0SRC_SHIFT, SIM_MISCTRL0_CMPWIN0SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL0, field CMPWIN1SRC[11:10] (RW)
 *
 * Values:
 * - 0b00 - XBARA output 17.
 * - 0b01 - CMP1 Sample/Window input is driven by both PDB0 and PDB1 pluse-out
 *     channel 1.
 * - 0b10 - PDB0 pluse-out channel 1.
 * - 0b11 - PDB1 pluse-out channel 1.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_CMPWIN1SRC field. */
#define SIM_RD_MISCTRL0_CMPWIN1SRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_CMPWIN1SRC_MASK) >> SIM_MISCTRL0_CMPWIN1SRC_SHIFT)
#define SIM_BRD_MISCTRL0_CMPWIN1SRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_CMPWIN1SRC_SHIFT, SIM_MISCTRL0_CMPWIN1SRC_WIDTH))

/*! @brief Set the CMPWIN1SRC field to a new value. */
#define SIM_WR_MISCTRL0_CMPWIN1SRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_CMPWIN1SRC_MASK, SIM_MISCTRL0_CMPWIN1SRC(value)))
#define SIM_BWR_MISCTRL0_CMPWIN1SRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_CMPWIN1SRC_SHIFT), SIM_MISCTRL0_CMPWIN1SRC_SHIFT, SIM_MISCTRL0_CMPWIN1SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL0, field CMPWIN2SRC[13:12] (RW)
 *
 * Values:
 * - 0b00 - XBARA output 18.
 * - 0b01 - CMP2 Sample/Window input is driven by both PDB0 and PDB1 pluse-out
 *     channel 2.
 * - 0b10 - PDB0 pluse-out channel 2.
 * - 0b11 - PDB1 pluse-out channel 2.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_CMPWIN2SRC field. */
#define SIM_RD_MISCTRL0_CMPWIN2SRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_CMPWIN2SRC_MASK) >> SIM_MISCTRL0_CMPWIN2SRC_SHIFT)
#define SIM_BRD_MISCTRL0_CMPWIN2SRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_CMPWIN2SRC_SHIFT, SIM_MISCTRL0_CMPWIN2SRC_WIDTH))

/*! @brief Set the CMPWIN2SRC field to a new value. */
#define SIM_WR_MISCTRL0_CMPWIN2SRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_CMPWIN2SRC_MASK, SIM_MISCTRL0_CMPWIN2SRC(value)))
#define SIM_BWR_MISCTRL0_CMPWIN2SRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_CMPWIN2SRC_SHIFT), SIM_MISCTRL0_CMPWIN2SRC_SHIFT, SIM_MISCTRL0_CMPWIN2SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL0, field CMPWIN3SRC[15:14] (RW)
 *
 * Values:
 * - 0b00 - XBARA output 19.
 * - 0b01 - CMP3 Sample/Window input is driven by both PDB0 and PDB1 pluse-out
 *     channel 3.
 * - 0b10 - PDB0 pluse-out channel 3.
 * - 0b11 - PDB1 pluse-out channel 3.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_CMPWIN3SRC field. */
#define SIM_RD_MISCTRL0_CMPWIN3SRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_CMPWIN3SRC_MASK) >> SIM_MISCTRL0_CMPWIN3SRC_SHIFT)
#define SIM_BRD_MISCTRL0_CMPWIN3SRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_CMPWIN3SRC_SHIFT, SIM_MISCTRL0_CMPWIN3SRC_WIDTH))

/*! @brief Set the CMPWIN3SRC field to a new value. */
#define SIM_WR_MISCTRL0_CMPWIN3SRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_CMPWIN3SRC_MASK, SIM_MISCTRL0_CMPWIN3SRC(value)))
#define SIM_BWR_MISCTRL0_CMPWIN3SRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_CMPWIN3SRC_SHIFT), SIM_MISCTRL0_CMPWIN3SRC_SHIFT, SIM_MISCTRL0_CMPWIN3SRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL0, field EWMINSRC[16] (RW)
 *
 * This bit controls the ewm_in source of EWM module.
 *
 * Values:
 * - 0b0 - XBARA output 58.
 * - 0b1 - EWM_IN pin
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_EWMINSRC field. */
#define SIM_RD_MISCTRL0_EWMINSRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_EWMINSRC_MASK) >> SIM_MISCTRL0_EWMINSRC_SHIFT)
#define SIM_BRD_MISCTRL0_EWMINSRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_EWMINSRC_SHIFT, SIM_MISCTRL0_EWMINSRC_WIDTH))

/*! @brief Set the EWMINSRC field to a new value. */
#define SIM_WR_MISCTRL0_EWMINSRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_EWMINSRC_MASK, SIM_MISCTRL0_EWMINSRC(value)))
#define SIM_BWR_MISCTRL0_EWMINSRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_EWMINSRC_SHIFT), SIM_MISCTRL0_EWMINSRC_SHIFT, SIM_MISCTRL0_EWMINSRC_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL0, field DACTRIGSRC[19:18] (RW)
 *
 * Values:
 * - 0b00 - XBARA output 15.
 * - 0b01 - DAC0 can be triggered by both PDB0 interval trigger 0 and PDB1
 *     interval trigger 0.
 * - 0b10 - PDB0 interval trigger 0
 * - 0b11 - PDB1 interval trigger 0
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL0_DACTRIGSRC field. */
#define SIM_RD_MISCTRL0_DACTRIGSRC(base) ((SIM_MISCTRL0_REG(base) & SIM_MISCTRL0_DACTRIGSRC_MASK) >> SIM_MISCTRL0_DACTRIGSRC_SHIFT)
#define SIM_BRD_MISCTRL0_DACTRIGSRC(base) (BME_UBFX32(&SIM_MISCTRL0_REG(base), SIM_MISCTRL0_DACTRIGSRC_SHIFT, SIM_MISCTRL0_DACTRIGSRC_WIDTH))

/*! @brief Set the DACTRIGSRC field to a new value. */
#define SIM_WR_MISCTRL0_DACTRIGSRC(base, value) (SIM_RMW_MISCTRL0(base, SIM_MISCTRL0_DACTRIGSRC_MASK, SIM_MISCTRL0_DACTRIGSRC(value)))
#define SIM_BWR_MISCTRL0_DACTRIGSRC(base, value) (BME_BFI32(&SIM_MISCTRL0_REG(base), ((uint32_t)(value) << SIM_MISCTRL0_DACTRIGSRC_SHIFT), SIM_MISCTRL0_DACTRIGSRC_SHIFT, SIM_MISCTRL0_DACTRIGSRC_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_MISCTRL1 - Miscellaneous Control Register 1
 ******************************************************************************/

/*!
 * @brief SIM_MISCTRL1 - Miscellaneous Control Register 1 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_MISCTRL1 register
 */
/*@{*/
#define SIM_RD_MISCTRL1(base)    (SIM_MISCTRL1_REG(base))
#define SIM_WR_MISCTRL1(base, value) (SIM_MISCTRL1_REG(base) = (value))
#define SIM_RMW_MISCTRL1(base, mask, value) (SIM_WR_MISCTRL1(base, (SIM_RD_MISCTRL1(base) & ~(mask)) | (value)))
#define SIM_SET_MISCTRL1(base, value) (BME_OR32(&SIM_MISCTRL1_REG(base), (uint32_t)(value)))
#define SIM_CLR_MISCTRL1(base, value) (BME_AND32(&SIM_MISCTRL1_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_MISCTRL1(base, value) (BME_XOR32(&SIM_MISCTRL1_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_MISCTRL1 bitfields
 */

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARAPITTRIG0[8] (RW)
 *
 * This field controls the synchronizer between PIT trigger 0 and XBARA's input.
 * Set this bit if the XBARA's input PIT trigger 0 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARAPITTRIG0 field. */
#define SIM_RD_MISCTRL1_SYNCXBARAPITTRIG0(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARAPITTRIG0_MASK) >> SIM_MISCTRL1_SYNCXBARAPITTRIG0_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARAPITTRIG0(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARAPITTRIG0_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG0_WIDTH))

/*! @brief Set the SYNCXBARAPITTRIG0 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARAPITTRIG0(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARAPITTRIG0_MASK, SIM_MISCTRL1_SYNCXBARAPITTRIG0(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARAPITTRIG0(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARAPITTRIG0_SHIFT), SIM_MISCTRL1_SYNCXBARAPITTRIG0_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARAPITTRIG1[9] (RW)
 *
 * This field controls the synchronizer between PIT trigger 1 and XBARA's input.
 * Set this bit if the XBARA's input PIT trigger 1 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARAPITTRIG1 field. */
#define SIM_RD_MISCTRL1_SYNCXBARAPITTRIG1(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARAPITTRIG1_MASK) >> SIM_MISCTRL1_SYNCXBARAPITTRIG1_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARAPITTRIG1(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARAPITTRIG1_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG1_WIDTH))

/*! @brief Set the SYNCXBARAPITTRIG1 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARAPITTRIG1(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARAPITTRIG1_MASK, SIM_MISCTRL1_SYNCXBARAPITTRIG1(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARAPITTRIG1(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARAPITTRIG1_SHIFT), SIM_MISCTRL1_SYNCXBARAPITTRIG1_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARAPITTRIG2[10] (RW)
 *
 * This field controls the synchronizer between PIT trigger 2 and XBARA's input.
 * Set this bit if the XBARA's input PIT trigger 2 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARAPITTRIG2 field. */
#define SIM_RD_MISCTRL1_SYNCXBARAPITTRIG2(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARAPITTRIG2_MASK) >> SIM_MISCTRL1_SYNCXBARAPITTRIG2_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARAPITTRIG2(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARAPITTRIG2_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG2_WIDTH))

/*! @brief Set the SYNCXBARAPITTRIG2 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARAPITTRIG2(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARAPITTRIG2_MASK, SIM_MISCTRL1_SYNCXBARAPITTRIG2(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARAPITTRIG2(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARAPITTRIG2_SHIFT), SIM_MISCTRL1_SYNCXBARAPITTRIG2_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG2_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARAPITTRIG3[11] (RW)
 *
 * This field controls the synchronizer between PIT trigger 3 and XBARA's input.
 * Set this bit if the XBARA's input PIT trigger 3 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARAPITTRIG3 field. */
#define SIM_RD_MISCTRL1_SYNCXBARAPITTRIG3(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARAPITTRIG3_MASK) >> SIM_MISCTRL1_SYNCXBARAPITTRIG3_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARAPITTRIG3(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARAPITTRIG3_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG3_WIDTH))

/*! @brief Set the SYNCXBARAPITTRIG3 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARAPITTRIG3(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARAPITTRIG3_MASK, SIM_MISCTRL1_SYNCXBARAPITTRIG3(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARAPITTRIG3(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARAPITTRIG3_SHIFT), SIM_MISCTRL1_SYNCXBARAPITTRIG3_SHIFT, SIM_MISCTRL1_SYNCXBARAPITTRIG3_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARBPITTRIG0[12] (RW)
 *
 * This field controls the synchronizer between PIT trigger 0 and XBARB's input.
 * Set this bit if the XBARB's input PIT trigger 0 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARBPITTRIG0 field. */
#define SIM_RD_MISCTRL1_SYNCXBARBPITTRIG0(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARBPITTRIG0_MASK) >> SIM_MISCTRL1_SYNCXBARBPITTRIG0_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARBPITTRIG0(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARBPITTRIG0_SHIFT, SIM_MISCTRL1_SYNCXBARBPITTRIG0_WIDTH))

/*! @brief Set the SYNCXBARBPITTRIG0 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARBPITTRIG0(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARBPITTRIG0_MASK, SIM_MISCTRL1_SYNCXBARBPITTRIG0(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARBPITTRIG0(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARBPITTRIG0_SHIFT), SIM_MISCTRL1_SYNCXBARBPITTRIG0_SHIFT, SIM_MISCTRL1_SYNCXBARBPITTRIG0_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCXBARBPITTRIG1[13] (RW)
 *
 * This field controls the synchronizer between PIT trigger 1 and XBARB's input.
 * Set this bit if the XBARB's input PIT trigger 1 is fed into fast peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCXBARBPITTRIG1 field. */
#define SIM_RD_MISCTRL1_SYNCXBARBPITTRIG1(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCXBARBPITTRIG1_MASK) >> SIM_MISCTRL1_SYNCXBARBPITTRIG1_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCXBARBPITTRIG1(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCXBARBPITTRIG1_SHIFT, SIM_MISCTRL1_SYNCXBARBPITTRIG1_WIDTH))

/*! @brief Set the SYNCXBARBPITTRIG1 field to a new value. */
#define SIM_WR_MISCTRL1_SYNCXBARBPITTRIG1(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCXBARBPITTRIG1_MASK, SIM_MISCTRL1_SYNCXBARBPITTRIG1(value)))
#define SIM_BWR_MISCTRL1_SYNCXBARBPITTRIG1(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCXBARBPITTRIG1_SHIFT), SIM_MISCTRL1_SYNCXBARBPITTRIG1_SHIFT, SIM_MISCTRL1_SYNCXBARBPITTRIG1_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCDACHWTRIG[16] (RW)
 *
 * This field controls the synchronizer between XBARA's output and DAC hardware
 * trigger. Set this bit if the DAC hardware trigger isn't from flash/slow
 * peripherials through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCDACHWTRIG field. */
#define SIM_RD_MISCTRL1_SYNCDACHWTRIG(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCDACHWTRIG_MASK) >> SIM_MISCTRL1_SYNCDACHWTRIG_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCDACHWTRIG(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCDACHWTRIG_SHIFT, SIM_MISCTRL1_SYNCDACHWTRIG_WIDTH))

/*! @brief Set the SYNCDACHWTRIG field to a new value. */
#define SIM_WR_MISCTRL1_SYNCDACHWTRIG(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCDACHWTRIG_MASK, SIM_MISCTRL1_SYNCDACHWTRIG(value)))
#define SIM_BWR_MISCTRL1_SYNCDACHWTRIG(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCDACHWTRIG_SHIFT), SIM_MISCTRL1_SYNCDACHWTRIG_SHIFT, SIM_MISCTRL1_SYNCDACHWTRIG_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCEWMIN[17] (RW)
 *
 * This field controls the synchronizer between XBARA's output and EWM's ewm_in
 * input. Set this bit if the EWM's ewm_in isn't from flash/slow peripherials
 * through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCEWMIN field. */
#define SIM_RD_MISCTRL1_SYNCEWMIN(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCEWMIN_MASK) >> SIM_MISCTRL1_SYNCEWMIN_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCEWMIN(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCEWMIN_SHIFT, SIM_MISCTRL1_SYNCEWMIN_WIDTH))

/*! @brief Set the SYNCEWMIN field to a new value. */
#define SIM_WR_MISCTRL1_SYNCEWMIN(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCEWMIN_MASK, SIM_MISCTRL1_SYNCEWMIN(value)))
#define SIM_BWR_MISCTRL1_SYNCEWMIN(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCEWMIN_SHIFT), SIM_MISCTRL1_SYNCEWMIN_SHIFT, SIM_MISCTRL1_SYNCEWMIN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCCMP0SAMPLEWIN[20] (RW)
 *
 * This field controls the synchronizer between XBARA's output and CMP0's
 * sample/window input. Set this bit if the CMP0's sample/window input isn't from
 * flash/slow peripherials through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCCMP0SAMPLEWIN field. */
#define SIM_RD_MISCTRL1_SYNCCMP0SAMPLEWIN(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_MASK) >> SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCCMP0SAMPLEWIN(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_WIDTH))

/*! @brief Set the SYNCCMP0SAMPLEWIN field to a new value. */
#define SIM_WR_MISCTRL1_SYNCCMP0SAMPLEWIN(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_MASK, SIM_MISCTRL1_SYNCCMP0SAMPLEWIN(value)))
#define SIM_BWR_MISCTRL1_SYNCCMP0SAMPLEWIN(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_SHIFT), SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP0SAMPLEWIN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCCMP1SAMPLEWIN[21] (RW)
 *
 * This field controls the synchronizer between XBARA's output and CMP1's
 * sample/window input. Set this bit if the CMP1's sample/window input isn't from
 * flash/slow peripherials through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCCMP1SAMPLEWIN field. */
#define SIM_RD_MISCTRL1_SYNCCMP1SAMPLEWIN(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_MASK) >> SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCCMP1SAMPLEWIN(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_WIDTH))

/*! @brief Set the SYNCCMP1SAMPLEWIN field to a new value. */
#define SIM_WR_MISCTRL1_SYNCCMP1SAMPLEWIN(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_MASK, SIM_MISCTRL1_SYNCCMP1SAMPLEWIN(value)))
#define SIM_BWR_MISCTRL1_SYNCCMP1SAMPLEWIN(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_SHIFT), SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP1SAMPLEWIN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCCMP2SAMPLEWIN[22] (RW)
 *
 * This field controls the synchronizer between XBARA's output and CMP2's
 * sample/window input. Set this bit if the CMP2's sample/window input isn't from
 * flash/slow peripherials through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCCMP2SAMPLEWIN field. */
#define SIM_RD_MISCTRL1_SYNCCMP2SAMPLEWIN(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_MASK) >> SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCCMP2SAMPLEWIN(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_WIDTH))

/*! @brief Set the SYNCCMP2SAMPLEWIN field to a new value. */
#define SIM_WR_MISCTRL1_SYNCCMP2SAMPLEWIN(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_MASK, SIM_MISCTRL1_SYNCCMP2SAMPLEWIN(value)))
#define SIM_BWR_MISCTRL1_SYNCCMP2SAMPLEWIN(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_SHIFT), SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP2SAMPLEWIN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_MISCTRL1, field SYNCCMP3SAMPLEWIN[23] (RW)
 *
 * This field controls the synchronizer between XBARA's output and CMP3's
 * sample/window input. Set this bit if the CMP3's sample/window input isn't from
 * flash/slow peripherials through xbar.
 *
 * Values:
 * - 0b0 - Disable, bypass synchronizer.
 * - 0b1 - Enable.
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCTRL1_SYNCCMP3SAMPLEWIN field. */
#define SIM_RD_MISCTRL1_SYNCCMP3SAMPLEWIN(base) ((SIM_MISCTRL1_REG(base) & SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_MASK) >> SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_SHIFT)
#define SIM_BRD_MISCTRL1_SYNCCMP3SAMPLEWIN(base) (BME_UBFX32(&SIM_MISCTRL1_REG(base), SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_WIDTH))

/*! @brief Set the SYNCCMP3SAMPLEWIN field to a new value. */
#define SIM_WR_MISCTRL1_SYNCCMP3SAMPLEWIN(base, value) (SIM_RMW_MISCTRL1(base, SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_MASK, SIM_MISCTRL1_SYNCCMP3SAMPLEWIN(value)))
#define SIM_BWR_MISCTRL1_SYNCCMP3SAMPLEWIN(base, value) (BME_BFI32(&SIM_MISCTRL1_REG(base), ((uint32_t)(value) << SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_SHIFT), SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_SHIFT, SIM_MISCTRL1_SYNCCMP3SAMPLEWIN_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_WDOGC - WDOG Control Register
 ******************************************************************************/

/*!
 * @brief SIM_WDOGC - WDOG Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_WDOGC register
 */
/*@{*/
#define SIM_RD_WDOGC(base)       (SIM_WDOGC_REG(base))
#define SIM_WR_WDOGC(base, value) (SIM_WDOGC_REG(base) = (value))
#define SIM_RMW_WDOGC(base, mask, value) (SIM_WR_WDOGC(base, (SIM_RD_WDOGC(base) & ~(mask)) | (value)))
#define SIM_SET_WDOGC(base, value) (BME_OR32(&SIM_WDOGC_REG(base), (uint32_t)(value)))
#define SIM_CLR_WDOGC(base, value) (BME_AND32(&SIM_WDOGC_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_WDOGC(base, value) (BME_XOR32(&SIM_WDOGC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_WDOGC bitfields
 */

/*!
 * @name Register SIM_WDOGC, field WDOGCLKS[1] (RW)
 *
 * This write-once bit selects the clock source of the WDOG watchdog. This is
 * the choice of two alternative clock sources that goto the ALTCLK of the WDOG.
 *
 * Values:
 * - 0b0 - 1 kHz LPO clock is source to WDOG
 * - 0b1 - MCGIRCLK is source to WDOG
 */
/*@{*/
/*! @brief Read current value of the SIM_WDOGC_WDOGCLKS field. */
#define SIM_RD_WDOGC_WDOGCLKS(base) ((SIM_WDOGC_REG(base) & SIM_WDOGC_WDOGCLKS_MASK) >> SIM_WDOGC_WDOGCLKS_SHIFT)
#define SIM_BRD_WDOGC_WDOGCLKS(base) (BME_UBFX32(&SIM_WDOGC_REG(base), SIM_WDOGC_WDOGCLKS_SHIFT, SIM_WDOGC_WDOGCLKS_WIDTH))

/*! @brief Set the WDOGCLKS field to a new value. */
#define SIM_WR_WDOGC_WDOGCLKS(base, value) (SIM_RMW_WDOGC(base, SIM_WDOGC_WDOGCLKS_MASK, SIM_WDOGC_WDOGCLKS(value)))
#define SIM_BWR_WDOGC_WDOGCLKS(base, value) (BME_BFI32(&SIM_WDOGC_REG(base), ((uint32_t)(value) << SIM_WDOGC_WDOGCLKS_SHIFT), SIM_WDOGC_WDOGCLKS_SHIFT, SIM_WDOGC_WDOGCLKS_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_PWRC - Power Control Register
 ******************************************************************************/

/*!
 * @brief SIM_PWRC - Power Control Register (RW)
 *
 * Reset value: 0x00000101U
 *
 * Setting PMC_REGSC[BGBE] before nanoedge regulator is enabled, because the
 * regulator uses 1v reference of PMC.
 */
/*!
 * @name Constants and macros for entire SIM_PWRC register
 */
/*@{*/
#define SIM_RD_PWRC(base)        (SIM_PWRC_REG(base))
#define SIM_WR_PWRC(base, value) (SIM_PWRC_REG(base) = (value))
#define SIM_RMW_PWRC(base, mask, value) (SIM_WR_PWRC(base, (SIM_RD_PWRC(base) & ~(mask)) | (value)))
#define SIM_SET_PWRC(base, value) (BME_OR32(&SIM_PWRC_REG(base), (uint32_t)(value)))
#define SIM_CLR_PWRC(base, value) (BME_AND32(&SIM_PWRC_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_PWRC(base, value) (BME_XOR32(&SIM_PWRC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_PWRC bitfields
 */

/*!
 * @name Register SIM_PWRC, field SRPDN[1:0] (RW)
 *
 * This field controls the powerdown mode of the 2.7V and 1.2V supply from the
 * nanoedge voltage regulator. Powerdown mode shuts down the 2.7V and 1.2V
 * regulated supply from the nanoedge regulator and eliminates its power consumption.
 * Analog modules powered by this supply should themselves be powered down before
 * entering this mode.
 *
 * Values:
 * - 0b00 - Nanoedge regulator placed in normal mode.
 * - 0b01 - Nanoedge regulator placed in powerdown mode.
 * - 0b10 - Nanoedge regulator placed in normal mode and SRPDN is write
 *     protected until chip reset.
 * - 0b11 - Nanoedge regulator placed in powerdown mode and SRPDN is write
 *     protected until chip reset.
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SRPDN field. */
#define SIM_RD_PWRC_SRPDN(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SRPDN_MASK) >> SIM_PWRC_SRPDN_SHIFT)
#define SIM_BRD_PWRC_SRPDN(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SRPDN_SHIFT, SIM_PWRC_SRPDN_WIDTH))

/*! @brief Set the SRPDN field to a new value. */
#define SIM_WR_PWRC_SRPDN(base, value) (SIM_RMW_PWRC(base, SIM_PWRC_SRPDN_MASK, SIM_PWRC_SRPDN(value)))
#define SIM_BWR_PWRC_SRPDN(base, value) (BME_BFI32(&SIM_PWRC_REG(base), ((uint32_t)(value) << SIM_PWRC_SRPDN_SHIFT), SIM_PWRC_SRPDN_SHIFT, SIM_PWRC_SRPDN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_PWRC, field SR27STDBY[3:2] (RW)
 *
 * This field controls the standby mode of the 2.7 V supply from the nanoedge
 * voltage regulator. Standby mode has restricted drive capacity but substantially
 * reduces power consumption. The field value can be optionally write protected.
 *
 * Values:
 * - 0b00 - Nanoedge regulator 2.7 V placed in normal mode.
 * - 0b01 - Nanoedge regulator 2.7 V placed in standby mode.
 * - 0b10 - Nanoedge regulator 2.7 V supply placed in normal mode and SR27STDBY
 *     is write protected until chip reset.
 * - 0b11 - Nanoedge regulator 2.7 V supply placed in standby mode and SR27STDBY
 *     is write protected until chip reset.
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SR27STDBY field. */
#define SIM_RD_PWRC_SR27STDBY(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SR27STDBY_MASK) >> SIM_PWRC_SR27STDBY_SHIFT)
#define SIM_BRD_PWRC_SR27STDBY(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SR27STDBY_SHIFT, SIM_PWRC_SR27STDBY_WIDTH))

/*! @brief Set the SR27STDBY field to a new value. */
#define SIM_WR_PWRC_SR27STDBY(base, value) (SIM_RMW_PWRC(base, SIM_PWRC_SR27STDBY_MASK, SIM_PWRC_SR27STDBY(value)))
#define SIM_BWR_PWRC_SR27STDBY(base, value) (BME_BFI32(&SIM_PWRC_REG(base), ((uint32_t)(value) << SIM_PWRC_SR27STDBY_SHIFT), SIM_PWRC_SR27STDBY_SHIFT, SIM_PWRC_SR27STDBY_WIDTH))
/*@}*/

/*!
 * @name Register SIM_PWRC, field SR12STDBY[7:6] (RW)
 *
 * This field controls the standby mode of the 1.2 V supply from the nanoedge
 * voltage regulator. Standby mode has restricted drive capacity but substantially
 * reduces power consumption. The field value can be optionally write protected.
 *
 * Values:
 * - 0b00 - Nanoedge regulator 1.2 V supply placed in normal mode
 * - 0b01 - Nanoedge regulator 1.2 V supply placed in standby mode.
 * - 0b10 - Nanoedge regulator 1.2 V supply placed in normal mode and SR12STDBY
 *     is write protected until chip reset.
 * - 0b11 - Nanoedge regulator 1.2 V supply placed in standby mode and SR12STDBY
 *     is write protected until chip reset.
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SR12STDBY field. */
#define SIM_RD_PWRC_SR12STDBY(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SR12STDBY_MASK) >> SIM_PWRC_SR12STDBY_SHIFT)
#define SIM_BRD_PWRC_SR12STDBY(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SR12STDBY_SHIFT, SIM_PWRC_SR12STDBY_WIDTH))

/*! @brief Set the SR12STDBY field to a new value. */
#define SIM_WR_PWRC_SR12STDBY(base, value) (SIM_RMW_PWRC(base, SIM_PWRC_SR12STDBY_MASK, SIM_PWRC_SR12STDBY(value)))
#define SIM_BWR_PWRC_SR12STDBY(base, value) (BME_BFI32(&SIM_PWRC_REG(base), ((uint32_t)(value) << SIM_PWRC_SR12STDBY_SHIFT), SIM_PWRC_SR12STDBY_SHIFT, SIM_PWRC_SR12STDBY_WIDTH))
/*@}*/

/*!
 * @name Register SIM_PWRC, field SRPWRDETEN[8] (RW)
 *
 * Write 1 to enable Nanoedge PMC power dectect to assert PMC ready signal when
 * PMC is stable.
 *
 * Values:
 * - 0b0 - Disable
 * - 0b1 - Enable
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SRPWRDETEN field. */
#define SIM_RD_PWRC_SRPWRDETEN(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SRPWRDETEN_MASK) >> SIM_PWRC_SRPWRDETEN_SHIFT)
#define SIM_BRD_PWRC_SRPWRDETEN(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SRPWRDETEN_SHIFT, SIM_PWRC_SRPWRDETEN_WIDTH))

/*! @brief Set the SRPWRDETEN field to a new value. */
#define SIM_WR_PWRC_SRPWRDETEN(base, value) (SIM_RMW_PWRC(base, SIM_PWRC_SRPWRDETEN_MASK, SIM_PWRC_SRPWRDETEN(value)))
#define SIM_BWR_PWRC_SRPWRDETEN(base, value) (BME_BFI32(&SIM_PWRC_REG(base), ((uint32_t)(value) << SIM_PWRC_SRPWRDETEN_SHIFT), SIM_PWRC_SRPWRDETEN_SHIFT, SIM_PWRC_SRPWRDETEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_PWRC, field SRPWRRDY[9] (RW)
 *
 * This bit is soft control to indicate nanoedge PMC is ready when PMC Power
 * dectect is disabled by SRPWRDETEN.
 *
 * Values:
 * - 0b0 - Not ready
 * - 0b1 - Assert PMC power output ready
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SRPWRRDY field. */
#define SIM_RD_PWRC_SRPWRRDY(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SRPWRRDY_MASK) >> SIM_PWRC_SRPWRRDY_SHIFT)
#define SIM_BRD_PWRC_SRPWRRDY(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SRPWRRDY_SHIFT, SIM_PWRC_SRPWRRDY_WIDTH))

/*! @brief Set the SRPWRRDY field to a new value. */
#define SIM_WR_PWRC_SRPWRRDY(base, value) (SIM_RMW_PWRC(base, SIM_PWRC_SRPWRRDY_MASK, SIM_PWRC_SRPWRRDY(value)))
#define SIM_BWR_PWRC_SRPWRRDY(base, value) (BME_BFI32(&SIM_PWRC_REG(base), ((uint32_t)(value) << SIM_PWRC_SRPWRRDY_SHIFT), SIM_PWRC_SRPWRRDY_SHIFT, SIM_PWRC_SRPWRRDY_WIDTH))
/*@}*/

/*!
 * @name Register SIM_PWRC, field SRPWROK[16] (RO)
 *
 * Values:
 * - 0b0 - Power supply for nanoedge isn't ready.
 * - 0b1 - Power supply for nanoedge is OK.
 */
/*@{*/
/*! @brief Read current value of the SIM_PWRC_SRPWROK field. */
#define SIM_RD_PWRC_SRPWROK(base) ((SIM_PWRC_REG(base) & SIM_PWRC_SRPWROK_MASK) >> SIM_PWRC_SRPWROK_SHIFT)
#define SIM_BRD_PWRC_SRPWROK(base) (BME_UBFX32(&SIM_PWRC_REG(base), SIM_PWRC_SRPWROK_SHIFT, SIM_PWRC_SRPWROK_WIDTH))
/*@}*/

/*******************************************************************************
 * SIM_ADCOPT - ADC Additional Option Register
 ******************************************************************************/

/*!
 * @brief SIM_ADCOPT - ADC Additional Option Register (RW)
 *
 * Reset value: 0x04000000U
 */
/*!
 * @name Constants and macros for entire SIM_ADCOPT register
 */
/*@{*/
#define SIM_RD_ADCOPT(base)      (SIM_ADCOPT_REG(base))
#define SIM_WR_ADCOPT(base, value) (SIM_ADCOPT_REG(base) = (value))
#define SIM_RMW_ADCOPT(base, mask, value) (SIM_WR_ADCOPT(base, (SIM_RD_ADCOPT(base) & ~(mask)) | (value)))
#define SIM_SET_ADCOPT(base, value) (BME_OR32(&SIM_ADCOPT_REG(base), (uint32_t)(value)))
#define SIM_CLR_ADCOPT(base, value) (BME_AND32(&SIM_ADCOPT_REG(base), (uint32_t)(~(value))))
#define SIM_TOG_ADCOPT(base, value) (BME_XOR32(&SIM_ADCOPT_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SIM_ADCOPT bitfields
 */

/*!
 * @name Register SIM_ADCOPT, field ADC0TRGSEL[19:16] (RW)
 *
 * Selects the ADC0 trigger source when alternative triggers are functional in
 * stop modes.
 *
 * Values:
 * - 0b0000 - PDB0 external trigger pin input (PDB0_EXTRG)
 * - 0b0001 - High speed comparator 0 output
 * - 0b0010 - High speed comparator 1 output
 * - 0b0011 - High speed comparator 2 output
 * - 0b0100 - PIT trigger 0
 * - 0b0101 - PIT trigger 1
 * - 0b0110 - PIT trigger 2
 * - 0b0111 - PIT trigger 3
 * - 0b1000 - FTM0 trigger
 * - 0b1001 - FTM1 trigger
 * - 0b1010 - FTM2 trigger
 * - 0b1011 - FTM3 trigger
 * - 0b1100 - XBARA output 38
 * - 0b1101 - Reserved
 * - 0b1110 - Low-power timer (LPTMR) trigger
 * - 0b1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0TRGSEL field. */
#define SIM_RD_ADCOPT_ADC0TRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0TRGSEL_MASK) >> SIM_ADCOPT_ADC0TRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC0TRGSEL(base) (BME_UBFX32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC0TRGSEL_SHIFT, SIM_ADCOPT_ADC0TRGSEL_WIDTH))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC0TRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0TRGSEL_MASK, SIM_ADCOPT_ADC0TRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC0TRGSEL(base, value) (BME_BFI32(&SIM_ADCOPT_REG(base), ((uint32_t)(value) << SIM_ADCOPT_ADC0TRGSEL_SHIFT), SIM_ADCOPT_ADC0TRGSEL_SHIFT, SIM_ADCOPT_ADC0TRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC0PRETRGSEL[20] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN or XBARA output 39 is selected
 *
 * Values:
 * - 0b0 - Pre-trigger A
 * - 0b1 - Pre-trigger B
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0PRETRGSEL field. */
#define SIM_RD_ADCOPT_ADC0PRETRGSEL(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0PRETRGSEL_MASK) >> SIM_ADCOPT_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_ADCOPT_ADC0PRETRGSEL(base) (BME_UBFX32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC0PRETRGSEL_SHIFT, SIM_ADCOPT_ADC0PRETRGSEL_WIDTH))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_ADCOPT_ADC0PRETRGSEL(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0PRETRGSEL_MASK, SIM_ADCOPT_ADC0PRETRGSEL(value)))
#define SIM_BWR_ADCOPT_ADC0PRETRGSEL(base, value) (BME_BFI32(&SIM_ADCOPT_REG(base), ((uint32_t)(value) << SIM_ADCOPT_ADC0PRETRGSEL_SHIFT), SIM_ADCOPT_ADC0PRETRGSEL_SHIFT, SIM_ADCOPT_ADC0PRETRGSEL_WIDTH))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field ADC0ALTTRGEN[23:22] (RW)
 *
 * Enable alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0b00 - XBARA output 39.
 * - 0b01 - PDB0 channel1 trigger selected for ADC0
 * - 0b10 - PDB1 channel0 trigger selected for ADC0
 * - 0b11 - Alternate trigger selected for ADC0 as defined by ADC0TRGSEL.
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_ADC0ALTTRGEN field. */
#define SIM_RD_ADCOPT_ADC0ALTTRGEN(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_ADC0ALTTRGEN_MASK) >> SIM_ADCOPT_ADC0ALTTRGEN_SHIFT)
#define SIM_BRD_ADCOPT_ADC0ALTTRGEN(base) (BME_UBFX32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_ADC0ALTTRGEN_SHIFT, SIM_ADCOPT_ADC0ALTTRGEN_WIDTH))

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define SIM_WR_ADCOPT_ADC0ALTTRGEN(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_ADC0ALTTRGEN_MASK, SIM_ADCOPT_ADC0ALTTRGEN(value)))
#define SIM_BWR_ADCOPT_ADC0ALTTRGEN(base, value) (BME_BFI32(&SIM_ADCOPT_REG(base), ((uint32_t)(value) << SIM_ADCOPT_ADC0ALTTRGEN_SHIFT), SIM_ADCOPT_ADC0ALTTRGEN_SHIFT, SIM_ADCOPT_ADC0ALTTRGEN_WIDTH))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field HSADCIRCLK[25] (RO)
 *
 * Indicates which clock is fed in the HSADCs. Can't access HSADC's registers
 * when this bit is "1". This bit is used in STOP/VLPS mode to make sure if the
 * HSADC clock is switched to the expected clock.
 *
 * Values:
 * - 0b0 - HSADC clock is Core/System clock.
 * - 0b1 - HSADC clock is MCGIRCLK.
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_HSADCIRCLK field. */
#define SIM_RD_ADCOPT_HSADCIRCLK(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_HSADCIRCLK_MASK) >> SIM_ADCOPT_HSADCIRCLK_SHIFT)
#define SIM_BRD_ADCOPT_HSADCIRCLK(base) (BME_UBFX32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_HSADCIRCLK_SHIFT, SIM_ADCOPT_HSADCIRCLK_WIDTH))
/*@}*/

/*!
 * @name Register SIM_ADCOPT, field HSADCSTOPEN[26] (RW)
 *
 * Controls whether HSADCs can run in STOP mode. If this bit is set HSADC0A,
 * HSADC0B, HSADC1A and HSADC1B can function in STOP mode or PSTOP mode with
 * MCGIRCLK.
 *
 * Values:
 * - 0b0 - HSADCs stopsin system STOP modes
 * - 0b1 - HSADCs can be enabled in system STOP modes
 */
/*@{*/
/*! @brief Read current value of the SIM_ADCOPT_HSADCSTOPEN field. */
#define SIM_RD_ADCOPT_HSADCSTOPEN(base) ((SIM_ADCOPT_REG(base) & SIM_ADCOPT_HSADCSTOPEN_MASK) >> SIM_ADCOPT_HSADCSTOPEN_SHIFT)
#define SIM_BRD_ADCOPT_HSADCSTOPEN(base) (BME_UBFX32(&SIM_ADCOPT_REG(base), SIM_ADCOPT_HSADCSTOPEN_SHIFT, SIM_ADCOPT_HSADCSTOPEN_WIDTH))

/*! @brief Set the HSADCSTOPEN field to a new value. */
#define SIM_WR_ADCOPT_HSADCSTOPEN(base, value) (SIM_RMW_ADCOPT(base, SIM_ADCOPT_HSADCSTOPEN_MASK, SIM_ADCOPT_HSADCSTOPEN(value)))
#define SIM_BWR_ADCOPT_HSADCSTOPEN(base, value) (BME_BFI32(&SIM_ADCOPT_REG(base), ((uint32_t)(value) << SIM_ADCOPT_HSADCSTOPEN_SHIFT), SIM_ADCOPT_HSADCSTOPEN_SHIFT, SIM_ADCOPT_HSADCSTOPEN_WIDTH))
/*@}*/

/*
 * MKV58F24 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x20U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (BME_OR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMPROT(base, value) (BME_AND8(&SMC_PMPROT_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMPROT(base, value) (BME_XOR8(&SMC_PMPROT_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0b0 - Any VLLSx mode is not allowed
 * - 0b1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLLS_SHIFT), SMC_PMPROT_AVLLS_SHIFT, SMC_PMPROT_AVLLS_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0b0 - VLPR, VLPW, and VLPS are not allowed.
 * - 0b1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AVLP_SHIFT), SMC_PMPROT_AVLP_SHIFT, SMC_PMPROT_AVLP_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AHSRUN[7] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter High Speed Run mode (HSRUN).
 *
 * Values:
 * - 0b0 - HSRUN is not allowed
 * - 0b1 - HSRUN is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AHSRUN field. */
#define SMC_RD_PMPROT_AHSRUN(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AHSRUN_MASK) >> SMC_PMPROT_AHSRUN_SHIFT)
#define SMC_BRD_PMPROT_AHSRUN(base) (BME_UBFX8(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT, SMC_PMPROT_AHSRUN_WIDTH))

/*! @brief Set the AHSRUN field to a new value. */
#define SMC_WR_PMPROT_AHSRUN(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AHSRUN_MASK, SMC_PMPROT_AHSRUN(value)))
#define SMC_BWR_PMPROT_AHSRUN(base, value) (BME_BFI8(&SMC_PMPROT_REG(base), ((uint8_t)(value) << SMC_PMPROT_AHSRUN_SHIFT), SMC_PMPROT_AHSRUN_SHIFT, SMC_PMPROT_AHSRUN_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x40U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (BME_OR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_PMCTRL(base, value) (BME_AND8(&SMC_PMCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_PMCTRL(base, value) (BME_XOR8(&SMC_PMCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSx, the VLLSM field in the STOPCTRL
 * register is used to further select the particular VLLS submode which will be
 * entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be used to
 * select a Partial Stop mode if desired.
 *
 * Values:
 * - 0b000 - Normal Stop (STOP)
 * - 0b001 - Reserved
 * - 0b010 - Very-Low-Power Stop (VLPS)
 * - 0b011 - Reserved
 * - 0b100 - Very-Low-Leakage Stop (VLLSx)
 * - 0b101 - Reserved
 * - 0b110 - Reseved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_STOPM_SHIFT), SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt occured during the
 * previous stop mode entry sequence, preventing the system from entering that
 * mode. This field is cleared by reset or by hardware at the beginning of any
 * stop mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0b0 - The previous stop mode entry was successful.
 * - 0b1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT, SMC_PMCTRL_STOPA_WIDTH))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR. RUNM may be set to
 * HSRUN only when PMSTAT=RUN. After being programmed to HSRUN, RUNM should not
 * be programmed back to RUN until PMSTAT=HSRUN. Also, stop mode entry should not
 * be attempted while RUNM=HSRUN or PMSTAT=HSRUN.
 *
 * Values:
 * - 0b00 - Normal Run mode (RUN)
 * - 0b01 - Reserved
 * - 0b10 - Very-Low-Power Run mode (VLPR)
 * - 0b11 - High Speed Run mode (HSRUN)
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (BME_UBFX8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (BME_BFI8(&SMC_PMCTRL_REG(base), ((uint8_t)(value) << SMC_PMCTRL_RUNM_SHIFT), SMC_PMCTRL_RUNM_SHIFT, SMC_PMCTRL_RUNM_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (BME_OR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
#define SMC_CLR_STOPCTRL(base, value) (BME_AND8(&SMC_STOPCTRL_REG(base), (uint8_t)(~(value))))
#define SMC_TOG_STOPCTRL(base, value) (BME_XOR8(&SMC_STOPCTRL_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field VLLSM[2:0] (RW)
 *
 * This field controls which VLLS sub-mode to enter if STOPM = VLLSx.
 *
 * Values:
 * - 0b000 - VLLS0
 * - 0b001 - VLLS1
 * - 0b010 - VLLS2
 * - 0b011 - VLLS3
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_VLLSM field. */
#define SMC_RD_STOPCTRL_VLLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_VLLSM_MASK) >> SMC_STOPCTRL_VLLSM_SHIFT)
#define SMC_BRD_STOPCTRL_VLLSM(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))

/*! @brief Set the VLLSM field to a new value. */
#define SMC_WR_STOPCTRL_VLLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_VLLSM_MASK, SMC_STOPCTRL_VLLSM(value)))
#define SMC_BWR_STOPCTRL_VLLSM(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_VLLSM_SHIFT), SMC_STOPCTRL_VLLSM_SHIFT, SMC_STOPCTRL_VLLSM_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field LPOPO[3] (RW)
 *
 * Controls whether the 1 kHz LPO clock is enabled in VLLSx modes. During VLLS0
 * mode, the LPO clock is disabled by hardware and this bit has no effect.
 *
 * Values:
 * - 0b0 - LPO clock is enabled in VLLSx
 * - 0b1 - LPO clock is disabled in VLLSx
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LPOPO field. */
#define SMC_RD_STOPCTRL_LPOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LPOPO_MASK) >> SMC_STOPCTRL_LPOPO_SHIFT)
#define SMC_BRD_STOPCTRL_LPOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))

/*! @brief Set the LPOPO field to a new value. */
#define SMC_WR_STOPCTRL_LPOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LPOPO_MASK, SMC_STOPCTRL_LPOPO(value)))
#define SMC_BWR_STOPCTRL_LPOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_LPOPO_SHIFT), SMC_STOPCTRL_LPOPO_SHIFT, SMC_STOPCTRL_LPOPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field RAM2PO[4] (RW)
 *
 * This bit controls powering of RAM partition 2 in VLLS2 mode. See the device's
 * Chip Configuration details for the size and location of RAM partition 2
 *
 * Values:
 * - 0b0 - RAM2 not powered in VLLS2
 * - 0b1 - RAM2 powered in VLLS2
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_RAM2PO field. */
#define SMC_RD_STOPCTRL_RAM2PO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_RAM2PO_MASK) >> SMC_STOPCTRL_RAM2PO_SHIFT)
#define SMC_BRD_STOPCTRL_RAM2PO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_RAM2PO_SHIFT, SMC_STOPCTRL_RAM2PO_WIDTH))

/*! @brief Set the RAM2PO field to a new value. */
#define SMC_WR_STOPCTRL_RAM2PO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_RAM2PO_MASK, SMC_STOPCTRL_RAM2PO(value)))
#define SMC_BWR_STOPCTRL_RAM2PO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_RAM2PO_SHIFT), SMC_STOPCTRL_RAM2PO_SHIFT, SMC_STOPCTRL_RAM2PO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0b0 - POR detect circuit is enabled in VLLS0
 * - 0b1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PORPO_SHIFT), SMC_STOPCTRL_PORPO_SHIFT, SMC_STOPCTRL_PORPO_WIDTH))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN (or VLPR) mode, the PMC, MCG and
 * flash remain fully powered, allowing the device to wakeup almost instantaneously
 * at the expense of higher power consumption. In PSTOP2, only system clocks are
 * gated allowing peripherals running on bus clock to remain fully functional. In
 * PSTOP1, both system and bus clocks are gated.
 *
 * Values:
 * - 0b00 - STOP - Normal Stop mode
 * - 0b01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 0b10 - PSTOP2 - Partial Stop with system clock disabled and bus clock
 *     enabled
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (BME_UBFX8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (BME_BFI8(&SMC_STOPCTRL_REG(base), ((uint8_t)(value) << SMC_STOPCTRL_PSTOPO_SHIFT), SMC_STOPCTRL_PSTOPO_SHIFT, SMC_STOPCTRL_PSTOPO_WIDTH))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x04U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * MKV58F24 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_MCR - Module Configuration Register
 * - SPI_TCR - Transfer Count Register
 * - SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 * - SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 * - SPI_SR - Status Register
 * - SPI_RSER - DMA/Interrupt Request Select and Enable Register
 * - SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 * - SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 * - SPI_POPR - POP RX FIFO Register
 * - SPI_TXFR0 - Transmit FIFO Registers
 * - SPI_TXFR1 - Transmit FIFO Registers
 * - SPI_TXFR2 - Transmit FIFO Registers
 * - SPI_TXFR3 - Transmit FIFO Registers
 * - SPI_RXFR0 - Receive FIFO Registers
 * - SPI_RXFR1 - Receive FIFO Registers
 * - SPI_RXFR2 - Receive FIFO Registers
 * - SPI_RXFR3 - Receive FIFO Registers
 */

#define SPI_INSTANCE_COUNT (3U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */
#define SPI1_IDX (1U) /*!< Instance number for SPI1. */
#define SPI2_IDX (2U) /*!< Instance number for SPI2. */

/*******************************************************************************
 * SPI_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief SPI_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with the module
 * operations. The HALT and MDIS bits can be changed at any time, but the effect
 * takes place only on the next frame boundary. Only the HALT and MDIS bits in the
 * MCR can be changed, while the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define SPI_RD_MCR(base)         (SPI_MCR_REG(base))
#define SPI_WR_MCR(base, value)  (SPI_MCR_REG(base) = (value))
#define SPI_RMW_MCR(base, mask, value) (SPI_WR_MCR(base, (SPI_RD_MCR(base) & ~(mask)) | (value)))
#define SPI_SET_MCR(base, value) (BME_OR32(&SPI_MCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_MCR(base, value) (BME_AND32(&SPI_MCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_MCR(base, value) (BME_XOR32(&SPI_MCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * The HALT bit starts and stops frame transfers. See Start and Stop of Module
 * transfers
 *
 * Values:
 * - 0b0 - Start transfers.
 * - 0b1 - Stop transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_HALT field. */
#define SPI_RD_MCR_HALT(base) ((SPI_MCR_REG(base) & SPI_MCR_HALT_MASK) >> SPI_MCR_HALT_SHIFT)
#define SPI_BRD_MCR_HALT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))

/*! @brief Set the HALT field to a new value. */
#define SPI_WR_MCR_HALT(base, value) (SPI_RMW_MCR(base, SPI_MCR_HALT_MASK, SPI_MCR_HALT(value)))
#define SPI_BWR_MCR_HALT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_HALT_SHIFT), SPI_MCR_HALT_SHIFT, SPI_MCR_HALT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the module master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTARn[CPHA] is 0.
 *
 * Values:
 * - 0b00 - 0 protocol clock cycles between SCK edge and SIN sample
 * - 0b01 - 1 protocol clock cycle between SCK edge and SIN sample
 * - 0b10 - 2 protocol clock cycles between SCK edge and SIN sample
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define SPI_RD_MCR_SMPL_PT(base) ((SPI_MCR_REG(base) & SPI_MCR_SMPL_PT_MASK) >> SPI_MCR_SMPL_PT_SHIFT)
#define SPI_BRD_MCR_SMPL_PT(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))

/*! @brief Set the SMPL_PT field to a new value. */
#define SPI_WR_MCR_SMPL_PT(base, value) (SPI_RMW_MCR(base, SPI_MCR_SMPL_PT_MASK, SPI_MCR_SMPL_PT(value)))
#define SPI_BWR_MCR_SMPL_PT(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_SMPL_PT_SHIFT), SPI_MCR_SMPL_PT_SHIFT, SPI_MCR_SMPL_PT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero. After every RX FIFO clear operation (MCR
 * [CLR_RXF] = 0b1) following a RX FIFO overflow (SR [RFOF] = 0b1) scenario, immediately
 * perform a single POP from the RX FIFO and discard the read data. The POP and
 * discard operation should be completed before the reception of new incoming
 * frame.
 *
 * Values:
 * - 0b0 - Do not clear the RX FIFO counter.
 * - 0b1 - Clear the RX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_RXF field to a new value. */
#define SPI_WR_MCR_CLR_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_RXF_MASK, SPI_MCR_CLR_RXF(value)))
#define SPI_BWR_MCR_CLR_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_RXF_SHIFT), SPI_MCR_CLR_RXF_SHIFT, SPI_MCR_CLR_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0b0 - Do not clear the TX FIFO counter.
 * - 0b1 - Clear the TX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_TXF field to a new value. */
#define SPI_WR_MCR_CLR_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_TXF_MASK, SPI_MCR_CLR_TXF(value)))
#define SPI_BWR_MCR_CLR_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CLR_TXF_SHIFT), SPI_MCR_CLR_TXF_SHIFT, SPI_MCR_CLR_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the module operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0b0 - RX FIFO is enabled.
 * - 0b1 - RX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define SPI_RD_MCR_DIS_RXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_RXF_MASK) >> SPI_MCR_DIS_RXF_SHIFT)
#define SPI_BRD_MCR_DIS_RXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))

/*! @brief Set the DIS_RXF field to a new value. */
#define SPI_WR_MCR_DIS_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_RXF_MASK, SPI_MCR_DIS_RXF(value)))
#define SPI_BWR_MCR_DIS_RXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_RXF_SHIFT), SPI_MCR_DIS_RXF_SHIFT, SPI_MCR_DIS_RXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the module operates as a
 * simplified double-buffered SPI. This bit can be written only when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0b0 - TX FIFO is enabled.
 * - 0b1 - TX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define SPI_RD_MCR_DIS_TXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_TXF_MASK) >> SPI_MCR_DIS_TXF_SHIFT)
#define SPI_BRD_MCR_DIS_TXF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))

/*! @brief Set the DIS_TXF field to a new value. */
#define SPI_WR_MCR_DIS_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_TXF_MASK, SPI_MCR_DIS_TXF(value)))
#define SPI_BWR_MCR_DIS_TXF(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DIS_TXF_SHIFT), SPI_MCR_DIS_TXF_SHIFT, SPI_MCR_DIS_TXF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the module
 * effectively putting it in a software-controlled power-saving state. The reset
 * value of the MDIS bit is parameterized, with a default reset value of 1. When
 * the module is used in Slave Mode, it is recommended to leave this bit 0,
 * because a slave doesn't have control over master transactions.
 *
 * Values:
 * - 0b0 - Enables the module clocks.
 * - 0b1 - Allows external logic to disable the module clocks.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define SPI_RD_MCR_MDIS(base) ((SPI_MCR_REG(base) & SPI_MCR_MDIS_MASK) >> SPI_MCR_MDIS_SHIFT)
#define SPI_BRD_MCR_MDIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))

/*! @brief Set the MDIS field to a new value. */
#define SPI_WR_MCR_MDIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_MDIS_MASK, SPI_MCR_MDIS(value)))
#define SPI_BWR_MCR_MDIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MDIS_SHIFT), SPI_MCR_MDIS_SHIFT, SPI_MCR_MDIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0b0 - Doze mode has no effect on the module.
 * - 0b1 - Doze mode disables the module.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define SPI_RD_MCR_DOZE(base) ((SPI_MCR_REG(base) & SPI_MCR_DOZE_MASK) >> SPI_MCR_DOZE_SHIFT)
#define SPI_BRD_MCR_DOZE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))

/*! @brief Set the DOZE field to a new value. */
#define SPI_WR_MCR_DOZE(base, value) (SPI_RMW_MCR(base, SPI_MCR_DOZE_MASK, SPI_MCR_DOZE(value)))
#define SPI_BWR_MCR_DOZE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_DOZE_SHIFT), SPI_MCR_DOZE_SHIFT, SPI_MCR_DOZE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[21:16] (RW)
 *
 * Determines the inactive state of PCSx. Refer to the chip-specific SPI
 * information for the number of PCS signals used in this chip. The effect of this bit
 * only takes place when module is enabled. Ensure that this bit is configured
 * correctly before enabling the DSPI interface.
 *
 * Values:
 * - 0b000000 - The inactive state of PCSx is low.
 * - 0b000001 - The inactive state of PCSx is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define SPI_RD_MCR_PCSIS(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSIS_MASK) >> SPI_MCR_PCSIS_SHIFT)
#define SPI_BRD_MCR_PCSIS(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))

/*! @brief Set the PCSIS field to a new value. */
#define SPI_WR_MCR_PCSIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSIS_MASK, SPI_MCR_PCSIS(value)))
#define SPI_BWR_MCR_PCSIS(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_PCSIS_SHIFT), SPI_MCR_PCSIS_SHIFT, SPI_MCR_PCSIS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the module to ignore the
 * incoming serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored
 * or shifted into the shift register.
 *
 * Values:
 * - 0b0 - Incoming data is ignored.
 * - 0b1 - Incoming data is shifted into the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define SPI_RD_MCR_ROOE(base) ((SPI_MCR_REG(base) & SPI_MCR_ROOE_MASK) >> SPI_MCR_ROOE_SHIFT)
#define SPI_BRD_MCR_ROOE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))

/*! @brief Set the ROOE field to a new value. */
#define SPI_WR_MCR_ROOE(base, value) (SPI_RMW_MCR(base, SPI_MCR_ROOE_MASK, SPI_MCR_ROOE(value)))
#define SPI_BWR_MCR_ROOE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_ROOE_SHIFT), SPI_MCR_ROOE_SHIFT, SPI_MCR_ROOE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSSE[25] (RW)
 *
 * Enables the PCS5/ PCSS to operate as a PCS Strobe output signal.
 *
 * Values:
 * - 0b0 - PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
 * - 0b1 - PCS5/ PCSS is used as an active-low PCS Strobe signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSSE field. */
#define SPI_RD_MCR_PCSSE(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSSE_MASK) >> SPI_MCR_PCSSE_SHIFT)
#define SPI_BRD_MCR_PCSSE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_PCSSE_SHIFT, SPI_MCR_PCSSE_WIDTH))

/*! @brief Set the PCSSE field to a new value. */
#define SPI_WR_MCR_PCSSE(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSSE_MASK, SPI_MCR_PCSSE(value)))
#define SPI_BWR_MCR_PCSSE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_PCSSE_SHIFT), SPI_MCR_PCSSE_SHIFT, SPI_MCR_PCSSE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0b0 - Modified SPI transfer format disabled.
 * - 0b1 - Modified SPI transfer format enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define SPI_RD_MCR_MTFE(base) ((SPI_MCR_REG(base) & SPI_MCR_MTFE_MASK) >> SPI_MCR_MTFE_SHIFT)
#define SPI_BRD_MCR_MTFE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))

/*! @brief Set the MTFE field to a new value. */
#define SPI_WR_MCR_MTFE(base, value) (SPI_RMW_MCR(base, SPI_MCR_MTFE_MASK, SPI_MCR_MTFE(value)))
#define SPI_BWR_MCR_MTFE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MTFE_SHIFT), SPI_MCR_MTFE_SHIFT, SPI_MCR_MTFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables transfers to be stopped on the next frame boundary when the device
 * enters Debug mode.
 *
 * Values:
 * - 0b0 - Do not halt serial transfers in Debug mode.
 * - 0b1 - Halt serial transfers in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define SPI_RD_MCR_FRZ(base) ((SPI_MCR_REG(base) & SPI_MCR_FRZ_MASK) >> SPI_MCR_FRZ_SHIFT)
#define SPI_BRD_MCR_FRZ(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))

/*! @brief Set the FRZ field to a new value. */
#define SPI_WR_MCR_FRZ(base, value) (SPI_RMW_MCR(base, SPI_MCR_FRZ_MASK, SPI_MCR_FRZ(value)))
#define SPI_BWR_MCR_FRZ(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_FRZ_SHIFT), SPI_MCR_FRZ_SHIFT, SPI_MCR_FRZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RO)
 *
 * Selects among the different configurations of the module.
 *
 * Values:
 * - 0b00 - SPI
 * - 0b01 - Reserved
 * - 0b10 - Reserved
 * - 0b11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define SPI_RD_MCR_DCONF(base) ((SPI_MCR_REG(base) & SPI_MCR_DCONF_MASK) >> SPI_MCR_DCONF_SHIFT)
#define SPI_BRD_MCR_DCONF(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_DCONF_SHIFT, SPI_MCR_DCONF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0b0 - Continuous SCK disabled.
 * - 0b1 - Continuous SCK enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define SPI_RD_MCR_CONT_SCKE(base) ((SPI_MCR_REG(base) & SPI_MCR_CONT_SCKE_MASK) >> SPI_MCR_CONT_SCKE_SHIFT)
#define SPI_BRD_MCR_CONT_SCKE(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))

/*! @brief Set the CONT_SCKE field to a new value. */
#define SPI_WR_MCR_CONT_SCKE(base, value) (SPI_RMW_MCR(base, SPI_MCR_CONT_SCKE_MASK, SPI_MCR_CONT_SCKE(value)))
#define SPI_BWR_MCR_CONT_SCKE(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_CONT_SCKE_SHIFT), SPI_MCR_CONT_SCKE_SHIFT, SPI_MCR_CONT_SCKE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Enables either Master mode (if supported) or Slave mode (if supported)
 * operation.
 *
 * Values:
 * - 0b0 - Enables Slave mode
 * - 0b1 - Enables Master mode
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define SPI_RD_MCR_MSTR(base) ((SPI_MCR_REG(base) & SPI_MCR_MSTR_MASK) >> SPI_MCR_MSTR_SHIFT)
#define SPI_BRD_MCR_MSTR(base) (BME_UBFX32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_MCR_MSTR(base, value) (SPI_RMW_MCR(base, SPI_MCR_MSTR_MASK, SPI_MCR_MSTR(value)))
#define SPI_BWR_MCR_MSTR(base, value) (BME_BFI32(&SPI_MCR_REG(base), ((uint32_t)(value) << SPI_MCR_MSTR_SHIFT), SPI_MCR_MSTR_SHIFT, SPI_MCR_MSTR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_TCR - Transfer Count Register
 ******************************************************************************/

/*!
 * @brief SPI_TCR - Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define SPI_RD_TCR(base)         (SPI_TCR_REG(base))
#define SPI_WR_TCR(base, value)  (SPI_TCR_REG(base) = (value))
#define SPI_RMW_TCR(base, mask, value) (SPI_WR_TCR(base, (SPI_RD_TCR(base) & ~(mask)) | (value)))
#define SPI_SET_TCR(base, value) (BME_OR32(&SPI_TCR_REG(base), (uint32_t)(value)))
#define SPI_CLR_TCR(base, value) (BME_AND32(&SPI_TCR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_TCR(base, value) (BME_XOR32(&SPI_TCR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the module makes. The SPI_TCNT field
 * increments every time the last bit of an SPI frame is transmitted. A value written
 * to SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at
 * the beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define SPI_RD_TCR_SPI_TCNT(base) ((SPI_TCR_REG(base) & SPI_TCR_SPI_TCNT_MASK) >> SPI_TCR_SPI_TCNT_SHIFT)
#define SPI_BRD_TCR_SPI_TCNT(base) (SPI_RD_TCR_SPI_TCNT(base))

/*! @brief Set the SPI_TCNT field to a new value. */
#define SPI_WR_TCR_SPI_TCNT(base, value) (SPI_RMW_TCR(base, SPI_TCR_SPI_TCNT_MASK, SPI_TCR_SPI_TCNT(value)))
#define SPI_BWR_TCR_SPI_TCNT(base, value) (SPI_WR_TCR_SPI_TCNT(base, value))
/*@}*/

/*******************************************************************************
 * SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the module is configured as an SPI bus slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR_SLAVE register
 */
/*@{*/
#define SPI_RD_CTAR_SLAVE(base, index) (SPI_CTAR_SLAVE_REG(base, index))
#define SPI_WR_CTAR_SLAVE(base, index, value) (SPI_CTAR_SLAVE_REG(base, index) = (value))
#define SPI_RMW_CTAR_SLAVE(base, index, mask, value) (SPI_WR_CTAR_SLAVE(base, index, (SPI_RD_CTAR_SLAVE(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR_SLAVE(base, index, value) (BME_OR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR_SLAVE(base, index, value) (BME_AND32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR_SLAVE(base, index, value) (BME_XOR32(&SPI_CTAR_SLAVE_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTAR_SLAVE, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPHA field. */
#define SPI_RD_CTAR_SLAVE_CPHA(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPHA_MASK) >> SPI_CTAR_SLAVE_CPHA_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPHA(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPHA_MASK, SPI_CTAR_SLAVE_CPHA(value)))
#define SPI_BWR_CTAR_SLAVE_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPHA_SHIFT), SPI_CTAR_SLAVE_CPHA_SHIFT, SPI_CTAR_SLAVE_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPOL field. */
#define SPI_RD_CTAR_SLAVE_CPOL(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPOL_MASK) >> SPI_CTAR_SLAVE_CPOL_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPOL(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPOL_MASK, SPI_CTAR_SLAVE_CPOL(value)))
#define SPI_BWR_CTAR_SLAVE_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_CPOL_SHIFT), SPI_CTAR_SLAVE_CPOL_SHIFT, SPI_CTAR_SLAVE_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field FMSZ[30:27] (RW)
 *
 * The number of bits transfered per frame is equal to the FMSZ field value plus
 * 1. Note that the minimum valid value of frame size is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_FMSZ field. */
#define SPI_RD_CTAR_SLAVE_FMSZ(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT)
#define SPI_BRD_CTAR_SLAVE_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_FMSZ_MASK, SPI_CTAR_SLAVE_FMSZ(value)))
#define SPI_BWR_CTAR_SLAVE_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_SLAVE_REG(base, index), ((uint32_t)(value) << SPI_CTAR_SLAVE_FMSZ_SHIFT), SPI_CTAR_SLAVE_FMSZ_SHIFT, SPI_CTAR_SLAVE_FMSZ_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. Do not write
 * to the CTAR registers while the module is in the Running state. In Master
 * mode, the CTAR registers define combinations of transfer attributes such as frame
 * size, clock phase and polarity, data bit ordering, baud rate, and various
 * delays. In slave mode, a subset of the bitfields in CTAR0 are used to set the
 * slave transfer attributes. When the module is configured as an SPI master, the
 * CTAS field in the command portion of the TX FIFO entry selects which of the CTAR
 * registers is used. When the module is configured as an SPI bus slave, it uses
 * the CTAR0 register.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR register
 */
/*@{*/
#define SPI_RD_CTAR(base, index) (SPI_CTAR_REG(base, index))
#define SPI_WR_CTAR(base, index, value) (SPI_CTAR_REG(base, index) = (value))
#define SPI_RMW_CTAR(base, index, mask, value) (SPI_WR_CTAR(base, index, (SPI_RD_CTAR(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR(base, index, value) (BME_OR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
#define SPI_CLR_CTAR(base, index, value) (BME_AND32(&SPI_CTAR_REG(base, index), (uint32_t)(~(value))))
#define SPI_TOG_CTAR(base, index, value) (BME_XOR32(&SPI_CTAR_REG(base, index), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR bitfields
 */

/*!
 * @name Register SPI_CTAR, field BR[3:0] (RW)
 *
 * Selects the scaler value for the baud rate. This field is used only in master
 * mode. The prescaled protocol clock is divided by the Baud Rate Scaler to
 * generate the frequency of the SCK. The baud rate is computed according to the
 * following equation: SCK baud rate = (fP /PBR) x [(1+DBR)/BR] The following table
 * lists the baud rate scaler values. Baud Rate Scaler CTARn[BR] Baud Rate Scaler
 * Value 0000 2 0001 4 0010 6 0011 8 0100 16 0101 32 0110 64 0111 128 1000 256
 * 1001 512 1010 1024 1011 2048 1100 4096 1101 8192 1110 16384 1111 32768
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_BR field. */
#define SPI_RD_CTAR_BR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_BR_MASK) >> SPI_CTAR_BR_SHIFT)
#define SPI_BRD_CTAR_BR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))

/*! @brief Set the BR field to a new value. */
#define SPI_WR_CTAR_BR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_BR_MASK, SPI_CTAR_BR(value)))
#define SPI_BWR_CTAR_BR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_BR_SHIFT), SPI_CTAR_BR_SHIFT, SPI_CTAR_BR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DT[7:4] (RW)
 *
 * Selects the Delay after Transfer Scaler. This field is used only in master
 * mode. The Delay after Transfer is the time between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the next
 * frame. In the Continuous Serial Communications Clock operation, the DT value
 * is fixed to one SCK clock period, The Delay after Transfer is a multiple of the
 * protocol clock period, and it is computed according to the following
 * equation: tDT = (1/fP ) x PDT x DT See Delay Scaler Encoding table in CTARn[CSSCK] bit
 * field description for scaler values.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DT field. */
#define SPI_RD_CTAR_DT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DT_MASK) >> SPI_CTAR_DT_SHIFT)
#define SPI_BRD_CTAR_DT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))

/*! @brief Set the DT field to a new value. */
#define SPI_WR_CTAR_DT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DT_MASK, SPI_CTAR_DT(value)))
#define SPI_BWR_CTAR_DT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DT_SHIFT), SPI_CTAR_DT_SHIFT, SPI_CTAR_DT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field ASC[11:8] (RW)
 *
 * Selects the scaler value for the After SCK Delay. This field is used only in
 * master mode. The After SCK Delay is the delay between the last edge of SCK and
 * the negation of PCS. The delay is a multiple of the protocol clock period,
 * and it is computed according to the following equation: t ASC = (1/fP) x PASC x
 * ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for
 * scaler values. Refer After SCK Delay (tASC ) for more details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_ASC field. */
#define SPI_RD_CTAR_ASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_ASC_MASK) >> SPI_CTAR_ASC_SHIFT)
#define SPI_BRD_CTAR_ASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))

/*! @brief Set the ASC field to a new value. */
#define SPI_WR_CTAR_ASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_ASC_MASK, SPI_CTAR_ASC(value)))
#define SPI_BWR_CTAR_ASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_ASC_SHIFT), SPI_CTAR_ASC_SHIFT, SPI_CTAR_ASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CSSCK[15:12] (RW)
 *
 * Selects the scaler value for the PCS to SCK delay. This field is used only in
 * master mode. The PCS to SCK Delay is the delay between the assertion of PCS
 * and the first edge of the SCK. The delay is a multiple of the protocol clock
 * period, and it is computed according to the following equation: t CSC = (1/fP )
 * x PCSSCK x CSSCK. The following table lists the delay scaler values. Delay
 * Scaler Encoding Field Value Delay Scaler Value 0000 2 0001 4 0010 8 0011 16 0100
 * 32 0101 64 0110 128 0111 256 1000 512 1001 1024 1010 2048 1011 4096 1100 8192
 * 1101 16384 1110 32768 1111 65536 Refer PCS to SCK Delay (tCSC ) for more
 * details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CSSCK field. */
#define SPI_RD_CTAR_CSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CSSCK_MASK) >> SPI_CTAR_CSSCK_SHIFT)
#define SPI_BRD_CTAR_CSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))

/*! @brief Set the CSSCK field to a new value. */
#define SPI_WR_CTAR_CSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CSSCK_MASK, SPI_CTAR_CSSCK(value)))
#define SPI_BWR_CTAR_CSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CSSCK_SHIFT), SPI_CTAR_CSSCK_SHIFT, SPI_CTAR_CSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PBR[17:16] (RW)
 *
 * Selects the prescaler value for the baud rate. This field is used only in
 * master mode. The baud rate is the frequency of the SCK. The protocol clock is
 * divided by the prescaler value before the baud rate selection takes place. See
 * the BR field description for details on how to compute the baud rate.
 *
 * Values:
 * - 0b00 - Baud Rate Prescaler value is 2.
 * - 0b01 - Baud Rate Prescaler value is 3.
 * - 0b10 - Baud Rate Prescaler value is 5.
 * - 0b11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PBR field. */
#define SPI_RD_CTAR_PBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PBR_MASK) >> SPI_CTAR_PBR_SHIFT)
#define SPI_BRD_CTAR_PBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))

/*! @brief Set the PBR field to a new value. */
#define SPI_WR_CTAR_PBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PBR_MASK, SPI_CTAR_PBR(value)))
#define SPI_BWR_CTAR_PBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PBR_SHIFT), SPI_CTAR_PBR_SHIFT, SPI_CTAR_PBR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PDT[19:18] (RW)
 *
 * Selects the prescaler value for the delay between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the
 * next frame. The PDT field is only used in master mode. See the DT field
 * description for details on how to compute the Delay after Transfer. Refer Delay after
 * Transfer (tDT ) for more details.
 *
 * Values:
 * - 0b00 - Delay after Transfer Prescaler value is 1.
 * - 0b01 - Delay after Transfer Prescaler value is 3.
 * - 0b10 - Delay after Transfer Prescaler value is 5.
 * - 0b11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PDT field. */
#define SPI_RD_CTAR_PDT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PDT_MASK) >> SPI_CTAR_PDT_SHIFT)
#define SPI_BRD_CTAR_PDT(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))

/*! @brief Set the PDT field to a new value. */
#define SPI_WR_CTAR_PDT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PDT_MASK, SPI_CTAR_PDT(value)))
#define SPI_BWR_CTAR_PDT(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PDT_SHIFT), SPI_CTAR_PDT_SHIFT, SPI_CTAR_PDT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PASC[21:20] (RW)
 *
 * Selects the prescaler value for the delay between the last edge of SCK and
 * the negation of PCS. See the ASC field description for information on how to
 * compute the After SCK Delay. Refer After SCK Delay (tASC ) for more details.
 *
 * Values:
 * - 0b00 - Delay after Transfer Prescaler value is 1.
 * - 0b01 - Delay after Transfer Prescaler value is 3.
 * - 0b10 - Delay after Transfer Prescaler value is 5.
 * - 0b11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PASC field. */
#define SPI_RD_CTAR_PASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PASC_MASK) >> SPI_CTAR_PASC_SHIFT)
#define SPI_BRD_CTAR_PASC(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))

/*! @brief Set the PASC field to a new value. */
#define SPI_WR_CTAR_PASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PASC_MASK, SPI_CTAR_PASC(value)))
#define SPI_BWR_CTAR_PASC(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PASC_SHIFT), SPI_CTAR_PASC_SHIFT, SPI_CTAR_PASC_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PCSSCK[23:22] (RW)
 *
 * Selects the prescaler value for the delay between assertion of PCS and the
 * first edge of the SCK. See the CSSCK field description for information on how to
 * compute the PCS to SCK Delay. Refer PCS to SCK Delay (tCSC ) for more details.
 *
 * Values:
 * - 0b00 - PCS to SCK Prescaler value is 1.
 * - 0b01 - PCS to SCK Prescaler value is 3.
 * - 0b10 - PCS to SCK Prescaler value is 5.
 * - 0b11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PCSSCK field. */
#define SPI_RD_CTAR_PCSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PCSSCK_MASK) >> SPI_CTAR_PCSSCK_SHIFT)
#define SPI_BRD_CTAR_PCSSCK(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))

/*! @brief Set the PCSSCK field to a new value. */
#define SPI_WR_CTAR_PCSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PCSSCK_MASK, SPI_CTAR_PCSSCK(value)))
#define SPI_BWR_CTAR_PCSSCK(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_PCSSCK_SHIFT), SPI_CTAR_PCSSCK_SHIFT, SPI_CTAR_PCSSCK_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field LSBFE[24] (RW)
 *
 * Specifies whether the LSB or MSB of the frame is transferred first.
 *
 * Values:
 * - 0b0 - Data is transferred MSB first.
 * - 0b1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_LSBFE field. */
#define SPI_RD_CTAR_LSBFE(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_LSBFE_MASK) >> SPI_CTAR_LSBFE_SHIFT)
#define SPI_BRD_CTAR_LSBFE(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_CTAR_LSBFE(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_LSBFE_MASK, SPI_CTAR_LSBFE(value)))
#define SPI_BWR_CTAR_LSBFE(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_LSBFE_SHIFT), SPI_CTAR_LSBFE_SHIFT, SPI_CTAR_LSBFE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0b0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 0b1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPHA field. */
#define SPI_RD_CTAR_CPHA(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPHA_MASK) >> SPI_CTAR_CPHA_SHIFT)
#define SPI_BRD_CTAR_CPHA(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_CPHA(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPHA_MASK, SPI_CTAR_CPHA(value)))
#define SPI_BWR_CTAR_CPHA(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPHA_SHIFT), SPI_CTAR_CPHA_SHIFT, SPI_CTAR_CPHA_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). This bit
 * is used in both master and slave mode. For successful communication between
 * serial devices, the devices must have identical clock polarities. When the
 * Continuous Selection Format is selected, switching between clock polarities
 * without stopping the module can cause errors in the transfer due to the peripheral
 * device interpreting the switch of clock polarity as a valid clock edge. In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0b0 - The inactive state value of SCK is low.
 * - 0b1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPOL field. */
#define SPI_RD_CTAR_CPOL(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPOL_MASK) >> SPI_CTAR_CPOL_SHIFT)
#define SPI_BRD_CTAR_CPOL(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_CPOL(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPOL_MASK, SPI_CTAR_CPOL(value)))
#define SPI_BWR_CTAR_CPOL(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_CPOL_SHIFT), SPI_CTAR_CPOL_SHIFT, SPI_CTAR_CPOL_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field FMSZ[30:27] (RW)
 *
 * The number of bits transferred per frame is equal to the FMSZ value plus 1.
 * Regardless of the transmission mode, the minimum valid frame size value is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_FMSZ field. */
#define SPI_RD_CTAR_FMSZ(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT)
#define SPI_BRD_CTAR_FMSZ(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_FMSZ(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_FMSZ_MASK, SPI_CTAR_FMSZ(value)))
#define SPI_BWR_CTAR_FMSZ(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_FMSZ_SHIFT), SPI_CTAR_FMSZ_SHIFT, SPI_CTAR_FMSZ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DBR[31] (RW)
 *
 * Doubles the effective baud rate of the Serial Communications Clock (SCK).
 * This field is used only in master mode. It effectively halves the Baud Rate
 * division ratio, supporting faster frequencies, and odd division ratios for the
 * Serial Communications Clock (SCK). When the DBR bit is set, the duty cycle of the
 * Serial Communications Clock (SCK) depends on the value in the Baud Rate
 * Prescaler and the Clock Phase bit as listed in the following table. See the BR field
 * description for details on how to compute the baud rate. SPI SCK Duty Cycle
 * DBR CPHA PBR SCK Duty Cycle 0 any any 50/50 1 0 00 50/50 1 0 01 33/66 1 0 10
 * 40/60 1 0 11 43/57 1 1 00 50/50 1 1 01 66/33 1 1 10 60/40 1 1 11 57/43
 *
 * Values:
 * - 0b0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 0b1 - The baud rate is doubled with the duty cycle depending on the Baud
 *     Rate Prescaler.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DBR field. */
#define SPI_RD_CTAR_DBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DBR_MASK) >> SPI_CTAR_DBR_SHIFT)
#define SPI_BRD_CTAR_DBR(base, index) (BME_UBFX32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))

/*! @brief Set the DBR field to a new value. */
#define SPI_WR_CTAR_DBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DBR_MASK, SPI_CTAR_DBR(value)))
#define SPI_BWR_CTAR_DBR(base, index, value) (BME_BFI32(&SPI_CTAR_REG(base, index), ((uint32_t)(value) << SPI_CTAR_DBR_SHIFT), SPI_CTAR_DBR_SHIFT, SPI_CTAR_DBR_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief SPI_SR - Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the module
 * and indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in Module
 * Disable mode due to the use of power saving mechanisms.
 */
/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define SPI_RD_SR(base)          (SPI_SR_REG(base))
#define SPI_WR_SR(base, value)   (SPI_SR_REG(base) = (value))
#define SPI_RMW_SR(base, mask, value) (SPI_WR_SR(base, (SPI_RD_SR(base) & ~(mask)) | (value)))
#define SPI_SET_SR(base, value)  (BME_OR32(&SPI_SR_REG(base), (uint32_t)(value)))
#define SPI_CLR_SR(base, value)  (BME_AND32(&SPI_SR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_SR(base, value)  (BME_XOR32(&SPI_SR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define SPI_RD_SR_POPNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_POPNXTPTR_MASK) >> SPI_SR_POPNXTPTR_SHIFT)
#define SPI_BRD_SR_POPNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_POPNXTPTR_SHIFT, SPI_SR_POPNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define SPI_RD_SR_RXCTR(base) ((SPI_SR_REG(base) & SPI_SR_RXCTR_MASK) >> SPI_SR_RXCTR_SHIFT)
#define SPI_BRD_SR_RXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RXCTR_SHIFT, SPI_SR_RXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define SPI_RD_SR_TXNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_TXNXTPTR_MASK) >> SPI_SR_TXNXTPTR_SHIFT)
#define SPI_BRD_SR_TXNXTPTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXNXTPTR_SHIFT, SPI_SR_TXNXTPTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time an SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define SPI_RD_SR_TXCTR(base) ((SPI_SR_REG(base) & SPI_SR_TXCTR_MASK) >> SPI_SR_TXCTR_SHIFT)
#define SPI_BRD_SR_TXCTR(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXCTR_SHIFT, SPI_SR_TXCTR_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the module to request that entries be removed from the
 * RX FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when
 * the RX FIFO is empty.
 *
 * Values:
 * - 0b0 - RX FIFO is empty.
 * - 0b1 - RX FIFO is not empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFDF field. */
#define SPI_RD_SR_RFDF(base) ((SPI_SR_REG(base) & SPI_SR_RFDF_MASK) >> SPI_SR_RFDF_SHIFT)
#define SPI_BRD_SR_RFDF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))

/*! @brief Set the RFDF field to a new value. */
#define SPI_WR_SR_RFDF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_RFDF(value)))
#define SPI_BWR_SR_RFDF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFDF_SHIFT), SPI_SR_RFDF_SHIFT, SPI_SR_RFDF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The field is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No Rx FIFO overflow.
 * - 0b1 - Rx FIFO overflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFOF field. */
#define SPI_RD_SR_RFOF(base) ((SPI_SR_REG(base) & SPI_SR_RFOF_MASK) >> SPI_SR_RFOF_SHIFT)
#define SPI_BRD_SR_RFOF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))

/*! @brief Set the RFOF field to a new value. */
#define SPI_WR_SR_RFOF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_RFOF(value)))
#define SPI_BWR_SR_RFOF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_RFOF_SHIFT), SPI_SR_RFOF_SHIFT, SPI_SR_RFOF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the module to request more entries to be added to the
 * TX FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to
 * the TX FIFO full request. The reset value of this bit is 0 when the module is
 * disabled,(MCR[MDIS]=1).
 *
 * Values:
 * - 0b0 - TX FIFO is full.
 * - 0b1 - TX FIFO is not full.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFFF field. */
#define SPI_RD_SR_TFFF(base) ((SPI_SR_REG(base) & SPI_SR_TFFF_MASK) >> SPI_SR_TFFF_SHIFT)
#define SPI_BRD_SR_TFFF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))

/*! @brief Set the TFFF field to a new value. */
#define SPI_WR_SR_TFFF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TFFF(value)))
#define SPI_BWR_SR_TFFF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFFF_SHIFT), SPI_SR_TFFF_SHIFT, SPI_SR_TFFF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for SPI blocks operating in Slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of the module operating in SPI Slave mode
 * is empty and an external SPI master initiates a transfer. The TFUF bit remains
 * set until cleared by writing 1 to it.
 *
 * Values:
 * - 0b0 - No TX FIFO underflow.
 * - 0b1 - TX FIFO underflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFUF field. */
#define SPI_RD_SR_TFUF(base) ((SPI_SR_REG(base) & SPI_SR_TFUF_MASK) >> SPI_SR_TFUF_SHIFT)
#define SPI_BRD_SR_TFUF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))

/*! @brief Set the TFUF field to a new value. */
#define SPI_WR_SR_TFUF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFUF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TFUF(value)))
#define SPI_BWR_SR_TFUF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TFUF_SHIFT), SPI_SR_TFUF_SHIFT, SPI_SR_TFUF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the module
 * is in Master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0b0 - EOQ is not set in the executing command.
 * - 0b1 - EOQ is set in the executing SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_EOQF field. */
#define SPI_RD_SR_EOQF(base) ((SPI_SR_REG(base) & SPI_SR_EOQF_MASK) >> SPI_SR_EOQF_SHIFT)
#define SPI_BRD_SR_EOQF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))

/*! @brief Set the EOQF field to a new value. */
#define SPI_WR_SR_EOQF(base, value) (SPI_RMW_SR(base, (SPI_SR_EOQF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TCF_MASK), SPI_SR_EOQF(value)))
#define SPI_BWR_SR_EOQF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_EOQF_SHIFT), SPI_SR_EOQF_SHIFT, SPI_SR_EOQF_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (RO)
 *
 * Reflects the run status of the module.
 *
 * Values:
 * - 0b0 - Transmit and receive operations are disabled (The module is in
 *     Stopped state).
 * - 0b1 - Transmit and receive operations are enabled (The module is in Running
 *     state).
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define SPI_RD_SR_TXRXS(base) ((SPI_SR_REG(base) & SPI_SR_TXRXS_MASK) >> SPI_SR_TXRXS_SHIFT)
#define SPI_BRD_SR_TXRXS(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT, SPI_SR_TXRXS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - Transfer not complete.
 * - 0b1 - Transfer complete.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TCF field. */
#define SPI_RD_SR_TCF(base)  ((SPI_SR_REG(base) & SPI_SR_TCF_MASK) >> SPI_SR_TCF_SHIFT)
#define SPI_BRD_SR_TCF(base) (BME_UBFX32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))

/*! @brief Set the TCF field to a new value. */
#define SPI_WR_SR_TCF(base, value) (SPI_RMW_SR(base, (SPI_SR_TCF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK), SPI_SR_TCF(value)))
#define SPI_BWR_SR_TCF(base, value) (BME_BFI32(&SPI_SR_REG(base), ((uint32_t)(value) << SPI_SR_TCF_SHIFT), SPI_SR_TCF_SHIFT, SPI_SR_TCF_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_RSER - DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief SPI_RSER - DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define SPI_RD_RSER(base)        (SPI_RSER_REG(base))
#define SPI_WR_RSER(base, value) (SPI_RSER_REG(base) = (value))
#define SPI_RMW_RSER(base, mask, value) (SPI_WR_RSER(base, (SPI_RD_RSER(base) & ~(mask)) | (value)))
#define SPI_SET_RSER(base, value) (BME_OR32(&SPI_RSER_REG(base), (uint32_t)(value)))
#define SPI_CLR_RSER(base, value) (BME_AND32(&SPI_RSER_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_RSER(base, value) (BME_XOR32(&SPI_RSER_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - Interrupt request.
 * - 0b1 - DMA request.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define SPI_RD_RSER_RFDF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_DIRS_MASK) >> SPI_RSER_RFDF_DIRS_SHIFT)
#define SPI_BRD_RSER_RFDF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))

/*! @brief Set the RFDF_DIRS field to a new value. */
#define SPI_WR_RSER_RFDF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_DIRS_MASK, SPI_RSER_RFDF_DIRS(value)))
#define SPI_BWR_RSER_RFDF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_DIRS_SHIFT), SPI_RSER_RFDF_DIRS_SHIFT, SPI_RSER_RFDF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - RFDF interrupt or DMA requests are disabled.
 * - 0b1 - RFDF interrupt or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define SPI_RD_RSER_RFDF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_RE_MASK) >> SPI_RSER_RFDF_RE_SHIFT)
#define SPI_BRD_RSER_RFDF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))

/*! @brief Set the RFDF_RE field to a new value. */
#define SPI_WR_RSER_RFDF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_RE_MASK, SPI_RSER_RFDF_RE(value)))
#define SPI_BWR_RSER_RFDF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFDF_RE_SHIFT), SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_RFDF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - RFOF interrupt requests are disabled.
 * - 0b1 - RFOF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define SPI_RD_RSER_RFOF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFOF_RE_MASK) >> SPI_RSER_RFOF_RE_SHIFT)
#define SPI_BRD_RSER_RFOF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))

/*! @brief Set the RFOF_RE field to a new value. */
#define SPI_WR_RSER_RFOF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFOF_RE_MASK, SPI_RSER_RFOF_RE(value)))
#define SPI_BWR_RSER_RFOF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_RFOF_RE_SHIFT), SPI_RSER_RFOF_RE_SHIFT, SPI_RSER_RFOF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When
 * SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an
 * interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - TFFF flag generates interrupt requests.
 * - 0b1 - TFFF flag generates DMA requests.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define SPI_RD_RSER_TFFF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_DIRS_MASK) >> SPI_RSER_TFFF_DIRS_SHIFT)
#define SPI_BRD_RSER_TFFF_DIRS(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))

/*! @brief Set the TFFF_DIRS field to a new value. */
#define SPI_WR_RSER_TFFF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_DIRS_MASK, SPI_RSER_TFFF_DIRS(value)))
#define SPI_BWR_RSER_TFFF_DIRS(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_DIRS_SHIFT), SPI_RSER_TFFF_DIRS_SHIFT, SPI_RSER_TFFF_DIRS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0b0 - TFFF interrupts or DMA requests are disabled.
 * - 0b1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define SPI_RD_RSER_TFFF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_RE_MASK) >> SPI_RSER_TFFF_RE_SHIFT)
#define SPI_BRD_RSER_TFFF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))

/*! @brief Set the TFFF_RE field to a new value. */
#define SPI_WR_RSER_TFFF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_RE_MASK, SPI_RSER_TFFF_RE(value)))
#define SPI_BWR_RSER_TFFF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFFF_RE_SHIFT), SPI_RSER_TFFF_RE_SHIFT, SPI_RSER_TFFF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - TFUF interrupt requests are disabled.
 * - 0b1 - TFUF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define SPI_RD_RSER_TFUF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFUF_RE_MASK) >> SPI_RSER_TFUF_RE_SHIFT)
#define SPI_BRD_RSER_TFUF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))

/*! @brief Set the TFUF_RE field to a new value. */
#define SPI_WR_RSER_TFUF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFUF_RE_MASK, SPI_RSER_TFUF_RE(value)))
#define SPI_BWR_RSER_TFUF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TFUF_RE_SHIFT), SPI_RSER_TFUF_RE_SHIFT, SPI_RSER_TFUF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - EOQF interrupt requests are disabled.
 * - 0b1 - EOQF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define SPI_RD_RSER_EOQF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_EOQF_RE_MASK) >> SPI_RSER_EOQF_RE_SHIFT)
#define SPI_BRD_RSER_EOQF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))

/*! @brief Set the EOQF_RE field to a new value. */
#define SPI_WR_RSER_EOQF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_EOQF_RE_MASK, SPI_RSER_EOQF_RE(value)))
#define SPI_BWR_RSER_EOQF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_EOQF_RE_SHIFT), SPI_RSER_EOQF_RE_SHIFT, SPI_RSER_EOQF_RE_WIDTH))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0b0 - TCF interrupt requests are disabled.
 * - 0b1 - TCF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define SPI_RD_RSER_TCF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TCF_RE_MASK) >> SPI_RSER_TCF_RE_SHIFT)
#define SPI_BRD_RSER_TCF_RE(base) (BME_UBFX32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))

/*! @brief Set the TCF_RE field to a new value. */
#define SPI_WR_RSER_TCF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TCF_RE_MASK, SPI_RSER_TCF_RE(value)))
#define SPI_BWR_RSER_TCF_RE(base, value) (BME_BFI32(&SPI_RSER_REG(base), ((uint32_t)(value) << SPI_RSER_TCF_RE_SHIFT), SPI_RSER_TCF_RE_SHIFT, SPI_RSER_TCF_RE_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR - PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * transfers all 32 bits to the TX FIFO. In Master mode, the register transfers
 * 16 bits of data and 16 bits of command information. A read access of PUSHR
 * returns the topmost TX FIFO entry. When the module is disabled, writing to this
 * register does not update the FIFO. Therefore, any reads performed while the
 * module is disabled return the last PUSHR write performed while the module was
 * still enabled.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define SPI_RD_PUSHR(base)       (SPI_PUSHR_REG(base))
#define SPI_WR_PUSHR(base, value) (SPI_PUSHR_REG(base) = (value))
#define SPI_RMW_PUSHR(base, mask, value) (SPI_WR_PUSHR(base, (SPI_RD_PUSHR(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR(base, value) (BME_OR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR(base, value) (BME_AND32(&SPI_PUSHR_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR(base, value) (BME_XOR32(&SPI_PUSHR_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define SPI_RD_PUSHR_TXDATA(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_TXDATA_MASK) >> SPI_PUSHR_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_TXDATA(base) (SPI_RD_PUSHR_TXDATA(base))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_TXDATA(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_TXDATA_MASK, SPI_PUSHR_TXDATA(value)))
#define SPI_BWR_PUSHR_TXDATA(base, value) (SPI_WR_PUSHR_TXDATA(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[21:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip-specific SPI information for the number of PCS signals used in this chip.
 *
 * Values:
 * - 0b000000 - Negate the PCS[x] signal.
 * - 0b000001 - Assert the PCS[x] signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define SPI_RD_PUSHR_PCS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_PCS_MASK) >> SPI_PUSHR_PCS_SHIFT)
#define SPI_BRD_PUSHR_PCS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))

/*! @brief Set the PCS field to a new value. */
#define SPI_WR_PUSHR_PCS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_PCS_MASK, SPI_PUSHR_PCS(value)))
#define SPI_BWR_PUSHR_PCS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_PCS_SHIFT), SPI_PUSHR_PCS_SHIFT, SPI_PUSHR_PCS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the TCNT field in the TCR register. The TCNT field is cleared before
 * the module starts transmitting the current SPI frame.
 *
 * Values:
 * - 0b0 - Do not clear the TCR[TCNT] field.
 * - 0b1 - Clear the TCR[TCNT] field.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define SPI_RD_PUSHR_CTCNT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTCNT_MASK) >> SPI_PUSHR_CTCNT_SHIFT)
#define SPI_BRD_PUSHR_CTCNT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))

/*! @brief Set the CTCNT field to a new value. */
#define SPI_WR_PUSHR_CTCNT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTCNT_MASK, SPI_PUSHR_CTCNT(value)))
#define SPI_BWR_PUSHR_CTCNT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTCNT_SHIFT), SPI_PUSHR_CTCNT_SHIFT, SPI_PUSHR_CTCNT_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the module that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the
 * SR is set.
 *
 * Values:
 * - 0b0 - The SPI data is not the last data to transfer.
 * - 0b1 - The SPI data is the last data to transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define SPI_RD_PUSHR_EOQ(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_EOQ_MASK) >> SPI_PUSHR_EOQ_SHIFT)
#define SPI_BRD_PUSHR_EOQ(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))

/*! @brief Set the EOQ field to a new value. */
#define SPI_WR_PUSHR_EOQ(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_EOQ_MASK, SPI_PUSHR_EOQ(value)))
#define SPI_BWR_PUSHR_EOQ(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_EOQ_SHIFT), SPI_PUSHR_EOQ_SHIFT, SPI_PUSHR_EOQ_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR to use in master mode to specify the transfer attributes
 * for the associated SPI frame. In SPI Slave mode, CTAR0 is used. See the chip
 * specific section for details to determine how many CTARs this device has. You
 * should not program a value in this field for a register that is not present.
 *
 * Values:
 * - 0b000 - CTAR0
 * - 0b001 - CTAR1
 * - 0b010 - Reserved
 * - 0b011 - Reserved
 * - 0b100 - Reserved
 * - 0b101 - Reserved
 * - 0b110 - Reserved
 * - 0b111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define SPI_RD_PUSHR_CTAS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTAS_MASK) >> SPI_PUSHR_CTAS_SHIFT)
#define SPI_BRD_PUSHR_CTAS(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))

/*! @brief Set the CTAS field to a new value. */
#define SPI_WR_PUSHR_CTAS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTAS_MASK, SPI_PUSHR_CTAS(value)))
#define SPI_BWR_PUSHR_CTAS(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CTAS_SHIFT), SPI_PUSHR_CTAS_SHIFT, SPI_PUSHR_CTAS_WIDTH))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a continuous selection format. The bit is used in SPI Master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0b0 - Return PCSn signals to their inactive state between transfers.
 * - 0b1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define SPI_RD_PUSHR_CONT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CONT_MASK) >> SPI_PUSHR_CONT_SHIFT)
#define SPI_BRD_PUSHR_CONT(base) (BME_UBFX32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))

/*! @brief Set the CONT field to a new value. */
#define SPI_WR_PUSHR_CONT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CONT_MASK, SPI_PUSHR_CONT(value)))
#define SPI_BWR_PUSHR_CONT(base, value) (BME_BFI32(&SPI_PUSHR_REG(base), ((uint32_t)(value) << SPI_PUSHR_CONT_SHIFT), SPI_PUSHR_CONT_SHIFT, SPI_PUSHR_CONT_WIDTH))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO in slave mode. An 8- or
 * 16-bit write access to PUSHR transfers the 16-bit TXDATA field to the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define SPI_RD_PUSHR_SLAVE(base) (SPI_PUSHR_SLAVE_REG(base))
#define SPI_WR_PUSHR_SLAVE(base, value) (SPI_PUSHR_SLAVE_REG(base) = (value))
#define SPI_RMW_PUSHR_SLAVE(base, mask, value) (SPI_WR_PUSHR_SLAVE(base, (SPI_RD_PUSHR_SLAVE(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR_SLAVE(base, value) (BME_OR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
#define SPI_CLR_PUSHR_SLAVE(base, value) (BME_AND32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(~(value))))
#define SPI_TOG_PUSHR_SLAVE(base, value) (BME_XOR32(&SPI_PUSHR_SLAVE_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR_SLAVE bitfields
 */

/*!
 * @name Register SPI_PUSHR_SLAVE, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_SLAVE_TXDATA field. */
#define SPI_RD_PUSHR_SLAVE_TXDATA(base) ((SPI_PUSHR_SLAVE_REG(base) & SPI_PUSHR_SLAVE_TXDATA_MASK) >> SPI_PUSHR_SLAVE_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_SLAVE_TXDATA(base) (SPI_RD_PUSHR_SLAVE_TXDATA(base))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_SLAVE_TXDATA(base, value) (SPI_RMW_PUSHR_SLAVE(base, SPI_PUSHR_SLAVE_TXDATA_MASK, SPI_PUSHR_SLAVE_TXDATA(value)))
#define SPI_BWR_PUSHR_SLAVE_TXDATA(base, value) (SPI_WR_PUSHR_SLAVE_TXDATA(base, value))
/*@}*/

/*******************************************************************************
 * SPI_POPR - POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief SPI_POPR - POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define SPI_RD_POPR(base)        (SPI_POPR_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR0 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR0 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR0 register
 */
/*@{*/
#define SPI_RD_TXFR0(base)       (SPI_TXFR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR0 bitfields
 */

/*!
 * @name Register SPI_TXFR0, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXDATA field. */
#define SPI_RD_TXFR0_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXDATA_MASK) >> SPI_TXFR0_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXDATA(base) (SPI_RD_TXFR0_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR0, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXCMD_TXDATA field. */
#define SPI_RD_TXFR0_TXCMD_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXCMD_TXDATA_MASK) >> SPI_TXFR0_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXCMD_TXDATA(base) (SPI_RD_TXFR0_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR1 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR1 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR1 register
 */
/*@{*/
#define SPI_RD_TXFR1(base)       (SPI_TXFR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR1 bitfields
 */

/*!
 * @name Register SPI_TXFR1, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXDATA field. */
#define SPI_RD_TXFR1_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXDATA_MASK) >> SPI_TXFR1_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXDATA(base) (SPI_RD_TXFR1_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR1, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXCMD_TXDATA field. */
#define SPI_RD_TXFR1_TXCMD_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXCMD_TXDATA_MASK) >> SPI_TXFR1_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXCMD_TXDATA(base) (SPI_RD_TXFR1_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR2 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR2 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR2 register
 */
/*@{*/
#define SPI_RD_TXFR2(base)       (SPI_TXFR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR2 bitfields
 */

/*!
 * @name Register SPI_TXFR2, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXDATA field. */
#define SPI_RD_TXFR2_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXDATA_MASK) >> SPI_TXFR2_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXDATA(base) (SPI_RD_TXFR2_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR2, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXCMD_TXDATA field. */
#define SPI_RD_TXFR2_TXCMD_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXCMD_TXDATA_MASK) >> SPI_TXFR2_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXCMD_TXDATA(base) (SPI_RD_TXFR2_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR3 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR3 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR3 register
 */
/*@{*/
#define SPI_RD_TXFR3(base)       (SPI_TXFR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR3 bitfields
 */

/*!
 * @name Register SPI_TXFR3, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXDATA field. */
#define SPI_RD_TXFR3_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXDATA_MASK) >> SPI_TXFR3_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXDATA(base) (SPI_RD_TXFR3_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR3, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXCMD_TXDATA field. */
#define SPI_RD_TXFR3_TXCMD_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXCMD_TXDATA_MASK) >> SPI_TXFR3_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXCMD_TXDATA(base) (SPI_RD_TXFR3_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR0 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR0 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR0 register
 */
/*@{*/
#define SPI_RD_RXFR0(base)       (SPI_RXFR0_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR1 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR1 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR1 register
 */
/*@{*/
#define SPI_RD_RXFR1(base)       (SPI_RXFR1_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR2 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR2 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR2 register
 */
/*@{*/
#define SPI_RD_RXFR2(base)       (SPI_RXFR2_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR3 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR3 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR3 register
 */
/*@{*/
#define SPI_RD_RXFR3(base)       (SPI_RXFR3_REG(base))
/*@}*/

/*
 * MKV58F24 TRNG
 *
 * RNG
 *
 * Registers defined in this header file:
 * - TRNG_MCTL - RNG Miscellaneous Control Register
 * - TRNG_SCMISC - RNG Statistical Check Miscellaneous Register
 * - TRNG_PKRRNG - RNG Poker Range Register
 * - TRNG_PKRMAX - RNG Poker Maximum Limit Register
 * - TRNG_PKRSQ - RNG Poker Square Calculation Result Register
 * - TRNG_SDCTL - RNG Seed Control Register
 * - TRNG_SBLIM - RNG Sparse Bit Limit Register
 * - TRNG_TOTSAM - RNG Total Samples Register
 * - TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register
 * - TRNG_FRQCNT - RNG Frequency Count Register
 * - TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register
 * - TRNG_SCMC - RNG Statistical Check Monobit Count Register
 * - TRNG_SCML - RNG Statistical Check Monobit Limit Register
 * - TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register
 * - TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register
 * - TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register
 * - TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register
 * - TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register
 * - TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register
 * - TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register
 * - TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register
 * - TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register
 * - TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register
 * - TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register
 * - TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 * - TRNG_STATUS - RNG Status Register
 * - TRNG_ENT - RNG TRNG Entropy Read Register
 * - TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 * - TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 * - TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 * - TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 * - TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 * - TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register
 * - TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register
 * - TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register
 * - TRNG_SEC_CFG - RNG Security Configuration Register
 * - TRNG_INT_CTRL - RNG Interrupt Control Register
 * - TRNG_INT_MASK - RNG Mask Register
 * - TRNG_INT_STATUS - RNG Interrupt Status Register
 * - TRNG_VID1 - RNG Version ID Register (MS)
 * - TRNG_VID2 - RNG Version ID Register (LS)
 */

#define TRNG_INSTANCE_COUNT (1U) /*!< Number of instances of the TRNG module. */
#define TRNG0_IDX (0U) /*!< Instance number for TRNG0. */

/*******************************************************************************
 * TRNG_MCTL - RNG Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_MCTL - RNG Miscellaneous Control Register (RW)
 *
 * Reset value: 0x00012001U
 *
 * This register is intended to be used for programming, configuring and testing
 * the RNG. It is the main register to read/write, in order to enable Entropy
 * generation, to stop entropy generation and to block access to entropy registers.
 * This is done via the special TRNG_ACC and PRGM bits below. The RNG
 * Miscellaneous Control Register is a read/write register used to control the RNG's True
 * Random Number Generator (TRNG) access, operation and test. Note that in many
 * cases two RNG registers share the same address, and a particular register at the
 * shared address is selected based upon the value in the PRGM field of the MCTL
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_MCTL register
 */
/*@{*/
#define TRNG_RD_MCTL(base)       (TRNG_MCTL_REG(base))
#define TRNG_WR_MCTL(base, value) (TRNG_MCTL_REG(base) = (value))
#define TRNG_RMW_MCTL(base, mask, value) (TRNG_WR_MCTL(base, (TRNG_RD_MCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_MCTL(base, value) (BME_OR32(&TRNG_MCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_MCTL(base, value) (BME_AND32(&TRNG_MCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_MCTL(base, value) (BME_XOR32(&TRNG_MCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_MCTL bitfields
 */

/*!
 * @name Register TRNG_MCTL, field SAMP_MODE[1:0] (RW)
 *
 * Sample Mode. Determines the method of sampling the ring oscillator while
 * generating the Entropy value: This field is writable only if PRGM bit is 1, or
 * PRGM bit is being written to 1 simultaneously with writing this field. This field
 * is cleared to the POR default value by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use Von Neumann data into both Entropy shifter and Statistical
 *     Checker
 * - 0b01 - use raw data into both Entropy shifter and Statistical Checker
 * - 0b10 - use Von Neumann data into Entropy shifter. Use raw data into
 *     Statistical Checker
 * - 0b11 - reserved.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_SAMP_MODE field. */
#define TRNG_RD_MCTL_SAMP_MODE(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_SAMP_MODE_MASK) >> TRNG_MCTL_SAMP_MODE_SHIFT)
#define TRNG_BRD_MCTL_SAMP_MODE(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_SAMP_MODE_SHIFT, TRNG_MCTL_SAMP_MODE_WIDTH))

/*! @brief Set the SAMP_MODE field to a new value. */
#define TRNG_WR_MCTL_SAMP_MODE(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_SAMP_MODE_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_SAMP_MODE(value)))
#define TRNG_BWR_MCTL_SAMP_MODE(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_SAMP_MODE_SHIFT), TRNG_MCTL_SAMP_MODE_SHIFT, TRNG_MCTL_SAMP_MODE_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field OSC_DIV[3:2] (RW)
 *
 * Oscillator Divide. Determines the amount of dividing done to the ring
 * oscillator before it is used by the TRNG. This field is writable only if PRGM bit is
 * 1, or PRGM bit is being written to 1 simultaneously to writing this field.
 * This field is cleared to 00 by writing the RST_DEF bit to 1.
 *
 * Values:
 * - 0b00 - use ring oscillator with no divide
 * - 0b01 - use ring oscillator divided-by-2
 * - 0b10 - use ring oscillator divided-by-4
 * - 0b11 - use ring oscillator divided-by-8
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_OSC_DIV field. */
#define TRNG_RD_MCTL_OSC_DIV(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_OSC_DIV_MASK) >> TRNG_MCTL_OSC_DIV_SHIFT)
#define TRNG_BRD_MCTL_OSC_DIV(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_OSC_DIV_SHIFT, TRNG_MCTL_OSC_DIV_WIDTH))

/*! @brief Set the OSC_DIV field to a new value. */
#define TRNG_WR_MCTL_OSC_DIV(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_OSC_DIV_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_OSC_DIV(value)))
#define TRNG_BWR_MCTL_OSC_DIV(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_OSC_DIV_SHIFT), TRNG_MCTL_OSC_DIV_SHIFT, TRNG_MCTL_OSC_DIV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field UNUSED[4] (RW)
 *
 * This bit is unused but write-able. Must be left as zero.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_UNUSED field. */
#define TRNG_RD_MCTL_UNUSED(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_UNUSED_MASK) >> TRNG_MCTL_UNUSED_SHIFT)
#define TRNG_BRD_MCTL_UNUSED(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_UNUSED_SHIFT, TRNG_MCTL_UNUSED_WIDTH))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_MCTL_UNUSED(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_UNUSED_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_UNUSED(value)))
#define TRNG_BWR_MCTL_UNUSED(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_UNUSED_SHIFT), TRNG_MCTL_UNUSED_SHIFT, TRNG_MCTL_UNUSED_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TRNG_ACC[5] (RW)
 *
 * TRNG Access Mode. If this bit is set to 1, the TRNG will generate an Entropy
 * value that can be read via the ENT0-ENT15 registers. The Entropy value may be
 * read once the ENT VAL bit is asserted. Also see ENTa register descriptions
 * (For a = 0 to 15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TRNG_ACC field. */
#define TRNG_RD_MCTL_TRNG_ACC(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TRNG_ACC_MASK) >> TRNG_MCTL_TRNG_ACC_SHIFT)
#define TRNG_BRD_MCTL_TRNG_ACC(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TRNG_ACC_SHIFT, TRNG_MCTL_TRNG_ACC_WIDTH))

/*! @brief Set the TRNG_ACC field to a new value. */
#define TRNG_WR_MCTL_TRNG_ACC(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_TRNG_ACC_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_TRNG_ACC(value)))
#define TRNG_BWR_MCTL_TRNG_ACC(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_TRNG_ACC_SHIFT), TRNG_MCTL_TRNG_ACC_SHIFT, TRNG_MCTL_TRNG_ACC_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field RST_DEF[6] (WO)
 *
 * Reset Defaults. Writing a 1 to this bit clears various TRNG registers, and
 * bits within registers, to their default state. This bit is writable only if PRGM
 * bit is 1, or PRGM bit is being written to 1 simultaneously to writing this
 * bit. Reading this bit always produces a 0.
 */
/*@{*/
/*! @brief Set the RST_DEF field to a new value. */
#define TRNG_WR_MCTL_RST_DEF(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_RST_DEF_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_RST_DEF(value)))
#define TRNG_BWR_MCTL_RST_DEF(base, value) (TRNG_WR_MCTL_RST_DEF(base, value))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FOR_SCLK[7] (RW)
 *
 * Force System Clock. If set, the system clock is used to operate the TRNG,
 * instead of the ring oscillator. This is for test use only, and indeterminate
 * results may occur. This bit is writable only if PRGM bit is 1, or PRGM bit is
 * being written to 1 simultaneously to writing this bit. This bit is cleared by
 * writing the RST_DEF bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FOR_SCLK field. */
#define TRNG_RD_MCTL_FOR_SCLK(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FOR_SCLK_MASK) >> TRNG_MCTL_FOR_SCLK_SHIFT)
#define TRNG_BRD_MCTL_FOR_SCLK(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FOR_SCLK_SHIFT, TRNG_MCTL_FOR_SCLK_WIDTH))

/*! @brief Set the FOR_SCLK field to a new value. */
#define TRNG_WR_MCTL_FOR_SCLK(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_FOR_SCLK_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_FOR_SCLK(value)))
#define TRNG_BWR_MCTL_FOR_SCLK(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_FOR_SCLK_SHIFT), TRNG_MCTL_FOR_SCLK_SHIFT, TRNG_MCTL_FOR_SCLK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FCT_FAIL[8] (RO)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the FRQMAX and/or FRQMIN
 * registers, or a hardware failure in the ring oscillator. This error may be cleared by
 * writing a 1 to the ERR bit.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FCT_FAIL field. */
#define TRNG_RD_MCTL_FCT_FAIL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FCT_FAIL_MASK) >> TRNG_MCTL_FCT_FAIL_SHIFT)
#define TRNG_BRD_MCTL_FCT_FAIL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FCT_FAIL_SHIFT, TRNG_MCTL_FCT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field FCT_VAL[9] (RO)
 *
 * Read only: Frequency Count Valid. Indicates that a valid frequency count may
 * be read from FRQCNT.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_FCT_VAL field. */
#define TRNG_RD_MCTL_FCT_VAL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_FCT_VAL_MASK) >> TRNG_MCTL_FCT_VAL_SHIFT)
#define TRNG_BRD_MCTL_FCT_VAL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_FCT_VAL_SHIFT, TRNG_MCTL_FCT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field ENT_VAL[10] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when ENT15 is read. (ENT0
 * through ENT14 should be read before reading ENT15).
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_ENT_VAL field. */
#define TRNG_RD_MCTL_ENT_VAL(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_ENT_VAL_MASK) >> TRNG_MCTL_ENT_VAL_SHIFT)
#define TRNG_BRD_MCTL_ENT_VAL(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_ENT_VAL_SHIFT, TRNG_MCTL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TST_OUT[11] (RO)
 *
 * Read only: Test point inside ring oscillator.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TST_OUT field. */
#define TRNG_RD_MCTL_TST_OUT(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TST_OUT_MASK) >> TRNG_MCTL_TST_OUT_SHIFT)
#define TRNG_BRD_MCTL_TST_OUT(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TST_OUT_SHIFT, TRNG_MCTL_TST_OUT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field ERR[12] (W1C)
 *
 * Read: Error status. 1 = error detected. 0 = no error. Write: Write 1 to clear
 * errors. Writing 0 has no effect.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_ERR field. */
#define TRNG_RD_MCTL_ERR(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_ERR_MASK) >> TRNG_MCTL_ERR_SHIFT)
#define TRNG_BRD_MCTL_ERR(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_ERR_SHIFT, TRNG_MCTL_ERR_WIDTH))

/*! @brief Set the ERR field to a new value. */
#define TRNG_WR_MCTL_ERR(base, value) (TRNG_RMW_MCTL(base, TRNG_MCTL_ERR_MASK, TRNG_MCTL_ERR(value)))
#define TRNG_BWR_MCTL_ERR(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_ERR_SHIFT), TRNG_MCTL_ERR_SHIFT, TRNG_MCTL_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field TSTOP_OK[13] (RO)
 *
 * TRNG_OK_TO_STOP. Software should check that this bit is a 1 before
 * transitioning RNG to low power mode (RNG clock stopped). RNG turns on the TRNG
 * free-running ring oscillator whenever new entropy is being generated and turns off the
 * ring oscillator when entropy generation is complete. If the RNG clock is
 * stopped while the TRNG ring oscillator is running, the oscillator will continue
 * running even though the RNG clock is stopped. TSTOP_OK is asserted when the TRNG
 * ring oscillator is not running. and therefore it is ok to stop the RNG clock.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_TSTOP_OK field. */
#define TRNG_RD_MCTL_TSTOP_OK(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_TSTOP_OK_MASK) >> TRNG_MCTL_TSTOP_OK_SHIFT)
#define TRNG_BRD_MCTL_TSTOP_OK(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_TSTOP_OK_SHIFT, TRNG_MCTL_TSTOP_OK_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_MCTL, field PRGM[16] (RW)
 *
 * Programming Mode Select. When this bit is 1, the TRNG is in Program Mode,
 * otherwise it is in Run Mode. No Entropy value will be generated while the TRNG is
 * in Program Mode. Note that different RNG registers are accessible at the same
 * address depending on whether PRGM is set to 1 or 0. This is noted in the RNG
 * register descriptions.
 */
/*@{*/
/*! @brief Read current value of the TRNG_MCTL_PRGM field. */
#define TRNG_RD_MCTL_PRGM(base) ((TRNG_MCTL_REG(base) & TRNG_MCTL_PRGM_MASK) >> TRNG_MCTL_PRGM_SHIFT)
#define TRNG_BRD_MCTL_PRGM(base) (BME_UBFX32(&TRNG_MCTL_REG(base), TRNG_MCTL_PRGM_SHIFT, TRNG_MCTL_PRGM_WIDTH))

/*! @brief Set the PRGM field to a new value. */
#define TRNG_WR_MCTL_PRGM(base, value) (TRNG_RMW_MCTL(base, (TRNG_MCTL_PRGM_MASK | TRNG_MCTL_ERR_MASK), TRNG_MCTL_PRGM(value)))
#define TRNG_BWR_MCTL_PRGM(base, value) (BME_BFI32(&TRNG_MCTL_REG(base), ((uint32_t)(value) << TRNG_MCTL_PRGM_SHIFT), TRNG_MCTL_PRGM_SHIFT, TRNG_MCTL_PRGM_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_SCMISC - RNG Statistical Check Miscellaneous Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCMISC - RNG Statistical Check Miscellaneous Register (RW)
 *
 * Reset value: 0x0001001FU
 *
 * The RNG Statistical Check Miscellaneous Register contains the Long Run
 * Maximum Limit value and the Retry Count value. This register is accessible only when
 * the MCTL[PRGM] bit is 1, otherwise this register will read zeroes, and cannot
 * be written.
 */
/*!
 * @name Constants and macros for entire TRNG_SCMISC register
 */
/*@{*/
#define TRNG_RD_SCMISC(base)     (TRNG_SCMISC_REG(base))
#define TRNG_WR_SCMISC(base, value) (TRNG_SCMISC_REG(base) = (value))
#define TRNG_RMW_SCMISC(base, mask, value) (TRNG_WR_SCMISC(base, (TRNG_RD_SCMISC(base) & ~(mask)) | (value)))
#define TRNG_SET_SCMISC(base, value) (BME_OR32(&TRNG_SCMISC_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCMISC(base, value) (BME_AND32(&TRNG_SCMISC_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCMISC(base, value) (BME_XOR32(&TRNG_SCMISC_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCMISC bitfields
 */

/*!
 * @name Register TRNG_SCMISC, field LRUN_MAX[7:0] (RW)
 *
 * LONG RUN MAX LIMIT. This value is the largest allowable number of consecutive
 * samples of all 1, or all 0, that is allowed during the Entropy generation.
 * This field is writable only if MCTL[PRGM] bit is 1. This field will read zeroes
 * if MCTL[PRGM] = 0. This field is cleared to 22h by writing the MCTL[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMISC_LRUN_MAX field. */
#define TRNG_RD_SCMISC_LRUN_MAX(base) ((TRNG_SCMISC_REG(base) & TRNG_SCMISC_LRUN_MAX_MASK) >> TRNG_SCMISC_LRUN_MAX_SHIFT)
#define TRNG_BRD_SCMISC_LRUN_MAX(base) (BME_UBFX32(&TRNG_SCMISC_REG(base), TRNG_SCMISC_LRUN_MAX_SHIFT, TRNG_SCMISC_LRUN_MAX_WIDTH))

/*! @brief Set the LRUN_MAX field to a new value. */
#define TRNG_WR_SCMISC_LRUN_MAX(base, value) (TRNG_RMW_SCMISC(base, TRNG_SCMISC_LRUN_MAX_MASK, TRNG_SCMISC_LRUN_MAX(value)))
#define TRNG_BWR_SCMISC_LRUN_MAX(base, value) (BME_BFI32(&TRNG_SCMISC_REG(base), ((uint32_t)(value) << TRNG_SCMISC_LRUN_MAX_SHIFT), TRNG_SCMISC_LRUN_MAX_SHIFT, TRNG_SCMISC_LRUN_MAX_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SCMISC, field RTY_CT[19:16] (RW)
 *
 * RETRY COUNT. If a statistical check fails during the TRNG Entropy Generation,
 * the RTY_CT value indicates the number of times a retry should occur before
 * generating an error. This field is writable only if MCTL[PRGM] bit is 1. This
 * field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 1h by writing
 * the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMISC_RTY_CT field. */
#define TRNG_RD_SCMISC_RTY_CT(base) ((TRNG_SCMISC_REG(base) & TRNG_SCMISC_RTY_CT_MASK) >> TRNG_SCMISC_RTY_CT_SHIFT)
#define TRNG_BRD_SCMISC_RTY_CT(base) (BME_UBFX32(&TRNG_SCMISC_REG(base), TRNG_SCMISC_RTY_CT_SHIFT, TRNG_SCMISC_RTY_CT_WIDTH))

/*! @brief Set the RTY_CT field to a new value. */
#define TRNG_WR_SCMISC_RTY_CT(base, value) (TRNG_RMW_SCMISC(base, TRNG_SCMISC_RTY_CT_MASK, TRNG_SCMISC_RTY_CT(value)))
#define TRNG_BWR_SCMISC_RTY_CT(base, value) (BME_BFI32(&TRNG_SCMISC_REG(base), ((uint32_t)(value) << TRNG_SCMISC_RTY_CT_SHIFT), TRNG_SCMISC_RTY_CT_SHIFT, TRNG_SCMISC_RTY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_PKRRNG - RNG Poker Range Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRRNG - RNG Poker Range Register (RW)
 *
 * Reset value: 0x000009A3U
 *
 * The RNG Poker Range Register defines the difference between the TRNG Poker
 * Maximum Limit and the minimum limit. These limits are used during the TRNG
 * Statistical Check Poker Test.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRRNG register
 */
/*@{*/
#define TRNG_RD_PKRRNG(base)     (TRNG_PKRRNG_REG(base))
#define TRNG_WR_PKRRNG(base, value) (TRNG_PKRRNG_REG(base) = (value))
#define TRNG_RMW_PKRRNG(base, mask, value) (TRNG_WR_PKRRNG(base, (TRNG_RD_PKRRNG(base) & ~(mask)) | (value)))
#define TRNG_SET_PKRRNG(base, value) (BME_OR32(&TRNG_PKRRNG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_PKRRNG(base, value) (BME_AND32(&TRNG_PKRRNG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_PKRRNG(base, value) (BME_XOR32(&TRNG_PKRRNG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRRNG bitfields
 */

/*!
 * @name Register TRNG_PKRRNG, field PKR_RNG[15:0] (RW)
 *
 * Poker Range. During the TRNG Statistical Checks, a "Poker Test" is run which
 * requires a maximum and minimum limit. The maximum is programmed in the
 * RTPKRMAX[PKR_MAX] register, and the minimum is derived by subtracting the PKR_RNG
 * value from the programmed maximum value. This field is writable only if
 * MCTL[PRGM] bit is 1. This field will read zeroes if MCTL[PRGM] = 0. This field is
 * cleared to 09A3h (decimal 2467) by writing the MCTL[RST_DEF] bit to 1. Note that
 * the minimum allowable Poker result is PKR_MAX - PKR_RNG + 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRRNG_PKR_RNG field. */
#define TRNG_RD_PKRRNG_PKR_RNG(base) ((TRNG_PKRRNG_REG(base) & TRNG_PKRRNG_PKR_RNG_MASK) >> TRNG_PKRRNG_PKR_RNG_SHIFT)
#define TRNG_BRD_PKRRNG_PKR_RNG(base) (TRNG_RD_PKRRNG_PKR_RNG(base))

/*! @brief Set the PKR_RNG field to a new value. */
#define TRNG_WR_PKRRNG_PKR_RNG(base, value) (TRNG_RMW_PKRRNG(base, TRNG_PKRRNG_PKR_RNG_MASK, TRNG_PKRRNG_PKR_RNG(value)))
#define TRNG_BWR_PKRRNG_PKR_RNG(base, value) (TRNG_WR_PKRRNG_PKR_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_PKRMAX - RNG Poker Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRMAX - RNG Poker Maximum Limit Register (RW)
 *
 * Reset value: 0x00006920U
 *
 * The RNG Poker Maximum Limit Register defines Maximum Limit allowable during
 * the TRNG Statistical Check Poker Test. Note that this offset (0xBASE_060C) is
 * used as PKRMAX only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used
 * as the PKRSQ readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRMAX register
 */
/*@{*/
#define TRNG_RD_PKRMAX(base)     (TRNG_PKRMAX_REG(base))
#define TRNG_WR_PKRMAX(base, value) (TRNG_PKRMAX_REG(base) = (value))
#define TRNG_RMW_PKRMAX(base, mask, value) (TRNG_WR_PKRMAX(base, (TRNG_RD_PKRMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_PKRMAX(base, value) (BME_OR32(&TRNG_PKRMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_PKRMAX(base, value) (BME_AND32(&TRNG_PKRMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_PKRMAX(base, value) (BME_XOR32(&TRNG_PKRMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRMAX bitfields
 */

/*!
 * @name Register TRNG_PKRMAX, field PKR_MAX[23:0] (RW)
 *
 * Poker Maximum Limit. During the TRNG Statistical Checks, a "Poker Test" is
 * run which requires a maximum and minimum limit. The maximum allowable result is
 * programmed in the PKRMAX[PKR_MAX] register. This field is writable only if
 * MCTL[PRGM] bit is 1. This register is cleared to 006920h (decimal 26912) by
 * writing the MCTL[RST_DEF] bit to 1. Note that the PKRMAX and PKRRNG registers
 * combined are used to define the minimum allowable Poker result, which is PKR_MAX -
 * PKR_RNG + 1. Note that if MCTL[PRGM] bit is 0, this register address is used
 * to read the Poker Test Square Calculation result in register PKRSQ, as defined
 * in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRMAX_PKR_MAX field. */
#define TRNG_RD_PKRMAX_PKR_MAX(base) ((TRNG_PKRMAX_REG(base) & TRNG_PKRMAX_PKR_MAX_MASK) >> TRNG_PKRMAX_PKR_MAX_SHIFT)
#define TRNG_BRD_PKRMAX_PKR_MAX(base) (TRNG_RD_PKRMAX_PKR_MAX(base))

/*! @brief Set the PKR_MAX field to a new value. */
#define TRNG_WR_PKRMAX_PKR_MAX(base, value) (TRNG_RMW_PKRMAX(base, TRNG_PKRMAX_PKR_MAX_MASK, TRNG_PKRMAX_PKR_MAX(value)))
#define TRNG_BWR_PKRMAX_PKR_MAX(base, value) (TRNG_WR_PKRMAX_PKR_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_PKRSQ - RNG Poker Square Calculation Result Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRSQ - RNG Poker Square Calculation Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Poker Square Calculation Result Register is a read-only register used
 * to read the result of the TRNG Statistical Check Poker Test's Square
 * Calculation. This test starts with the PKRMAX value and decreases towards a final
 * result, which is read here. For the Poker Test to pass, this final result must be
 * less than the programmed PKRRNG value. Note that this offset (0xBASE_060C) is
 * used as PKRMAX if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * PKRSQ readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRSQ register
 */
/*@{*/
#define TRNG_RD_PKRSQ(base)      (TRNG_PKRSQ_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRSQ bitfields
 */

/*!
 * @name Register TRNG_PKRSQ, field PKR_SQ[23:0] (RO)
 *
 * Poker Square Calculation Result. During the TRNG Statistical Checks, a "Poker
 * Test" is run which starts with the value PKRMAX[PKR_MAX]. This value
 * decreases according to a "sum of squares" algorithm, and must remain greater than
 * zero, but less than the PKRRNG[PKR_RNG] limit. The resulting value may be read
 * through this register, if MCTL[PRGM] bit is 0. Note that if MCTL[PRGM] bit is 1,
 * this register address is used to access the Poker Test Maximum Limit in
 * register PKRMAX, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRSQ_PKR_SQ field. */
#define TRNG_RD_PKRSQ_PKR_SQ(base) ((TRNG_PKRSQ_REG(base) & TRNG_PKRSQ_PKR_SQ_MASK) >> TRNG_PKRSQ_PKR_SQ_SHIFT)
#define TRNG_BRD_PKRSQ_PKR_SQ(base) (TRNG_RD_PKRSQ_PKR_SQ(base))
/*@}*/

/*******************************************************************************
 * TRNG_SDCTL - RNG Seed Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_SDCTL - RNG Seed Control Register (RW)
 *
 * Reset value: 0x0C8009C4U
 *
 * The RNG Seed Control Register contains two fields. One field defines the
 * length (in system clocks) of each Entropy sample (ENT_DLY), and the other field
 * indicates the number of samples that will taken during each TRNG Entropy
 * generation (SAMP_SIZE).
 */
/*!
 * @name Constants and macros for entire TRNG_SDCTL register
 */
/*@{*/
#define TRNG_RD_SDCTL(base)      (TRNG_SDCTL_REG(base))
#define TRNG_WR_SDCTL(base, value) (TRNG_SDCTL_REG(base) = (value))
#define TRNG_RMW_SDCTL(base, mask, value) (TRNG_WR_SDCTL(base, (TRNG_RD_SDCTL(base) & ~(mask)) | (value)))
#define TRNG_SET_SDCTL(base, value) (BME_OR32(&TRNG_SDCTL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SDCTL(base, value) (BME_AND32(&TRNG_SDCTL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SDCTL(base, value) (BME_XOR32(&TRNG_SDCTL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SDCTL bitfields
 */

/*!
 * @name Register TRNG_SDCTL, field SAMP_SIZE[15:0] (RW)
 *
 * Sample Size. Defines the total number of Entropy samples that will be taken
 * during Entropy generation. This field is writable only if MCTL[PRGM] bit is 1.
 * This field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 09C4h
 * (decimal 2500) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SDCTL_SAMP_SIZE field. */
#define TRNG_RD_SDCTL_SAMP_SIZE(base) ((TRNG_SDCTL_REG(base) & TRNG_SDCTL_SAMP_SIZE_MASK) >> TRNG_SDCTL_SAMP_SIZE_SHIFT)
#define TRNG_BRD_SDCTL_SAMP_SIZE(base) (TRNG_RD_SDCTL_SAMP_SIZE(base))

/*! @brief Set the SAMP_SIZE field to a new value. */
#define TRNG_WR_SDCTL_SAMP_SIZE(base, value) (TRNG_RMW_SDCTL(base, TRNG_SDCTL_SAMP_SIZE_MASK, TRNG_SDCTL_SAMP_SIZE(value)))
#define TRNG_BWR_SDCTL_SAMP_SIZE(base, value) (TRNG_WR_SDCTL_SAMP_SIZE(base, value))
/*@}*/

/*!
 * @name Register TRNG_SDCTL, field ENT_DLY[31:16] (RW)
 *
 * Entropy Delay. Defines the length (in system clocks) of each Entropy sample
 * taken. This field is writable only if MCTL[PRGM] bit is 1. This field will read
 * zeroes if MCTL[PRGM] = 0. This field is cleared to 0C80h (decimal 3200) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SDCTL_ENT_DLY field. */
#define TRNG_RD_SDCTL_ENT_DLY(base) ((TRNG_SDCTL_REG(base) & TRNG_SDCTL_ENT_DLY_MASK) >> TRNG_SDCTL_ENT_DLY_SHIFT)
#define TRNG_BRD_SDCTL_ENT_DLY(base) (TRNG_RD_SDCTL_ENT_DLY(base))

/*! @brief Set the ENT_DLY field to a new value. */
#define TRNG_WR_SDCTL_ENT_DLY(base, value) (TRNG_RMW_SDCTL(base, TRNG_SDCTL_ENT_DLY_MASK, TRNG_SDCTL_ENT_DLY(value)))
#define TRNG_BWR_SDCTL_ENT_DLY(base, value) (TRNG_WR_SDCTL_ENT_DLY(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SBLIM - RNG Sparse Bit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SBLIM - RNG Sparse Bit Limit Register (RW)
 *
 * Reset value: 0x0000003FU
 *
 * The RNG Sparse Bit Limit Register is used when Von Neumann sampling is
 * selected during Entropy Generation. It defines the maximum number of consecutive Von
 * Neumann samples which may be discarded before an error is generated. Note
 * that this address (0xBASE_0614) is used as SBLIM only if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this address is used as TOTSAM readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SBLIM register
 */
/*@{*/
#define TRNG_RD_SBLIM(base)      (TRNG_SBLIM_REG(base))
#define TRNG_WR_SBLIM(base, value) (TRNG_SBLIM_REG(base) = (value))
#define TRNG_RMW_SBLIM(base, mask, value) (TRNG_WR_SBLIM(base, (TRNG_RD_SBLIM(base) & ~(mask)) | (value)))
#define TRNG_SET_SBLIM(base, value) (BME_OR32(&TRNG_SBLIM_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SBLIM(base, value) (BME_AND32(&TRNG_SBLIM_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SBLIM(base, value) (BME_XOR32(&TRNG_SBLIM_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SBLIM bitfields
 */

/*!
 * @name Register TRNG_SBLIM, field SB_LIM[9:0] (RW)
 *
 * Sparse Bit Limit. During Von Neumann sampling (if enabled by MCTL[SAMP_MODE],
 * samples are discarded if two consecutive raw samples are both 0 or both 1. If
 * this discarding occurs for a long period of time, it indicates that there is
 * insufficient Entropy. The Sparse Bit Limit defines the maximum number of
 * consecutive samples that may be discarded before an error is generated. This field
 * is writable only if MCTL[PRGM] bit is 1. This register is cleared to 03hF by
 * writing the MCTL[RST_DEF] bit to 1. Note that if MCTL[PRGM] bit is 0, this
 * register address is used to read the Total Samples count in register TOTSAM, as
 * defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SBLIM_SB_LIM field. */
#define TRNG_RD_SBLIM_SB_LIM(base) ((TRNG_SBLIM_REG(base) & TRNG_SBLIM_SB_LIM_MASK) >> TRNG_SBLIM_SB_LIM_SHIFT)
#define TRNG_BRD_SBLIM_SB_LIM(base) (TRNG_RD_SBLIM_SB_LIM(base))

/*! @brief Set the SB_LIM field to a new value. */
#define TRNG_WR_SBLIM_SB_LIM(base, value) (TRNG_RMW_SBLIM(base, TRNG_SBLIM_SB_LIM_MASK, TRNG_SBLIM_SB_LIM(value)))
#define TRNG_BWR_SBLIM_SB_LIM(base, value) (TRNG_WR_SBLIM_SB_LIM(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_TOTSAM - RNG Total Samples Register
 ******************************************************************************/

/*!
 * @brief TRNG_TOTSAM - RNG Total Samples Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Total Samples Register is a read-only register used to read the total
 * number of samples taken during Entropy generation. It is used to give an
 * indication of how often a sample is actually used during Von Neumann sampling.
 * Note that this offset (0xBASE_0614) is used as SBLIM if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this offset is used as TOTSAM readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_TOTSAM register
 */
/*@{*/
#define TRNG_RD_TOTSAM(base)     (TRNG_TOTSAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_TOTSAM bitfields
 */

/*!
 * @name Register TRNG_TOTSAM, field TOT_SAM[19:0] (RO)
 *
 * Total Samples. During Entropy generation, the total number of raw samples is
 * counted. This count is useful in determining how often a sample is used during
 * Von Neumann sampling. The count may be read through this register, if
 * MCTL[PRGM] bit is 0. Note that if MCTL[PRGM] bit is 1, this register address is used
 * to access the Sparse Bit Limit in register SBLIM, as defined in the previous
 * section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_TOTSAM_TOT_SAM field. */
#define TRNG_RD_TOTSAM_TOT_SAM(base) ((TRNG_TOTSAM_REG(base) & TRNG_TOTSAM_TOT_SAM_MASK) >> TRNG_TOTSAM_TOT_SAM_SHIFT)
#define TRNG_BRD_TOTSAM_TOT_SAM(base) (TRNG_RD_TOTSAM_TOT_SAM(base))
/*@}*/

/*******************************************************************************
 * TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQMIN - RNG Frequency Count Minimum Limit Register (RW)
 *
 * Reset value: 0x00000640U
 *
 * The RNG Frequency Count Minimum Limit Register defines the minimum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is less than this programmed minimum, a
 * Frequency Count Fail is flagged in MCTL[FCT_FAIL] and an error is generated.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQMIN register
 */
/*@{*/
#define TRNG_RD_FRQMIN(base)     (TRNG_FRQMIN_REG(base))
#define TRNG_WR_FRQMIN(base, value) (TRNG_FRQMIN_REG(base) = (value))
#define TRNG_RMW_FRQMIN(base, mask, value) (TRNG_WR_FRQMIN(base, (TRNG_RD_FRQMIN(base) & ~(mask)) | (value)))
#define TRNG_SET_FRQMIN(base, value) (BME_OR32(&TRNG_FRQMIN_REG(base), (uint32_t)(value)))
#define TRNG_CLR_FRQMIN(base, value) (BME_AND32(&TRNG_FRQMIN_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_FRQMIN(base, value) (BME_XOR32(&TRNG_FRQMIN_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQMIN bitfields
 */

/*!
 * @name Register TRNG_FRQMIN, field FRQ_MIN[21:0] (RW)
 *
 * Frequency Count Minimum Limit. Defines the minimum allowable count taken
 * during each entropy sample. This field is writable only if MCTL[PRGM] bit is 1.
 * This field will read zeroes if MCTL[PRGM] = 0. This field is cleared to 0000h64
 * by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQMIN_FRQ_MIN field. */
#define TRNG_RD_FRQMIN_FRQ_MIN(base) ((TRNG_FRQMIN_REG(base) & TRNG_FRQMIN_FRQ_MIN_MASK) >> TRNG_FRQMIN_FRQ_MIN_SHIFT)
#define TRNG_BRD_FRQMIN_FRQ_MIN(base) (TRNG_RD_FRQMIN_FRQ_MIN(base))

/*! @brief Set the FRQ_MIN field to a new value. */
#define TRNG_WR_FRQMIN_FRQ_MIN(base, value) (TRNG_RMW_FRQMIN(base, TRNG_FRQMIN_FRQ_MIN_MASK, TRNG_FRQMIN_FRQ_MIN(value)))
#define TRNG_BWR_FRQMIN_FRQ_MIN(base, value) (TRNG_WR_FRQMIN_FRQ_MIN(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQMAX - RNG Frequency Count Maximum Limit Register (RW)
 *
 * Reset value: 0x00006400U
 *
 * The RNG Frequency Count Maximum Limit Register defines the maximum allowable
 * count taken by the Entropy sample counter during each Entropy sample. During
 * any sample period, if the count is greater than this programmed maximum, a
 * Frequency Count Fail is flagged in MCTL[FCT_FAIL] and an error is generated. Note
 * that this address (061C) is used as FRQMAX only if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this address is used as FRQCNT readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQMAX register
 */
/*@{*/
#define TRNG_RD_FRQMAX(base)     (TRNG_FRQMAX_REG(base))
#define TRNG_WR_FRQMAX(base, value) (TRNG_FRQMAX_REG(base) = (value))
#define TRNG_RMW_FRQMAX(base, mask, value) (TRNG_WR_FRQMAX(base, (TRNG_RD_FRQMAX(base) & ~(mask)) | (value)))
#define TRNG_SET_FRQMAX(base, value) (BME_OR32(&TRNG_FRQMAX_REG(base), (uint32_t)(value)))
#define TRNG_CLR_FRQMAX(base, value) (BME_AND32(&TRNG_FRQMAX_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_FRQMAX(base, value) (BME_XOR32(&TRNG_FRQMAX_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQMAX bitfields
 */

/*!
 * @name Register TRNG_FRQMAX, field FRQ_MAX[21:0] (RW)
 *
 * Frequency Counter Maximum Limit. Defines the maximum allowable count taken
 * during each entropy sample. This field is writable only if MCTL[PRGM] bit is 1.
 * This register is cleared to 000640h by writing the MCTL[RST_DEF] bit to 1.
 * Note that if MCTL[PRGM] bit is 0, this register address is used to read the
 * Frequency Count result in register FRQCNT, as defined in the following section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQMAX_FRQ_MAX field. */
#define TRNG_RD_FRQMAX_FRQ_MAX(base) ((TRNG_FRQMAX_REG(base) & TRNG_FRQMAX_FRQ_MAX_MASK) >> TRNG_FRQMAX_FRQ_MAX_SHIFT)
#define TRNG_BRD_FRQMAX_FRQ_MAX(base) (TRNG_RD_FRQMAX_FRQ_MAX(base))

/*! @brief Set the FRQ_MAX field to a new value. */
#define TRNG_WR_FRQMAX_FRQ_MAX(base, value) (TRNG_RMW_FRQMAX(base, TRNG_FRQMAX_FRQ_MAX_MASK, TRNG_FRQMAX_FRQ_MAX(value)))
#define TRNG_BWR_FRQMAX_FRQ_MAX(base, value) (TRNG_WR_FRQMAX_FRQ_MAX(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_FRQCNT - RNG Frequency Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_FRQCNT - RNG Frequency Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Frequency Count Register is a read-only register used to read the
 * frequency counter within the TRNG entropy generator. It will read all zeroes
 * unless MCTL[TRNG_ACC] = 1. Note that this offset (0xBASE_061C) is used as FRQMAX
 * if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as FRQCNT readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_FRQCNT register
 */
/*@{*/
#define TRNG_RD_FRQCNT(base)     (TRNG_FRQCNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_FRQCNT bitfields
 */

/*!
 * @name Register TRNG_FRQCNT, field FRQ_CT[21:0] (RO)
 *
 * Frequency Count. If MCTL[TRNG_ACC] = 1, reads a sample frequency count taken
 * during entropy generation. Requires MCTL[PRGM] = 0. Note that if MCTL[PRGM]
 * bit is 1, this register address is used to access the Poker Test Maximum Limit
 * in register PKRMAX, as defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_FRQCNT_FRQ_CT field. */
#define TRNG_RD_FRQCNT_FRQ_CT(base) ((TRNG_FRQCNT_REG(base) & TRNG_FRQCNT_FRQ_CT_MASK) >> TRNG_FRQCNT_FRQ_CT_SHIFT)
#define TRNG_BRD_FRQCNT_FRQ_CT(base) (TRNG_RD_FRQCNT_FRQ_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCMC - RNG Statistical Check Monobit Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCMC - RNG Statistical Check Monobit Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Monobit Count Register is a read-only register used
 * to read the final monobit count after entropy generation. This counter starts
 * with the value in SCML[MONO_MAX], and is decremented each time a one is
 * sampled. Note that this offset (0xBASE_0620) is used as SCML if MCTL[PRGM] is 1. If
 * MCTL[PRGM] is 0, this offset is used as SCMC readback register, as described
 * here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCMC register
 */
/*@{*/
#define TRNG_RD_SCMC(base)       (TRNG_SCMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCMC bitfields
 */

/*!
 * @name Register TRNG_SCMC, field MONO_CT[15:0] (RO)
 *
 * Monobit Count. Reads the final Monobit count after entropy generation.
 * Requires MCTL[PRGM] = 0. Note that if MCTL[PRGM] bit is 1, this register address is
 * used to access the Statistical Check Monobit Limit in register SCML, as
 * defined in the previous section.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCMC_MONO_CT field. */
#define TRNG_RD_SCMC_MONO_CT(base) ((TRNG_SCMC_REG(base) & TRNG_SCMC_MONO_CT_MASK) >> TRNG_SCMC_MONO_CT_SHIFT)
#define TRNG_BRD_SCMC_MONO_CT(base) (TRNG_RD_SCMC_MONO_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCML - RNG Statistical Check Monobit Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCML - RNG Statistical Check Monobit Limit Register (RW)
 *
 * Reset value: 0x010C0568U
 *
 * The RNG Statistical Check Monobit Limit Register defines the allowable
 * maximum and minimum number of ones/zero detected during entropy generation. To pass
 * the test, the number of ones/zeroes generated must be less than the programmed
 * maximum value, and the number of ones/zeroes generated must be greater than
 * (maximum - range). If this test fails, the Retry Counter in SCMISC will be
 * decremented, and a retry will occur if the Retry Count has not reached zero. If
 * the Retry Count has reached zero, an error will be generated. Note that this
 * offset (0xBASE_0620) is used as SCML only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0,
 * this offset is used as SCMC readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCML register
 */
/*@{*/
#define TRNG_RD_SCML(base)       (TRNG_SCML_REG(base))
#define TRNG_WR_SCML(base, value) (TRNG_SCML_REG(base) = (value))
#define TRNG_RMW_SCML(base, mask, value) (TRNG_WR_SCML(base, (TRNG_RD_SCML(base) & ~(mask)) | (value)))
#define TRNG_SET_SCML(base, value) (BME_OR32(&TRNG_SCML_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCML(base, value) (BME_AND32(&TRNG_SCML_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCML(base, value) (BME_XOR32(&TRNG_SCML_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCML bitfields
 */

/*!
 * @name Register TRNG_SCML, field MONO_MAX[15:0] (RW)
 *
 * Monobit Maximum Limit. Defines the maximum allowable count taken during
 * entropy generation. The number of ones/zeroes detected during entropy generation
 * must be less than MONO_MAX, else a retry or error will occur. This register is
 * cleared to 00056Bh (decimal 1387) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCML_MONO_MAX field. */
#define TRNG_RD_SCML_MONO_MAX(base) ((TRNG_SCML_REG(base) & TRNG_SCML_MONO_MAX_MASK) >> TRNG_SCML_MONO_MAX_SHIFT)
#define TRNG_BRD_SCML_MONO_MAX(base) (TRNG_RD_SCML_MONO_MAX(base))

/*! @brief Set the MONO_MAX field to a new value. */
#define TRNG_WR_SCML_MONO_MAX(base, value) (TRNG_RMW_SCML(base, TRNG_SCML_MONO_MAX_MASK, TRNG_SCML_MONO_MAX(value)))
#define TRNG_BWR_SCML_MONO_MAX(base, value) (TRNG_WR_SCML_MONO_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCML, field MONO_RNG[31:16] (RW)
 *
 * Monobit Range. The number of ones/zeroes detected during entropy generation
 * must be greater than MONO_MAX - MONO_RNG, else a retry or error will occur.
 * This register is cleared to 000112h (decimal 274) by writing the MCTL[RST_DEF]
 * bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCML_MONO_RNG field. */
#define TRNG_RD_SCML_MONO_RNG(base) ((TRNG_SCML_REG(base) & TRNG_SCML_MONO_RNG_MASK) >> TRNG_SCML_MONO_RNG_SHIFT)
#define TRNG_BRD_SCML_MONO_RNG(base) (TRNG_RD_SCML_MONO_RNG(base))

/*! @brief Set the MONO_RNG field to a new value. */
#define TRNG_WR_SCML_MONO_RNG(base, value) (TRNG_RMW_SCML(base, TRNG_SCML_MONO_RNG_MASK, TRNG_SCML_MONO_RNG(value)))
#define TRNG_BWR_SCML_MONO_RNG(base, value) (TRNG_WR_SCML_MONO_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR1L - RNG Statistical Check Run Length 1 Limit Register (RW)
 *
 * Reset value: 0x00B20195U
 *
 * The RNG Statistical Check Run Length 1 Limit Register defines the allowable
 * maximum and minimum number of runs of length 1 detected during entropy
 * generation. To pass the test, the number of runs of length 1 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 1 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0624) is used as SCR1L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR1C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR1L register
 */
/*@{*/
#define TRNG_RD_SCR1L(base)      (TRNG_SCR1L_REG(base))
#define TRNG_WR_SCR1L(base, value) (TRNG_SCR1L_REG(base) = (value))
#define TRNG_RMW_SCR1L(base, mask, value) (TRNG_WR_SCR1L(base, (TRNG_RD_SCR1L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR1L(base, value) (BME_OR32(&TRNG_SCR1L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR1L(base, value) (BME_AND32(&TRNG_SCR1L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR1L(base, value) (BME_XOR32(&TRNG_SCR1L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR1L bitfields
 */

/*!
 * @name Register TRNG_SCR1L, field RUN1_MAX[14:0] (RW)
 *
 * Run Length 1 Maximum Limit. Defines the maximum allowable runs of length 1
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 1 detected during entropy generation must be less than RUN1_MAX, else a
 * retry or error will occur. This register is cleared to 01E5h (decimal 485) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1L_RUN1_MAX field. */
#define TRNG_RD_SCR1L_RUN1_MAX(base) ((TRNG_SCR1L_REG(base) & TRNG_SCR1L_RUN1_MAX_MASK) >> TRNG_SCR1L_RUN1_MAX_SHIFT)
#define TRNG_BRD_SCR1L_RUN1_MAX(base) (TRNG_RD_SCR1L_RUN1_MAX(base))

/*! @brief Set the RUN1_MAX field to a new value. */
#define TRNG_WR_SCR1L_RUN1_MAX(base, value) (TRNG_RMW_SCR1L(base, TRNG_SCR1L_RUN1_MAX_MASK, TRNG_SCR1L_RUN1_MAX(value)))
#define TRNG_BWR_SCR1L_RUN1_MAX(base, value) (TRNG_WR_SCR1L_RUN1_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR1L, field RUN1_RNG[30:16] (RW)
 *
 * Run Length 1 Range. The number of runs of length 1 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN1_MAX - RUN1_RNG, else a
 * retry or error will occur. This register is cleared to 0102h (decimal 258) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1L_RUN1_RNG field. */
#define TRNG_RD_SCR1L_RUN1_RNG(base) ((TRNG_SCR1L_REG(base) & TRNG_SCR1L_RUN1_RNG_MASK) >> TRNG_SCR1L_RUN1_RNG_SHIFT)
#define TRNG_BRD_SCR1L_RUN1_RNG(base) (TRNG_RD_SCR1L_RUN1_RNG(base))

/*! @brief Set the RUN1_RNG field to a new value. */
#define TRNG_WR_SCR1L_RUN1_RNG(base, value) (TRNG_RMW_SCR1L(base, TRNG_SCR1L_RUN1_RNG_MASK, TRNG_SCR1L_RUN1_RNG(value)))
#define TRNG_BWR_SCR1L_RUN1_RNG(base, value) (TRNG_WR_SCR1L_RUN1_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR1C - RNG Statistical Check Run Length 1 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 1 Counters Register is a read-only
 * register used to read the final Run Length 1 counts after entropy generation. These
 * counters start with the value in SCR1L[RUN1_MAX]. The R1_1_CT decrements each
 * time a single one is sampled (preceded by a zero and followed by a zero). The
 * R1_0_CT decrements each time a single zero is sampled (preceded by a one and
 * followed by a one). Note that this offset (0xBASE_0624) is used as SCR1L if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as SCR1C readback
 * register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR1C register
 */
/*@{*/
#define TRNG_RD_SCR1C(base)      (TRNG_SCR1C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR1C bitfields
 */

/*!
 * @name Register TRNG_SCR1C, field R1_0_CT[14:0] (RO)
 *
 * Runs of Zero, Length 1 Count. Reads the final Runs of Zeroes, length 1 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1C_R1_0_CT field. */
#define TRNG_RD_SCR1C_R1_0_CT(base) ((TRNG_SCR1C_REG(base) & TRNG_SCR1C_R1_0_CT_MASK) >> TRNG_SCR1C_R1_0_CT_SHIFT)
#define TRNG_BRD_SCR1C_R1_0_CT(base) (TRNG_RD_SCR1C_R1_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR1C, field R1_1_CT[30:16] (RO)
 *
 * Runs of One, Length 1 Count. Reads the final Runs of Ones, length 1 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR1C_R1_1_CT field. */
#define TRNG_RD_SCR1C_R1_1_CT(base) ((TRNG_SCR1C_REG(base) & TRNG_SCR1C_R1_1_CT_MASK) >> TRNG_SCR1C_R1_1_CT_SHIFT)
#define TRNG_BRD_SCR1C_R1_1_CT(base) (TRNG_RD_SCR1C_R1_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR2L - RNG Statistical Check Run Length 2 Limit Register (RW)
 *
 * Reset value: 0x007A00DCU
 *
 * The RNG Statistical Check Run Length 2 Limit Register defines the allowable
 * maximum and minimum number of runs of length 2 detected during entropy
 * generation. To pass the test, the number of runs of length 2 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 2 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0628) is used as SCR2L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR2C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR2L register
 */
/*@{*/
#define TRNG_RD_SCR2L(base)      (TRNG_SCR2L_REG(base))
#define TRNG_WR_SCR2L(base, value) (TRNG_SCR2L_REG(base) = (value))
#define TRNG_RMW_SCR2L(base, mask, value) (TRNG_WR_SCR2L(base, (TRNG_RD_SCR2L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR2L(base, value) (BME_OR32(&TRNG_SCR2L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR2L(base, value) (BME_AND32(&TRNG_SCR2L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR2L(base, value) (BME_XOR32(&TRNG_SCR2L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR2L bitfields
 */

/*!
 * @name Register TRNG_SCR2L, field RUN2_MAX[13:0] (RW)
 *
 * Run Length 2 Maximum Limit. Defines the maximum allowable runs of length 2
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 2 detected during entropy generation must be less than RUN2_MAX, else a
 * retry or error will occur. This register is cleared to 00DCh (decimal 220) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2L_RUN2_MAX field. */
#define TRNG_RD_SCR2L_RUN2_MAX(base) ((TRNG_SCR2L_REG(base) & TRNG_SCR2L_RUN2_MAX_MASK) >> TRNG_SCR2L_RUN2_MAX_SHIFT)
#define TRNG_BRD_SCR2L_RUN2_MAX(base) (TRNG_RD_SCR2L_RUN2_MAX(base))

/*! @brief Set the RUN2_MAX field to a new value. */
#define TRNG_WR_SCR2L_RUN2_MAX(base, value) (TRNG_RMW_SCR2L(base, TRNG_SCR2L_RUN2_MAX_MASK, TRNG_SCR2L_RUN2_MAX(value)))
#define TRNG_BWR_SCR2L_RUN2_MAX(base, value) (TRNG_WR_SCR2L_RUN2_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR2L, field RUN2_RNG[29:16] (RW)
 *
 * Run Length 2 Range. The number of runs of length 2 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN2_MAX - RUN2_RNG, else a
 * retry or error will occur. This register is cleared to 007Ah (decimal 122) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2L_RUN2_RNG field. */
#define TRNG_RD_SCR2L_RUN2_RNG(base) ((TRNG_SCR2L_REG(base) & TRNG_SCR2L_RUN2_RNG_MASK) >> TRNG_SCR2L_RUN2_RNG_SHIFT)
#define TRNG_BRD_SCR2L_RUN2_RNG(base) (TRNG_RD_SCR2L_RUN2_RNG(base))

/*! @brief Set the RUN2_RNG field to a new value. */
#define TRNG_WR_SCR2L_RUN2_RNG(base, value) (TRNG_RMW_SCR2L(base, TRNG_SCR2L_RUN2_RNG_MASK, TRNG_SCR2L_RUN2_RNG(value)))
#define TRNG_BWR_SCR2L_RUN2_RNG(base, value) (TRNG_WR_SCR2L_RUN2_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR2C - RNG Statistical Check Run Length 2 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 2 Counters Register is a read-only
 * register used to read the final Run Length 2 counts after entropy generation. These
 * counters start with the value in SCR2L[RUN2_MAX]. The R2_1_CT decrements each
 * time two consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R2_0_CT decrements each time two consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0628) is
 * used as SCR2L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR2C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR2C register
 */
/*@{*/
#define TRNG_RD_SCR2C(base)      (TRNG_SCR2C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR2C bitfields
 */

/*!
 * @name Register TRNG_SCR2C, field R2_0_CT[13:0] (RO)
 *
 * Runs of Zero, Length 2 Count. Reads the final Runs of Zeroes, length 2 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2C_R2_0_CT field. */
#define TRNG_RD_SCR2C_R2_0_CT(base) ((TRNG_SCR2C_REG(base) & TRNG_SCR2C_R2_0_CT_MASK) >> TRNG_SCR2C_R2_0_CT_SHIFT)
#define TRNG_BRD_SCR2C_R2_0_CT(base) (TRNG_RD_SCR2C_R2_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR2C, field R2_1_CT[29:16] (RO)
 *
 * Runs of One, Length 2 Count. Reads the final Runs of Ones, length 2 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR2C_R2_1_CT field. */
#define TRNG_RD_SCR2C_R2_1_CT(base) ((TRNG_SCR2C_REG(base) & TRNG_SCR2C_R2_1_CT_MASK) >> TRNG_SCR2C_R2_1_CT_SHIFT)
#define TRNG_BRD_SCR2C_R2_1_CT(base) (TRNG_RD_SCR2C_R2_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR3C - RNG Statistical Check Run Length 3 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 3 Counters Register is a read-only
 * register used to read the final Run Length 3 counts after entropy generation. These
 * counters start with the value in SCR3L[RUN3_MAX]. The R3_1_CT decrements each
 * time three consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R3_0_CT decrements each time three consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_062C)
 * is used as SCR3L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used
 * as SCR3C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR3C register
 */
/*@{*/
#define TRNG_RD_SCR3C(base)      (TRNG_SCR3C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR3C bitfields
 */

/*!
 * @name Register TRNG_SCR3C, field R3_0_CT[12:0] (RO)
 *
 * Runs of Zeroes, Length 3 Count. Reads the final Runs of Zeroes, length 3
 * count after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3C_R3_0_CT field. */
#define TRNG_RD_SCR3C_R3_0_CT(base) ((TRNG_SCR3C_REG(base) & TRNG_SCR3C_R3_0_CT_MASK) >> TRNG_SCR3C_R3_0_CT_SHIFT)
#define TRNG_BRD_SCR3C_R3_0_CT(base) (TRNG_RD_SCR3C_R3_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR3C, field R3_1_CT[28:16] (RO)
 *
 * Runs of Ones, Length 3 Count. Reads the final Runs of Ones, length 3 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3C_R3_1_CT field. */
#define TRNG_RD_SCR3C_R3_1_CT(base) ((TRNG_SCR3C_REG(base) & TRNG_SCR3C_R3_1_CT_MASK) >> TRNG_SCR3C_R3_1_CT_SHIFT)
#define TRNG_BRD_SCR3C_R3_1_CT(base) (TRNG_RD_SCR3C_R3_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR3L - RNG Statistical Check Run Length 3 Limit Register (RW)
 *
 * Reset value: 0x0058007DU
 *
 * The RNG Statistical Check Run Length 3 Limit Register defines the allowable
 * maximum and minimum number of runs of length 3 detected during entropy
 * generation. To pass the test, the number of runs of length 3 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 3 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_062C) is used as SCR3L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR3C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR3L register
 */
/*@{*/
#define TRNG_RD_SCR3L(base)      (TRNG_SCR3L_REG(base))
#define TRNG_WR_SCR3L(base, value) (TRNG_SCR3L_REG(base) = (value))
#define TRNG_RMW_SCR3L(base, mask, value) (TRNG_WR_SCR3L(base, (TRNG_RD_SCR3L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR3L(base, value) (BME_OR32(&TRNG_SCR3L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR3L(base, value) (BME_AND32(&TRNG_SCR3L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR3L(base, value) (BME_XOR32(&TRNG_SCR3L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR3L bitfields
 */

/*!
 * @name Register TRNG_SCR3L, field RUN3_MAX[12:0] (RW)
 *
 * Run Length 3 Maximum Limit. Defines the maximum allowable runs of length 3
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 3 detected during entropy generation must be less than RUN3_MAX, else a
 * retry or error will occur. This register is cleared to 007Dh (decimal 125) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3L_RUN3_MAX field. */
#define TRNG_RD_SCR3L_RUN3_MAX(base) ((TRNG_SCR3L_REG(base) & TRNG_SCR3L_RUN3_MAX_MASK) >> TRNG_SCR3L_RUN3_MAX_SHIFT)
#define TRNG_BRD_SCR3L_RUN3_MAX(base) (TRNG_RD_SCR3L_RUN3_MAX(base))

/*! @brief Set the RUN3_MAX field to a new value. */
#define TRNG_WR_SCR3L_RUN3_MAX(base, value) (TRNG_RMW_SCR3L(base, TRNG_SCR3L_RUN3_MAX_MASK, TRNG_SCR3L_RUN3_MAX(value)))
#define TRNG_BWR_SCR3L_RUN3_MAX(base, value) (TRNG_WR_SCR3L_RUN3_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR3L, field RUN3_RNG[28:16] (RW)
 *
 * Run Length 3 Range. The number of runs of length 3 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN3_MAX - RUN3_RNG, else a
 * retry or error will occur. This register is cleared to 0058h (decimal 88) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR3L_RUN3_RNG field. */
#define TRNG_RD_SCR3L_RUN3_RNG(base) ((TRNG_SCR3L_REG(base) & TRNG_SCR3L_RUN3_RNG_MASK) >> TRNG_SCR3L_RUN3_RNG_SHIFT)
#define TRNG_BRD_SCR3L_RUN3_RNG(base) (TRNG_RD_SCR3L_RUN3_RNG(base))

/*! @brief Set the RUN3_RNG field to a new value. */
#define TRNG_WR_SCR3L_RUN3_RNG(base, value) (TRNG_RMW_SCR3L(base, TRNG_SCR3L_RUN3_RNG_MASK, TRNG_SCR3L_RUN3_RNG(value)))
#define TRNG_BWR_SCR3L_RUN3_RNG(base, value) (TRNG_WR_SCR3L_RUN3_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR4C - RNG Statistical Check Run Length 4 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 4 Counters Register is a read-only
 * register used to read the final Run Length 4 counts after entropy generation. These
 * counters start with the value in SCR4L[RUN4_MAX]. The R4_1_CT decrements each
 * time four consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R4_0_CT decrements each time four consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0630)
 * is used as SCR4L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR4C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR4C register
 */
/*@{*/
#define TRNG_RD_SCR4C(base)      (TRNG_SCR4C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR4C bitfields
 */

/*!
 * @name Register TRNG_SCR4C, field R4_0_CT[11:0] (RO)
 *
 * Runs of Zero, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4C_R4_0_CT field. */
#define TRNG_RD_SCR4C_R4_0_CT(base) ((TRNG_SCR4C_REG(base) & TRNG_SCR4C_R4_0_CT_MASK) >> TRNG_SCR4C_R4_0_CT_SHIFT)
#define TRNG_BRD_SCR4C_R4_0_CT(base) (TRNG_RD_SCR4C_R4_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR4C, field R4_1_CT[27:16] (RO)
 *
 * Runs of One, Length 4 Count. Reads the final Runs of Ones, length 4 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4C_R4_1_CT field. */
#define TRNG_RD_SCR4C_R4_1_CT(base) ((TRNG_SCR4C_REG(base) & TRNG_SCR4C_R4_1_CT_MASK) >> TRNG_SCR4C_R4_1_CT_SHIFT)
#define TRNG_BRD_SCR4C_R4_1_CT(base) (TRNG_RD_SCR4C_R4_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR4L - RNG Statistical Check Run Length 4 Limit Register (RW)
 *
 * Reset value: 0x0040004BU
 *
 * The RNG Statistical Check Run Length 4 Limit Register defines the allowable
 * maximum and minimum number of runs of length 4 detected during entropy
 * generation. To pass the test, the number of runs of length 4 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 4 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0630) is used as SCR4L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR4C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR4L register
 */
/*@{*/
#define TRNG_RD_SCR4L(base)      (TRNG_SCR4L_REG(base))
#define TRNG_WR_SCR4L(base, value) (TRNG_SCR4L_REG(base) = (value))
#define TRNG_RMW_SCR4L(base, mask, value) (TRNG_WR_SCR4L(base, (TRNG_RD_SCR4L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR4L(base, value) (BME_OR32(&TRNG_SCR4L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR4L(base, value) (BME_AND32(&TRNG_SCR4L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR4L(base, value) (BME_XOR32(&TRNG_SCR4L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR4L bitfields
 */

/*!
 * @name Register TRNG_SCR4L, field RUN4_MAX[11:0] (RW)
 *
 * Run Length 4 Maximum Limit. Defines the maximum allowable runs of length 4
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 4 detected during entropy generation must be less than RUN4_MAX, else a
 * retry or error will occur. This register is cleared to 004Bh (decimal 75) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4L_RUN4_MAX field. */
#define TRNG_RD_SCR4L_RUN4_MAX(base) ((TRNG_SCR4L_REG(base) & TRNG_SCR4L_RUN4_MAX_MASK) >> TRNG_SCR4L_RUN4_MAX_SHIFT)
#define TRNG_BRD_SCR4L_RUN4_MAX(base) (TRNG_RD_SCR4L_RUN4_MAX(base))

/*! @brief Set the RUN4_MAX field to a new value. */
#define TRNG_WR_SCR4L_RUN4_MAX(base, value) (TRNG_RMW_SCR4L(base, TRNG_SCR4L_RUN4_MAX_MASK, TRNG_SCR4L_RUN4_MAX(value)))
#define TRNG_BWR_SCR4L_RUN4_MAX(base, value) (TRNG_WR_SCR4L_RUN4_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR4L, field RUN4_RNG[27:16] (RW)
 *
 * Run Length 4 Range. The number of runs of length 4 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN4_MAX - RUN4_RNG, else a
 * retry or error will occur. This register is cleared to 0040h (decimal 64) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR4L_RUN4_RNG field. */
#define TRNG_RD_SCR4L_RUN4_RNG(base) ((TRNG_SCR4L_REG(base) & TRNG_SCR4L_RUN4_RNG_MASK) >> TRNG_SCR4L_RUN4_RNG_SHIFT)
#define TRNG_BRD_SCR4L_RUN4_RNG(base) (TRNG_RD_SCR4L_RUN4_RNG(base))

/*! @brief Set the RUN4_RNG field to a new value. */
#define TRNG_WR_SCR4L_RUN4_RNG(base, value) (TRNG_RMW_SCR4L(base, TRNG_SCR4L_RUN4_RNG_MASK, TRNG_SCR4L_RUN4_RNG(value)))
#define TRNG_BWR_SCR4L_RUN4_RNG(base, value) (TRNG_WR_SCR4L_RUN4_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR5L - RNG Statistical Check Run Length 5 Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 5 Limit Register defines the allowable
 * maximum and minimum number of runs of length 5 detected during entropy
 * generation. To pass the test, the number of runs of length 5 (for samples of both 0
 * and 1) must be less than the programmed maximum value, and the number of runs of
 * length 5 must be greater than (maximum - range). If this test fails, the
 * Retry Counter in SCMISC will be decremented, and a retry will occur if the Retry
 * Count has not reached zero. If the Retry Count has reached zero, an error will
 * be generated. Note that this address (0xBASE_0634) is used as SCR5L only if
 * MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this address is used as SCR5C readback
 * register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR5L register
 */
/*@{*/
#define TRNG_RD_SCR5L(base)      (TRNG_SCR5L_REG(base))
#define TRNG_WR_SCR5L(base, value) (TRNG_SCR5L_REG(base) = (value))
#define TRNG_RMW_SCR5L(base, mask, value) (TRNG_WR_SCR5L(base, (TRNG_RD_SCR5L(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR5L(base, value) (BME_OR32(&TRNG_SCR5L_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR5L(base, value) (BME_AND32(&TRNG_SCR5L_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR5L(base, value) (BME_XOR32(&TRNG_SCR5L_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR5L bitfields
 */

/*!
 * @name Register TRNG_SCR5L, field RUN5_MAX[10:0] (RW)
 *
 * Run Length 5 Maximum Limit. Defines the maximum allowable runs of length 5
 * (for both 0 and 1) detected during entropy generation. The number of runs of
 * length 5 detected during entropy generation must be less than RUN5_MAX, else a
 * retry or error will occur. This register is cleared to 002Fh (decimal 47) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5L_RUN5_MAX field. */
#define TRNG_RD_SCR5L_RUN5_MAX(base) ((TRNG_SCR5L_REG(base) & TRNG_SCR5L_RUN5_MAX_MASK) >> TRNG_SCR5L_RUN5_MAX_SHIFT)
#define TRNG_BRD_SCR5L_RUN5_MAX(base) (TRNG_RD_SCR5L_RUN5_MAX(base))

/*! @brief Set the RUN5_MAX field to a new value. */
#define TRNG_WR_SCR5L_RUN5_MAX(base, value) (TRNG_RMW_SCR5L(base, TRNG_SCR5L_RUN5_MAX_MASK, TRNG_SCR5L_RUN5_MAX(value)))
#define TRNG_BWR_SCR5L_RUN5_MAX(base, value) (TRNG_WR_SCR5L_RUN5_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR5L, field RUN5_RNG[26:16] (RW)
 *
 * Run Length 5 Range. The number of runs of length 5 (for both 0 and 1)
 * detected during entropy generation must be greater than RUN5_MAX - RUN5_RNG, else a
 * retry or error will occur. This register is cleared to 002Eh (decimal 46) by
 * writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5L_RUN5_RNG field. */
#define TRNG_RD_SCR5L_RUN5_RNG(base) ((TRNG_SCR5L_REG(base) & TRNG_SCR5L_RUN5_RNG_MASK) >> TRNG_SCR5L_RUN5_RNG_SHIFT)
#define TRNG_BRD_SCR5L_RUN5_RNG(base) (TRNG_RD_SCR5L_RUN5_RNG(base))

/*! @brief Set the RUN5_RNG field to a new value. */
#define TRNG_WR_SCR5L_RUN5_RNG(base, value) (TRNG_RMW_SCR5L(base, TRNG_SCR5L_RUN5_RNG_MASK, TRNG_SCR5L_RUN5_RNG(value)))
#define TRNG_BWR_SCR5L_RUN5_RNG(base, value) (TRNG_WR_SCR5L_RUN5_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR5C - RNG Statistical Check Run Length 5 Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 5 Counters Register is a read-only
 * register used to read the final Run Length 5 counts after entropy generation. These
 * counters start with the value in SCR5L[RUN5_MAX]. The R5_1_CT decrements each
 * time five consecutive ones are sampled (preceded by a zero and followed by a
 * zero). The R5_0_CT decrements each time five consecutive zeroes are sampled
 * (preceded by a one and followed by a one). Note that this offset (0xBASE_0634)
 * is used as SCR5L if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is used as
 * SCR5C readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR5C register
 */
/*@{*/
#define TRNG_RD_SCR5C(base)      (TRNG_SCR5C_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR5C bitfields
 */

/*!
 * @name Register TRNG_SCR5C, field R5_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5C_R5_0_CT field. */
#define TRNG_RD_SCR5C_R5_0_CT(base) ((TRNG_SCR5C_REG(base) & TRNG_SCR5C_R5_0_CT_MASK) >> TRNG_SCR5C_R5_0_CT_SHIFT)
#define TRNG_BRD_SCR5C_R5_0_CT(base) (TRNG_RD_SCR5C_R5_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR5C, field R5_1_CT[26:16] (RO)
 *
 * Runs of One, Length 5 Count. Reads the final Runs of Ones, length 5 count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR5C_R5_1_CT field. */
#define TRNG_RD_SCR5C_R5_1_CT(base) ((TRNG_SCR5C_REG(base) & TRNG_SCR5C_R5_1_CT_MASK) >> TRNG_SCR5C_R5_1_CT_SHIFT)
#define TRNG_BRD_SCR5C_R5_1_CT(base) (TRNG_RD_SCR5C_R5_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR6PL - RNG Statistical Check Run Length 6+ Limit Register (RW)
 *
 * Reset value: 0x002E002FU
 *
 * The RNG Statistical Check Run Length 6+ Limit Register defines the allowable
 * maximum and minimum number of runs of length 6 or more detected during entropy
 * generation. To pass the test, the number of runs of length 6 or more (for
 * samples of both 0 and 1) must be less than the programmed maximum value, and the
 * number of runs of length 6 or more must be greater than (maximum - range). If
 * this test fails, the Retry Counter in SCMISC will be decremented, and a retry
 * will occur if the Retry Count has not reached zero. If the Retry Count has
 * reached zero, an error will be generated. Note that this offset (0xBASE_0638) is
 * used as SCR6PL only if MCTL[PRGM] is 1. If MCTL[PRGM] is 0, this offset is
 * used as SCR6PC readback register.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR6PL register
 */
/*@{*/
#define TRNG_RD_SCR6PL(base)     (TRNG_SCR6PL_REG(base))
#define TRNG_WR_SCR6PL(base, value) (TRNG_SCR6PL_REG(base) = (value))
#define TRNG_RMW_SCR6PL(base, mask, value) (TRNG_WR_SCR6PL(base, (TRNG_RD_SCR6PL(base) & ~(mask)) | (value)))
#define TRNG_SET_SCR6PL(base, value) (BME_OR32(&TRNG_SCR6PL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SCR6PL(base, value) (BME_AND32(&TRNG_SCR6PL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SCR6PL(base, value) (BME_XOR32(&TRNG_SCR6PL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR6PL bitfields
 */

/*!
 * @name Register TRNG_SCR6PL, field RUN6P_MAX[10:0] (RW)
 *
 * Run Length 6+ Maximum Limit. Defines the maximum allowable runs of length 6
 * or more (for both 0 and 1) detected during entropy generation. The number of
 * runs of length 6 or more detected during entropy generation must be less than
 * RUN6P_MAX, else a retry or error will occur. This register is cleared to 002Fh
 * (decimal 47) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PL_RUN6P_MAX field. */
#define TRNG_RD_SCR6PL_RUN6P_MAX(base) ((TRNG_SCR6PL_REG(base) & TRNG_SCR6PL_RUN6P_MAX_MASK) >> TRNG_SCR6PL_RUN6P_MAX_SHIFT)
#define TRNG_BRD_SCR6PL_RUN6P_MAX(base) (TRNG_RD_SCR6PL_RUN6P_MAX(base))

/*! @brief Set the RUN6P_MAX field to a new value. */
#define TRNG_WR_SCR6PL_RUN6P_MAX(base, value) (TRNG_RMW_SCR6PL(base, TRNG_SCR6PL_RUN6P_MAX_MASK, TRNG_SCR6PL_RUN6P_MAX(value)))
#define TRNG_BWR_SCR6PL_RUN6P_MAX(base, value) (TRNG_WR_SCR6PL_RUN6P_MAX(base, value))
/*@}*/

/*!
 * @name Register TRNG_SCR6PL, field RUN6P_RNG[26:16] (RW)
 *
 * Run Length 6+ Range. The number of runs of length 6 or more (for both 0 and
 * 1) detected during entropy generation must be greater than RUN6P_MAX -
 * RUN6P_RNG, else a retry or error will occur. This register is cleared to 002Eh
 * (decimal 46) by writing the MCTL[RST_DEF] bit to 1.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PL_RUN6P_RNG field. */
#define TRNG_RD_SCR6PL_RUN6P_RNG(base) ((TRNG_SCR6PL_REG(base) & TRNG_SCR6PL_RUN6P_RNG_MASK) >> TRNG_SCR6PL_RUN6P_RNG_SHIFT)
#define TRNG_BRD_SCR6PL_RUN6P_RNG(base) (TRNG_RD_SCR6PL_RUN6P_RNG(base))

/*! @brief Set the RUN6P_RNG field to a new value. */
#define TRNG_WR_SCR6PL_RUN6P_RNG(base, value) (TRNG_RMW_SCR6PL(base, TRNG_SCR6PL_RUN6P_RNG_MASK, TRNG_SCR6PL_RUN6P_RNG(value)))
#define TRNG_BWR_SCR6PL_RUN6P_RNG(base, value) (TRNG_WR_SCR6PL_RUN6P_RNG(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register
 ******************************************************************************/

/*!
 * @brief TRNG_SCR6PC - RNG Statistical Check Run Length 6+ Count Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Run Length 6+ Counters Register is a read-only
 * register used to read the final Run Length 6+ counts after entropy generation.
 * These counters start with the value in SCR6PL[RUN6P_MAX]. The R6P_1_CT decrements
 * each time six or more consecutive ones are sampled (preceded by a zero and
 * followed by a zero). The R6P_0_CT decrements each time six or more consecutive
 * zeroes are sampled (preceded by a one and followed by a one). Note that this
 * offset (0xBASE_0638) is used as SCR6PL if MCTL[PRGM] is 1. If MCTL[PRGM] is 0,
 * this offset is used as SCR6PC readback register, as described here.
 */
/*!
 * @name Constants and macros for entire TRNG_SCR6PC register
 */
/*@{*/
#define TRNG_RD_SCR6PC(base)     (TRNG_SCR6PC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_SCR6PC bitfields
 */

/*!
 * @name Register TRNG_SCR6PC, field R6P_0_CT[10:0] (RO)
 *
 * Runs of Zero, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PC_R6P_0_CT field. */
#define TRNG_RD_SCR6PC_R6P_0_CT(base) ((TRNG_SCR6PC_REG(base) & TRNG_SCR6PC_R6P_0_CT_MASK) >> TRNG_SCR6PC_R6P_0_CT_SHIFT)
#define TRNG_BRD_SCR6PC_R6P_0_CT(base) (TRNG_RD_SCR6PC_R6P_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_SCR6PC, field R6P_1_CT[26:16] (RO)
 *
 * Runs of One, Length 6+ Count. Reads the final Runs of Ones, length 6+ count
 * after entropy generation. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SCR6PC_R6P_1_CT field. */
#define TRNG_RD_SCR6PC_R6P_1_CT(base) ((TRNG_SCR6PC_REG(base) & TRNG_SCR6PC_R6P_1_CT_MASK) >> TRNG_SCR6PC_R6P_1_CT_SHIFT)
#define TRNG_BRD_SCR6PC_R6P_1_CT(base) (TRNG_RD_SCR6PC_R6P_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_STATUS - RNG Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_STATUS - RNG Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Various statistical tests are run as a normal part of the TRNG's entropy
 * generation process. The least-significant 16 bits of the STATUS register reflect
 * the result of each of these tests. The status of these bits will be valid when
 * the TRNG has finished its entropy generation process. Software can determine
 * when this occurs by polling the ENT_VAL bit in the RNG Miscellaneous Control
 * Register. Note that there is a very small probability that a statistical test
 * will fail even though the TRNG is operating properly. If this happens the TRNG
 * will automatically retry the entire entropy generation process, including
 * running all the statistical tests. The value in RETRY_CT is decremented each time
 * an entropy generation retry occurs. If a statistical check fails when the retry
 * count is nonzero, a retry is initiated. But if a statistical check fails when
 * the retry count is zero, an error is generated by the RNG. By default
 * RETRY_CT is initialized to 1, but software can increase the retry count by writing to
 * the RTY_CT field in the SCMISC register. All 0s will be returned if this
 * register address is read while the RNG is in Program Mode (see PRGM field in MCTL
 * register. If this register is read while the RNG is in Run Mode the value
 * returned will be formatted as follows.
 */
/*!
 * @name Constants and macros for entire TRNG_STATUS register
 */
/*@{*/
#define TRNG_RD_STATUS(base)     (TRNG_STATUS_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_STATUS bitfields
 */

/*!
 * @name Register TRNG_STATUS, field TF1BR0[0] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 0s. If TF1BR0=1, the 1-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF1BR0 field. */
#define TRNG_RD_STATUS_TF1BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF1BR0_MASK) >> TRNG_STATUS_TF1BR0_SHIFT)
#define TRNG_BRD_STATUS_TF1BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF1BR0_SHIFT, TRNG_STATUS_TF1BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF1BR1[1] (RO)
 *
 * Test Fail, 1-Bit Run, Sampling 1s. If TF1BR1=1, the 1-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF1BR1 field. */
#define TRNG_RD_STATUS_TF1BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF1BR1_MASK) >> TRNG_STATUS_TF1BR1_SHIFT)
#define TRNG_BRD_STATUS_TF1BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF1BR1_SHIFT, TRNG_STATUS_TF1BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF2BR0[2] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 0s. If TF2BR0=1, the 2-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF2BR0 field. */
#define TRNG_RD_STATUS_TF2BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF2BR0_MASK) >> TRNG_STATUS_TF2BR0_SHIFT)
#define TRNG_BRD_STATUS_TF2BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF2BR0_SHIFT, TRNG_STATUS_TF2BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF2BR1[3] (RO)
 *
 * Test Fail, 2-Bit Run, Sampling 1s. If TF2BR1=1, the 2-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF2BR1 field. */
#define TRNG_RD_STATUS_TF2BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF2BR1_MASK) >> TRNG_STATUS_TF2BR1_SHIFT)
#define TRNG_BRD_STATUS_TF2BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF2BR1_SHIFT, TRNG_STATUS_TF2BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF3BR0[4] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 0s. If TF3BR0=1, the 3-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF3BR0 field. */
#define TRNG_RD_STATUS_TF3BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF3BR0_MASK) >> TRNG_STATUS_TF3BR0_SHIFT)
#define TRNG_BRD_STATUS_TF3BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF3BR0_SHIFT, TRNG_STATUS_TF3BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF3BR1[5] (RO)
 *
 * Test Fail, 3-Bit Run, Sampling 1s. If TF3BR1=1, the 3-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF3BR1 field. */
#define TRNG_RD_STATUS_TF3BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF3BR1_MASK) >> TRNG_STATUS_TF3BR1_SHIFT)
#define TRNG_BRD_STATUS_TF3BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF3BR1_SHIFT, TRNG_STATUS_TF3BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF4BR0[6] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 0s. If TF4BR0=1, the 4-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF4BR0 field. */
#define TRNG_RD_STATUS_TF4BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF4BR0_MASK) >> TRNG_STATUS_TF4BR0_SHIFT)
#define TRNG_BRD_STATUS_TF4BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF4BR0_SHIFT, TRNG_STATUS_TF4BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF4BR1[7] (RO)
 *
 * Test Fail, 4-Bit Run, Sampling 1s. If TF4BR1=1, the 4-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF4BR1 field. */
#define TRNG_RD_STATUS_TF4BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF4BR1_MASK) >> TRNG_STATUS_TF4BR1_SHIFT)
#define TRNG_BRD_STATUS_TF4BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF4BR1_SHIFT, TRNG_STATUS_TF4BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF5BR0[8] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 0s. If TF5BR0=1, the 5-Bit Run, Sampling 0s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF5BR0 field. */
#define TRNG_RD_STATUS_TF5BR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF5BR0_MASK) >> TRNG_STATUS_TF5BR0_SHIFT)
#define TRNG_BRD_STATUS_TF5BR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF5BR0_SHIFT, TRNG_STATUS_TF5BR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF5BR1[9] (RO)
 *
 * Test Fail, 5-Bit Run, Sampling 1s. If TF5BR1=1, the 5-Bit Run, Sampling 1s
 * Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF5BR1 field. */
#define TRNG_RD_STATUS_TF5BR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF5BR1_MASK) >> TRNG_STATUS_TF5BR1_SHIFT)
#define TRNG_BRD_STATUS_TF5BR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF5BR1_SHIFT, TRNG_STATUS_TF5BR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF6PBR0[10] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 0s. If TF6PBR0=1, the 6 Plus Bit Run,
 * Sampling 0s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF6PBR0 field. */
#define TRNG_RD_STATUS_TF6PBR0(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF6PBR0_MASK) >> TRNG_STATUS_TF6PBR0_SHIFT)
#define TRNG_BRD_STATUS_TF6PBR0(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF6PBR0_SHIFT, TRNG_STATUS_TF6PBR0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TF6PBR1[11] (RO)
 *
 * Test Fail, 6 Plus Bit Run, Sampling 1s. If TF6PBR1=1, the 6 Plus Bit Run,
 * Sampling 1s Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TF6PBR1 field. */
#define TRNG_RD_STATUS_TF6PBR1(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TF6PBR1_MASK) >> TRNG_STATUS_TF6PBR1_SHIFT)
#define TRNG_BRD_STATUS_TF6PBR1(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TF6PBR1_SHIFT, TRNG_STATUS_TF6PBR1_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFSB[12] (RO)
 *
 * Test Fail, Sparse Bit. If TFSB=1, the Sparse Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFSB field. */
#define TRNG_RD_STATUS_TFSB(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFSB_MASK) >> TRNG_STATUS_TFSB_SHIFT)
#define TRNG_BRD_STATUS_TFSB(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFSB_SHIFT, TRNG_STATUS_TFSB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFLR[13] (RO)
 *
 * Test Fail, Long Run. If TFLR=1, the Long Run Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFLR field. */
#define TRNG_RD_STATUS_TFLR(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFLR_MASK) >> TRNG_STATUS_TFLR_SHIFT)
#define TRNG_BRD_STATUS_TFLR(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFLR_SHIFT, TRNG_STATUS_TFLR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFP[14] (RO)
 *
 * Test Fail, Poker. If TFP=1, the Poker Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFP field. */
#define TRNG_RD_STATUS_TFP(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFP_MASK) >> TRNG_STATUS_TFP_SHIFT)
#define TRNG_BRD_STATUS_TFP(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFP_SHIFT, TRNG_STATUS_TFP_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field TFMB[15] (RO)
 *
 * Test Fail, Mono Bit. If TFMB=1, the Mono Bit Test has failed.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_TFMB field. */
#define TRNG_RD_STATUS_TFMB(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_TFMB_MASK) >> TRNG_STATUS_TFMB_SHIFT)
#define TRNG_BRD_STATUS_TFMB(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_TFMB_SHIFT, TRNG_STATUS_TFMB_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_STATUS, field RETRY_CT[19:16] (RO)
 *
 * RETRY COUNT. This represents the current number of entropy generation retries
 * left before a statistical text failure will cause the RNG to generate an
 * error condition.
 */
/*@{*/
/*! @brief Read current value of the TRNG_STATUS_RETRY_CT field. */
#define TRNG_RD_STATUS_RETRY_CT(base) ((TRNG_STATUS_REG(base) & TRNG_STATUS_RETRY_CT_MASK) >> TRNG_STATUS_RETRY_CT_SHIFT)
#define TRNG_BRD_STATUS_RETRY_CT(base) (BME_UBFX32(&TRNG_STATUS_REG(base), TRNG_STATUS_RETRY_CT_SHIFT, TRNG_STATUS_RETRY_CT_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_ENT - RNG TRNG Entropy Read Register
 ******************************************************************************/

/*!
 * @brief TRNG_ENT - RNG TRNG Entropy Read Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG TRNG can be programmed to generate an entropy value that is readable
 * via the SkyBlue bus. To do this, set the MCTL[TRNG_ACC] bit to 1. Once the
 * entropy value has been generated, the MCTL[ENT_VAL] bit will be set to 1. At this
 * point, ENT0 through ENT15 may be read to retrieve the 512-bit entropy value.
 * Note that once ENT15 is read, the entropy value will be cleared and a new
 * value will begin generation, so it is important that ENT15 be read last. These
 * registers are readable only when MCTL[PRGM] = 0 (Run Mode), MCTL[TRNG_ACC] = 1
 * (TRNG access mode) and MCTL[ENT_VAL] = 1, otherwise zeroes will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_ENT register
 */
/*@{*/
#define TRNG_RD_ENT(base, index) (TRNG_ENT_REG(base, index))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT10 - RNG Statistical Check Poker Count 1 and 0 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 1 and 0 Register is a read-only
 * register used to read the final Poker test counts of 1h and 0h patterns. The Poker 0h
 * Count increments each time a nibble of sample data is found to be 0h. The
 * Poker 1h Count increments each time a nibble of sample data is found to be 1h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT10 register
 */
/*@{*/
#define TRNG_RD_PKRCNT10(base)   (TRNG_PKRCNT10_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT10 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT10, field PKR_0_CT[15:0] (RO)
 *
 * Poker 0h Count. Total number of nibbles of sample data which were found to be
 * 0h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT10_PKR_0_CT field. */
#define TRNG_RD_PKRCNT10_PKR_0_CT(base) ((TRNG_PKRCNT10_REG(base) & TRNG_PKRCNT10_PKR_0_CT_MASK) >> TRNG_PKRCNT10_PKR_0_CT_SHIFT)
#define TRNG_BRD_PKRCNT10_PKR_0_CT(base) (TRNG_RD_PKRCNT10_PKR_0_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT10, field PKR_1_CT[31:16] (RO)
 *
 * Poker 1h Count. Total number of nibbles of sample data which were found to be
 * 1h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT10_PKR_1_CT field. */
#define TRNG_RD_PKRCNT10_PKR_1_CT(base) ((TRNG_PKRCNT10_REG(base) & TRNG_PKRCNT10_PKR_1_CT_MASK) >> TRNG_PKRCNT10_PKR_1_CT_SHIFT)
#define TRNG_BRD_PKRCNT10_PKR_1_CT(base) (TRNG_RD_PKRCNT10_PKR_1_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT32 - RNG Statistical Check Poker Count 3 and 2 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 3 and 2 Register is a read-only
 * register used to read the final Poker test counts of 3h and 2h patterns. The Poker 2h
 * Count increments each time a nibble of sample data is found to be 2h. The
 * Poker 3h Count increments each time a nibble of sample data is found to be 3h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT32 register
 */
/*@{*/
#define TRNG_RD_PKRCNT32(base)   (TRNG_PKRCNT32_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT32 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT32, field PKR_2_CT[15:0] (RO)
 *
 * Poker 2h Count. Total number of nibbles of sample data which were found to be
 * 2h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT32_PKR_2_CT field. */
#define TRNG_RD_PKRCNT32_PKR_2_CT(base) ((TRNG_PKRCNT32_REG(base) & TRNG_PKRCNT32_PKR_2_CT_MASK) >> TRNG_PKRCNT32_PKR_2_CT_SHIFT)
#define TRNG_BRD_PKRCNT32_PKR_2_CT(base) (TRNG_RD_PKRCNT32_PKR_2_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT32, field PKR_3_CT[31:16] (RO)
 *
 * Poker 3h Count. Total number of nibbles of sample data which were found to be
 * 3h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT32_PKR_3_CT field. */
#define TRNG_RD_PKRCNT32_PKR_3_CT(base) ((TRNG_PKRCNT32_REG(base) & TRNG_PKRCNT32_PKR_3_CT_MASK) >> TRNG_PKRCNT32_PKR_3_CT_SHIFT)
#define TRNG_BRD_PKRCNT32_PKR_3_CT(base) (TRNG_RD_PKRCNT32_PKR_3_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT54 - RNG Statistical Check Poker Count 5 and 4 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 5 and 4 Register is a read-only
 * register used to read the final Poker test counts of 5h and 4h patterns. The Poker 4h
 * Count increments each time a nibble of sample data is found to be 4h. The
 * Poker 5h Count increments each time a nibble of sample data is found to be 5h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT54 register
 */
/*@{*/
#define TRNG_RD_PKRCNT54(base)   (TRNG_PKRCNT54_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT54 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT54, field PKR_4_CT[15:0] (RO)
 *
 * Poker 4h Count. Total number of nibbles of sample data which were found to be
 * 4h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT54_PKR_4_CT field. */
#define TRNG_RD_PKRCNT54_PKR_4_CT(base) ((TRNG_PKRCNT54_REG(base) & TRNG_PKRCNT54_PKR_4_CT_MASK) >> TRNG_PKRCNT54_PKR_4_CT_SHIFT)
#define TRNG_BRD_PKRCNT54_PKR_4_CT(base) (TRNG_RD_PKRCNT54_PKR_4_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT54, field PKR_5_CT[31:16] (RO)
 *
 * Poker 5h Count. Total number of nibbles of sample data which were found to be
 * 5h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT54_PKR_5_CT field. */
#define TRNG_RD_PKRCNT54_PKR_5_CT(base) ((TRNG_PKRCNT54_REG(base) & TRNG_PKRCNT54_PKR_5_CT_MASK) >> TRNG_PKRCNT54_PKR_5_CT_SHIFT)
#define TRNG_BRD_PKRCNT54_PKR_5_CT(base) (TRNG_RD_PKRCNT54_PKR_5_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT76 - RNG Statistical Check Poker Count 7 and 6 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 7 and 6 Register is a read-only
 * register used to read the final Poker test counts of 7h and 6h patterns. The Poker 6h
 * Count increments each time a nibble of sample data is found to be 6h. The
 * Poker 7h Count increments each time a nibble of sample data is found to be 7h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT76 register
 */
/*@{*/
#define TRNG_RD_PKRCNT76(base)   (TRNG_PKRCNT76_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT76 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT76, field PKR_6_CT[15:0] (RO)
 *
 * Poker 6h Count. Total number of nibbles of sample data which were found to be
 * 6h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT76_PKR_6_CT field. */
#define TRNG_RD_PKRCNT76_PKR_6_CT(base) ((TRNG_PKRCNT76_REG(base) & TRNG_PKRCNT76_PKR_6_CT_MASK) >> TRNG_PKRCNT76_PKR_6_CT_SHIFT)
#define TRNG_BRD_PKRCNT76_PKR_6_CT(base) (TRNG_RD_PKRCNT76_PKR_6_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT76, field PKR_7_CT[31:16] (RO)
 *
 * Poker 7h Count. Total number of nibbles of sample data which were found to be
 * 7h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT76_PKR_7_CT field. */
#define TRNG_RD_PKRCNT76_PKR_7_CT(base) ((TRNG_PKRCNT76_REG(base) & TRNG_PKRCNT76_PKR_7_CT_MASK) >> TRNG_PKRCNT76_PKR_7_CT_SHIFT)
#define TRNG_BRD_PKRCNT76_PKR_7_CT(base) (TRNG_RD_PKRCNT76_PKR_7_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNT98 - RNG Statistical Check Poker Count 9 and 8 Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count 9 and 8 Register is a read-only
 * register used to read the final Poker test counts of 9h and 8h patterns. The Poker 8h
 * Count increments each time a nibble of sample data is found to be 8h. The
 * Poker 9h Count increments each time a nibble of sample data is found to be 9h.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNT98 register
 */
/*@{*/
#define TRNG_RD_PKRCNT98(base)   (TRNG_PKRCNT98_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNT98 bitfields
 */

/*!
 * @name Register TRNG_PKRCNT98, field PKR_8_CT[15:0] (RO)
 *
 * Poker 8h Count. Total number of nibbles of sample data which were found to be
 * 8h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT98_PKR_8_CT field. */
#define TRNG_RD_PKRCNT98_PKR_8_CT(base) ((TRNG_PKRCNT98_REG(base) & TRNG_PKRCNT98_PKR_8_CT_MASK) >> TRNG_PKRCNT98_PKR_8_CT_SHIFT)
#define TRNG_BRD_PKRCNT98_PKR_8_CT(base) (TRNG_RD_PKRCNT98_PKR_8_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNT98, field PKR_9_CT[31:16] (RO)
 *
 * Poker 9h Count. Total number of nibbles of sample data which were found to be
 * 9h. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNT98_PKR_9_CT field. */
#define TRNG_RD_PKRCNT98_PKR_9_CT(base) ((TRNG_PKRCNT98_REG(base) & TRNG_PKRCNT98_PKR_9_CT_MASK) >> TRNG_PKRCNT98_PKR_9_CT_SHIFT)
#define TRNG_BRD_PKRCNT98_PKR_9_CT(base) (TRNG_RD_PKRCNT98_PKR_9_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTBA - RNG Statistical Check Poker Count B and A Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count B and A Register is a read-only
 * register used to read the final Poker test counts of Bh and Ah patterns. The Poker Ah
 * Count increments each time a nibble of sample data is found to be Ah. The
 * Poker Bh Count increments each time a nibble of sample data is found to be Bh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTBA register
 */
/*@{*/
#define TRNG_RD_PKRCNTBA(base)   (TRNG_PKRCNTBA_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTBA bitfields
 */

/*!
 * @name Register TRNG_PKRCNTBA, field PKR_A_CT[15:0] (RO)
 *
 * Poker Ah Count. Total number of nibbles of sample data which were found to be
 * Ah. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTBA_PKR_A_CT field. */
#define TRNG_RD_PKRCNTBA_PKR_A_CT(base) ((TRNG_PKRCNTBA_REG(base) & TRNG_PKRCNTBA_PKR_A_CT_MASK) >> TRNG_PKRCNTBA_PKR_A_CT_SHIFT)
#define TRNG_BRD_PKRCNTBA_PKR_A_CT(base) (TRNG_RD_PKRCNTBA_PKR_A_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTBA, field PKR_B_CT[31:16] (RO)
 *
 * Poker Bh Count. Total number of nibbles of sample data which were found to be
 * Bh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTBA_PKR_B_CT field. */
#define TRNG_RD_PKRCNTBA_PKR_B_CT(base) ((TRNG_PKRCNTBA_REG(base) & TRNG_PKRCNTBA_PKR_B_CT_MASK) >> TRNG_PKRCNTBA_PKR_B_CT_SHIFT)
#define TRNG_BRD_PKRCNTBA_PKR_B_CT(base) (TRNG_RD_PKRCNTBA_PKR_B_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTDC - RNG Statistical Check Poker Count D and C Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count D and C Register is a read-only
 * register used to read the final Poker test counts of Dh and Ch patterns. The Poker Ch
 * Count increments each time a nibble of sample data is found to be Ch. The
 * Poker Dh Count increments each time a nibble of sample data is found to be Dh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTDC register
 */
/*@{*/
#define TRNG_RD_PKRCNTDC(base)   (TRNG_PKRCNTDC_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTDC bitfields
 */

/*!
 * @name Register TRNG_PKRCNTDC, field PKR_C_CT[15:0] (RO)
 *
 * Poker Ch Count. Total number of nibbles of sample data which were found to be
 * Ch. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTDC_PKR_C_CT field. */
#define TRNG_RD_PKRCNTDC_PKR_C_CT(base) ((TRNG_PKRCNTDC_REG(base) & TRNG_PKRCNTDC_PKR_C_CT_MASK) >> TRNG_PKRCNTDC_PKR_C_CT_SHIFT)
#define TRNG_BRD_PKRCNTDC_PKR_C_CT(base) (TRNG_RD_PKRCNTDC_PKR_C_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTDC, field PKR_D_CT[31:16] (RO)
 *
 * Poker Dh Count. Total number of nibbles of sample data which were found to be
 * Dh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTDC_PKR_D_CT field. */
#define TRNG_RD_PKRCNTDC_PKR_D_CT(base) ((TRNG_PKRCNTDC_REG(base) & TRNG_PKRCNTDC_PKR_D_CT_MASK) >> TRNG_PKRCNTDC_PKR_D_CT_SHIFT)
#define TRNG_BRD_PKRCNTDC_PKR_D_CT(base) (TRNG_RD_PKRCNTDC_PKR_D_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register
 ******************************************************************************/

/*!
 * @brief TRNG_PKRCNTFE - RNG Statistical Check Poker Count F and E Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Statistical Check Poker Count F and E Register is a read-only
 * register used to read the final Poker test counts of Fh and Eh patterns. The Poker Eh
 * Count increments each time a nibble of sample data is found to be Eh. The
 * Poker Fh Count increments each time a nibble of sample data is found to be Fh.
 * Note that this register is readable only if MCTL[PRGM] is 0, otherwise zeroes
 * will be read.
 */
/*!
 * @name Constants and macros for entire TRNG_PKRCNTFE register
 */
/*@{*/
#define TRNG_RD_PKRCNTFE(base)   (TRNG_PKRCNTFE_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_PKRCNTFE bitfields
 */

/*!
 * @name Register TRNG_PKRCNTFE, field PKR_E_CT[15:0] (RO)
 *
 * Poker Eh Count. Total number of nibbles of sample data which were found to be
 * Eh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTFE_PKR_E_CT field. */
#define TRNG_RD_PKRCNTFE_PKR_E_CT(base) ((TRNG_PKRCNTFE_REG(base) & TRNG_PKRCNTFE_PKR_E_CT_MASK) >> TRNG_PKRCNTFE_PKR_E_CT_SHIFT)
#define TRNG_BRD_PKRCNTFE_PKR_E_CT(base) (TRNG_RD_PKRCNTFE_PKR_E_CT(base))
/*@}*/

/*!
 * @name Register TRNG_PKRCNTFE, field PKR_F_CT[31:16] (RO)
 *
 * Poker Fh Count. Total number of nibbles of sample data which were found to be
 * Fh. Requires MCTL[PRGM] = 0.
 */
/*@{*/
/*! @brief Read current value of the TRNG_PKRCNTFE_PKR_F_CT field. */
#define TRNG_RD_PKRCNTFE_PKR_F_CT(base) ((TRNG_PKRCNTFE_REG(base) & TRNG_PKRCNTFE_PKR_F_CT_MASK) >> TRNG_PKRCNTFE_PKR_F_CT_SHIFT)
#define TRNG_BRD_PKRCNTFE_PKR_F_CT(base) (TRNG_RD_PKRCNTFE_PKR_F_CT(base))
/*@}*/

/*******************************************************************************
 * TRNG_SEC_CFG - RNG Security Configuration Register
 ******************************************************************************/

/*!
 * @brief TRNG_SEC_CFG - RNG Security Configuration Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Security Configuration Register is a read/write register used to
 * control the test mode, programmability and state modes of the RNG. Many bits are
 * place holders for this version. More configurability will be added here. Clears
 * on asynchronous reset. For SA-TRNG releases before 2014/July/01, offsets 0xA0
 * to 0xAC used to be 0xB0 to 0xBC respectively. So, update newer tests that use
 * these registers, if hard coded.
 */
/*!
 * @name Constants and macros for entire TRNG_SEC_CFG register
 */
/*@{*/
#define TRNG_RD_SEC_CFG(base)    (TRNG_SEC_CFG_REG(base))
#define TRNG_WR_SEC_CFG(base, value) (TRNG_SEC_CFG_REG(base) = (value))
#define TRNG_RMW_SEC_CFG(base, mask, value) (TRNG_WR_SEC_CFG(base, (TRNG_RD_SEC_CFG(base) & ~(mask)) | (value)))
#define TRNG_SET_SEC_CFG(base, value) (BME_OR32(&TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
#define TRNG_CLR_SEC_CFG(base, value) (BME_AND32(&TRNG_SEC_CFG_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_SEC_CFG(base, value) (BME_XOR32(&TRNG_SEC_CFG_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_SEC_CFG bitfields
 */

/*!
 * @name Register TRNG_SEC_CFG, field SH0[0] (RW)
 *
 * Reserved. DRNG specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_SH0 field. */
#define TRNG_RD_SEC_CFG_SH0(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_SH0_MASK) >> TRNG_SEC_CFG_SH0_SHIFT)
#define TRNG_BRD_SEC_CFG_SH0(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_SH0_SHIFT, TRNG_SEC_CFG_SH0_WIDTH))

/*! @brief Set the SH0 field to a new value. */
#define TRNG_WR_SEC_CFG_SH0(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_SH0_MASK, TRNG_SEC_CFG_SH0(value)))
#define TRNG_BWR_SEC_CFG_SH0(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_SH0_SHIFT), TRNG_SEC_CFG_SH0_SHIFT, TRNG_SEC_CFG_SH0_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SEC_CFG, field NO_PRGM[1] (RW)
 *
 * If set the TRNG registers cannot be programmed. That is, regardless of the
 * TRNG access mode in the SA-TRNG Miscellaneous Control Register.
 *
 * Values:
 * - 0b0 - Programability of registers controlled only by the RNG Miscellaneous
 *     Control Register's access mode bit.
 * - 0b1 - Overides RNG Miscellaneous Control Register access mode and prevents
 *     TRNG register programming.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_NO_PRGM field. */
#define TRNG_RD_SEC_CFG_NO_PRGM(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_NO_PRGM_MASK) >> TRNG_SEC_CFG_NO_PRGM_SHIFT)
#define TRNG_BRD_SEC_CFG_NO_PRGM(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SEC_CFG_NO_PRGM_WIDTH))

/*! @brief Set the NO_PRGM field to a new value. */
#define TRNG_WR_SEC_CFG_NO_PRGM(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_NO_PRGM_MASK, TRNG_SEC_CFG_NO_PRGM(value)))
#define TRNG_BWR_SEC_CFG_NO_PRGM(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_NO_PRGM_SHIFT), TRNG_SEC_CFG_NO_PRGM_SHIFT, TRNG_SEC_CFG_NO_PRGM_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_SEC_CFG, field SK_VAL[2] (RW)
 *
 * Reserved. DRNG-specific, not applicable to this version.
 *
 * Values:
 * - 0b0 - See DRNG version.
 * - 0b1 - See DRNG version.
 */
/*@{*/
/*! @brief Read current value of the TRNG_SEC_CFG_SK_VAL field. */
#define TRNG_RD_SEC_CFG_SK_VAL(base) ((TRNG_SEC_CFG_REG(base) & TRNG_SEC_CFG_SK_VAL_MASK) >> TRNG_SEC_CFG_SK_VAL_SHIFT)
#define TRNG_BRD_SEC_CFG_SK_VAL(base) (BME_UBFX32(&TRNG_SEC_CFG_REG(base), TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SEC_CFG_SK_VAL_WIDTH))

/*! @brief Set the SK_VAL field to a new value. */
#define TRNG_WR_SEC_CFG_SK_VAL(base, value) (TRNG_RMW_SEC_CFG(base, TRNG_SEC_CFG_SK_VAL_MASK, TRNG_SEC_CFG_SK_VAL(value)))
#define TRNG_BWR_SEC_CFG_SK_VAL(base, value) (BME_BFI32(&TRNG_SEC_CFG_REG(base), ((uint32_t)(value) << TRNG_SEC_CFG_SK_VAL_SHIFT), TRNG_SEC_CFG_SK_VAL_SHIFT, TRNG_SEC_CFG_SK_VAL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_INT_CTRL - RNG Interrupt Control Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_CTRL - RNG Interrupt Control Register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The RNG Interrupt Control Register is a read/write register used to control
 * the status for the (currently) three important interrupts that are generated by
 * the TRNG. See INT_STATUS register description above. Each interrupt can be
 * cleared by de-asserting the corresponding bit in the INT_CTRL register. Only a
 * new interrupt will reassert the corresponding bit in the status register. Even
 * if the interrupt is cleared or masked, interrupt status information can be
 * read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_CTRL register
 */
/*@{*/
#define TRNG_RD_INT_CTRL(base)   (TRNG_INT_CTRL_REG(base))
#define TRNG_WR_INT_CTRL(base, value) (TRNG_INT_CTRL_REG(base) = (value))
#define TRNG_RMW_INT_CTRL(base, mask, value) (TRNG_WR_INT_CTRL(base, (TRNG_RD_INT_CTRL(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_CTRL(base, value) (BME_OR32(&TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_CTRL(base, value) (BME_AND32(&TRNG_INT_CTRL_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_CTRL(base, value) (BME_XOR32(&TRNG_INT_CTRL_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_CTRL bitfields
 */

/*!
 * @name Register TRNG_INT_CTRL, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of INT_STATUS has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding bit of INT_STATUS cleared.
 * - 0b1 - Corresponding bit of INT_STATUS active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_HW_ERR field. */
#define TRNG_RD_INT_CTRL_HW_ERR(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_HW_ERR_MASK) >> TRNG_INT_CTRL_HW_ERR_SHIFT)
#define TRNG_BRD_INT_CTRL_HW_ERR(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_INT_CTRL_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_INT_CTRL_HW_ERR(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_HW_ERR_MASK, TRNG_INT_CTRL_HW_ERR(value)))
#define TRNG_BWR_INT_CTRL_HW_ERR(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_HW_ERR_SHIFT), TRNG_INT_CTRL_HW_ERR_SHIFT, TRNG_INT_CTRL_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_ENT_VAL field. */
#define TRNG_RD_INT_CTRL_ENT_VAL(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_ENT_VAL_MASK) >> TRNG_INT_CTRL_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_CTRL_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_INT_CTRL_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_INT_CTRL_ENT_VAL(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_ENT_VAL_MASK, TRNG_INT_CTRL_ENT_VAL(value)))
#define TRNG_BWR_INT_CTRL_ENT_VAL(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_ENT_VAL_SHIFT), TRNG_INT_CTRL_ENT_VAL_SHIFT, TRNG_INT_CTRL_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_CTRL_FRQ_CT_FAIL(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_FRQ_CT_FAIL_MASK) >> TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_CTRL_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_CTRL_REG(base), TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_CTRL_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_FRQ_CT_FAIL_MASK, TRNG_INT_CTRL_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_CTRL_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_CTRL_REG(base), ((uint32_t)(value) << TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT), TRNG_INT_CTRL_FRQ_CT_FAIL_SHIFT, TRNG_INT_CTRL_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_CTRL, field UNUSED[31:3] (RW)
 *
 * Reserved but writeable.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_CTRL_UNUSED field. */
#define TRNG_RD_INT_CTRL_UNUSED(base) ((TRNG_INT_CTRL_REG(base) & TRNG_INT_CTRL_UNUSED_MASK) >> TRNG_INT_CTRL_UNUSED_SHIFT)
#define TRNG_BRD_INT_CTRL_UNUSED(base) (TRNG_RD_INT_CTRL_UNUSED(base))

/*! @brief Set the UNUSED field to a new value. */
#define TRNG_WR_INT_CTRL_UNUSED(base, value) (TRNG_RMW_INT_CTRL(base, TRNG_INT_CTRL_UNUSED_MASK, TRNG_INT_CTRL_UNUSED(value)))
#define TRNG_BWR_INT_CTRL_UNUSED(base, value) (TRNG_WR_INT_CTRL_UNUSED(base, value))
/*@}*/

/*******************************************************************************
 * TRNG_INT_MASK - RNG Mask Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_MASK - RNG Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Mask Register is a read/write register used to disable/mask
 * the status reporting of the (currently) three important interrupts that are
 * generated by the TRNG. See INT_STATUS register description above. Each
 * interrupt can be masked/disabled by de-asserting the corresponding bit in the INT_MASK
 * register. Only setting this bit high will re-enable the interrupt in the
 * status register. Even if the interrupt is cleared or masked, interrupt status
 * information can be read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_MASK register
 */
/*@{*/
#define TRNG_RD_INT_MASK(base)   (TRNG_INT_MASK_REG(base))
#define TRNG_WR_INT_MASK(base, value) (TRNG_INT_MASK_REG(base) = (value))
#define TRNG_RMW_INT_MASK(base, mask, value) (TRNG_WR_INT_MASK(base, (TRNG_RD_INT_MASK(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_MASK(base, value) (BME_OR32(&TRNG_INT_MASK_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_MASK(base, value) (BME_AND32(&TRNG_INT_MASK_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_MASK(base, value) (BME_XOR32(&TRNG_INT_MASK_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_MASK bitfields
 */

/*!
 * @name Register TRNG_INT_MASK, field HW_ERR[0] (RW)
 *
 * Bit position that can be cleared if corresponding bit of INT_STATUS has been
 * asserted.
 *
 * Values:
 * - 0b0 - Corresponding interrupt of INT_STATUS is masked.
 * - 0b1 - Corresponding bit of INT_STATUS is active.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_HW_ERR field. */
#define TRNG_RD_INT_MASK_HW_ERR(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_HW_ERR_MASK) >> TRNG_INT_MASK_HW_ERR_SHIFT)
#define TRNG_BRD_INT_MASK_HW_ERR(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_INT_MASK_HW_ERR_WIDTH))

/*! @brief Set the HW_ERR field to a new value. */
#define TRNG_WR_INT_MASK_HW_ERR(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_HW_ERR_MASK, TRNG_INT_MASK_HW_ERR(value)))
#define TRNG_BWR_INT_MASK_HW_ERR(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_HW_ERR_SHIFT), TRNG_INT_MASK_HW_ERR_SHIFT, TRNG_INT_MASK_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_MASK, field ENT_VAL[1] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_ENT_VAL field. */
#define TRNG_RD_INT_MASK_ENT_VAL(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_ENT_VAL_MASK) >> TRNG_INT_MASK_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_MASK_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_INT_MASK_ENT_VAL_WIDTH))

/*! @brief Set the ENT_VAL field to a new value. */
#define TRNG_WR_INT_MASK_ENT_VAL(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_ENT_VAL_MASK, TRNG_INT_MASK_ENT_VAL(value)))
#define TRNG_BWR_INT_MASK_ENT_VAL(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_ENT_VAL_SHIFT), TRNG_INT_MASK_ENT_VAL_SHIFT, TRNG_INT_MASK_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_MASK, field FRQ_CT_FAIL[2] (RW)
 *
 * Same behavior as bit 0 above.
 *
 * Values:
 * - 0b0 - Same behavior as bit 0 above.
 * - 0b1 - Same behavior as bit 0 above.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_MASK_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_MASK_FRQ_CT_FAIL(base) ((TRNG_INT_MASK_REG(base) & TRNG_INT_MASK_FRQ_CT_FAIL_MASK) >> TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_MASK_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_MASK_REG(base), TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_MASK_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_MASK(base, TRNG_INT_MASK_FRQ_CT_FAIL_MASK, TRNG_INT_MASK_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_MASK_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_MASK_REG(base), ((uint32_t)(value) << TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT), TRNG_INT_MASK_FRQ_CT_FAIL_SHIFT, TRNG_INT_MASK_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_INT_STATUS - RNG Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief TRNG_INT_STATUS - RNG Interrupt Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Interrupt Status Register is a read register used to control and
 * provide status for the (currently) three important interrupts that are generated
 * by the TRNG. The ipi_rng_int_b interrupt signals that RNG has either generated
 * a Frequency Count Fail, Entropy Valid or Error Interrupt. The cause of the
 * interrupt can be decoded by checking the least significant bits of the INT_STATUS
 * register. Each interrupt can be temporarily cleared by de-asserting the
 * corresponding bit in the INT_CTRL register. To mask the interrupts, clear the
 * corresponding bits in the INT_MASK register. The description of each of the 3
 * interrupts is defined in the Block Guide under the MCTL register description. Even
 * if the interrupt is cleared or masked, interrupt status information can be
 * read from the MCTL register.
 */
/*!
 * @name Constants and macros for entire TRNG_INT_STATUS register
 */
/*@{*/
#define TRNG_RD_INT_STATUS(base) (TRNG_INT_STATUS_REG(base))
#define TRNG_WR_INT_STATUS(base, value) (TRNG_INT_STATUS_REG(base) = (value))
#define TRNG_RMW_INT_STATUS(base, mask, value) (TRNG_WR_INT_STATUS(base, (TRNG_RD_INT_STATUS(base) & ~(mask)) | (value)))
#define TRNG_SET_INT_STATUS(base, value) (BME_OR32(&TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
#define TRNG_CLR_INT_STATUS(base, value) (BME_AND32(&TRNG_INT_STATUS_REG(base), (uint32_t)(~(value))))
#define TRNG_TOG_INT_STATUS(base, value) (BME_XOR32(&TRNG_INT_STATUS_REG(base), (uint32_t)(value)))
/*@}*/

/*
 * Constants & macros for individual TRNG_INT_STATUS bitfields
 */

/*!
 * @name Register TRNG_INT_STATUS, field HW_ERR[0] (RO)
 *
 * Read: Error status. 1 = error detected. 0 = no error. Any HW error in the
 * TRNG will trigger this interrupt.
 *
 * Values:
 * - 0b0 - no error
 * - 0b1 - error detected.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_HW_ERR field. */
#define TRNG_RD_INT_STATUS_HW_ERR(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_HW_ERR_MASK) >> TRNG_INT_STATUS_HW_ERR_SHIFT)
#define TRNG_BRD_INT_STATUS_HW_ERR(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_HW_ERR_SHIFT, TRNG_INT_STATUS_HW_ERR_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_STATUS, field ENT_VAL[1] (RO)
 *
 * Read only: Entropy Valid. Will assert only if TRNG ACC bit is set, and then
 * after an entropy value is generated. Will be cleared when ENT15 is read. (ENT0
 * through ENT14 should be read before reading ENT15).
 *
 * Values:
 * - 0b0 - Busy generation entropy. Any value read is invalid.
 * - 0b1 - TRNG can be stopped and entropy is valid if read.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_ENT_VAL field. */
#define TRNG_RD_INT_STATUS_ENT_VAL(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_ENT_VAL_MASK) >> TRNG_INT_STATUS_ENT_VAL_SHIFT)
#define TRNG_BRD_INT_STATUS_ENT_VAL(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_ENT_VAL_SHIFT, TRNG_INT_STATUS_ENT_VAL_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_INT_STATUS, field FRQ_CT_FAIL[2] (RW)
 *
 * Read only: Frequency Count Fail. The frequency counter has detected a
 * failure. This may be due to improper programming of the FRQMAX and/or FRQMIN
 * registers, or a hardware failure in the ring oscillator.
 *
 * Values:
 * - 0b0 - No hardware nor self test frequency errors.
 * - 0b1 - The frequency counter has detected a failure.
 */
/*@{*/
/*! @brief Read current value of the TRNG_INT_STATUS_FRQ_CT_FAIL field. */
#define TRNG_RD_INT_STATUS_FRQ_CT_FAIL(base) ((TRNG_INT_STATUS_REG(base) & TRNG_INT_STATUS_FRQ_CT_FAIL_MASK) >> TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT)
#define TRNG_BRD_INT_STATUS_FRQ_CT_FAIL(base) (BME_UBFX32(&TRNG_INT_STATUS_REG(base), TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))

/*! @brief Set the FRQ_CT_FAIL field to a new value. */
#define TRNG_WR_INT_STATUS_FRQ_CT_FAIL(base, value) (TRNG_RMW_INT_STATUS(base, TRNG_INT_STATUS_FRQ_CT_FAIL_MASK, TRNG_INT_STATUS_FRQ_CT_FAIL(value)))
#define TRNG_BWR_INT_STATUS_FRQ_CT_FAIL(base, value) (BME_BFI32(&TRNG_INT_STATUS_REG(base), ((uint32_t)(value) << TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT), TRNG_INT_STATUS_FRQ_CT_FAIL_SHIFT, TRNG_INT_STATUS_FRQ_CT_FAIL_WIDTH))
/*@}*/

/*******************************************************************************
 * TRNG_VID1 - RNG Version ID Register (MS)
 ******************************************************************************/

/*!
 * @brief TRNG_VID1 - RNG Version ID Register (MS) (RO)
 *
 * Reset value: 0x00300100U
 *
 * The RNG Version ID Register is a read only register used to identify the
 * version of the TRNG in use. This register as well as VID2 should both be read to
 * verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_VID1 register
 */
/*@{*/
#define TRNG_RD_VID1(base)       (TRNG_VID1_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_VID1 bitfields
 */

/*!
 * @name Register TRNG_VID1, field RNG_MIN_REV[7:0] (RO)
 *
 * Shows the Freescale IP's Minor revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - Minor revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_MIN_REV field. */
#define TRNG_RD_VID1_RNG_MIN_REV(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_MIN_REV_MASK) >> TRNG_VID1_RNG_MIN_REV_SHIFT)
#define TRNG_BRD_VID1_RNG_MIN_REV(base) (BME_UBFX32(&TRNG_VID1_REG(base), TRNG_VID1_RNG_MIN_REV_SHIFT, TRNG_VID1_RNG_MIN_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID1, field RNG_MAJ_REV[15:8] (RO)
 *
 * Shows the Freescale IP's Major revision of the TRNG.
 *
 * Values:
 * - 0b00000001 - Major revision number for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_MAJ_REV field. */
#define TRNG_RD_VID1_RNG_MAJ_REV(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_MAJ_REV_MASK) >> TRNG_VID1_RNG_MAJ_REV_SHIFT)
#define TRNG_BRD_VID1_RNG_MAJ_REV(base) (BME_UBFX32(&TRNG_VID1_REG(base), TRNG_VID1_RNG_MAJ_REV_SHIFT, TRNG_VID1_RNG_MAJ_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID1, field RNG_IP_ID[31:16] (RO)
 *
 * Shows the Freescale IP ID.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID1_RNG_IP_ID field. */
#define TRNG_RD_VID1_RNG_IP_ID(base) ((TRNG_VID1_REG(base) & TRNG_VID1_RNG_IP_ID_MASK) >> TRNG_VID1_RNG_IP_ID_SHIFT)
#define TRNG_BRD_VID1_RNG_IP_ID(base) (TRNG_RD_VID1_RNG_IP_ID(base))
/*@}*/

/*******************************************************************************
 * TRNG_VID2 - RNG Version ID Register (LS)
 ******************************************************************************/

/*!
 * @brief TRNG_VID2 - RNG Version ID Register (LS) (RO)
 *
 * Reset value: 0x00000000U
 *
 * The RNG Version ID Register LSB is a read only register used to identify the
 * architecture of the TRNG in use. This register as well as VID1 should both be
 * read to verify the expected version.
 */
/*!
 * @name Constants and macros for entire TRNG_VID2 register
 */
/*@{*/
#define TRNG_RD_VID2(base)       (TRNG_VID2_REG(base))
/*@}*/

/*
 * Constants & macros for individual TRNG_VID2 bitfields
 */

/*!
 * @name Register TRNG_VID2, field RNG_CONFIG_OPT[7:0] (RO)
 *
 * Shows the Freescale IP's Configuaration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_CONFIG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_CONFIG_OPT field. */
#define TRNG_RD_VID2_RNG_CONFIG_OPT(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_CONFIG_OPT_MASK) >> TRNG_VID2_RNG_CONFIG_OPT_SHIFT)
#define TRNG_BRD_VID2_RNG_CONFIG_OPT(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_CONFIG_OPT_SHIFT, TRNG_VID2_RNG_CONFIG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_ECO_REV[15:8] (RO)
 *
 * Shows the Freescale IP's ECO revision of the TRNG.
 *
 * Values:
 * - 0b00000000 - TRNG_ECO_REV for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_ECO_REV field. */
#define TRNG_RD_VID2_RNG_ECO_REV(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_ECO_REV_MASK) >> TRNG_VID2_RNG_ECO_REV_SHIFT)
#define TRNG_BRD_VID2_RNG_ECO_REV(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_ECO_REV_SHIFT, TRNG_VID2_RNG_ECO_REV_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_INTG_OPT[23:16] (RO)
 *
 * Shows the Freescale integration options for the TRNG.
 *
 * Values:
 * - 0b00000000 - INTG_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_INTG_OPT field. */
#define TRNG_RD_VID2_RNG_INTG_OPT(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_INTG_OPT_MASK) >> TRNG_VID2_RNG_INTG_OPT_SHIFT)
#define TRNG_BRD_VID2_RNG_INTG_OPT(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_INTG_OPT_SHIFT, TRNG_VID2_RNG_INTG_OPT_WIDTH))
/*@}*/

/*!
 * @name Register TRNG_VID2, field RNG_ERA[31:24] (RO)
 *
 * Shows the Freescale compile options for the TRNG.
 *
 * Values:
 * - 0b00000000 - COMPILE_OPT for TRNG.
 */
/*@{*/
/*! @brief Read current value of the TRNG_VID2_RNG_ERA field. */
#define TRNG_RD_VID2_RNG_ERA(base) ((TRNG_VID2_REG(base) & TRNG_VID2_RNG_ERA_MASK) >> TRNG_VID2_RNG_ERA_SHIFT)
#define TRNG_BRD_VID2_RNG_ERA(base) (BME_UBFX32(&TRNG_VID2_REG(base), TRNG_VID2_RNG_ERA_SHIFT, TRNG_VID2_RNG_ERA_WIDTH))
/*@}*/

/*
 * MKV58F24 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - UART_BDH - UART Baud Rate Registers: High
 * - UART_BDL - UART Baud Rate Registers: Low
 * - UART_C1 - UART Control Register 1
 * - UART_C2 - UART Control Register 2
 * - UART_S1 - UART Status Register 1
 * - UART_S2 - UART Status Register 2
 * - UART_C3 - UART Control Register 3
 * - UART_D - UART Data Register
 * - UART_MA1 - UART Match Address Registers 1
 * - UART_MA2 - UART Match Address Registers 2
 * - UART_C4 - UART Control Register 4
 * - UART_C5 - UART Control Register 5
 * - UART_ED - UART Extended Data Register
 * - UART_MODEM - UART Modem Register
 * - UART_IR - UART Infrared Register
 * - UART_PFIFO - UART FIFO Parameters
 * - UART_CFIFO - UART FIFO Control Register
 * - UART_SFIFO - UART FIFO Status Register
 * - UART_TWFIFO - UART FIFO Transmit Watermark
 * - UART_TCFIFO - UART FIFO Transmit Count
 * - UART_RWFIFO - UART FIFO Receive Watermark
 * - UART_RCFIFO - UART FIFO Receive Count
 * - UART_C7816 - UART 7816 Control Register
 * - UART_IE7816 - UART 7816 Interrupt Enable Register
 * - UART_IS7816 - UART 7816 Interrupt Status Register
 * - UART_WP7816 - UART 7816 Wait Parameter Register
 * - UART_WN7816 - UART 7816 Wait N Register
 * - UART_WF7816 - UART 7816 Wait FD Register
 * - UART_ET7816 - UART 7816 Error Threshold Register
 * - UART_TL7816 - UART 7816 Transmit Length Register
 * - UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 * - UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 * - UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 * - UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 * - UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 * - UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 */

#define UART_INSTANCE_COUNT (6U) /*!< Number of instances of the UART module. */
#define UART0_IDX (0U) /*!< Instance number for UART0. */
#define UART1_IDX (1U) /*!< Instance number for UART1. */
#define UART2_IDX (2U) /*!< Instance number for UART2. */
#define UART3_IDX (3U) /*!< Instance number for UART3. */
#define UART4_IDX (4U) /*!< Instance number for UART4. */
#define UART5_IDX (5U) /*!< Instance number for UART5. */

/*******************************************************************************
 * UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define UART_RD_BDH(base)        (UART_BDH_REG(base))
#define UART_WR_BDH(base, value) (UART_BDH_REG(base) = (value))
#define UART_RMW_BDH(base, mask, value) (UART_WR_BDH(base, (UART_RD_BDH(base) & ~(mask)) | (value)))
#define UART_SET_BDH(base, value) (BME_OR8(&UART_BDH_REG(base), (uint8_t)(value)))
#define UART_CLR_BDH(base, value) (BME_AND8(&UART_BDH_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDH(base, value) (BME_XOR8(&UART_BDH_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBR field. */
#define UART_RD_BDH_SBR(base) ((UART_BDH_REG(base) & UART_BDH_SBR_MASK) >> UART_BDH_SBR_SHIFT)
#define UART_BRD_BDH_SBR(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))

/*! @brief Set the SBR field to a new value. */
#define UART_WR_BDH_SBR(base, value) (UART_RMW_BDH(base, UART_BDH_SBR_MASK, UART_BDH_SBR(value)))
#define UART_BWR_BDH_SBR(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_SBR_SHIFT), UART_BDH_SBR_SHIFT, UART_BDH_SBR_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field SBNS[5] (RW)
 *
 * SBNS selects the number of stop bits present in a data frame. This field
 * valid for all 8, 9 and 10 bit data formats available. This field is not valid when
 * C7816[ISO7816E] is enabled.
 *
 * Values:
 * - 0b0 - Data frame consists of a single stop bit.
 * - 0b1 - Data frame consists of two stop bits.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBNS field. */
#define UART_RD_BDH_SBNS(base) ((UART_BDH_REG(base) & UART_BDH_SBNS_MASK) >> UART_BDH_SBNS_SHIFT)
#define UART_BRD_BDH_SBNS(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_SBNS_SHIFT, UART_BDH_SBNS_WIDTH))

/*! @brief Set the SBNS field to a new value. */
#define UART_WR_BDH_SBNS(base, value) (UART_RMW_BDH(base, UART_BDH_SBNS_MASK, UART_BDH_SBNS(value)))
#define UART_BWR_BDH_SBNS(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_SBNS_SHIFT), UART_BDH_SBNS_SHIFT, UART_BDH_SBNS_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0b0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 0b1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define UART_RD_BDH_RXEDGIE(base) ((UART_BDH_REG(base) & UART_BDH_RXEDGIE_MASK) >> UART_BDH_RXEDGIE_SHIFT)
#define UART_BRD_BDH_RXEDGIE(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))

/*! @brief Set the RXEDGIE field to a new value. */
#define UART_WR_BDH_RXEDGIE(base, value) (UART_RMW_BDH(base, UART_BDH_RXEDGIE_MASK, UART_BDH_RXEDGIE(value)))
#define UART_BWR_BDH_RXEDGIE(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_RXEDGIE_SHIFT), UART_BDH_RXEDGIE_SHIFT, UART_BDH_RXEDGIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests
 * based on the state of LBKDDMAS. or DMA transfer requests,
 *
 * Values:
 * - 0b0 - LBKDIF interrupt and DMA transfer requests disabled.
 * - 0b1 - LBKDIF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define UART_RD_BDH_LBKDIE(base) ((UART_BDH_REG(base) & UART_BDH_LBKDIE_MASK) >> UART_BDH_LBKDIE_SHIFT)
#define UART_BRD_BDH_LBKDIE(base) (BME_UBFX8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT, UART_BDH_LBKDIE_WIDTH))

/*! @brief Set the LBKDIE field to a new value. */
#define UART_WR_BDH_LBKDIE(base, value) (UART_RMW_BDH(base, UART_BDH_LBKDIE_MASK, UART_BDH_LBKDIE(value)))
#define UART_BWR_BDH_LBKDIE(base, value) (BME_BFI8(&UART_BDH_REG(base), ((uint8_t)(value) << UART_BDH_LBKDIE_SHIFT), UART_BDH_LBKDIE_SHIFT, UART_BDH_LBKDIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define UART_RD_BDL(base)        (UART_BDL_REG(base))
#define UART_WR_BDL(base, value) (UART_BDL_REG(base) = (value))
#define UART_RMW_BDL(base, mask, value) (UART_WR_BDL(base, (UART_RD_BDL(base) & ~(mask)) | (value)))
#define UART_SET_BDL(base, value) (BME_OR8(&UART_BDL_REG(base), (uint8_t)(value)))
#define UART_CLR_BDL(base, value) (BME_AND8(&UART_BDL_REG(base), (uint8_t)(~(value))))
#define UART_TOG_BDL(base, value) (BME_XOR8(&UART_BDL_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define UART_RD_C1(base)         (UART_C1_REG(base))
#define UART_WR_C1(base, value)  (UART_C1_REG(base) = (value))
#define UART_RMW_C1(base, mask, value) (UART_WR_C1(base, (UART_RD_C1(base) & ~(mask)) | (value)))
#define UART_SET_C1(base, value) (BME_OR8(&UART_C1_REG(base), (uint8_t)(value)))
#define UART_CLR_C1(base, value) (BME_AND8(&UART_C1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C1(base, value) (BME_XOR8(&UART_C1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Even parity.
 * - 0b1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PT field. */
#define UART_RD_C1_PT(base)  ((UART_C1_REG(base) & UART_C1_PT_MASK) >> UART_C1_PT_SHIFT)
#define UART_BRD_C1_PT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))

/*! @brief Set the PT field to a new value. */
#define UART_WR_C1_PT(base, value) (UART_RMW_C1(base, UART_C1_PT_MASK, UART_C1_PT(value)))
#define UART_BWR_C1_PT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PT_SHIFT), UART_C1_PT_SHIFT, UART_C1_PT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Parity function disabled.
 * - 0b1 - Parity function enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PE field. */
#define UART_RD_C1_PE(base)  ((UART_C1_REG(base) & UART_C1_PE_MASK) >> UART_C1_PE_SHIFT)
#define UART_BRD_C1_PE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))

/*! @brief Set the PE field to a new value. */
#define UART_WR_C1_PE(base, value) (UART_RMW_C1(base, UART_C1_PE_MASK, UART_C1_PE(value)))
#define UART_BWR_C1_PE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_PE_SHIFT), UART_C1_PE_SHIFT, UART_C1_PE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0b0 - Idle character bit count starts after start bit.
 * - 0b1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_ILT field. */
#define UART_RD_C1_ILT(base) ((UART_C1_REG(base) & UART_C1_ILT_MASK) >> UART_C1_ILT_SHIFT)
#define UART_BRD_C1_ILT(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))

/*! @brief Set the ILT field to a new value. */
#define UART_WR_C1_ILT(base, value) (UART_RMW_C1(base, UART_C1_ILT_MASK, UART_C1_ILT(value)))
#define UART_BWR_C1_ILT(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_ILT_SHIFT), UART_C1_ILT_SHIFT, UART_C1_ILT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0b0 - Idle line wakeup.
 * - 0b1 - Address mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_WAKE field. */
#define UART_RD_C1_WAKE(base) ((UART_C1_REG(base) & UART_C1_WAKE_MASK) >> UART_C1_WAKE_SHIFT)
#define UART_BRD_C1_WAKE(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))

/*! @brief Set the WAKE field to a new value. */
#define UART_WR_C1_WAKE(base, value) (UART_RMW_C1(base, UART_C1_WAKE_MASK, UART_C1_WAKE(value)))
#define UART_BWR_C1_WAKE(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_WAKE_SHIFT), UART_C1_WAKE_SHIFT, UART_C1_WAKE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) +
 *     stop.
 * - 0b1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_M field. */
#define UART_RD_C1_M(base)   ((UART_C1_REG(base) & UART_C1_M_MASK) >> UART_C1_M_SHIFT)
#define UART_BRD_C1_M(base)  (BME_UBFX8(&UART_C1_REG(base), UART_C1_M_SHIFT, UART_C1_M_WIDTH))

/*! @brief Set the M field to a new value. */
#define UART_WR_C1_M(base, value) (UART_RMW_C1(base, UART_C1_M_MASK, UART_C1_M(value)))
#define UART_BWR_C1_M(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_M_SHIFT), UART_C1_M_SHIFT, UART_C1_M_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0b0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 0b1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_RSRC field. */
#define UART_RD_C1_RSRC(base) ((UART_C1_REG(base) & UART_C1_RSRC_MASK) >> UART_C1_RSRC_SHIFT)
#define UART_BRD_C1_RSRC(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))

/*! @brief Set the RSRC field to a new value. */
#define UART_WR_C1_RSRC(base, value) (UART_RMW_C1(base, UART_C1_RSRC_MASK, UART_C1_RSRC(value)))
#define UART_BWR_C1_RSRC(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_RSRC_SHIFT), UART_C1_RSRC_SHIFT, UART_C1_RSRC_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0b0 - UART clock continues to run in Wait mode.
 * - 0b1 - UART clock freezes while CPU is in Wait mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define UART_RD_C1_UARTSWAI(base) ((UART_C1_REG(base) & UART_C1_UARTSWAI_MASK) >> UART_C1_UARTSWAI_SHIFT)
#define UART_BRD_C1_UARTSWAI(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT, UART_C1_UARTSWAI_WIDTH))

/*! @brief Set the UARTSWAI field to a new value. */
#define UART_WR_C1_UARTSWAI(base, value) (UART_RMW_C1(base, UART_C1_UARTSWAI_MASK, UART_C1_UARTSWAI(value)))
#define UART_BWR_C1_UARTSWAI(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_UARTSWAI_SHIFT), UART_C1_UARTSWAI_SHIFT, UART_C1_UARTSWAI_WIDTH))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - Loop mode where transmitter output is internally connected to
 *     receiver input. The receiver input is determined by RSRC.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_LOOPS field. */
#define UART_RD_C1_LOOPS(base) ((UART_C1_REG(base) & UART_C1_LOOPS_MASK) >> UART_C1_LOOPS_SHIFT)
#define UART_BRD_C1_LOOPS(base) (BME_UBFX8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))

/*! @brief Set the LOOPS field to a new value. */
#define UART_WR_C1_LOOPS(base, value) (UART_RMW_C1(base, UART_C1_LOOPS_MASK, UART_C1_LOOPS(value)))
#define UART_BWR_C1_LOOPS(base, value) (BME_BFI8(&UART_C1_REG(base), ((uint8_t)(value) << UART_C1_LOOPS_SHIFT), UART_C1_LOOPS_SHIFT, UART_C1_LOOPS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define UART_RD_C2(base)         (UART_C2_REG(base))
#define UART_WR_C2(base, value)  (UART_C2_REG(base) = (value))
#define UART_RMW_C2(base, mask, value) (UART_WR_C2(base, (UART_RD_C2(base) & ~(mask)) | (value)))
#define UART_SET_C2(base, value) (BME_OR8(&UART_C2_REG(base), (uint8_t)(value)))
#define UART_CLR_C2(base, value) (BME_AND8(&UART_C2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C2(base, value) (BME_XOR8(&UART_C2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set. This field
 * must be cleared when C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0b0 - Normal transmitter operation.
 * - 0b1 - Queue break characters to be sent.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_SBK field. */
#define UART_RD_C2_SBK(base) ((UART_C2_REG(base) & UART_C2_SBK_MASK) >> UART_C2_SBK_SHIFT)
#define UART_BRD_C2_SBK(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))

/*! @brief Set the SBK field to a new value. */
#define UART_WR_C2_SBK(base, value) (UART_RMW_C2(base, UART_C2_SBK_MASK, UART_C2_SBK(value)))
#define UART_BWR_C2_SBK(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_SBK_SHIFT), UART_C2_SBK_SHIFT, UART_C2_SBK_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received or a LIN break detected after an IDLE is detected before IDLE
 * is allowed to reasserted.
 *
 * Values:
 * - 0b0 - Normal operation.
 * - 0b1 - RWU enables the wakeup function and inhibits further receiver
 *     interrupt requests. Normally, hardware wakes the receiver by automatically
 *     clearing RWU.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RWU field. */
#define UART_RD_C2_RWU(base) ((UART_C2_REG(base) & UART_C2_RWU_MASK) >> UART_C2_RWU_SHIFT)
#define UART_BRD_C2_RWU(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))

/*! @brief Set the RWU field to a new value. */
#define UART_WR_C2_RWU(base, value) (UART_RMW_C2(base, UART_C2_RWU_MASK, UART_C2_RWU(value)))
#define UART_BWR_C2_RWU(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RWU_SHIFT), UART_C2_RWU_SHIFT, UART_C2_RWU_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0b0 - Receiver off.
 * - 0b1 - Receiver on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RE field. */
#define UART_RD_C2_RE(base)  ((UART_C2_REG(base) & UART_C2_RE_MASK) >> UART_C2_RE_SHIFT)
#define UART_BRD_C2_RE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))

/*! @brief Set the RE field to a new value. */
#define UART_WR_C2_RE(base, value) (UART_RMW_C2(base, UART_C2_RE_MASK, UART_C2_RE(value)))
#define UART_BWR_C2_RE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RE_SHIFT), UART_C2_RE_SHIFT, UART_C2_RE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0b0 - Transmitter off.
 * - 0b1 - Transmitter on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TE field. */
#define UART_RD_C2_TE(base)  ((UART_C2_REG(base) & UART_C2_TE_MASK) >> UART_C2_TE_SHIFT)
#define UART_BRD_C2_TE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))

/*! @brief Set the TE field to a new value. */
#define UART_WR_C2_TE(base, value) (UART_RMW_C2(base, UART_C2_TE_MASK, UART_C2_TE(value)))
#define UART_BWR_C2_TE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TE_SHIFT), UART_C2_TE_SHIFT, UART_C2_TE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requests
 *
 * Values:
 * - 0b0 - IDLE interrupt requests disabled.
 * - 0b1 - IDLE interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_ILIE field. */
#define UART_RD_C2_ILIE(base) ((UART_C2_REG(base) & UART_C2_ILIE_MASK) >> UART_C2_ILIE_SHIFT)
#define UART_BRD_C2_ILIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))

/*! @brief Set the ILIE field to a new value. */
#define UART_WR_C2_ILIE(base, value) (UART_RMW_C2(base, UART_C2_ILIE_MASK, UART_C2_ILIE(value)))
#define UART_BWR_C2_ILIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_ILIE_SHIFT), UART_C2_ILIE_SHIFT, UART_C2_ILIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0b0 - RDRF interrupt and DMA transfer requests disabled.
 * - 0b1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RIE field. */
#define UART_RD_C2_RIE(base) ((UART_C2_REG(base) & UART_C2_RIE_MASK) >> UART_C2_RIE_SHIFT)
#define UART_BRD_C2_RIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))

/*! @brief Set the RIE field to a new value. */
#define UART_WR_C2_RIE(base, value) (UART_RMW_C2(base, UART_C2_RIE_MASK, UART_C2_RIE(value)))
#define UART_BWR_C2_RIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_RIE_SHIFT), UART_C2_RIE_SHIFT, UART_C2_RIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0b0 - TC interrupt requests disabled.
 * - 0b1 - TC interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TCIE field. */
#define UART_RD_C2_TCIE(base) ((UART_C2_REG(base) & UART_C2_TCIE_MASK) >> UART_C2_TCIE_SHIFT)
#define UART_BRD_C2_TCIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))

/*! @brief Set the TCIE field to a new value. */
#define UART_WR_C2_TCIE(base, value) (UART_RMW_C2(base, UART_C2_TCIE_MASK, UART_C2_TCIE(value)))
#define UART_BWR_C2_TCIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TCIE_SHIFT), UART_C2_TCIE_SHIFT, UART_C2_TCIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0b0 - TDRE interrupt and DMA transfer requests disabled.
 * - 0b1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TIE field. */
#define UART_RD_C2_TIE(base) ((UART_C2_REG(base) & UART_C2_TIE_MASK) >> UART_C2_TIE_SHIFT)
#define UART_BRD_C2_TIE(base) (BME_UBFX8(&UART_C2_REG(base), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))

/*! @brief Set the TIE field to a new value. */
#define UART_WR_C2_TIE(base, value) (UART_RMW_C2(base, UART_C2_TIE_MASK, UART_C2_TIE(value)))
#define UART_BWR_C2_TIE(base, value) (BME_BFI8(&UART_C2_REG(base), ((uint8_t)(value) << UART_C2_TIE_SHIFT), UART_C2_TIE_SHIFT, UART_C2_TIE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define UART_RD_S1(base)         (UART_S1_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D., S2[LBKDE] is
 * disabled, Within the receive buffer structure the received dataword is tagged
 * if it is received with a parity error. This information is available by reading
 * the ED register prior to reading the D register.
 *
 * Values:
 * - 0b0 - No parity error detected since the last time this flag was cleared.
 *     If the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 0b1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_PF field. */
#define UART_RD_S1_PF(base)  ((UART_S1_REG(base) & UART_S1_PF_MASK) >> UART_S1_PF_SHIFT)
#define UART_BRD_S1_PF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_PF_SHIFT, UART_S1_PF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. When BDH[SBNS] is set,
 * then FE will set when a logic 0 is accepted for either of the two stop bits.
 * FE does not set in the case of an overrun or while the LIN break detect feature
 * is enabled (S2[LBKDE] = 1). FE inhibits further data reception until it is
 * cleared. To clear FE, read S1 with FE set and then read D. The last data in the
 * receive buffer represents the data that was received with the frame error
 * enabled. Framing errors are not supported when 7816E is set/enabled. However, if
 * this flag is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0b0 - No framing error detected.
 * - 0b1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_FE field. */
#define UART_RD_S1_FE(base)  ((UART_S1_REG(base) & UART_S1_FE_MASK) >> UART_S1_FE_SHIFT)
#define UART_BRD_S1_FE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_FE_SHIFT, UART_S1_FE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it indicates only that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that there
 * is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read D.
 *
 * Values:
 * - 0b0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 0b1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_NF field. */
#define UART_RD_S1_NF(base)  ((UART_S1_REG(base) & UART_S1_NF_MASK) >> UART_S1_NF_SHIFT)
#define UART_BRD_S1_NF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_NF_SHIFT, UART_S1_NF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit.If
 * LBKDE is enabled and a LIN Break is detected, the OR field asserts if S2[LBKDIF]
 * is not cleared before the next data character is received. In 7816 mode, it is
 * possible to configure a NACK to be returned by programing C7816[ONACK].
 *
 * Values:
 * - 0b0 - No overrun has occurred since the last time the flag was cleared.
 * - 0b1 - Overrun has occurred or the overrun flag has not been cleared since
 *     the last overrun occured.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_OR field. */
#define UART_RD_S1_OR(base)  ((UART_S1_REG(base) & UART_S1_OR_MASK) >> UART_S1_OR_SHIFT)
#define UART_BRD_S1_OR(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_OR_SHIFT, UART_S1_OR_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set), or a LIN
 * break character must set the S2[LBKDIF] flag before an idle condition can set the
 * IDLE flag. To clear IDLE, read UART status S1 with IDLE set and then read D.
 * IDLE is set when either of the following appear on the receiver input: 10
 * consecutive logic 1s if C1[M] = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10]
 * = 0 12 consecutive logic 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle
 * detection is not supported when 7816E is set/enabled and hence this flag is
 * ignored. When RWU is set and WAKE is cleared, an idle line condition sets the IDLE
 * flag if RWUID is set, else the IDLE flag does not become set.
 *
 * Values:
 * - 0b0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 0b1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_IDLE field. */
#define UART_RD_S1_IDLE(base) ((UART_S1_REG(base) & UART_S1_IDLE_MASK) >> UART_S1_IDLE_SHIFT)
#define UART_BRD_S1_IDLE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_IDLE_SHIFT, UART_S1_IDLE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.RDRF is prevented from setting while S2[LBKDE] is set.
 * Additionally, when S2[LBKDE] is set, the received datawords are stored in the receive
 * buffer but over-write each other.
 *
 * Values:
 * - 0b0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 0b1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_RDRF field. */
#define UART_RD_S1_RDRF(base) ((UART_S1_REG(base) & UART_S1_RDRF_MASK) >> UART_S1_RDRF_SHIFT)
#define UART_BRD_S1_RDRF(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_RDRF_SHIFT, UART_S1_RDRF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0b0 - Transmitter active (sending data, a preamble, or a break).
 * - 0b1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TC field. */
#define UART_RD_S1_TC(base)  ((UART_S1_REG(base) & UART_S1_TC_MASK) >> UART_S1_TC_SHIFT)
#define UART_BRD_S1_TC(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TC_SHIFT, UART_S1_TC_WIDTH))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0b0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 0b1 - The amount of data in the transmit buffer is less than or equal to
 *     the value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TDRE field. */
#define UART_RD_S1_TDRE(base) ((UART_S1_REG(base) & UART_S1_TDRE_MASK) >> UART_S1_TDRE_SHIFT)
#define UART_BRD_S1_TDRE(base) (BME_UBFX8(&UART_S1_REG(base), UART_S1_TDRE_SHIFT, UART_S1_TDRE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define UART_RD_S2(base)         (UART_S2_REG(base))
#define UART_WR_S2(base, value)  (UART_S2_REG(base) = (value))
#define UART_RMW_S2(base, mask, value) (UART_WR_S2(base, (UART_RD_S2(base) & ~(mask)) | (value)))
#define UART_SET_S2(base, value) (BME_OR8(&UART_S2_REG(base), (uint8_t)(value)))
#define UART_CLR_S2(base, value) (BME_AND8(&UART_S2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_S2(base, value) (BME_XOR8(&UART_S2_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0b0 - UART receiver idle/inactive waiting for a start bit.
 * - 0b1 - UART receiver active, RxD input not idle.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RAF field. */
#define UART_RD_S2_RAF(base) ((UART_S2_REG(base) & UART_S2_RAF_MASK) >> UART_S2_RAF_SHIFT)
#define UART_BRD_S2_RAF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RAF_SHIFT, UART_S2_RAF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * Enables the LIN Break detection feature. While LBKDE is set, S1[RDRF],
 * S1[NF], S1[FE], and S1[PF] are prevented from setting. When LBKDE is set, see .
 * Overrun operation LBKDE must be cleared when C7816[ISO7816E] is set.
 *
 * Values:
 * - 0b0 - Break character detection is disabled.
 * - 0b1 - Break character is detected at length of 11 bit times if C1[M] = 0 or
 *     12 bits time if C1[M] = 1.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDE field. */
#define UART_RD_S2_LBKDE(base) ((UART_S2_REG(base) & UART_S2_LBKDE_MASK) >> UART_S2_LBKDE_SHIFT)
#define UART_BRD_S2_LBKDE(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT, UART_S2_LBKDE_WIDTH))

/*! @brief Set the LBKDE field to a new value. */
#define UART_WR_S2_LBKDE(base, value) (UART_RMW_S2(base, (UART_S2_LBKDE_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_LBKDE(value)))
#define UART_BWR_S2_LBKDE(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_LBKDE_SHIFT), UART_S2_LBKDE_SHIFT, UART_S2_LBKDE_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0b0 - Break character is 10, 11, or 12 bits long.
 * - 0b1 - Break character is 13 or 14 bits long.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_BRK13 field. */
#define UART_RD_S2_BRK13(base) ((UART_S2_REG(base) & UART_S2_BRK13_MASK) >> UART_S2_BRK13_SHIFT)
#define UART_BRD_S2_BRK13(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))

/*! @brief Set the BRK13 field to a new value. */
#define UART_WR_S2_BRK13(base, value) (UART_RMW_S2(base, (UART_S2_BRK13_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_BRK13(value)))
#define UART_BWR_S2_BRK13(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_BRK13_SHIFT), UART_S2_BRK13_SHIFT, UART_S2_BRK13_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0b0 - S1[IDLE] is not set upon detection of an idle character.
 * - 0b1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RWUID field. */
#define UART_RD_S2_RWUID(base) ((UART_S2_REG(base) & UART_S2_RWUID_MASK) >> UART_S2_RWUID_SHIFT)
#define UART_BRD_S2_RWUID(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))

/*! @brief Set the RWUID field to a new value. */
#define UART_WR_S2_RWUID(base, value) (UART_RMW_S2(base, (UART_S2_RWUID_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RWUID(value)))
#define UART_BWR_S2_RWUID(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RWUID_SHIFT), UART_S2_RWUID_SHIFT, UART_S2_RWUID_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity. A zero is represented by a short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This field is automatically set when C7816[INIT] and C7816[ISO7816E] are
 * enabled and an initial character is detected in T = 0 protocol mode. Setting
 * RXINV inverts the RxD input for data bits, start and stop bits, break, and
 * idle. When C7816[ISO7816E] is set/enabled, only the data bits and the parity bit
 * are inverted.
 *
 * Values:
 * - 0b0 - Receive data is not inverted.
 * - 0b1 - Receive data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXINV field. */
#define UART_RD_S2_RXINV(base) ((UART_S2_REG(base) & UART_S2_RXINV_MASK) >> UART_S2_RXINV_SHIFT)
#define UART_BRD_S2_RXINV(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))

/*! @brief Set the RXINV field to a new value. */
#define UART_WR_S2_RXINV(base, value) (UART_RMW_S2(base, (UART_S2_RXINV_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXINV(value)))
#define UART_BWR_S2_RXINV(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXINV_SHIFT), UART_S2_RXINV_SHIFT, UART_S2_RXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0b0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 0b1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit, depending on the setting of C1[M] and C1[PE]. Further,
 *     the first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
/*! @brief Read current value of the UART_S2_MSBF field. */
#define UART_RD_S2_MSBF(base) ((UART_S2_REG(base) & UART_S2_MSBF_MASK) >> UART_S2_MSBF_SHIFT)
#define UART_BRD_S2_MSBF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))

/*! @brief Set the MSBF field to a new value. */
#define UART_WR_S2_MSBF(base, value) (UART_RMW_S2(base, (UART_S2_MSBF_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_MSBF(value)))
#define UART_BWR_S2_MSBF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_MSBF_SHIFT), UART_S2_MSBF_SHIFT, UART_S2_MSBF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0b0 - No active edge on the receive pin has occurred.
 * - 0b1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define UART_RD_S2_RXEDGIF(base) ((UART_S2_REG(base) & UART_S2_RXEDGIF_MASK) >> UART_S2_RXEDGIF_SHIFT)
#define UART_BRD_S2_RXEDGIF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))

/*! @brief Set the RXEDGIF field to a new value. */
#define UART_WR_S2_RXEDGIF(base, value) (UART_RMW_S2(base, (UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXEDGIF(value)))
#define UART_BWR_S2_RXEDGIF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_RXEDGIF_SHIFT), UART_S2_RXEDGIF_SHIFT, UART_S2_RXEDGIF_WIDTH))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (W1C)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected on the
 * receiver input. The LIN break characters are 11 consecutive logic 0s if C1[M]
 * = 0 or 12 consecutive logic 0s if C1[M] = 1. LBKDIF is set after receiving the
 * last LIN break character. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0b0 - No LIN break character detected.
 * - 0b1 - LIN break character detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define UART_RD_S2_LBKDIF(base) ((UART_S2_REG(base) & UART_S2_LBKDIF_MASK) >> UART_S2_LBKDIF_SHIFT)
#define UART_BRD_S2_LBKDIF(base) (BME_UBFX8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT, UART_S2_LBKDIF_WIDTH))

/*! @brief Set the LBKDIF field to a new value. */
#define UART_WR_S2_LBKDIF(base, value) (UART_RMW_S2(base, (UART_S2_LBKDIF_MASK | UART_S2_RXEDGIF_MASK), UART_S2_LBKDIF(value)))
#define UART_BWR_S2_LBKDIF(base, value) (BME_BFI8(&UART_S2_REG(base), ((uint8_t)(value) << UART_S2_LBKDIF_SHIFT), UART_S2_LBKDIF_SHIFT, UART_S2_LBKDIF_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define UART_RD_C3(base)         (UART_C3_REG(base))
#define UART_WR_C3(base, value)  (UART_C3_REG(base) = (value))
#define UART_RMW_C3(base, mask, value) (UART_WR_C3(base, (UART_RD_C3(base) & ~(mask)) | (value)))
#define UART_SET_C3(base, value) (BME_OR8(&UART_C3_REG(base), (uint8_t)(value)))
#define UART_CLR_C3(base, value) (BME_AND8(&UART_C3_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C3(base, value) (BME_XOR8(&UART_C3_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - PF interrupt requests are disabled.
 * - 0b1 - PF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_PEIE field. */
#define UART_RD_C3_PEIE(base) ((UART_C3_REG(base) & UART_C3_PEIE_MASK) >> UART_C3_PEIE_SHIFT)
#define UART_BRD_C3_PEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))

/*! @brief Set the PEIE field to a new value. */
#define UART_WR_C3_PEIE(base, value) (UART_RMW_C3(base, UART_C3_PEIE_MASK, UART_C3_PEIE(value)))
#define UART_BWR_C3_PEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_PEIE_SHIFT), UART_C3_PEIE_SHIFT, UART_C3_PEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - FE interrupt requests are disabled.
 * - 0b1 - FE interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_FEIE field. */
#define UART_RD_C3_FEIE(base) ((UART_C3_REG(base) & UART_C3_FEIE_MASK) >> UART_C3_FEIE_SHIFT)
#define UART_BRD_C3_FEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))

/*! @brief Set the FEIE field to a new value. */
#define UART_WR_C3_FEIE(base, value) (UART_RMW_C3(base, UART_C3_FEIE_MASK, UART_C3_FEIE(value)))
#define UART_BWR_C3_FEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_FEIE_SHIFT), UART_C3_FEIE_SHIFT, UART_C3_FEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - NF interrupt requests are disabled.
 * - 0b1 - NF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_NEIE field. */
#define UART_RD_C3_NEIE(base) ((UART_C3_REG(base) & UART_C3_NEIE_MASK) >> UART_C3_NEIE_SHIFT)
#define UART_BRD_C3_NEIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))

/*! @brief Set the NEIE field to a new value. */
#define UART_WR_C3_NEIE(base, value) (UART_RMW_C3(base, UART_C3_NEIE_MASK, UART_C3_NEIE(value)))
#define UART_BWR_C3_NEIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_NEIE_SHIFT), UART_C3_NEIE_SHIFT, UART_C3_NEIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0b0 - OR interrupts are disabled.
 * - 0b1 - OR interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_ORIE field. */
#define UART_RD_C3_ORIE(base) ((UART_C3_REG(base) & UART_C3_ORIE_MASK) >> UART_C3_ORIE_SHIFT)
#define UART_BRD_C3_ORIE(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))

/*! @brief Set the ORIE field to a new value. */
#define UART_WR_C3_ORIE(base, value) (UART_RMW_C3(base, UART_C3_ORIE_MASK, UART_C3_ORIE(value)))
#define UART_BWR_C3_ORIE(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_ORIE_SHIFT), UART_C3_ORIE_SHIFT, UART_C3_ORIE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. In IrDA format,
 * a zero is represented by short high pulse in the middle of a bit time
 * remaining idle low for a one for normal polarity, and a zero is represented by short
 * low pulse in the middle of a bit time remaining idle high for a one for
 * inverted polarity. This field is automatically set when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected in T = 0 protocol mode.
 * Setting TXINV inverts all transmitted values, including idle, break, start, and
 * stop bits. In loop mode, if TXINV is set, the receiver gets the transmit
 * inversion bit when RXINV is disabled. When C7816[ISO7816E] is set/enabled then only
 * the transmitted data bits and parity bit are inverted.
 *
 * Values:
 * - 0b0 - Transmit data is not inverted.
 * - 0b1 - Transmit data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXINV field. */
#define UART_RD_C3_TXINV(base) ((UART_C3_REG(base) & UART_C3_TXINV_MASK) >> UART_C3_TXINV_SHIFT)
#define UART_BRD_C3_TXINV(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))

/*! @brief Set the TXINV field to a new value. */
#define UART_WR_C3_TXINV(base, value) (UART_RMW_C3(base, UART_C3_TXINV_MASK, UART_C3_TXINV(value)))
#define UART_BWR_C3_TXINV(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXINV_SHIFT), UART_C3_TXINV_SHIFT, UART_C3_TXINV_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0b0 - TXD pin is an input in single wire mode.
 * - 0b1 - TXD pin is an output in single wire mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXDIR field. */
#define UART_RD_C3_TXDIR(base) ((UART_C3_REG(base) & UART_C3_TXDIR_MASK) >> UART_C3_TXDIR_SHIFT)
#define UART_BRD_C3_TXDIR(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))

/*! @brief Set the TXDIR field to a new value. */
#define UART_WR_C3_TXDIR(base, value) (UART_RMW_C3(base, UART_C3_TXDIR_MASK, UART_C3_TXDIR(value)))
#define UART_BWR_C3_TXDIR(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_TXDIR_SHIFT), UART_C3_TXDIR_SHIFT, UART_C3_TXDIR_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_T8 field. */
#define UART_RD_C3_T8(base)  ((UART_C3_REG(base) & UART_C3_T8_MASK) >> UART_C3_T8_SHIFT)
#define UART_BRD_C3_T8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))

/*! @brief Set the T8 field to a new value. */
#define UART_WR_C3_T8(base, value) (UART_RMW_C3(base, UART_C3_T8_MASK, UART_C3_T8(value)))
#define UART_BWR_C3_T8(base, value) (BME_BFI8(&UART_C3_REG(base), ((uint8_t)(value) << UART_C3_T8_SHIFT), UART_C3_T8_SHIFT, UART_C3_T8_WIDTH))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_R8 field. */
#define UART_RD_C3_R8(base)  ((UART_C3_REG(base) & UART_C3_R8_MASK) >> UART_C3_R8_SHIFT)
#define UART_BRD_C3_R8(base) (BME_UBFX8(&UART_C3_REG(base), UART_C3_R8_SHIFT, UART_C3_R8_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define UART_RD_D(base)          (UART_D_REG(base))
#define UART_WR_D(base, value)   (UART_D_REG(base) = (value))
#define UART_RMW_D(base, mask, value) (UART_WR_D(base, (UART_RD_D(base) & ~(mask)) | (value)))
#define UART_SET_D(base, value)  (BME_OR8(&UART_D_REG(base), (uint8_t)(value)))
#define UART_CLR_D(base, value)  (BME_AND8(&UART_D_REG(base), (uint8_t)(~(value))))
#define UART_TOG_D(base, value)  (BME_XOR8(&UART_D_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define UART_RD_MA1(base)        (UART_MA1_REG(base))
#define UART_WR_MA1(base, value) (UART_MA1_REG(base) = (value))
#define UART_RMW_MA1(base, mask, value) (UART_WR_MA1(base, (UART_RD_MA1(base) & ~(mask)) | (value)))
#define UART_SET_MA1(base, value) (BME_OR8(&UART_MA1_REG(base), (uint8_t)(value)))
#define UART_CLR_MA1(base, value) (BME_AND8(&UART_MA1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA1(base, value) (BME_XOR8(&UART_MA1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define UART_RD_MA2(base)        (UART_MA2_REG(base))
#define UART_WR_MA2(base, value) (UART_MA2_REG(base) = (value))
#define UART_RMW_MA2(base, mask, value) (UART_WR_MA2(base, (UART_RD_MA2(base) & ~(mask)) | (value)))
#define UART_SET_MA2(base, value) (BME_OR8(&UART_MA2_REG(base), (uint8_t)(value)))
#define UART_CLR_MA2(base, value) (BME_AND8(&UART_MA2_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MA2(base, value) (BME_XOR8(&UART_MA2_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define UART_RD_C4(base)         (UART_C4_REG(base))
#define UART_WR_C4(base, value)  (UART_C4_REG(base) = (value))
#define UART_RMW_C4(base, mask, value) (UART_WR_C4(base, (UART_RD_C4(base) & ~(mask)) | (value)))
#define UART_SET_C4(base, value) (BME_OR8(&UART_C4_REG(base), (uint8_t)(value)))
#define UART_CLR_C4(base, value) (BME_AND8(&UART_C4_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C4(base, value) (BME_XOR8(&UART_C4_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_BRFA field. */
#define UART_RD_C4_BRFA(base) ((UART_C4_REG(base) & UART_C4_BRFA_MASK) >> UART_C4_BRFA_SHIFT)
#define UART_BRD_C4_BRFA(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))

/*! @brief Set the BRFA field to a new value. */
#define UART_WR_C4_BRFA(base, value) (UART_RMW_C4(base, UART_C4_BRFA_MASK, UART_C4_BRFA(value)))
#define UART_BWR_C4_BRFA(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_BRFA_SHIFT), UART_C4_BRFA_SHIFT, UART_C4_BRFA_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. The M10 field
 * does not affect the LIN send or detect break behavior. If M10 is set, then both
 * C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more information.
 *
 * Values:
 * - 0b0 - The parity bit is the ninth bit in the serial transmission.
 * - 0b1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_M10 field. */
#define UART_RD_C4_M10(base) ((UART_C4_REG(base) & UART_C4_M10_MASK) >> UART_C4_M10_SHIFT)
#define UART_BRD_C4_M10(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))

/*! @brief Set the M10 field to a new value. */
#define UART_WR_C4_M10(base, value) (UART_RMW_C4(base, UART_C4_M10_MASK, UART_C4_M10(value)))
#define UART_BWR_C4_M10(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_M10_SHIFT), UART_C4_M10_SHIFT, UART_C4_M10_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0b0 - All data received is transferred to the data buffer if MAEN1 is
 *     cleared.
 * - 0b1 - All data received with the most significant bit cleared, is
 *     discarded. All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define UART_RD_C4_MAEN2(base) ((UART_C4_REG(base) & UART_C4_MAEN2_MASK) >> UART_C4_MAEN2_SHIFT)
#define UART_BRD_C4_MAEN2(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))

/*! @brief Set the MAEN2 field to a new value. */
#define UART_WR_C4_MAEN2(base, value) (UART_RMW_C4(base, UART_C4_MAEN2_MASK, UART_C4_MAEN2(value)))
#define UART_BWR_C4_MAEN2(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN2_SHIFT), UART_C4_MAEN2_SHIFT, UART_C4_MAEN2_WIDTH))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0b0 - All data received is transferred to the data buffer if MAEN2 is
 *     cleared.
 * - 0b1 - All data received with the most significant bit cleared, is
 *     discarded. All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define UART_RD_C4_MAEN1(base) ((UART_C4_REG(base) & UART_C4_MAEN1_MASK) >> UART_C4_MAEN1_SHIFT)
#define UART_BRD_C4_MAEN1(base) (BME_UBFX8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))

/*! @brief Set the MAEN1 field to a new value. */
#define UART_WR_C4_MAEN1(base, value) (UART_RMW_C4(base, UART_C4_MAEN1_MASK, UART_C4_MAEN1(value)))
#define UART_BWR_C4_MAEN1(base, value) (BME_BFI8(&UART_C4_REG(base), ((uint8_t)(value) << UART_C4_MAEN1_SHIFT), UART_C4_MAEN1_SHIFT, UART_C4_MAEN1_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define UART_RD_C5(base)         (UART_C5_REG(base))
#define UART_WR_C5(base, value)  (UART_C5_REG(base) = (value))
#define UART_RMW_C5(base, mask, value) (UART_WR_C5(base, (UART_RD_C5(base) & ~(mask)) | (value)))
#define UART_SET_C5(base, value) (BME_OR8(&UART_C5_REG(base), (uint8_t)(value)))
#define UART_CLR_C5(base, value) (BME_AND8(&UART_C5_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C5(base, value) (BME_XOR8(&UART_C5_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field LBKDDMAS[3] (RW)
 *
 * Configures the LIN break detect flag, S2[LBKDIF], to generate interrupt or
 * DMA requests if BDH[LBKDIE] is set. If BDH[LBKDIE] is cleared, and S2[LBKDIF] is
 * set, the LBKDIF DMA and LBKDIF interrupt signals are not asserted, regardless
 * of the state of LBKDDMAS.
 *
 * Values:
 * - 0b0 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF interrupt signal is
 *     asserted to request an interrupt service.
 * - 0b1 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF DMA request signal
 *     is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_LBKDDMAS field. */
#define UART_RD_C5_LBKDDMAS(base) ((UART_C5_REG(base) & UART_C5_LBKDDMAS_MASK) >> UART_C5_LBKDDMAS_SHIFT)
#define UART_BRD_C5_LBKDDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_LBKDDMAS_SHIFT, UART_C5_LBKDDMAS_WIDTH))

/*! @brief Set the LBKDDMAS field to a new value. */
#define UART_WR_C5_LBKDDMAS(base, value) (UART_RMW_C5(base, UART_C5_LBKDDMAS_MASK, UART_C5_LBKDDMAS(value)))
#define UART_BWR_C5_LBKDDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_LBKDDMAS_SHIFT), UART_C5_LBKDDMAS_SHIFT, UART_C5_LBKDDMAS_WIDTH))
/*@}*/

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0b0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 0b1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_RDMAS field. */
#define UART_RD_C5_RDMAS(base) ((UART_C5_REG(base) & UART_C5_RDMAS_MASK) >> UART_C5_RDMAS_SHIFT)
#define UART_BRD_C5_RDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))

/*! @brief Set the RDMAS field to a new value. */
#define UART_WR_C5_RDMAS(base, value) (UART_RMW_C5(base, UART_C5_RDMAS_MASK, UART_C5_RDMAS(value)))
#define UART_BWR_C5_RDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_RDMAS_SHIFT), UART_C5_RDMAS_SHIFT, UART_C5_RDMAS_WIDTH))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0b0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 0b1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_TDMAS field. */
#define UART_RD_C5_TDMAS(base) ((UART_C5_REG(base) & UART_C5_TDMAS_MASK) >> UART_C5_TDMAS_SHIFT)
#define UART_BRD_C5_TDMAS(base) (BME_UBFX8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))

/*! @brief Set the TDMAS field to a new value. */
#define UART_WR_C5_TDMAS(base, value) (UART_RMW_C5(base, UART_C5_TDMAS_MASK, UART_C5_TDMAS(value)))
#define UART_BWR_C5_TDMAS(base, value) (BME_BFI8(&UART_C5_REG(base), ((uint8_t)(value) << UART_C5_TDMAS_SHIFT), UART_C5_TDMAS_SHIFT, UART_C5_TDMAS_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but contains valid data
 * only if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with the
 * application, and in some cases maybe completely optional. These fields automatically
 * update to reflect the conditions of the next dataword whenever D is read. If
 * S1[NF] and S1[PF] have not been set since the last time the receive buffer was
 * empty, the NOISY and PARITYE fields will be zero.
 */
/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define UART_RD_ED(base)         (UART_ED_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0b0 - The dataword was received without a parity error.
 * - 0b1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_PARITYE field. */
#define UART_RD_ED_PARITYE(base) ((UART_ED_REG(base) & UART_ED_PARITYE_MASK) >> UART_ED_PARITYE_SHIFT)
#define UART_BRD_ED_PARITYE(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_PARITYE_SHIFT, UART_ED_PARITYE_WIDTH))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0b0 - The dataword was received without noise.
 * - 0b1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_NOISY field. */
#define UART_RD_ED_NOISY(base) ((UART_ED_REG(base) & UART_ED_NOISY_MASK) >> UART_ED_NOISY_SHIFT)
#define UART_BRD_ED_NOISY(base) (BME_UBFX8(&UART_ED_REG(base), UART_ED_NOISY_SHIFT, UART_ED_NOISY_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE, and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not use the RTS and CTS signals.
 */
/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define UART_RD_MODEM(base)      (UART_MODEM_REG(base))
#define UART_WR_MODEM(base, value) (UART_MODEM_REG(base) = (value))
#define UART_RMW_MODEM(base, mask, value) (UART_WR_MODEM(base, (UART_RD_MODEM(base) & ~(mask)) | (value)))
#define UART_SET_MODEM(base, value) (BME_OR8(&UART_MODEM_REG(base), (uint8_t)(value)))
#define UART_CLR_MODEM(base, value) (BME_AND8(&UART_MODEM_REG(base), (uint8_t)(~(value))))
#define UART_TOG_MODEM(base, value) (BME_XOR8(&UART_MODEM_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0b0 - CTS has no effect on the transmitter.
 * - 0b1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as
 *     a character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define UART_RD_MODEM_TXCTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXCTSE_MASK) >> UART_MODEM_TXCTSE_SHIFT)
#define UART_BRD_MODEM_TXCTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))

/*! @brief Set the TXCTSE field to a new value. */
#define UART_WR_MODEM_TXCTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXCTSE_MASK, UART_MODEM_TXCTSE(value)))
#define UART_BWR_MODEM_TXCTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXCTSE_SHIFT), UART_MODEM_TXCTSE_SHIFT, UART_MODEM_TXCTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0b0 - The transmitter has no effect on RTS.
 * - 0b1 - When a character is placed into an empty transmitter data buffer ,
 *     RTS asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit. (FIFO) Ensure
 *     that C2[TE] is asserted before assertion of this bit.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define UART_RD_MODEM_TXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSE_MASK) >> UART_MODEM_TXRTSE_SHIFT)
#define UART_BRD_MODEM_TXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))

/*! @brief Set the TXRTSE field to a new value. */
#define UART_WR_MODEM_TXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSE_MASK, UART_MODEM_TXRTSE(value)))
#define UART_BWR_MODEM_TXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSE_SHIFT), UART_MODEM_TXRTSE_SHIFT, UART_MODEM_TXRTSE_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0b0 - Transmitter RTS is active low.
 * - 0b1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define UART_RD_MODEM_TXRTSPOL(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSPOL_MASK) >> UART_MODEM_TXRTSPOL_SHIFT)
#define UART_BRD_MODEM_TXRTSPOL(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))

/*! @brief Set the TXRTSPOL field to a new value. */
#define UART_WR_MODEM_TXRTSPOL(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSPOL_MASK, UART_MODEM_TXRTSPOL(value)))
#define UART_BWR_MODEM_TXRTSPOL(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_TXRTSPOL_SHIFT), UART_MODEM_TXRTSPOL_SHIFT, UART_MODEM_TXRTSPOL_WIDTH))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0b0 - The receiver has no effect on RTS.
 * - 0b1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is
 *     less than RWFIFO[RXWATER]. See Hardware flow control
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define UART_RD_MODEM_RXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_RXRTSE_MASK) >> UART_MODEM_RXRTSE_SHIFT)
#define UART_BRD_MODEM_RXRTSE(base) (BME_UBFX8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))

/*! @brief Set the RXRTSE field to a new value. */
#define UART_WR_MODEM_RXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_RXRTSE_MASK, UART_MODEM_RXRTSE(value)))
#define UART_BWR_MODEM_RXRTSE(base, value) (BME_BFI8(&UART_MODEM_REG(base), ((uint8_t)(value) << UART_MODEM_RXRTSE_SHIFT), UART_MODEM_RXRTSE_SHIFT, UART_MODEM_RXRTSE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_IR - UART Infrared Register
 ******************************************************************************/

/*!
 * @brief UART_IR - UART Infrared Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IR register controls options for setting the infrared configuration.
 */
/*!
 * @name Constants and macros for entire UART_IR register
 */
/*@{*/
#define UART_RD_IR(base)         (UART_IR_REG(base))
#define UART_WR_IR(base, value)  (UART_IR_REG(base) = (value))
#define UART_RMW_IR(base, mask, value) (UART_WR_IR(base, (UART_RD_IR(base) & ~(mask)) | (value)))
#define UART_SET_IR(base, value) (BME_OR8(&UART_IR_REG(base), (uint8_t)(value)))
#define UART_CLR_IR(base, value) (BME_AND8(&UART_IR_REG(base), (uint8_t)(~(value))))
#define UART_TOG_IR(base, value) (BME_XOR8(&UART_IR_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_IR bitfields
 */

/*!
 * @name Register UART_IR, field TNP[1:0] (RW)
 *
 * Enables whether the UART transmits a 1/16, 3/16, 1/32, or 1/4 narrow pulse.
 *
 * Values:
 * - 0b00 - 3/16.
 * - 0b01 - 1/16.
 * - 0b10 - 1/32.
 * - 0b11 - 1/4.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_TNP field. */
#define UART_RD_IR_TNP(base) ((UART_IR_REG(base) & UART_IR_TNP_MASK) >> UART_IR_TNP_SHIFT)
#define UART_BRD_IR_TNP(base) (BME_UBFX8(&UART_IR_REG(base), UART_IR_TNP_SHIFT, UART_IR_TNP_WIDTH))

/*! @brief Set the TNP field to a new value. */
#define UART_WR_IR_TNP(base, value) (UART_RMW_IR(base, UART_IR_TNP_MASK, UART_IR_TNP(value)))
#define UART_BWR_IR_TNP(base, value) (BME_BFI8(&UART_IR_REG(base), ((uint8_t)(value) << UART_IR_TNP_SHIFT), UART_IR_TNP_SHIFT, UART_IR_TNP_WIDTH))
/*@}*/

/*!
 * @name Register UART_IR, field IREN[2] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0b0 - IR disabled.
 * - 0b1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_IREN field. */
#define UART_RD_IR_IREN(base) ((UART_IR_REG(base) & UART_IR_IREN_MASK) >> UART_IR_IREN_SHIFT)
#define UART_BRD_IR_IREN(base) (BME_UBFX8(&UART_IR_REG(base), UART_IR_IREN_SHIFT, UART_IR_IREN_WIDTH))

/*! @brief Set the IREN field to a new value. */
#define UART_WR_IR_IREN(base, value) (UART_RMW_IR(base, UART_IR_IREN_MASK, UART_IR_IREN(value)))
#define UART_BWR_IR_IREN(base, value) (BME_BFI8(&UART_IR_REG(base), ((uint8_t)(value) << UART_IR_IREN_SHIFT), UART_IR_IREN_SHIFT, UART_IR_IREN_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when C2[RE] and C2[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define UART_RD_PFIFO(base)      (UART_PFIFO_REG(base))
#define UART_WR_PFIFO(base, value) (UART_PFIFO_REG(base) = (value))
#define UART_RMW_PFIFO(base, mask, value) (UART_WR_PFIFO(base, (UART_RD_PFIFO(base) & ~(mask)) | (value)))
#define UART_SET_PFIFO(base, value) (BME_OR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_PFIFO(base, value) (BME_AND8(&UART_PFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_PFIFO(base, value) (BME_XOR8(&UART_PFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 0b000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define UART_RD_PFIFO_RXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFIFOSIZE_MASK) >> UART_PFIFO_RXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_RXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFIFOSIZE_SHIFT, UART_PFIFO_RXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this field. Additionally, TXFLUSH and RXFLUSH
 * commands must be issued immediately after changing this field.
 *
 * Values:
 * - 0b0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 0b1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define UART_RD_PFIFO_RXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFE_MASK) >> UART_PFIFO_RXFE_SHIFT)
#define UART_BRD_PFIFO_RXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))

/*! @brief Set the RXFE field to a new value. */
#define UART_WR_PFIFO_RXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_RXFE_MASK, UART_PFIFO_RXFE(value)))
#define UART_BWR_PFIFO_RXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_RXFE_SHIFT), UART_PFIFO_RXFE_SHIFT, UART_PFIFO_RXFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 0b000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 0b001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 0b010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 0b011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 0b100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 0b101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 0b110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 0b111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define UART_RD_PFIFO_TXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFIFOSIZE_MASK) >> UART_PFIFO_TXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_TXFIFOSIZE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFIFOSIZE_SHIFT, UART_PFIFO_TXFIFOSIZE_WIDTH))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must be cleared
 * prior to changing this field. Additionally, TXFLUSH and RXFLUSH commands must
 * be issued immediately after changing this field.
 *
 * Values:
 * - 0b0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 0b1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define UART_RD_PFIFO_TXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFE_MASK) >> UART_PFIFO_TXFE_SHIFT)
#define UART_BRD_PFIFO_TXFE(base) (BME_UBFX8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))

/*! @brief Set the TXFE field to a new value. */
#define UART_WR_PFIFO_TXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_TXFE_MASK, UART_PFIFO_TXFE(value)))
#define UART_BWR_PFIFO_TXFE(base, value) (BME_BFI8(&UART_PFIFO_REG(base), ((uint8_t)(value) << UART_PFIFO_TXFE_SHIFT), UART_PFIFO_TXFE_SHIFT, UART_PFIFO_TXFE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control fields for FIFO
 * operation. This register may be read or written at any time. Note that
 * writing to TXFLUSH and RXFLUSH may result in data loss and requires careful action
 * to prevent unintended/unpredictable behavior. Therefore, it is recommended that
 * TE and RE be cleared prior to flushing the corresponding FIFO.
 */
/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define UART_RD_CFIFO(base)      (UART_CFIFO_REG(base))
#define UART_WR_CFIFO(base, value) (UART_CFIFO_REG(base) = (value))
#define UART_RMW_CFIFO(base, mask, value) (UART_WR_CFIFO(base, (UART_RD_CFIFO(base) & ~(mask)) | (value)))
#define UART_SET_CFIFO(base, value) (BME_OR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_CFIFO(base, value) (BME_AND8(&UART_CFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_CFIFO(base, value) (BME_XOR8(&UART_CFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - RXUF flag does not generate an interrupt to the host.
 * - 0b1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define UART_RD_CFIFO_RXUFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXUFE_MASK) >> UART_CFIFO_RXUFE_SHIFT)
#define UART_BRD_CFIFO_RXUFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))

/*! @brief Set the RXUFE field to a new value. */
#define UART_WR_CFIFO_RXUFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXUFE_MASK, UART_CFIFO_RXUFE(value)))
#define UART_BWR_CFIFO_RXUFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXUFE_SHIFT), UART_CFIFO_RXUFE_SHIFT, UART_CFIFO_RXUFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - TXOF flag does not generate an interrupt to the host.
 * - 0b1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define UART_RD_CFIFO_TXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_TXOFE_MASK) >> UART_CFIFO_TXOFE_SHIFT)
#define UART_BRD_CFIFO_TXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))

/*! @brief Set the TXOFE field to a new value. */
#define UART_WR_CFIFO_TXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXOFE_MASK, UART_CFIFO_TXOFE(value)))
#define UART_BWR_CFIFO_TXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXOFE_SHIFT), UART_CFIFO_TXOFE_SHIFT, UART_CFIFO_TXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXOFE[2] (RW)
 *
 * When this field is set, the RXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0b0 - RXOF flag does not generate an interrupt to the host.
 * - 0b1 - RXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXOFE field. */
#define UART_RD_CFIFO_RXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXOFE_MASK) >> UART_CFIFO_RXOFE_SHIFT)
#define UART_BRD_CFIFO_RXOFE(base) (BME_UBFX8(&UART_CFIFO_REG(base), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))

/*! @brief Set the RXOFE field to a new value. */
#define UART_WR_CFIFO_RXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXOFE_MASK, UART_CFIFO_RXOFE(value)))
#define UART_BWR_CFIFO_RXOFE(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXOFE_SHIFT), UART_CFIFO_RXOFE_SHIFT, UART_CFIFO_RXOFE_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define UART_WR_CFIFO_RXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXFLUSH_MASK, UART_CFIFO_RXFLUSH(value)))
#define UART_BWR_CFIFO_RXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_RXFLUSH_SHIFT), UART_CFIFO_RXFLUSH_SHIFT, UART_CFIFO_RXFLUSH_WIDTH))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0b0 - No flush operation occurs.
 * - 0b1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define UART_WR_CFIFO_TXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXFLUSH_MASK, UART_CFIFO_TXFLUSH(value)))
#define UART_BWR_CFIFO_TXFLUSH(base, value) (BME_BFI8(&UART_CFIFO_REG(base), ((uint8_t)(value) << UART_CFIFO_TXFLUSH_SHIFT), UART_CFIFO_TXFLUSH_SHIFT, UART_CFIFO_TXFLUSH_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides status information regarding the transmit and receiver
 * buffers/FIFOs, including interrupt information. This register may be written
 * to or read at any time.
 */
/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define UART_RD_SFIFO(base)      (UART_SFIFO_REG(base))
#define UART_WR_SFIFO(base, value) (UART_SFIFO_REG(base) = (value))
#define UART_RMW_SFIFO(base, mask, value) (UART_WR_SFIFO(base, (UART_RD_SFIFO(base) & ~(mask)) | (value)))
#define UART_SET_SFIFO(base, value) (BME_OR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_SFIFO(base, value) (BME_AND8(&UART_SFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_SFIFO(base, value) (BME_XOR8(&UART_SFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of CFIFO[RXUFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXUFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one receive buffer underflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define UART_RD_SFIFO_RXUF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXUF_MASK) >> UART_SFIFO_RXUF_SHIFT)
#define UART_BRD_SFIFO_RXUF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))

/*! @brief Set the RXUF field to a new value. */
#define UART_WR_SFIFO_RXUF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_RXUF(value)))
#define UART_BWR_SFIFO_RXUF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXUF_SHIFT), UART_SFIFO_RXUF_SHIFT, UART_SFIFO_RXUF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[TXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[TXOFE] is set. This
 * flag is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one transmit buffer overflow has occurred since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define UART_RD_SFIFO_TXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXOF_MASK) >> UART_SFIFO_TXOF_SHIFT)
#define UART_BRD_SFIFO_TXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))

/*! @brief Set the TXOF field to a new value. */
#define UART_WR_SFIFO_TXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_TXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_TXOF(value)))
#define UART_BWR_SFIFO_TXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_TXOF_SHIFT), UART_SFIFO_TXOF_SHIFT, UART_SFIFO_TXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXOF[2] (W1C)
 *
 * Indicates that more data has been written to the receive buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[RXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXOFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0b0 - No receive buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 0b1 - At least one receive buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXOF field. */
#define UART_RD_SFIFO_RXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXOF_MASK) >> UART_SFIFO_RXOF_SHIFT)
#define UART_BRD_SFIFO_RXOF(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))

/*! @brief Set the RXOF field to a new value. */
#define UART_WR_SFIFO_RXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK), UART_SFIFO_RXOF(value)))
#define UART_BWR_SFIFO_RXOF(base, value) (BME_BFI8(&UART_SFIFO_REG(base), ((uint8_t)(value) << UART_SFIFO_RXOF_SHIFT), UART_SFIFO_RXOF_SHIFT, UART_SFIFO_RXOF_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0b0 - Receive buffer is not empty.
 * - 0b1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define UART_RD_SFIFO_RXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXEMPT_MASK) >> UART_SFIFO_RXEMPT_SHIFT)
#define UART_BRD_SFIFO_RXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_RXEMPT_SHIFT, UART_SFIFO_RXEMPT_WIDTH))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0b0 - Transmit buffer is not empty.
 * - 0b1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define UART_RD_SFIFO_TXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXEMPT_MASK) >> UART_SFIFO_TXEMPT_SHIFT)
#define UART_BRD_SFIFO_TXEMPT(base) (BME_UBFX8(&UART_SFIFO_REG(base), UART_SFIFO_TXEMPT_SHIFT, UART_SFIFO_TXEMPT_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when C2[TE] is not set. Changing the value of the
 * watermark will not clear the S1[TDRE] flag.
 */
/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define UART_RD_TWFIFO(base)     (UART_TWFIFO_REG(base))
#define UART_WR_TWFIFO(base, value) (UART_TWFIFO_REG(base) = (value))
#define UART_RMW_TWFIFO(base, mask, value) (UART_WR_TWFIFO(base, (UART_RD_TWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_TWFIFO(base, value) (BME_OR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_TWFIFO(base, value) (BME_AND8(&UART_TWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_TWFIFO(base, value) (BME_XOR8(&UART_TWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define UART_RD_TCFIFO(base)     (UART_TCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of the need to remove data from the receiver FIFO/buffer. This register
 * may be read at any time but must be written only when C2[RE] is not asserted.
 * Changing the value in this register will not clear S1[RDRF].
 */
/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define UART_RD_RWFIFO(base)     (UART_RWFIFO_REG(base))
#define UART_WR_RWFIFO(base, value) (UART_RWFIFO_REG(base) = (value))
#define UART_RMW_RWFIFO(base, mask, value) (UART_WR_RWFIFO(base, (UART_RD_RWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_RWFIFO(base, value) (BME_OR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
#define UART_CLR_RWFIFO(base, value) (BME_AND8(&UART_RWFIFO_REG(base), (uint8_t)(~(value))))
#define UART_TOG_RWFIFO(base, value) (BME_XOR8(&UART_RWFIFO_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive FIFO/buffer. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define UART_RD_RCFIFO(base)     (UART_RCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define UART_RD_C7816(base)      (UART_C7816_REG(base))
#define UART_WR_C7816(base, value) (UART_C7816_REG(base) = (value))
#define UART_RMW_C7816(base, mask, value) (UART_WR_C7816(base, (UART_RD_C7816(base) & ~(mask)) | (value)))
#define UART_SET_C7816(base, value) (BME_OR8(&UART_C7816_REG(base), (uint8_t)(value)))
#define UART_CLR_C7816(base, value) (BME_AND8(&UART_C7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_C7816(base, value) (BME_XOR8(&UART_C7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0b0 - ISO-7816 functionality is turned off/not enabled.
 * - 0b1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define UART_RD_C7816_ISO_7816E(base) ((UART_C7816_REG(base) & UART_C7816_ISO_7816E_MASK) >> UART_C7816_ISO_7816E_SHIFT)
#define UART_BRD_C7816_ISO_7816E(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT, UART_C7816_ISO_7816E_WIDTH))

/*! @brief Set the ISO_7816E field to a new value. */
#define UART_WR_C7816_ISO_7816E(base, value) (UART_RMW_C7816(base, UART_C7816_ISO_7816E_MASK, UART_C7816_ISO_7816E(value)))
#define UART_BWR_C7816_ISO_7816E(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ISO_7816E_SHIFT), UART_C7816_ISO_7816E_SHIFT, UART_C7816_ISO_7816E_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0b0 - T = 0 per the ISO-7816 specification.
 * - 0b1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define UART_RD_C7816_TTYPE(base) ((UART_C7816_REG(base) & UART_C7816_TTYPE_MASK) >> UART_C7816_TTYPE_SHIFT)
#define UART_BRD_C7816_TTYPE(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT, UART_C7816_TTYPE_WIDTH))

/*! @brief Set the TTYPE field to a new value. */
#define UART_WR_C7816_TTYPE(base, value) (UART_RMW_C7816(base, UART_C7816_TTYPE_MASK, UART_C7816_TTYPE(value)))
#define UART_BWR_C7816_TTYPE(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_TTYPE_SHIFT), UART_C7816_TTYPE_SHIFT, UART_C7816_TTYPE_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[ADT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detecting a
 * valid initial character, the configuration values S2[MSBF], C3[TXINV], and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character, IS7816[INITD] is set and an
 * interrupt issued as programmed by IE7816[INITDE]. When a valid initial
 * character is detected, INIT is automatically cleared. This Initial Character Detect
 * feature is supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0b0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 0b1 - Receiver searches for initial character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_INIT field. */
#define UART_RD_C7816_INIT(base) ((UART_C7816_REG(base) & UART_C7816_INIT_MASK) >> UART_C7816_INIT_SHIFT)
#define UART_BRD_C7816_INIT(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT, UART_C7816_INIT_WIDTH))

/*! @brief Set the INIT field to a new value. */
#define UART_WR_C7816_INIT(base, value) (UART_RMW_C7816(base, UART_C7816_INIT_MASK, UART_C7816_INIT(value)))
#define UART_BWR_C7816_INIT(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_INIT_SHIFT), UART_C7816_INIT_SHIFT, UART_C7816_INIT_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0b0 - No NACK is automatically generated.
 * - 0b1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ANACK field. */
#define UART_RD_C7816_ANACK(base) ((UART_C7816_REG(base) & UART_C7816_ANACK_MASK) >> UART_C7816_ANACK_SHIFT)
#define UART_BRD_C7816_ANACK(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT, UART_C7816_ANACK_WIDTH))

/*! @brief Set the ANACK field to a new value. */
#define UART_WR_C7816_ANACK(base, value) (UART_RMW_C7816(base, UART_C7816_ANACK_MASK, UART_C7816_ANACK(value)))
#define UART_BWR_C7816_ANACK(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ANACK_SHIFT), UART_C7816_ANACK_SHIFT, UART_C7816_ANACK_WIDTH))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0b0 - The received data does not generate a NACK when the receipt of the
 *     data results in an overflow event.
 * - 0b1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ONACK field. */
#define UART_RD_C7816_ONACK(base) ((UART_C7816_REG(base) & UART_C7816_ONACK_MASK) >> UART_C7816_ONACK_SHIFT)
#define UART_BRD_C7816_ONACK(base) (BME_UBFX8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT, UART_C7816_ONACK_WIDTH))

/*! @brief Set the ONACK field to a new value. */
#define UART_WR_C7816_ONACK(base, value) (UART_RMW_C7816(base, UART_C7816_ONACK_MASK, UART_C7816_ONACK(value)))
#define UART_BWR_C7816_ONACK(base, value) (BME_BFI8(&UART_C7816_REG(base), ((uint8_t)(value) << UART_C7816_ONACK_SHIFT), UART_C7816_ONACK_SHIFT, UART_C7816_ONACK_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define UART_RD_IE7816(base)     (UART_IE7816_REG(base))
#define UART_WR_IE7816(base, value) (UART_IE7816_REG(base) = (value))
#define UART_RMW_IE7816(base, mask, value) (UART_WR_IE7816(base, (UART_RD_IE7816(base) & ~(mask)) | (value)))
#define UART_SET_IE7816(base, value) (BME_OR8(&UART_IE7816_REG(base), (uint8_t)(value)))
#define UART_CLR_IE7816(base, value) (BME_AND8(&UART_IE7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_IE7816(base, value) (BME_XOR8(&UART_IE7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[RXT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define UART_RD_IE7816_RXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_RXTE_MASK) >> UART_IE7816_RXTE_SHIFT)
#define UART_BRD_IE7816_RXTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT, UART_IE7816_RXTE_WIDTH))

/*! @brief Set the RXTE field to a new value. */
#define UART_WR_IE7816_RXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_RXTE_MASK, UART_IE7816_RXTE(value)))
#define UART_BWR_IE7816_RXTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_RXTE_SHIFT), UART_IE7816_RXTE_SHIFT, UART_IE7816_RXTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[TXT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define UART_RD_IE7816_TXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_TXTE_MASK) >> UART_IE7816_TXTE_SHIFT)
#define UART_BRD_IE7816_TXTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT, UART_IE7816_TXTE_WIDTH))

/*! @brief Set the TXTE field to a new value. */
#define UART_WR_IE7816_TXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_TXTE_MASK, UART_IE7816_TXTE(value)))
#define UART_BWR_IE7816_TXTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_TXTE_SHIFT), UART_IE7816_TXTE_SHIFT, UART_IE7816_TXTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[GTV] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define UART_RD_IE7816_GTVE(base) ((UART_IE7816_REG(base) & UART_IE7816_GTVE_MASK) >> UART_IE7816_GTVE_SHIFT)
#define UART_BRD_IE7816_GTVE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT, UART_IE7816_GTVE_WIDTH))

/*! @brief Set the GTVE field to a new value. */
#define UART_WR_IE7816_GTVE(base, value) (UART_RMW_IE7816(base, UART_IE7816_GTVE_MASK, UART_IE7816_GTVE(value)))
#define UART_BWR_IE7816_GTVE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_GTVE_SHIFT), UART_IE7816_GTVE_SHIFT, UART_IE7816_GTVE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field ADTE[3] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[ADT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[ADT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_ADTE field. */
#define UART_RD_IE7816_ADTE(base) ((UART_IE7816_REG(base) & UART_IE7816_ADTE_MASK) >> UART_IE7816_ADTE_SHIFT)
#define UART_BRD_IE7816_ADTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_ADTE_SHIFT, UART_IE7816_ADTE_WIDTH))

/*! @brief Set the ADTE field to a new value. */
#define UART_WR_IE7816_ADTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_ADTE_MASK, UART_IE7816_ADTE(value)))
#define UART_BWR_IE7816_ADTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_ADTE_SHIFT), UART_IE7816_ADTE_SHIFT, UART_IE7816_ADTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[INITD] does not result in the generation of
 *     an interrupt.
 * - 0b1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define UART_RD_IE7816_INITDE(base) ((UART_IE7816_REG(base) & UART_IE7816_INITDE_MASK) >> UART_IE7816_INITDE_SHIFT)
#define UART_BRD_IE7816_INITDE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT, UART_IE7816_INITDE_WIDTH))

/*! @brief Set the INITDE field to a new value. */
#define UART_WR_IE7816_INITDE(base, value) (UART_RMW_IE7816(base, UART_IE7816_INITDE_MASK, UART_IE7816_INITDE(value)))
#define UART_BWR_IE7816_INITDE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_INITDE_SHIFT), UART_IE7816_INITDE_SHIFT, UART_IE7816_INITDE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[BWT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define UART_RD_IE7816_BWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_BWTE_MASK) >> UART_IE7816_BWTE_SHIFT)
#define UART_BRD_IE7816_BWTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT, UART_IE7816_BWTE_WIDTH))

/*! @brief Set the BWTE field to a new value. */
#define UART_WR_IE7816_BWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_BWTE_MASK, UART_IE7816_BWTE(value)))
#define UART_BWR_IE7816_BWTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_BWTE_SHIFT), UART_IE7816_BWTE_SHIFT, UART_IE7816_BWTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[CWT] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define UART_RD_IE7816_CWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_CWTE_MASK) >> UART_IE7816_CWTE_SHIFT)
#define UART_BRD_IE7816_CWTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT, UART_IE7816_CWTE_WIDTH))

/*! @brief Set the CWTE field to a new value. */
#define UART_WR_IE7816_CWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_CWTE_MASK, UART_IE7816_CWTE(value)))
#define UART_BWR_IE7816_CWTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_CWTE_SHIFT), UART_IE7816_CWTE_SHIFT, UART_IE7816_CWTE_WIDTH))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0b0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 0b1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_WTE field. */
#define UART_RD_IE7816_WTE(base) ((UART_IE7816_REG(base) & UART_IE7816_WTE_MASK) >> UART_IE7816_WTE_SHIFT)
#define UART_BRD_IE7816_WTE(base) (BME_UBFX8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT, UART_IE7816_WTE_WIDTH))

/*! @brief Set the WTE field to a new value. */
#define UART_WR_IE7816_WTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_WTE_MASK, UART_IE7816_WTE(value)))
#define UART_BWR_IE7816_WTE(base, value) (BME_BFI8(&UART_IE7816_REG(base), ((uint8_t)(value) << UART_IE7816_WTE_SHIFT), UART_IE7816_WTE_SHIFT, UART_IE7816_WTE_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief UART_IS7816 - UART 7816 Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define UART_RD_IS7816(base)     (UART_IS7816_REG(base))
#define UART_WR_IS7816(base, value) (UART_IS7816_REG(base) = (value))
#define UART_RMW_IS7816(base, mask, value) (UART_WR_IS7816(base, (UART_RD_IS7816(base) & ~(mask)) | (value)))
#define UART_SET_IS7816(base, value) (BME_OR8(&UART_IS7816_REG(base), (uint8_t)(value)))
#define UART_CLR_IS7816(base, value) (BME_AND8(&UART_IS7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_IS7816(base, value) (BME_XOR8(&UART_IS7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - The number of consecutive NACKS generated as a result of parity
 *     errors and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 0b1 - The number of consecutive NACKS generated as a result of parity
 *     errors and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_RXT field. */
#define UART_RD_IS7816_RXT(base) ((UART_IS7816_REG(base) & UART_IS7816_RXT_MASK) >> UART_IS7816_RXT_SHIFT)
#define UART_BRD_IS7816_RXT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT, UART_IS7816_RXT_WIDTH))

/*! @brief Set the RXT field to a new value. */
#define UART_WR_IS7816_RXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_RXT(value)))
#define UART_BWR_IS7816_RXT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_RXT_SHIFT), UART_IS7816_RXT_SHIFT, UART_IS7816_RXT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - The number of retries and corresponding NACKS does not exceed the
 *     value in ET7816[TXTHRESHOLD].
 * - 0b1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_TXT field. */
#define UART_RD_IS7816_TXT(base) ((UART_IS7816_REG(base) & UART_IS7816_TXT_MASK) >> UART_IS7816_TXT_SHIFT)
#define UART_BRD_IS7816_TXT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT, UART_IS7816_TXT_WIDTH))

/*! @brief Set the TXT field to a new value. */
#define UART_WR_IS7816_TXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_TXT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_TXT(value)))
#define UART_BWR_IS7816_TXT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_TXT_SHIFT), UART_IS7816_TXT_SHIFT, UART_IS7816_TXT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 0b1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_GTV field. */
#define UART_RD_IS7816_GTV(base) ((UART_IS7816_REG(base) & UART_IS7816_GTV_MASK) >> UART_IS7816_GTV_SHIFT)
#define UART_BRD_IS7816_GTV(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT, UART_IS7816_GTV_WIDTH))

/*! @brief Set the GTV field to a new value. */
#define UART_WR_IS7816_GTV(base, value) (UART_RMW_IS7816(base, (UART_IS7816_GTV_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_GTV(value)))
#define UART_BWR_IS7816_GTV(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_GTV_SHIFT), UART_IS7816_GTV_SHIFT, UART_IS7816_GTV_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field ADT[3] (W1C)
 *
 * Indicates that the ATR duration time, the time between the leading edge of
 * the TS character being received and the leading edge of the next response
 * character, has exceeded the programmed value. This flag asserts only when
 * C7816[TTYPE] = 0. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - ATR Duration time (ADT) has not been violated.
 * - 0b1 - ATR Duration time (ADT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_ADT field. */
#define UART_RD_IS7816_ADT(base) ((UART_IS7816_REG(base) & UART_IS7816_ADT_MASK) >> UART_IS7816_ADT_SHIFT)
#define UART_BRD_IS7816_ADT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_ADT_SHIFT, UART_IS7816_ADT_WIDTH))

/*! @brief Set the ADT field to a new value. */
#define UART_WR_IS7816_ADT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_ADT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_ADT(value)))
#define UART_BWR_IS7816_ADT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_ADT_SHIFT), UART_IS7816_ADT_SHIFT, UART_IS7816_ADT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0b0 - A valid initial character has not been received.
 * - 0b1 - A valid initial character has been received.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_INITD field. */
#define UART_RD_IS7816_INITD(base) ((UART_IS7816_REG(base) & UART_IS7816_INITD_MASK) >> UART_IS7816_INITD_SHIFT)
#define UART_BRD_IS7816_INITD(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT, UART_IS7816_INITD_WIDTH))

/*! @brief Set the INITD field to a new value. */
#define UART_WR_IS7816_INITD(base, value) (UART_RMW_IS7816(base, (UART_IS7816_INITD_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_INITD(value)))
#define UART_BWR_IS7816_INITD(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_INITD_SHIFT), UART_IS7816_INITD_SHIFT, UART_IS7816_INITD_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - Block wait time (BWT) has not been violated.
 * - 0b1 - Block wait time (BWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_BWT field. */
#define UART_RD_IS7816_BWT(base) ((UART_IS7816_REG(base) & UART_IS7816_BWT_MASK) >> UART_IS7816_BWT_SHIFT)
#define UART_BRD_IS7816_BWT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT, UART_IS7816_BWT_WIDTH))

/*! @brief Set the BWT field to a new value. */
#define UART_WR_IS7816_BWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_BWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_BWT(value)))
#define UART_BWR_IS7816_BWT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_BWT_SHIFT), UART_IS7816_BWT_SHIFT, UART_IS7816_BWT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0b0 - Character wait time (CWT) has not been violated.
 * - 0b1 - Character wait time (CWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_CWT field. */
#define UART_RD_IS7816_CWT(base) ((UART_IS7816_REG(base) & UART_IS7816_CWT_MASK) >> UART_IS7816_CWT_SHIFT)
#define UART_BRD_IS7816_CWT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT, UART_IS7816_CWT_WIDTH))

/*! @brief Set the CWT field to a new value. */
#define UART_WR_IS7816_CWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_CWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_CWT(value)))
#define UART_BWR_IS7816_CWT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_CWT_SHIFT), UART_IS7816_CWT_SHIFT, UART_IS7816_CWT_WIDTH))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0b0 - Wait time (WT) has not been violated.
 * - 0b1 - Wait time (WT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_WT field. */
#define UART_RD_IS7816_WT(base) ((UART_IS7816_REG(base) & UART_IS7816_WT_MASK) >> UART_IS7816_WT_SHIFT)
#define UART_BRD_IS7816_WT(base) (BME_UBFX8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT, UART_IS7816_WT_WIDTH))

/*! @brief Set the WT field to a new value. */
#define UART_WR_IS7816_WT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_WT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK), UART_IS7816_WT(value)))
#define UART_BWR_IS7816_WT(base, value) (BME_BFI8(&UART_IS7816_REG(base), ((uint8_t)(value) << UART_IS7816_WT_SHIFT), UART_IS7816_WT_SHIFT, UART_IS7816_WT_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_WP7816 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WP7816 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816 register contains the WTX variable used in the generation of the
 * block wait timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816 register
 */
/*@{*/
#define UART_RD_WP7816(base)     (UART_WP7816_REG(base))
#define UART_WR_WP7816(base, value) (UART_WP7816_REG(base) = (value))
#define UART_RMW_WP7816(base, mask, value) (UART_WR_WP7816(base, (UART_RD_WP7816(base) & ~(mask)) | (value)))
#define UART_SET_WP7816(base, value) (BME_OR8(&UART_WP7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816(base, value) (BME_AND8(&UART_WP7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816(base, value) (BME_XOR8(&UART_WP7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define UART_RD_WN7816(base)     (UART_WN7816_REG(base))
#define UART_WR_WN7816(base, value) (UART_WN7816_REG(base) = (value))
#define UART_RMW_WN7816(base, mask, value) (UART_WR_WN7816(base, (UART_RD_WN7816(base) & ~(mask)) | (value)))
#define UART_SET_WN7816(base, value) (BME_OR8(&UART_WN7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WN7816(base, value) (BME_AND8(&UART_WN7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WN7816(base, value) (BME_XOR8(&UART_WN7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define UART_RD_WF7816(base)     (UART_WF7816_REG(base))
#define UART_WR_WF7816(base, value) (UART_WF7816_REG(base) = (value))
#define UART_RMW_WF7816(base, mask, value) (UART_WR_WF7816(base, (UART_RD_WF7816(base) & ~(mask)) | (value)))
#define UART_SET_WF7816(base, value) (BME_OR8(&UART_WF7816_REG(base), (uint8_t)(value)))
#define UART_CLR_WF7816(base, value) (BME_AND8(&UART_WF7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WF7816(base, value) (BME_XOR8(&UART_WF7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define UART_RD_ET7816(base)     (UART_ET7816_REG(base))
#define UART_WR_ET7816(base, value) (UART_ET7816_REG(base) = (value))
#define UART_RMW_ET7816(base, mask, value) (UART_WR_ET7816(base, (UART_RD_ET7816(base) & ~(mask)) | (value)))
#define UART_SET_ET7816(base, value) (BME_OR8(&UART_ET7816_REG(base), (uint8_t)(value)))
#define UART_CLR_ET7816(base, value) (BME_AND8(&UART_ET7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_ET7816(base, value) (BME_XOR8(&UART_ET7816_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define UART_RD_ET7816_RXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_RXTHRESHOLD_MASK) >> UART_ET7816_RXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_RXTHRESHOLD(base) (BME_UBFX8(&UART_ET7816_REG(base), UART_ET7816_RXTHRESHOLD_SHIFT, UART_ET7816_RXTHRESHOLD_WIDTH))

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_RXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_RXTHRESHOLD_MASK, UART_ET7816_RXTHRESHOLD(value)))
#define UART_BWR_ET7816_RXTHRESHOLD(base, value) (BME_BFI8(&UART_ET7816_REG(base), ((uint8_t)(value) << UART_ET7816_RXTHRESHOLD_SHIFT), UART_ET7816_RXTHRESHOLD_SHIFT, UART_ET7816_RXTHRESHOLD_WIDTH))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0b0000 - TXT asserts on the first NACK that is received.
 * - 0b0001 - TXT asserts on the second NACK that is received.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define UART_RD_ET7816_TXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_TXTHRESHOLD_MASK) >> UART_ET7816_TXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_TXTHRESHOLD(base) (BME_UBFX8(&UART_ET7816_REG(base), UART_ET7816_TXTHRESHOLD_SHIFT, UART_ET7816_TXTHRESHOLD_WIDTH))

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_TXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_TXTHRESHOLD_MASK, UART_ET7816_TXTHRESHOLD(value)))
#define UART_BWR_ET7816_TXTHRESHOLD(base, value) (BME_BFI8(&UART_ET7816_REG(base), ((uint8_t)(value) << UART_ET7816_TXTHRESHOLD_SHIFT), UART_ET7816_TXTHRESHOLD_SHIFT, UART_ET7816_TXTHRESHOLD_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define UART_RD_TL7816(base)     (UART_TL7816_REG(base))
#define UART_WR_TL7816(base, value) (UART_TL7816_REG(base) = (value))
#define UART_RMW_TL7816(base, mask, value) (UART_WR_TL7816(base, (UART_RD_TL7816(base) & ~(mask)) | (value)))
#define UART_SET_TL7816(base, value) (BME_OR8(&UART_TL7816_REG(base), (uint8_t)(value)))
#define UART_CLR_TL7816(base, value) (BME_AND8(&UART_TL7816_REG(base), (uint8_t)(~(value))))
#define UART_TOG_TL7816(base, value) (BME_XOR8(&UART_TL7816_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 ******************************************************************************/

/*!
 * @brief UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816A_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816A_T0 register
 */
/*@{*/
#define UART_RD_AP7816A_T0(base) (UART_AP7816A_T0_REG(base))
#define UART_WR_AP7816A_T0(base, value) (UART_AP7816A_T0_REG(base) = (value))
#define UART_RMW_AP7816A_T0(base, mask, value) (UART_WR_AP7816A_T0(base, (UART_RD_AP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816A_T0(base, value) (BME_OR8(&UART_AP7816A_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_AP7816A_T0(base, value) (BME_AND8(&UART_AP7816A_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_AP7816A_T0(base, value) (BME_XOR8(&UART_AP7816A_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 ******************************************************************************/

/*!
 * @brief UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816B_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816B_T0 register
 */
/*@{*/
#define UART_RD_AP7816B_T0(base) (UART_AP7816B_T0_REG(base))
#define UART_WR_AP7816B_T0(base, value) (UART_AP7816B_T0_REG(base) = (value))
#define UART_RMW_AP7816B_T0(base, mask, value) (UART_WR_AP7816B_T0(base, (UART_RD_AP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816B_T0(base, value) (BME_OR8(&UART_AP7816B_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_AP7816B_T0(base, value) (BME_AND8(&UART_AP7816B_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_AP7816B_T0(base, value) (BME_XOR8(&UART_AP7816B_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T0 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T0 register
 */
/*@{*/
#define UART_RD_WP7816A_T0(base) (UART_WP7816A_T0_REG(base))
#define UART_WR_WP7816A_T0(base, value) (UART_WP7816A_T0_REG(base) = (value))
#define UART_RMW_WP7816A_T0(base, mask, value) (UART_WR_WP7816A_T0(base, (UART_RD_WP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T0(base, value) (BME_OR8(&UART_WP7816A_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816A_T0(base, value) (BME_AND8(&UART_WP7816A_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816A_T0(base, value) (BME_XOR8(&UART_WP7816A_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T1 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T1 register
 */
/*@{*/
#define UART_RD_WP7816A_T1(base) (UART_WP7816A_T1_REG(base))
#define UART_WR_WP7816A_T1(base, value) (UART_WP7816A_T1_REG(base) = (value))
#define UART_RMW_WP7816A_T1(base, mask, value) (UART_WR_WP7816A_T1(base, (UART_RD_WP7816A_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T1(base, value) (BME_OR8(&UART_WP7816A_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816A_T1(base, value) (BME_AND8(&UART_WP7816A_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816A_T1(base, value) (BME_XOR8(&UART_WP7816A_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T0 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T0 register
 */
/*@{*/
#define UART_RD_WP7816B_T0(base) (UART_WP7816B_T0_REG(base))
#define UART_WR_WP7816B_T0(base, value) (UART_WP7816B_T0_REG(base) = (value))
#define UART_RMW_WP7816B_T0(base, mask, value) (UART_WR_WP7816B_T0(base, (UART_RD_WP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T0(base, value) (BME_OR8(&UART_WP7816B_T0_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816B_T0(base, value) (BME_AND8(&UART_WP7816B_T0_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816B_T0(base, value) (BME_XOR8(&UART_WP7816B_T0_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T1 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T1 register
 */
/*@{*/
#define UART_RD_WP7816B_T1(base) (UART_WP7816B_T1_REG(base))
#define UART_WR_WP7816B_T1(base, value) (UART_WP7816B_T1_REG(base) = (value))
#define UART_RMW_WP7816B_T1(base, mask, value) (UART_WR_WP7816B_T1(base, (UART_RD_WP7816B_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T1(base, value) (BME_OR8(&UART_WP7816B_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816B_T1(base, value) (BME_AND8(&UART_WP7816B_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816B_T1(base, value) (BME_XOR8(&UART_WP7816B_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*******************************************************************************
 * UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register (RW)
 *
 * Reset value: 0x06U
 *
 * The WGP7816_T1 register contains constants used in the generation of various
 * wait and guard timer counters. This register may be read at any time. This
 * register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WGP7816_T1 register
 */
/*@{*/
#define UART_RD_WGP7816_T1(base) (UART_WGP7816_T1_REG(base))
#define UART_WR_WGP7816_T1(base, value) (UART_WGP7816_T1_REG(base) = (value))
#define UART_RMW_WGP7816_T1(base, mask, value) (UART_WR_WGP7816_T1(base, (UART_RD_WGP7816_T1(base) & ~(mask)) | (value)))
#define UART_SET_WGP7816_T1(base, value) (BME_OR8(&UART_WGP7816_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WGP7816_T1(base, value) (BME_AND8(&UART_WGP7816_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WGP7816_T1(base, value) (BME_XOR8(&UART_WGP7816_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_WGP7816_T1 bitfields
 */

/*!
 * @name Register UART_WGP7816_T1, field BGI[3:0] (RW)
 *
 * Used to calculate the value used for the BGT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_BGI field. */
#define UART_RD_WGP7816_T1_BGI(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_BGI_MASK) >> UART_WGP7816_T1_BGI_SHIFT)
#define UART_BRD_WGP7816_T1_BGI(base) (BME_UBFX8(&UART_WGP7816_T1_REG(base), UART_WGP7816_T1_BGI_SHIFT, UART_WGP7816_T1_BGI_WIDTH))

/*! @brief Set the BGI field to a new value. */
#define UART_WR_WGP7816_T1_BGI(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_BGI_MASK, UART_WGP7816_T1_BGI(value)))
#define UART_BWR_WGP7816_T1_BGI(base, value) (BME_BFI8(&UART_WGP7816_T1_REG(base), ((uint8_t)(value) << UART_WGP7816_T1_BGI_SHIFT), UART_WGP7816_T1_BGI_SHIFT, UART_WGP7816_T1_BGI_WIDTH))
/*@}*/

/*!
 * @name Register UART_WGP7816_T1, field CWI1[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_CWI1 field. */
#define UART_RD_WGP7816_T1_CWI1(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_CWI1_MASK) >> UART_WGP7816_T1_CWI1_SHIFT)
#define UART_BRD_WGP7816_T1_CWI1(base) (BME_UBFX8(&UART_WGP7816_T1_REG(base), UART_WGP7816_T1_CWI1_SHIFT, UART_WGP7816_T1_CWI1_WIDTH))

/*! @brief Set the CWI1 field to a new value. */
#define UART_WR_WGP7816_T1_CWI1(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_CWI1_MASK, UART_WGP7816_T1_CWI1(value)))
#define UART_BWR_WGP7816_T1_CWI1(base, value) (BME_BFI8(&UART_WGP7816_T1_REG(base), ((uint8_t)(value) << UART_WGP7816_T1_CWI1_SHIFT), UART_WGP7816_T1_CWI1_SHIFT, UART_WGP7816_T1_CWI1_WIDTH))
/*@}*/

/*******************************************************************************
 * UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 ******************************************************************************/

/*!
 * @brief UART_WP7816C_T1 - UART 7816 Wait Parameter Register C (RW)
 *
 * Reset value: 0x0BU
 *
 * The WP7816C_T1 register contains constants used in the generation of various
 * wait timer counters. This register may be read at any time. This register must
 * be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816C_T1 register
 */
/*@{*/
#define UART_RD_WP7816C_T1(base) (UART_WP7816C_T1_REG(base))
#define UART_WR_WP7816C_T1(base, value) (UART_WP7816C_T1_REG(base) = (value))
#define UART_RMW_WP7816C_T1(base, mask, value) (UART_WR_WP7816C_T1(base, (UART_RD_WP7816C_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816C_T1(base, value) (BME_OR8(&UART_WP7816C_T1_REG(base), (uint8_t)(value)))
#define UART_CLR_WP7816C_T1(base, value) (BME_AND8(&UART_WP7816C_T1_REG(base), (uint8_t)(~(value))))
#define UART_TOG_WP7816C_T1(base, value) (BME_XOR8(&UART_WP7816C_T1_REG(base), (uint8_t)(value)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816C_T1 bitfields
 */

/*!
 * @name Register UART_WP7816C_T1, field CWI2[4:0] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 31. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WP7816C_T1_CWI2 field. */
#define UART_RD_WP7816C_T1_CWI2(base) ((UART_WP7816C_T1_REG(base) & UART_WP7816C_T1_CWI2_MASK) >> UART_WP7816C_T1_CWI2_SHIFT)
#define UART_BRD_WP7816C_T1_CWI2(base) (BME_UBFX8(&UART_WP7816C_T1_REG(base), UART_WP7816C_T1_CWI2_SHIFT, UART_WP7816C_T1_CWI2_WIDTH))

/*! @brief Set the CWI2 field to a new value. */
#define UART_WR_WP7816C_T1_CWI2(base, value) (UART_RMW_WP7816C_T1(base, UART_WP7816C_T1_CWI2_MASK, UART_WP7816C_T1_CWI2(value)))
#define UART_BWR_WP7816C_T1_CWI2(base, value) (BME_BFI8(&UART_WP7816C_T1_REG(base), ((uint8_t)(value) << UART_WP7816C_T1_CWI2_SHIFT), UART_WP7816C_T1_CWI2_SHIFT, UART_WP7816C_T1_CWI2_WIDTH))
/*@}*/

/*
 * MKV58F24 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - WDOG_STCTRLH - Watchdog Status and Control Register High
 * - WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - WDOG_TOVALH - Watchdog Time-out Value Register High
 * - WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - WDOG_WINH - Watchdog Window Register High
 * - WDOG_WINL - Watchdog Window Register Low
 * - WDOG_REFRESH - Watchdog Refresh register
 * - WDOG_UNLOCK - Watchdog Unlock register
 * - WDOG_TMROUTH - Watchdog Timer Output Register High
 * - WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - WDOG_RSTCNT - Watchdog Reset Count register
 * - WDOG_PRESC - Watchdog Prescaler register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x01D3U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define WDOG_RD_STCTRLH(base)    (WDOG_STCTRLH_REG(base))
#define WDOG_WR_STCTRLH(base, value) (WDOG_STCTRLH_REG(base) = (value))
#define WDOG_RMW_STCTRLH(base, mask, value) (WDOG_WR_STCTRLH(base, (WDOG_RD_STCTRLH(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLH(base, value) (BME_OR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLH(base, value) (BME_AND16(&WDOG_STCTRLH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLH(base, value) (BME_XOR16(&WDOG_STCTRLH_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0b0 - WDOG is disabled.
 * - 0b1 - WDOG is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define WDOG_RD_STCTRLH_WDOGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WDOGEN_MASK) >> WDOG_STCTRLH_WDOGEN_SHIFT)
#define WDOG_BRD_STCTRLH_WDOGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))

/*! @brief Set the WDOGEN field to a new value. */
#define WDOG_WR_STCTRLH_WDOGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WDOGEN_MASK, WDOG_STCTRLH_WDOGEN(value)))
#define WDOG_BWR_STCTRLH_WDOGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WDOGEN_SHIFT), WDOG_STCTRLH_WDOGEN_SHIFT, WDOG_STCTRLH_WDOGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0b0 - WDOG clock sourced from LPO .
 * - 0b1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define WDOG_RD_STCTRLH_CLKSRC(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_CLKSRC_MASK) >> WDOG_STCTRLH_CLKSRC_SHIFT)
#define WDOG_BRD_STCTRLH_CLKSRC(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))

/*! @brief Set the CLKSRC field to a new value. */
#define WDOG_WR_STCTRLH_CLKSRC(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_CLKSRC_MASK, WDOG_STCTRLH_CLKSRC(value)))
#define WDOG_BWR_STCTRLH_CLKSRC(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_CLKSRC_SHIFT), WDOG_STCTRLH_CLKSRC_SHIFT, WDOG_STCTRLH_CLKSRC_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0b0 - WDOG time-out generates reset only.
 * - 0b1 - WDOG time-out initially generates an interrupt. After WCT, it
 *     generates a reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define WDOG_RD_STCTRLH_IRQRSTEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_IRQRSTEN_MASK) >> WDOG_STCTRLH_IRQRSTEN_SHIFT)
#define WDOG_BRD_STCTRLH_IRQRSTEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))

/*! @brief Set the IRQRSTEN field to a new value. */
#define WDOG_WR_STCTRLH_IRQRSTEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_IRQRSTEN_MASK, WDOG_STCTRLH_IRQRSTEN(value)))
#define WDOG_BWR_STCTRLH_IRQRSTEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_IRQRSTEN_SHIFT), WDOG_STCTRLH_IRQRSTEN_SHIFT, WDOG_STCTRLH_IRQRSTEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enables Windowing mode.
 *
 * Values:
 * - 0b0 - Windowing mode is disabled.
 * - 0b1 - Windowing mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define WDOG_RD_STCTRLH_WINEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WINEN_MASK) >> WDOG_STCTRLH_WINEN_SHIFT)
#define WDOG_BRD_STCTRLH_WINEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))

/*! @brief Set the WINEN field to a new value. */
#define WDOG_WR_STCTRLH_WINEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WINEN_MASK, WDOG_STCTRLH_WINEN(value)))
#define WDOG_BWR_STCTRLH_WINEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WINEN_SHIFT), WDOG_STCTRLH_WINEN_SHIFT, WDOG_STCTRLH_WINEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write-once registers, after the reset-triggered
 * initial configuration window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0b0 - No further updates allowed to WDOG write-once registers.
 * - 0b1 - WDOG write-once registers can be unlocked for updating.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define WDOG_RD_STCTRLH_ALLOWUPDATE(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_ALLOWUPDATE_MASK) >> WDOG_STCTRLH_ALLOWUPDATE_SHIFT)
#define WDOG_BRD_STCTRLH_ALLOWUPDATE(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define WDOG_WR_STCTRLH_ALLOWUPDATE(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_ALLOWUPDATE_MASK, WDOG_STCTRLH_ALLOWUPDATE(value)))
#define WDOG_BWR_STCTRLH_ALLOWUPDATE(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_ALLOWUPDATE_SHIFT), WDOG_STCTRLH_ALLOWUPDATE_SHIFT, WDOG_STCTRLH_ALLOWUPDATE_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0b0 - WDOG is disabled in CPU Debug mode.
 * - 0b1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define WDOG_RD_STCTRLH_DBGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DBGEN_MASK) >> WDOG_STCTRLH_DBGEN_SHIFT)
#define WDOG_BRD_STCTRLH_DBGEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))

/*! @brief Set the DBGEN field to a new value. */
#define WDOG_WR_STCTRLH_DBGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DBGEN_MASK, WDOG_STCTRLH_DBGEN(value)))
#define WDOG_BWR_STCTRLH_DBGEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DBGEN_SHIFT), WDOG_STCTRLH_DBGEN_SHIFT, WDOG_STCTRLH_DBGEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in Stop mode.
 *
 * Values:
 * - 0b0 - WDOG is disabled in CPU Stop mode.
 * - 0b1 - WDOG is enabled in CPU Stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define WDOG_RD_STCTRLH_STOPEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_STOPEN_MASK) >> WDOG_STCTRLH_STOPEN_SHIFT)
#define WDOG_BRD_STCTRLH_STOPEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))

/*! @brief Set the STOPEN field to a new value. */
#define WDOG_WR_STCTRLH_STOPEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_STOPEN_MASK, WDOG_STCTRLH_STOPEN(value)))
#define WDOG_BWR_STCTRLH_STOPEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_STOPEN_SHIFT), WDOG_STCTRLH_STOPEN_SHIFT, WDOG_STCTRLH_STOPEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WAITEN[7] (RW)
 *
 * Enables or disables WDOG in Wait mode.
 *
 * Values:
 * - 0b0 - WDOG is disabled in CPU Wait mode.
 * - 0b1 - WDOG is enabled in CPU Wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WAITEN field. */
#define WDOG_RD_STCTRLH_WAITEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WAITEN_MASK) >> WDOG_STCTRLH_WAITEN_SHIFT)
#define WDOG_BRD_STCTRLH_WAITEN(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT, WDOG_STCTRLH_WAITEN_WIDTH))

/*! @brief Set the WAITEN field to a new value. */
#define WDOG_WR_STCTRLH_WAITEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WAITEN_MASK, WDOG_STCTRLH_WAITEN(value)))
#define WDOG_BWR_STCTRLH_WAITEN(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_WAITEN_SHIFT), WDOG_STCTRLH_WAITEN_SHIFT, WDOG_STCTRLH_WAITEN_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode, the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock
 * to the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define WDOG_RD_STCTRLH_TESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTWDOG_MASK) >> WDOG_STCTRLH_TESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_TESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))

/*! @brief Set the TESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_TESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTWDOG_MASK, WDOG_STCTRLH_TESTWDOG(value)))
#define WDOG_BWR_STCTRLH_TESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTWDOG_SHIFT), WDOG_STCTRLH_TESTWDOG_SHIFT, WDOG_STCTRLH_TESTWDOG_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Effective only if TESTWDOG is set. Selects the test to be run on the watchdog
 * timer.
 *
 * Values:
 * - 0b0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 0b1 - Byte test. Puts the timer in the byte test mode where individual
 *     bytes of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define WDOG_RD_STCTRLH_TESTSEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTSEL_MASK) >> WDOG_STCTRLH_TESTSEL_SHIFT)
#define WDOG_BRD_STCTRLH_TESTSEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))

/*! @brief Set the TESTSEL field to a new value. */
#define WDOG_WR_STCTRLH_TESTSEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTSEL_MASK, WDOG_STCTRLH_TESTSEL(value)))
#define WDOG_BWR_STCTRLH_TESTSEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_TESTSEL_SHIFT), WDOG_STCTRLH_TESTSEL_SHIFT, WDOG_STCTRLH_TESTSEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field selects the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 0b00 - Byte 0 selected
 * - 0b01 - Byte 1 selected
 * - 0b10 - Byte 2 selected
 * - 0b11 - Byte 3 selected
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define WDOG_RD_STCTRLH_BYTESEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_BYTESEL_MASK) >> WDOG_STCTRLH_BYTESEL_SHIFT)
#define WDOG_BRD_STCTRLH_BYTESEL(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))

/*! @brief Set the BYTESEL field to a new value. */
#define WDOG_WR_STCTRLH_BYTESEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_BYTESEL_MASK, WDOG_STCTRLH_BYTESEL(value)))
#define WDOG_BWR_STCTRLH_BYTESEL(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_BYTESEL_SHIFT), WDOG_STCTRLH_BYTESEL_SHIFT, WDOG_STCTRLH_BYTESEL_WIDTH))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. After it
 * is set, it can only be cleared by a reset. It cannot be unlocked for editing
 * after it is set.
 *
 * Values:
 * - 0b0 - WDOG functional test mode is not disabled.
 * - 0b1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define WDOG_RD_STCTRLH_DISTESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DISTESTWDOG_MASK) >> WDOG_STCTRLH_DISTESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_DISTESTWDOG(base) (BME_UBFX16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))

/*! @brief Set the DISTESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_DISTESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DISTESTWDOG_MASK, WDOG_STCTRLH_DISTESTWDOG(value)))
#define WDOG_BWR_STCTRLH_DISTESTWDOG(base, value) (BME_BFI16(&WDOG_STCTRLH_REG(base), ((uint16_t)(value) << WDOG_STCTRLH_DISTESTWDOG_SHIFT), WDOG_STCTRLH_DISTESTWDOG_SHIFT, WDOG_STCTRLH_DISTESTWDOG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define WDOG_RD_STCTRLL(base)    (WDOG_STCTRLL_REG(base))
#define WDOG_WR_STCTRLL(base, value) (WDOG_STCTRLL_REG(base) = (value))
#define WDOG_RMW_STCTRLL(base, mask, value) (WDOG_WR_STCTRLL(base, (WDOG_RD_STCTRLL(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLL(base, value) (BME_OR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_STCTRLL(base, value) (BME_AND16(&WDOG_STCTRLL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_STCTRLL(base, value) (BME_XOR16(&WDOG_STCTRLL_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT later. The interrupt can be cleared by writing 1 to this
 * bit. It also gets cleared on a system reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define WDOG_RD_STCTRLL_INTFLG(base) ((WDOG_STCTRLL_REG(base) & WDOG_STCTRLL_INTFLG_MASK) >> WDOG_STCTRLL_INTFLG_SHIFT)
#define WDOG_BRD_STCTRLL_INTFLG(base) (BME_UBFX16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))

/*! @brief Set the INTFLG field to a new value. */
#define WDOG_WR_STCTRLL_INTFLG(base, value) (WDOG_RMW_STCTRLL(base, WDOG_STCTRLL_INTFLG_MASK, WDOG_STCTRLL_INTFLG(value)))
#define WDOG_BWR_STCTRLL_INTFLG(base, value) (BME_BFI16(&WDOG_STCTRLL_REG(base), ((uint16_t)(value) << WDOG_STCTRLL_INTFLG_SHIFT), WDOG_STCTRLL_INTFLG_SHIFT, WDOG_STCTRLL_INTFLG_WIDTH))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define WDOG_RD_TOVALH(base)     (WDOG_TOVALH_REG(base))
#define WDOG_WR_TOVALH(base, value) (WDOG_TOVALH_REG(base) = (value))
#define WDOG_RMW_TOVALH(base, mask, value) (WDOG_WR_TOVALH(base, (WDOG_RD_TOVALH(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALH(base, value) (BME_OR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALH(base, value) (BME_AND16(&WDOG_TOVALH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALH(base, value) (BME_XOR16(&WDOG_TOVALH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B4CU
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define WDOG_RD_TOVALL(base)     (WDOG_TOVALL_REG(base))
#define WDOG_WR_TOVALL(base, value) (WDOG_TOVALL_REG(base) = (value))
#define WDOG_RMW_TOVALL(base, mask, value) (WDOG_WR_TOVALL(base, (WDOG_RD_TOVALL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALL(base, value) (BME_OR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TOVALL(base, value) (BME_AND16(&WDOG_TOVALL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TOVALL(base, value) (BME_XOR16(&WDOG_TOVALL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define WDOG_RD_WINH(base)       (WDOG_WINH_REG(base))
#define WDOG_WR_WINH(base, value) (WDOG_WINH_REG(base) = (value))
#define WDOG_RMW_WINH(base, mask, value) (WDOG_WR_WINH(base, (WDOG_RD_WINH(base) & ~(mask)) | (value)))
#define WDOG_SET_WINH(base, value) (BME_OR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINH(base, value) (BME_AND16(&WDOG_WINH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINH(base, value) (BME_XOR16(&WDOG_WINH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define WDOG_RD_WINL(base)       (WDOG_WINL_REG(base))
#define WDOG_WR_WINL(base, value) (WDOG_WINL_REG(base) = (value))
#define WDOG_RMW_WINL(base, mask, value) (WDOG_WR_WINL(base, (WDOG_RD_WINL(base) & ~(mask)) | (value)))
#define WDOG_SET_WINL(base, value) (BME_OR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_WINL(base, value) (BME_AND16(&WDOG_WINL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_WINL(base, value) (BME_XOR16(&WDOG_WINL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_REFRESH - Watchdog Refresh register
 ******************************************************************************/

/*!
 * @brief WDOG_REFRESH - Watchdog Refresh register (RW)
 *
 * Reset value: 0xB480U
 */
/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define WDOG_RD_REFRESH(base)    (WDOG_REFRESH_REG(base))
#define WDOG_WR_REFRESH(base, value) (WDOG_REFRESH_REG(base) = (value))
#define WDOG_RMW_REFRESH(base, mask, value) (WDOG_WR_REFRESH(base, (WDOG_RD_REFRESH(base) & ~(mask)) | (value)))
#define WDOG_SET_REFRESH(base, value) (BME_OR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_REFRESH(base, value) (BME_AND16(&WDOG_REFRESH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_REFRESH(base, value) (BME_XOR16(&WDOG_REFRESH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_UNLOCK - Watchdog Unlock register
 ******************************************************************************/

/*!
 * @brief WDOG_UNLOCK - Watchdog Unlock register (RW)
 *
 * Reset value: 0xD928U
 */
/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define WDOG_RD_UNLOCK(base)     (WDOG_UNLOCK_REG(base))
#define WDOG_WR_UNLOCK(base, value) (WDOG_UNLOCK_REG(base) = (value))
#define WDOG_RMW_UNLOCK(base, mask, value) (WDOG_WR_UNLOCK(base, (WDOG_RD_UNLOCK(base) & ~(mask)) | (value)))
#define WDOG_SET_UNLOCK(base, value) (BME_OR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
#define WDOG_CLR_UNLOCK(base, value) (BME_AND16(&WDOG_UNLOCK_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_UNLOCK(base, value) (BME_XOR16(&WDOG_UNLOCK_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define WDOG_RD_TMROUTH(base)    (WDOG_TMROUTH_REG(base))
#define WDOG_WR_TMROUTH(base, value) (WDOG_TMROUTH_REG(base) = (value))
#define WDOG_RMW_TMROUTH(base, mask, value) (WDOG_WR_TMROUTH(base, (WDOG_RD_TMROUTH(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTH(base, value) (BME_OR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTH(base, value) (BME_AND16(&WDOG_TMROUTH_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTH(base, value) (BME_XOR16(&WDOG_TMROUTH_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During Stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting Stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define WDOG_RD_TMROUTL(base)    (WDOG_TMROUTL_REG(base))
#define WDOG_WR_TMROUTL(base, value) (WDOG_TMROUTL_REG(base) = (value))
#define WDOG_RMW_TMROUTL(base, mask, value) (WDOG_WR_TMROUTL(base, (WDOG_RD_TMROUTL(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTL(base, value) (BME_OR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
#define WDOG_CLR_TMROUTL(base, value) (BME_AND16(&WDOG_TMROUTL_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_TMROUTL(base, value) (BME_XOR16(&WDOG_TMROUTL_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_RSTCNT - Watchdog Reset Count register
 ******************************************************************************/

/*!
 * @brief WDOG_RSTCNT - Watchdog Reset Count register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define WDOG_RD_RSTCNT(base)     (WDOG_RSTCNT_REG(base))
#define WDOG_WR_RSTCNT(base, value) (WDOG_RSTCNT_REG(base) = (value))
#define WDOG_RMW_RSTCNT(base, mask, value) (WDOG_WR_RSTCNT(base, (WDOG_RD_RSTCNT(base) & ~(mask)) | (value)))
#define WDOG_SET_RSTCNT(base, value) (BME_OR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
#define WDOG_CLR_RSTCNT(base, value) (BME_AND16(&WDOG_RSTCNT_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_RSTCNT(base, value) (BME_XOR16(&WDOG_RSTCNT_REG(base), (uint16_t)(value)))
/*@}*/

/*******************************************************************************
 * WDOG_PRESC - Watchdog Prescaler register
 ******************************************************************************/

/*!
 * @brief WDOG_PRESC - Watchdog Prescaler register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define WDOG_RD_PRESC(base)      (WDOG_PRESC_REG(base))
#define WDOG_WR_PRESC(base, value) (WDOG_PRESC_REG(base) = (value))
#define WDOG_RMW_PRESC(base, mask, value) (WDOG_WR_PRESC(base, (WDOG_RD_PRESC(base) & ~(mask)) | (value)))
#define WDOG_SET_PRESC(base, value) (BME_OR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
#define WDOG_CLR_PRESC(base, value) (BME_AND16(&WDOG_PRESC_REG(base), (uint16_t)(~(value))))
#define WDOG_TOG_PRESC(base, value) (BME_XOR16(&WDOG_PRESC_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define WDOG_RD_PRESC_PRESCVAL(base) ((WDOG_PRESC_REG(base) & WDOG_PRESC_PRESCVAL_MASK) >> WDOG_PRESC_PRESCVAL_SHIFT)
#define WDOG_BRD_PRESC_PRESCVAL(base) (BME_UBFX16(&WDOG_PRESC_REG(base), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))

/*! @brief Set the PRESCVAL field to a new value. */
#define WDOG_WR_PRESC_PRESCVAL(base, value) (WDOG_RMW_PRESC(base, WDOG_PRESC_PRESCVAL_MASK, WDOG_PRESC_PRESCVAL(value)))
#define WDOG_BWR_PRESC_PRESCVAL(base, value) (BME_BFI16(&WDOG_PRESC_REG(base), ((uint16_t)(value) << WDOG_PRESC_PRESCVAL_SHIFT), WDOG_PRESC_PRESCVAL_SHIFT, WDOG_PRESC_PRESCVAL_WIDTH))
/*@}*/

/*
 * MKV58F24 XBARA
 *
 * Crossbar Switch
 *
 * Registers defined in this header file:
 * - XBARA_SEL0 - Crossbar A Select Register 0
 * - XBARA_SEL1 - Crossbar A Select Register 1
 * - XBARA_SEL2 - Crossbar A Select Register 2
 * - XBARA_SEL3 - Crossbar A Select Register 3
 * - XBARA_SEL4 - Crossbar A Select Register 4
 * - XBARA_SEL5 - Crossbar A Select Register 5
 * - XBARA_SEL6 - Crossbar A Select Register 6
 * - XBARA_SEL7 - Crossbar A Select Register 7
 * - XBARA_SEL8 - Crossbar A Select Register 8
 * - XBARA_SEL9 - Crossbar A Select Register 9
 * - XBARA_SEL10 - Crossbar A Select Register 10
 * - XBARA_SEL11 - Crossbar A Select Register 11
 * - XBARA_SEL12 - Crossbar A Select Register 12
 * - XBARA_SEL13 - Crossbar A Select Register 13
 * - XBARA_SEL14 - Crossbar A Select Register 14
 * - XBARA_SEL15 - Crossbar A Select Register 15
 * - XBARA_SEL16 - Crossbar A Select Register 16
 * - XBARA_SEL17 - Crossbar A Select Register 17
 * - XBARA_SEL18 - Crossbar A Select Register 18
 * - XBARA_SEL19 - Crossbar A Select Register 19
 * - XBARA_SEL20 - Crossbar A Select Register 20
 * - XBARA_SEL21 - Crossbar A Select Register 21
 * - XBARA_SEL22 - Crossbar A Select Register 22
 * - XBARA_SEL23 - Crossbar A Select Register 23
 * - XBARA_SEL24 - Crossbar A Select Register 24
 * - XBARA_SEL25 - Crossbar A Select Register 25
 * - XBARA_SEL26 - Crossbar A Select Register 26
 * - XBARA_SEL27 - Crossbar A Select Register 27
 * - XBARA_SEL28 - Crossbar A Select Register 28
 * - XBARA_SEL29 - Crossbar A Select Register 29
 * - XBARA_CTRL0 - Crossbar A Control Register 0
 * - XBARA_CTRL1 - Crossbar A Control Register 1
 */

#define XBARA_INSTANCE_COUNT (1U) /*!< Number of instances of the XBARA module. */
#define XBARA_IDX (0U) /*!< Instance number for XBARA. */

/*******************************************************************************
 * XBARA_SEL0 - Crossbar A Select Register 0
 ******************************************************************************/

/*!
 * @brief XBARA_SEL0 - Crossbar A Select Register 0 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL0 register
 */
/*@{*/
#define XBARA_RD_SEL0(base)      (XBARA_SEL0_REG(base))
#define XBARA_WR_SEL0(base, value) (XBARA_SEL0_REG(base) = (value))
#define XBARA_RMW_SEL0(base, mask, value) (XBARA_WR_SEL0(base, (XBARA_RD_SEL0(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL0(base, value) (BME_OR16(&XBARA_SEL0_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL0(base, value) (BME_AND16(&XBARA_SEL0_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL0(base, value) (BME_XOR16(&XBARA_SEL0_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL0 bitfields
 */

/*!
 * @name Register XBARA_SEL0, field SEL0[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT0 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL0_SEL0 field. */
#define XBARA_RD_SEL0_SEL0(base) ((XBARA_SEL0_REG(base) & XBARA_SEL0_SEL0_MASK) >> XBARA_SEL0_SEL0_SHIFT)
#define XBARA_BRD_SEL0_SEL0(base) (BME_UBFX16(&XBARA_SEL0_REG(base), XBARA_SEL0_SEL0_SHIFT, XBARA_SEL0_SEL0_WIDTH))

/*! @brief Set the SEL0 field to a new value. */
#define XBARA_WR_SEL0_SEL0(base, value) (XBARA_RMW_SEL0(base, XBARA_SEL0_SEL0_MASK, XBARA_SEL0_SEL0(value)))
#define XBARA_BWR_SEL0_SEL0(base, value) (BME_BFI16(&XBARA_SEL0_REG(base), ((uint16_t)(value) << XBARA_SEL0_SEL0_SHIFT), XBARA_SEL0_SEL0_SHIFT, XBARA_SEL0_SEL0_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL0, field SEL1[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT1 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL0_SEL1 field. */
#define XBARA_RD_SEL0_SEL1(base) ((XBARA_SEL0_REG(base) & XBARA_SEL0_SEL1_MASK) >> XBARA_SEL0_SEL1_SHIFT)
#define XBARA_BRD_SEL0_SEL1(base) (BME_UBFX16(&XBARA_SEL0_REG(base), XBARA_SEL0_SEL1_SHIFT, XBARA_SEL0_SEL1_WIDTH))

/*! @brief Set the SEL1 field to a new value. */
#define XBARA_WR_SEL0_SEL1(base, value) (XBARA_RMW_SEL0(base, XBARA_SEL0_SEL1_MASK, XBARA_SEL0_SEL1(value)))
#define XBARA_BWR_SEL0_SEL1(base, value) (BME_BFI16(&XBARA_SEL0_REG(base), ((uint16_t)(value) << XBARA_SEL0_SEL1_SHIFT), XBARA_SEL0_SEL1_SHIFT, XBARA_SEL0_SEL1_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL1 - Crossbar A Select Register 1
 ******************************************************************************/

/*!
 * @brief XBARA_SEL1 - Crossbar A Select Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL1 register
 */
/*@{*/
#define XBARA_RD_SEL1(base)      (XBARA_SEL1_REG(base))
#define XBARA_WR_SEL1(base, value) (XBARA_SEL1_REG(base) = (value))
#define XBARA_RMW_SEL1(base, mask, value) (XBARA_WR_SEL1(base, (XBARA_RD_SEL1(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL1(base, value) (BME_OR16(&XBARA_SEL1_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL1(base, value) (BME_AND16(&XBARA_SEL1_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL1(base, value) (BME_XOR16(&XBARA_SEL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL1 bitfields
 */

/*!
 * @name Register XBARA_SEL1, field SEL2[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT2 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL1_SEL2 field. */
#define XBARA_RD_SEL1_SEL2(base) ((XBARA_SEL1_REG(base) & XBARA_SEL1_SEL2_MASK) >> XBARA_SEL1_SEL2_SHIFT)
#define XBARA_BRD_SEL1_SEL2(base) (BME_UBFX16(&XBARA_SEL1_REG(base), XBARA_SEL1_SEL2_SHIFT, XBARA_SEL1_SEL2_WIDTH))

/*! @brief Set the SEL2 field to a new value. */
#define XBARA_WR_SEL1_SEL2(base, value) (XBARA_RMW_SEL1(base, XBARA_SEL1_SEL2_MASK, XBARA_SEL1_SEL2(value)))
#define XBARA_BWR_SEL1_SEL2(base, value) (BME_BFI16(&XBARA_SEL1_REG(base), ((uint16_t)(value) << XBARA_SEL1_SEL2_SHIFT), XBARA_SEL1_SEL2_SHIFT, XBARA_SEL1_SEL2_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL1, field SEL3[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT3 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL1_SEL3 field. */
#define XBARA_RD_SEL1_SEL3(base) ((XBARA_SEL1_REG(base) & XBARA_SEL1_SEL3_MASK) >> XBARA_SEL1_SEL3_SHIFT)
#define XBARA_BRD_SEL1_SEL3(base) (BME_UBFX16(&XBARA_SEL1_REG(base), XBARA_SEL1_SEL3_SHIFT, XBARA_SEL1_SEL3_WIDTH))

/*! @brief Set the SEL3 field to a new value. */
#define XBARA_WR_SEL1_SEL3(base, value) (XBARA_RMW_SEL1(base, XBARA_SEL1_SEL3_MASK, XBARA_SEL1_SEL3(value)))
#define XBARA_BWR_SEL1_SEL3(base, value) (BME_BFI16(&XBARA_SEL1_REG(base), ((uint16_t)(value) << XBARA_SEL1_SEL3_SHIFT), XBARA_SEL1_SEL3_SHIFT, XBARA_SEL1_SEL3_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL2 - Crossbar A Select Register 2
 ******************************************************************************/

/*!
 * @brief XBARA_SEL2 - Crossbar A Select Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL2 register
 */
/*@{*/
#define XBARA_RD_SEL2(base)      (XBARA_SEL2_REG(base))
#define XBARA_WR_SEL2(base, value) (XBARA_SEL2_REG(base) = (value))
#define XBARA_RMW_SEL2(base, mask, value) (XBARA_WR_SEL2(base, (XBARA_RD_SEL2(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL2(base, value) (BME_OR16(&XBARA_SEL2_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL2(base, value) (BME_AND16(&XBARA_SEL2_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL2(base, value) (BME_XOR16(&XBARA_SEL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL2 bitfields
 */

/*!
 * @name Register XBARA_SEL2, field SEL4[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT4 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL2_SEL4 field. */
#define XBARA_RD_SEL2_SEL4(base) ((XBARA_SEL2_REG(base) & XBARA_SEL2_SEL4_MASK) >> XBARA_SEL2_SEL4_SHIFT)
#define XBARA_BRD_SEL2_SEL4(base) (BME_UBFX16(&XBARA_SEL2_REG(base), XBARA_SEL2_SEL4_SHIFT, XBARA_SEL2_SEL4_WIDTH))

/*! @brief Set the SEL4 field to a new value. */
#define XBARA_WR_SEL2_SEL4(base, value) (XBARA_RMW_SEL2(base, XBARA_SEL2_SEL4_MASK, XBARA_SEL2_SEL4(value)))
#define XBARA_BWR_SEL2_SEL4(base, value) (BME_BFI16(&XBARA_SEL2_REG(base), ((uint16_t)(value) << XBARA_SEL2_SEL4_SHIFT), XBARA_SEL2_SEL4_SHIFT, XBARA_SEL2_SEL4_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL2, field SEL5[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT5 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL2_SEL5 field. */
#define XBARA_RD_SEL2_SEL5(base) ((XBARA_SEL2_REG(base) & XBARA_SEL2_SEL5_MASK) >> XBARA_SEL2_SEL5_SHIFT)
#define XBARA_BRD_SEL2_SEL5(base) (BME_UBFX16(&XBARA_SEL2_REG(base), XBARA_SEL2_SEL5_SHIFT, XBARA_SEL2_SEL5_WIDTH))

/*! @brief Set the SEL5 field to a new value. */
#define XBARA_WR_SEL2_SEL5(base, value) (XBARA_RMW_SEL2(base, XBARA_SEL2_SEL5_MASK, XBARA_SEL2_SEL5(value)))
#define XBARA_BWR_SEL2_SEL5(base, value) (BME_BFI16(&XBARA_SEL2_REG(base), ((uint16_t)(value) << XBARA_SEL2_SEL5_SHIFT), XBARA_SEL2_SEL5_SHIFT, XBARA_SEL2_SEL5_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL3 - Crossbar A Select Register 3
 ******************************************************************************/

/*!
 * @brief XBARA_SEL3 - Crossbar A Select Register 3 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL3 register
 */
/*@{*/
#define XBARA_RD_SEL3(base)      (XBARA_SEL3_REG(base))
#define XBARA_WR_SEL3(base, value) (XBARA_SEL3_REG(base) = (value))
#define XBARA_RMW_SEL3(base, mask, value) (XBARA_WR_SEL3(base, (XBARA_RD_SEL3(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL3(base, value) (BME_OR16(&XBARA_SEL3_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL3(base, value) (BME_AND16(&XBARA_SEL3_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL3(base, value) (BME_XOR16(&XBARA_SEL3_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL3 bitfields
 */

/*!
 * @name Register XBARA_SEL3, field SEL6[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT6 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL3_SEL6 field. */
#define XBARA_RD_SEL3_SEL6(base) ((XBARA_SEL3_REG(base) & XBARA_SEL3_SEL6_MASK) >> XBARA_SEL3_SEL6_SHIFT)
#define XBARA_BRD_SEL3_SEL6(base) (BME_UBFX16(&XBARA_SEL3_REG(base), XBARA_SEL3_SEL6_SHIFT, XBARA_SEL3_SEL6_WIDTH))

/*! @brief Set the SEL6 field to a new value. */
#define XBARA_WR_SEL3_SEL6(base, value) (XBARA_RMW_SEL3(base, XBARA_SEL3_SEL6_MASK, XBARA_SEL3_SEL6(value)))
#define XBARA_BWR_SEL3_SEL6(base, value) (BME_BFI16(&XBARA_SEL3_REG(base), ((uint16_t)(value) << XBARA_SEL3_SEL6_SHIFT), XBARA_SEL3_SEL6_SHIFT, XBARA_SEL3_SEL6_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL3, field SEL7[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT7 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL3_SEL7 field. */
#define XBARA_RD_SEL3_SEL7(base) ((XBARA_SEL3_REG(base) & XBARA_SEL3_SEL7_MASK) >> XBARA_SEL3_SEL7_SHIFT)
#define XBARA_BRD_SEL3_SEL7(base) (BME_UBFX16(&XBARA_SEL3_REG(base), XBARA_SEL3_SEL7_SHIFT, XBARA_SEL3_SEL7_WIDTH))

/*! @brief Set the SEL7 field to a new value. */
#define XBARA_WR_SEL3_SEL7(base, value) (XBARA_RMW_SEL3(base, XBARA_SEL3_SEL7_MASK, XBARA_SEL3_SEL7(value)))
#define XBARA_BWR_SEL3_SEL7(base, value) (BME_BFI16(&XBARA_SEL3_REG(base), ((uint16_t)(value) << XBARA_SEL3_SEL7_SHIFT), XBARA_SEL3_SEL7_SHIFT, XBARA_SEL3_SEL7_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL4 - Crossbar A Select Register 4
 ******************************************************************************/

/*!
 * @brief XBARA_SEL4 - Crossbar A Select Register 4 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL4 register
 */
/*@{*/
#define XBARA_RD_SEL4(base)      (XBARA_SEL4_REG(base))
#define XBARA_WR_SEL4(base, value) (XBARA_SEL4_REG(base) = (value))
#define XBARA_RMW_SEL4(base, mask, value) (XBARA_WR_SEL4(base, (XBARA_RD_SEL4(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL4(base, value) (BME_OR16(&XBARA_SEL4_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL4(base, value) (BME_AND16(&XBARA_SEL4_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL4(base, value) (BME_XOR16(&XBARA_SEL4_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL4 bitfields
 */

/*!
 * @name Register XBARA_SEL4, field SEL8[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT8 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL4_SEL8 field. */
#define XBARA_RD_SEL4_SEL8(base) ((XBARA_SEL4_REG(base) & XBARA_SEL4_SEL8_MASK) >> XBARA_SEL4_SEL8_SHIFT)
#define XBARA_BRD_SEL4_SEL8(base) (BME_UBFX16(&XBARA_SEL4_REG(base), XBARA_SEL4_SEL8_SHIFT, XBARA_SEL4_SEL8_WIDTH))

/*! @brief Set the SEL8 field to a new value. */
#define XBARA_WR_SEL4_SEL8(base, value) (XBARA_RMW_SEL4(base, XBARA_SEL4_SEL8_MASK, XBARA_SEL4_SEL8(value)))
#define XBARA_BWR_SEL4_SEL8(base, value) (BME_BFI16(&XBARA_SEL4_REG(base), ((uint16_t)(value) << XBARA_SEL4_SEL8_SHIFT), XBARA_SEL4_SEL8_SHIFT, XBARA_SEL4_SEL8_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL4, field SEL9[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT9 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL4_SEL9 field. */
#define XBARA_RD_SEL4_SEL9(base) ((XBARA_SEL4_REG(base) & XBARA_SEL4_SEL9_MASK) >> XBARA_SEL4_SEL9_SHIFT)
#define XBARA_BRD_SEL4_SEL9(base) (BME_UBFX16(&XBARA_SEL4_REG(base), XBARA_SEL4_SEL9_SHIFT, XBARA_SEL4_SEL9_WIDTH))

/*! @brief Set the SEL9 field to a new value. */
#define XBARA_WR_SEL4_SEL9(base, value) (XBARA_RMW_SEL4(base, XBARA_SEL4_SEL9_MASK, XBARA_SEL4_SEL9(value)))
#define XBARA_BWR_SEL4_SEL9(base, value) (BME_BFI16(&XBARA_SEL4_REG(base), ((uint16_t)(value) << XBARA_SEL4_SEL9_SHIFT), XBARA_SEL4_SEL9_SHIFT, XBARA_SEL4_SEL9_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL5 - Crossbar A Select Register 5
 ******************************************************************************/

/*!
 * @brief XBARA_SEL5 - Crossbar A Select Register 5 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL5 register
 */
/*@{*/
#define XBARA_RD_SEL5(base)      (XBARA_SEL5_REG(base))
#define XBARA_WR_SEL5(base, value) (XBARA_SEL5_REG(base) = (value))
#define XBARA_RMW_SEL5(base, mask, value) (XBARA_WR_SEL5(base, (XBARA_RD_SEL5(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL5(base, value) (BME_OR16(&XBARA_SEL5_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL5(base, value) (BME_AND16(&XBARA_SEL5_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL5(base, value) (BME_XOR16(&XBARA_SEL5_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL5 bitfields
 */

/*!
 * @name Register XBARA_SEL5, field SEL10[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT10 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL5_SEL10 field. */
#define XBARA_RD_SEL5_SEL10(base) ((XBARA_SEL5_REG(base) & XBARA_SEL5_SEL10_MASK) >> XBARA_SEL5_SEL10_SHIFT)
#define XBARA_BRD_SEL5_SEL10(base) (BME_UBFX16(&XBARA_SEL5_REG(base), XBARA_SEL5_SEL10_SHIFT, XBARA_SEL5_SEL10_WIDTH))

/*! @brief Set the SEL10 field to a new value. */
#define XBARA_WR_SEL5_SEL10(base, value) (XBARA_RMW_SEL5(base, XBARA_SEL5_SEL10_MASK, XBARA_SEL5_SEL10(value)))
#define XBARA_BWR_SEL5_SEL10(base, value) (BME_BFI16(&XBARA_SEL5_REG(base), ((uint16_t)(value) << XBARA_SEL5_SEL10_SHIFT), XBARA_SEL5_SEL10_SHIFT, XBARA_SEL5_SEL10_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL5, field SEL11[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT11 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL5_SEL11 field. */
#define XBARA_RD_SEL5_SEL11(base) ((XBARA_SEL5_REG(base) & XBARA_SEL5_SEL11_MASK) >> XBARA_SEL5_SEL11_SHIFT)
#define XBARA_BRD_SEL5_SEL11(base) (BME_UBFX16(&XBARA_SEL5_REG(base), XBARA_SEL5_SEL11_SHIFT, XBARA_SEL5_SEL11_WIDTH))

/*! @brief Set the SEL11 field to a new value. */
#define XBARA_WR_SEL5_SEL11(base, value) (XBARA_RMW_SEL5(base, XBARA_SEL5_SEL11_MASK, XBARA_SEL5_SEL11(value)))
#define XBARA_BWR_SEL5_SEL11(base, value) (BME_BFI16(&XBARA_SEL5_REG(base), ((uint16_t)(value) << XBARA_SEL5_SEL11_SHIFT), XBARA_SEL5_SEL11_SHIFT, XBARA_SEL5_SEL11_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL6 - Crossbar A Select Register 6
 ******************************************************************************/

/*!
 * @brief XBARA_SEL6 - Crossbar A Select Register 6 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL6 register
 */
/*@{*/
#define XBARA_RD_SEL6(base)      (XBARA_SEL6_REG(base))
#define XBARA_WR_SEL6(base, value) (XBARA_SEL6_REG(base) = (value))
#define XBARA_RMW_SEL6(base, mask, value) (XBARA_WR_SEL6(base, (XBARA_RD_SEL6(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL6(base, value) (BME_OR16(&XBARA_SEL6_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL6(base, value) (BME_AND16(&XBARA_SEL6_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL6(base, value) (BME_XOR16(&XBARA_SEL6_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL6 bitfields
 */

/*!
 * @name Register XBARA_SEL6, field SEL12[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT12 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL6_SEL12 field. */
#define XBARA_RD_SEL6_SEL12(base) ((XBARA_SEL6_REG(base) & XBARA_SEL6_SEL12_MASK) >> XBARA_SEL6_SEL12_SHIFT)
#define XBARA_BRD_SEL6_SEL12(base) (BME_UBFX16(&XBARA_SEL6_REG(base), XBARA_SEL6_SEL12_SHIFT, XBARA_SEL6_SEL12_WIDTH))

/*! @brief Set the SEL12 field to a new value. */
#define XBARA_WR_SEL6_SEL12(base, value) (XBARA_RMW_SEL6(base, XBARA_SEL6_SEL12_MASK, XBARA_SEL6_SEL12(value)))
#define XBARA_BWR_SEL6_SEL12(base, value) (BME_BFI16(&XBARA_SEL6_REG(base), ((uint16_t)(value) << XBARA_SEL6_SEL12_SHIFT), XBARA_SEL6_SEL12_SHIFT, XBARA_SEL6_SEL12_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL6, field SEL13[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT13 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL6_SEL13 field. */
#define XBARA_RD_SEL6_SEL13(base) ((XBARA_SEL6_REG(base) & XBARA_SEL6_SEL13_MASK) >> XBARA_SEL6_SEL13_SHIFT)
#define XBARA_BRD_SEL6_SEL13(base) (BME_UBFX16(&XBARA_SEL6_REG(base), XBARA_SEL6_SEL13_SHIFT, XBARA_SEL6_SEL13_WIDTH))

/*! @brief Set the SEL13 field to a new value. */
#define XBARA_WR_SEL6_SEL13(base, value) (XBARA_RMW_SEL6(base, XBARA_SEL6_SEL13_MASK, XBARA_SEL6_SEL13(value)))
#define XBARA_BWR_SEL6_SEL13(base, value) (BME_BFI16(&XBARA_SEL6_REG(base), ((uint16_t)(value) << XBARA_SEL6_SEL13_SHIFT), XBARA_SEL6_SEL13_SHIFT, XBARA_SEL6_SEL13_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL7 - Crossbar A Select Register 7
 ******************************************************************************/

/*!
 * @brief XBARA_SEL7 - Crossbar A Select Register 7 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL7 register
 */
/*@{*/
#define XBARA_RD_SEL7(base)      (XBARA_SEL7_REG(base))
#define XBARA_WR_SEL7(base, value) (XBARA_SEL7_REG(base) = (value))
#define XBARA_RMW_SEL7(base, mask, value) (XBARA_WR_SEL7(base, (XBARA_RD_SEL7(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL7(base, value) (BME_OR16(&XBARA_SEL7_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL7(base, value) (BME_AND16(&XBARA_SEL7_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL7(base, value) (BME_XOR16(&XBARA_SEL7_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL7 bitfields
 */

/*!
 * @name Register XBARA_SEL7, field SEL14[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT14 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL7_SEL14 field. */
#define XBARA_RD_SEL7_SEL14(base) ((XBARA_SEL7_REG(base) & XBARA_SEL7_SEL14_MASK) >> XBARA_SEL7_SEL14_SHIFT)
#define XBARA_BRD_SEL7_SEL14(base) (BME_UBFX16(&XBARA_SEL7_REG(base), XBARA_SEL7_SEL14_SHIFT, XBARA_SEL7_SEL14_WIDTH))

/*! @brief Set the SEL14 field to a new value. */
#define XBARA_WR_SEL7_SEL14(base, value) (XBARA_RMW_SEL7(base, XBARA_SEL7_SEL14_MASK, XBARA_SEL7_SEL14(value)))
#define XBARA_BWR_SEL7_SEL14(base, value) (BME_BFI16(&XBARA_SEL7_REG(base), ((uint16_t)(value) << XBARA_SEL7_SEL14_SHIFT), XBARA_SEL7_SEL14_SHIFT, XBARA_SEL7_SEL14_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL7, field SEL15[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT15 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL7_SEL15 field. */
#define XBARA_RD_SEL7_SEL15(base) ((XBARA_SEL7_REG(base) & XBARA_SEL7_SEL15_MASK) >> XBARA_SEL7_SEL15_SHIFT)
#define XBARA_BRD_SEL7_SEL15(base) (BME_UBFX16(&XBARA_SEL7_REG(base), XBARA_SEL7_SEL15_SHIFT, XBARA_SEL7_SEL15_WIDTH))

/*! @brief Set the SEL15 field to a new value. */
#define XBARA_WR_SEL7_SEL15(base, value) (XBARA_RMW_SEL7(base, XBARA_SEL7_SEL15_MASK, XBARA_SEL7_SEL15(value)))
#define XBARA_BWR_SEL7_SEL15(base, value) (BME_BFI16(&XBARA_SEL7_REG(base), ((uint16_t)(value) << XBARA_SEL7_SEL15_SHIFT), XBARA_SEL7_SEL15_SHIFT, XBARA_SEL7_SEL15_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL8 - Crossbar A Select Register 8
 ******************************************************************************/

/*!
 * @brief XBARA_SEL8 - Crossbar A Select Register 8 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL8 register
 */
/*@{*/
#define XBARA_RD_SEL8(base)      (XBARA_SEL8_REG(base))
#define XBARA_WR_SEL8(base, value) (XBARA_SEL8_REG(base) = (value))
#define XBARA_RMW_SEL8(base, mask, value) (XBARA_WR_SEL8(base, (XBARA_RD_SEL8(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL8(base, value) (BME_OR16(&XBARA_SEL8_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL8(base, value) (BME_AND16(&XBARA_SEL8_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL8(base, value) (BME_XOR16(&XBARA_SEL8_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL8 bitfields
 */

/*!
 * @name Register XBARA_SEL8, field SEL16[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT16 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL8_SEL16 field. */
#define XBARA_RD_SEL8_SEL16(base) ((XBARA_SEL8_REG(base) & XBARA_SEL8_SEL16_MASK) >> XBARA_SEL8_SEL16_SHIFT)
#define XBARA_BRD_SEL8_SEL16(base) (BME_UBFX16(&XBARA_SEL8_REG(base), XBARA_SEL8_SEL16_SHIFT, XBARA_SEL8_SEL16_WIDTH))

/*! @brief Set the SEL16 field to a new value. */
#define XBARA_WR_SEL8_SEL16(base, value) (XBARA_RMW_SEL8(base, XBARA_SEL8_SEL16_MASK, XBARA_SEL8_SEL16(value)))
#define XBARA_BWR_SEL8_SEL16(base, value) (BME_BFI16(&XBARA_SEL8_REG(base), ((uint16_t)(value) << XBARA_SEL8_SEL16_SHIFT), XBARA_SEL8_SEL16_SHIFT, XBARA_SEL8_SEL16_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL8, field SEL17[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT17 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL8_SEL17 field. */
#define XBARA_RD_SEL8_SEL17(base) ((XBARA_SEL8_REG(base) & XBARA_SEL8_SEL17_MASK) >> XBARA_SEL8_SEL17_SHIFT)
#define XBARA_BRD_SEL8_SEL17(base) (BME_UBFX16(&XBARA_SEL8_REG(base), XBARA_SEL8_SEL17_SHIFT, XBARA_SEL8_SEL17_WIDTH))

/*! @brief Set the SEL17 field to a new value. */
#define XBARA_WR_SEL8_SEL17(base, value) (XBARA_RMW_SEL8(base, XBARA_SEL8_SEL17_MASK, XBARA_SEL8_SEL17(value)))
#define XBARA_BWR_SEL8_SEL17(base, value) (BME_BFI16(&XBARA_SEL8_REG(base), ((uint16_t)(value) << XBARA_SEL8_SEL17_SHIFT), XBARA_SEL8_SEL17_SHIFT, XBARA_SEL8_SEL17_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL9 - Crossbar A Select Register 9
 ******************************************************************************/

/*!
 * @brief XBARA_SEL9 - Crossbar A Select Register 9 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL9 register
 */
/*@{*/
#define XBARA_RD_SEL9(base)      (XBARA_SEL9_REG(base))
#define XBARA_WR_SEL9(base, value) (XBARA_SEL9_REG(base) = (value))
#define XBARA_RMW_SEL9(base, mask, value) (XBARA_WR_SEL9(base, (XBARA_RD_SEL9(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL9(base, value) (BME_OR16(&XBARA_SEL9_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL9(base, value) (BME_AND16(&XBARA_SEL9_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL9(base, value) (BME_XOR16(&XBARA_SEL9_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL9 bitfields
 */

/*!
 * @name Register XBARA_SEL9, field SEL18[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT18 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL9_SEL18 field. */
#define XBARA_RD_SEL9_SEL18(base) ((XBARA_SEL9_REG(base) & XBARA_SEL9_SEL18_MASK) >> XBARA_SEL9_SEL18_SHIFT)
#define XBARA_BRD_SEL9_SEL18(base) (BME_UBFX16(&XBARA_SEL9_REG(base), XBARA_SEL9_SEL18_SHIFT, XBARA_SEL9_SEL18_WIDTH))

/*! @brief Set the SEL18 field to a new value. */
#define XBARA_WR_SEL9_SEL18(base, value) (XBARA_RMW_SEL9(base, XBARA_SEL9_SEL18_MASK, XBARA_SEL9_SEL18(value)))
#define XBARA_BWR_SEL9_SEL18(base, value) (BME_BFI16(&XBARA_SEL9_REG(base), ((uint16_t)(value) << XBARA_SEL9_SEL18_SHIFT), XBARA_SEL9_SEL18_SHIFT, XBARA_SEL9_SEL18_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL9, field SEL19[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT19 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL9_SEL19 field. */
#define XBARA_RD_SEL9_SEL19(base) ((XBARA_SEL9_REG(base) & XBARA_SEL9_SEL19_MASK) >> XBARA_SEL9_SEL19_SHIFT)
#define XBARA_BRD_SEL9_SEL19(base) (BME_UBFX16(&XBARA_SEL9_REG(base), XBARA_SEL9_SEL19_SHIFT, XBARA_SEL9_SEL19_WIDTH))

/*! @brief Set the SEL19 field to a new value. */
#define XBARA_WR_SEL9_SEL19(base, value) (XBARA_RMW_SEL9(base, XBARA_SEL9_SEL19_MASK, XBARA_SEL9_SEL19(value)))
#define XBARA_BWR_SEL9_SEL19(base, value) (BME_BFI16(&XBARA_SEL9_REG(base), ((uint16_t)(value) << XBARA_SEL9_SEL19_SHIFT), XBARA_SEL9_SEL19_SHIFT, XBARA_SEL9_SEL19_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL10 - Crossbar A Select Register 10
 ******************************************************************************/

/*!
 * @brief XBARA_SEL10 - Crossbar A Select Register 10 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL10 register
 */
/*@{*/
#define XBARA_RD_SEL10(base)     (XBARA_SEL10_REG(base))
#define XBARA_WR_SEL10(base, value) (XBARA_SEL10_REG(base) = (value))
#define XBARA_RMW_SEL10(base, mask, value) (XBARA_WR_SEL10(base, (XBARA_RD_SEL10(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL10(base, value) (BME_OR16(&XBARA_SEL10_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL10(base, value) (BME_AND16(&XBARA_SEL10_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL10(base, value) (BME_XOR16(&XBARA_SEL10_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL10 bitfields
 */

/*!
 * @name Register XBARA_SEL10, field SEL20[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT20 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL10_SEL20 field. */
#define XBARA_RD_SEL10_SEL20(base) ((XBARA_SEL10_REG(base) & XBARA_SEL10_SEL20_MASK) >> XBARA_SEL10_SEL20_SHIFT)
#define XBARA_BRD_SEL10_SEL20(base) (BME_UBFX16(&XBARA_SEL10_REG(base), XBARA_SEL10_SEL20_SHIFT, XBARA_SEL10_SEL20_WIDTH))

/*! @brief Set the SEL20 field to a new value. */
#define XBARA_WR_SEL10_SEL20(base, value) (XBARA_RMW_SEL10(base, XBARA_SEL10_SEL20_MASK, XBARA_SEL10_SEL20(value)))
#define XBARA_BWR_SEL10_SEL20(base, value) (BME_BFI16(&XBARA_SEL10_REG(base), ((uint16_t)(value) << XBARA_SEL10_SEL20_SHIFT), XBARA_SEL10_SEL20_SHIFT, XBARA_SEL10_SEL20_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL10, field SEL21[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT21 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL10_SEL21 field. */
#define XBARA_RD_SEL10_SEL21(base) ((XBARA_SEL10_REG(base) & XBARA_SEL10_SEL21_MASK) >> XBARA_SEL10_SEL21_SHIFT)
#define XBARA_BRD_SEL10_SEL21(base) (BME_UBFX16(&XBARA_SEL10_REG(base), XBARA_SEL10_SEL21_SHIFT, XBARA_SEL10_SEL21_WIDTH))

/*! @brief Set the SEL21 field to a new value. */
#define XBARA_WR_SEL10_SEL21(base, value) (XBARA_RMW_SEL10(base, XBARA_SEL10_SEL21_MASK, XBARA_SEL10_SEL21(value)))
#define XBARA_BWR_SEL10_SEL21(base, value) (BME_BFI16(&XBARA_SEL10_REG(base), ((uint16_t)(value) << XBARA_SEL10_SEL21_SHIFT), XBARA_SEL10_SEL21_SHIFT, XBARA_SEL10_SEL21_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL11 - Crossbar A Select Register 11
 ******************************************************************************/

/*!
 * @brief XBARA_SEL11 - Crossbar A Select Register 11 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL11 register
 */
/*@{*/
#define XBARA_RD_SEL11(base)     (XBARA_SEL11_REG(base))
#define XBARA_WR_SEL11(base, value) (XBARA_SEL11_REG(base) = (value))
#define XBARA_RMW_SEL11(base, mask, value) (XBARA_WR_SEL11(base, (XBARA_RD_SEL11(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL11(base, value) (BME_OR16(&XBARA_SEL11_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL11(base, value) (BME_AND16(&XBARA_SEL11_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL11(base, value) (BME_XOR16(&XBARA_SEL11_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL11 bitfields
 */

/*!
 * @name Register XBARA_SEL11, field SEL22[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT22 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL11_SEL22 field. */
#define XBARA_RD_SEL11_SEL22(base) ((XBARA_SEL11_REG(base) & XBARA_SEL11_SEL22_MASK) >> XBARA_SEL11_SEL22_SHIFT)
#define XBARA_BRD_SEL11_SEL22(base) (BME_UBFX16(&XBARA_SEL11_REG(base), XBARA_SEL11_SEL22_SHIFT, XBARA_SEL11_SEL22_WIDTH))

/*! @brief Set the SEL22 field to a new value. */
#define XBARA_WR_SEL11_SEL22(base, value) (XBARA_RMW_SEL11(base, XBARA_SEL11_SEL22_MASK, XBARA_SEL11_SEL22(value)))
#define XBARA_BWR_SEL11_SEL22(base, value) (BME_BFI16(&XBARA_SEL11_REG(base), ((uint16_t)(value) << XBARA_SEL11_SEL22_SHIFT), XBARA_SEL11_SEL22_SHIFT, XBARA_SEL11_SEL22_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL11, field SEL23[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT23 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL11_SEL23 field. */
#define XBARA_RD_SEL11_SEL23(base) ((XBARA_SEL11_REG(base) & XBARA_SEL11_SEL23_MASK) >> XBARA_SEL11_SEL23_SHIFT)
#define XBARA_BRD_SEL11_SEL23(base) (BME_UBFX16(&XBARA_SEL11_REG(base), XBARA_SEL11_SEL23_SHIFT, XBARA_SEL11_SEL23_WIDTH))

/*! @brief Set the SEL23 field to a new value. */
#define XBARA_WR_SEL11_SEL23(base, value) (XBARA_RMW_SEL11(base, XBARA_SEL11_SEL23_MASK, XBARA_SEL11_SEL23(value)))
#define XBARA_BWR_SEL11_SEL23(base, value) (BME_BFI16(&XBARA_SEL11_REG(base), ((uint16_t)(value) << XBARA_SEL11_SEL23_SHIFT), XBARA_SEL11_SEL23_SHIFT, XBARA_SEL11_SEL23_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL12 - Crossbar A Select Register 12
 ******************************************************************************/

/*!
 * @brief XBARA_SEL12 - Crossbar A Select Register 12 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL12 register
 */
/*@{*/
#define XBARA_RD_SEL12(base)     (XBARA_SEL12_REG(base))
#define XBARA_WR_SEL12(base, value) (XBARA_SEL12_REG(base) = (value))
#define XBARA_RMW_SEL12(base, mask, value) (XBARA_WR_SEL12(base, (XBARA_RD_SEL12(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL12(base, value) (BME_OR16(&XBARA_SEL12_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL12(base, value) (BME_AND16(&XBARA_SEL12_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL12(base, value) (BME_XOR16(&XBARA_SEL12_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL12 bitfields
 */

/*!
 * @name Register XBARA_SEL12, field SEL24[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT24 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL12_SEL24 field. */
#define XBARA_RD_SEL12_SEL24(base) ((XBARA_SEL12_REG(base) & XBARA_SEL12_SEL24_MASK) >> XBARA_SEL12_SEL24_SHIFT)
#define XBARA_BRD_SEL12_SEL24(base) (BME_UBFX16(&XBARA_SEL12_REG(base), XBARA_SEL12_SEL24_SHIFT, XBARA_SEL12_SEL24_WIDTH))

/*! @brief Set the SEL24 field to a new value. */
#define XBARA_WR_SEL12_SEL24(base, value) (XBARA_RMW_SEL12(base, XBARA_SEL12_SEL24_MASK, XBARA_SEL12_SEL24(value)))
#define XBARA_BWR_SEL12_SEL24(base, value) (BME_BFI16(&XBARA_SEL12_REG(base), ((uint16_t)(value) << XBARA_SEL12_SEL24_SHIFT), XBARA_SEL12_SEL24_SHIFT, XBARA_SEL12_SEL24_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL12, field SEL25[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT25 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL12_SEL25 field. */
#define XBARA_RD_SEL12_SEL25(base) ((XBARA_SEL12_REG(base) & XBARA_SEL12_SEL25_MASK) >> XBARA_SEL12_SEL25_SHIFT)
#define XBARA_BRD_SEL12_SEL25(base) (BME_UBFX16(&XBARA_SEL12_REG(base), XBARA_SEL12_SEL25_SHIFT, XBARA_SEL12_SEL25_WIDTH))

/*! @brief Set the SEL25 field to a new value. */
#define XBARA_WR_SEL12_SEL25(base, value) (XBARA_RMW_SEL12(base, XBARA_SEL12_SEL25_MASK, XBARA_SEL12_SEL25(value)))
#define XBARA_BWR_SEL12_SEL25(base, value) (BME_BFI16(&XBARA_SEL12_REG(base), ((uint16_t)(value) << XBARA_SEL12_SEL25_SHIFT), XBARA_SEL12_SEL25_SHIFT, XBARA_SEL12_SEL25_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL13 - Crossbar A Select Register 13
 ******************************************************************************/

/*!
 * @brief XBARA_SEL13 - Crossbar A Select Register 13 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL13 register
 */
/*@{*/
#define XBARA_RD_SEL13(base)     (XBARA_SEL13_REG(base))
#define XBARA_WR_SEL13(base, value) (XBARA_SEL13_REG(base) = (value))
#define XBARA_RMW_SEL13(base, mask, value) (XBARA_WR_SEL13(base, (XBARA_RD_SEL13(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL13(base, value) (BME_OR16(&XBARA_SEL13_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL13(base, value) (BME_AND16(&XBARA_SEL13_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL13(base, value) (BME_XOR16(&XBARA_SEL13_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL13 bitfields
 */

/*!
 * @name Register XBARA_SEL13, field SEL26[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT26 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL13_SEL26 field. */
#define XBARA_RD_SEL13_SEL26(base) ((XBARA_SEL13_REG(base) & XBARA_SEL13_SEL26_MASK) >> XBARA_SEL13_SEL26_SHIFT)
#define XBARA_BRD_SEL13_SEL26(base) (BME_UBFX16(&XBARA_SEL13_REG(base), XBARA_SEL13_SEL26_SHIFT, XBARA_SEL13_SEL26_WIDTH))

/*! @brief Set the SEL26 field to a new value. */
#define XBARA_WR_SEL13_SEL26(base, value) (XBARA_RMW_SEL13(base, XBARA_SEL13_SEL26_MASK, XBARA_SEL13_SEL26(value)))
#define XBARA_BWR_SEL13_SEL26(base, value) (BME_BFI16(&XBARA_SEL13_REG(base), ((uint16_t)(value) << XBARA_SEL13_SEL26_SHIFT), XBARA_SEL13_SEL26_SHIFT, XBARA_SEL13_SEL26_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL13, field SEL27[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT27 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL13_SEL27 field. */
#define XBARA_RD_SEL13_SEL27(base) ((XBARA_SEL13_REG(base) & XBARA_SEL13_SEL27_MASK) >> XBARA_SEL13_SEL27_SHIFT)
#define XBARA_BRD_SEL13_SEL27(base) (BME_UBFX16(&XBARA_SEL13_REG(base), XBARA_SEL13_SEL27_SHIFT, XBARA_SEL13_SEL27_WIDTH))

/*! @brief Set the SEL27 field to a new value. */
#define XBARA_WR_SEL13_SEL27(base, value) (XBARA_RMW_SEL13(base, XBARA_SEL13_SEL27_MASK, XBARA_SEL13_SEL27(value)))
#define XBARA_BWR_SEL13_SEL27(base, value) (BME_BFI16(&XBARA_SEL13_REG(base), ((uint16_t)(value) << XBARA_SEL13_SEL27_SHIFT), XBARA_SEL13_SEL27_SHIFT, XBARA_SEL13_SEL27_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL14 - Crossbar A Select Register 14
 ******************************************************************************/

/*!
 * @brief XBARA_SEL14 - Crossbar A Select Register 14 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL14 register
 */
/*@{*/
#define XBARA_RD_SEL14(base)     (XBARA_SEL14_REG(base))
#define XBARA_WR_SEL14(base, value) (XBARA_SEL14_REG(base) = (value))
#define XBARA_RMW_SEL14(base, mask, value) (XBARA_WR_SEL14(base, (XBARA_RD_SEL14(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL14(base, value) (BME_OR16(&XBARA_SEL14_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL14(base, value) (BME_AND16(&XBARA_SEL14_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL14(base, value) (BME_XOR16(&XBARA_SEL14_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL14 bitfields
 */

/*!
 * @name Register XBARA_SEL14, field SEL28[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT28 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL14_SEL28 field. */
#define XBARA_RD_SEL14_SEL28(base) ((XBARA_SEL14_REG(base) & XBARA_SEL14_SEL28_MASK) >> XBARA_SEL14_SEL28_SHIFT)
#define XBARA_BRD_SEL14_SEL28(base) (BME_UBFX16(&XBARA_SEL14_REG(base), XBARA_SEL14_SEL28_SHIFT, XBARA_SEL14_SEL28_WIDTH))

/*! @brief Set the SEL28 field to a new value. */
#define XBARA_WR_SEL14_SEL28(base, value) (XBARA_RMW_SEL14(base, XBARA_SEL14_SEL28_MASK, XBARA_SEL14_SEL28(value)))
#define XBARA_BWR_SEL14_SEL28(base, value) (BME_BFI16(&XBARA_SEL14_REG(base), ((uint16_t)(value) << XBARA_SEL14_SEL28_SHIFT), XBARA_SEL14_SEL28_SHIFT, XBARA_SEL14_SEL28_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL14, field SEL29[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT29 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL14_SEL29 field. */
#define XBARA_RD_SEL14_SEL29(base) ((XBARA_SEL14_REG(base) & XBARA_SEL14_SEL29_MASK) >> XBARA_SEL14_SEL29_SHIFT)
#define XBARA_BRD_SEL14_SEL29(base) (BME_UBFX16(&XBARA_SEL14_REG(base), XBARA_SEL14_SEL29_SHIFT, XBARA_SEL14_SEL29_WIDTH))

/*! @brief Set the SEL29 field to a new value. */
#define XBARA_WR_SEL14_SEL29(base, value) (XBARA_RMW_SEL14(base, XBARA_SEL14_SEL29_MASK, XBARA_SEL14_SEL29(value)))
#define XBARA_BWR_SEL14_SEL29(base, value) (BME_BFI16(&XBARA_SEL14_REG(base), ((uint16_t)(value) << XBARA_SEL14_SEL29_SHIFT), XBARA_SEL14_SEL29_SHIFT, XBARA_SEL14_SEL29_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL15 - Crossbar A Select Register 15
 ******************************************************************************/

/*!
 * @brief XBARA_SEL15 - Crossbar A Select Register 15 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL15 register
 */
/*@{*/
#define XBARA_RD_SEL15(base)     (XBARA_SEL15_REG(base))
#define XBARA_WR_SEL15(base, value) (XBARA_SEL15_REG(base) = (value))
#define XBARA_RMW_SEL15(base, mask, value) (XBARA_WR_SEL15(base, (XBARA_RD_SEL15(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL15(base, value) (BME_OR16(&XBARA_SEL15_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL15(base, value) (BME_AND16(&XBARA_SEL15_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL15(base, value) (BME_XOR16(&XBARA_SEL15_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL15 bitfields
 */

/*!
 * @name Register XBARA_SEL15, field SEL30[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT30 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL15_SEL30 field. */
#define XBARA_RD_SEL15_SEL30(base) ((XBARA_SEL15_REG(base) & XBARA_SEL15_SEL30_MASK) >> XBARA_SEL15_SEL30_SHIFT)
#define XBARA_BRD_SEL15_SEL30(base) (BME_UBFX16(&XBARA_SEL15_REG(base), XBARA_SEL15_SEL30_SHIFT, XBARA_SEL15_SEL30_WIDTH))

/*! @brief Set the SEL30 field to a new value. */
#define XBARA_WR_SEL15_SEL30(base, value) (XBARA_RMW_SEL15(base, XBARA_SEL15_SEL30_MASK, XBARA_SEL15_SEL30(value)))
#define XBARA_BWR_SEL15_SEL30(base, value) (BME_BFI16(&XBARA_SEL15_REG(base), ((uint16_t)(value) << XBARA_SEL15_SEL30_SHIFT), XBARA_SEL15_SEL30_SHIFT, XBARA_SEL15_SEL30_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL15, field SEL31[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT31 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL15_SEL31 field. */
#define XBARA_RD_SEL15_SEL31(base) ((XBARA_SEL15_REG(base) & XBARA_SEL15_SEL31_MASK) >> XBARA_SEL15_SEL31_SHIFT)
#define XBARA_BRD_SEL15_SEL31(base) (BME_UBFX16(&XBARA_SEL15_REG(base), XBARA_SEL15_SEL31_SHIFT, XBARA_SEL15_SEL31_WIDTH))

/*! @brief Set the SEL31 field to a new value. */
#define XBARA_WR_SEL15_SEL31(base, value) (XBARA_RMW_SEL15(base, XBARA_SEL15_SEL31_MASK, XBARA_SEL15_SEL31(value)))
#define XBARA_BWR_SEL15_SEL31(base, value) (BME_BFI16(&XBARA_SEL15_REG(base), ((uint16_t)(value) << XBARA_SEL15_SEL31_SHIFT), XBARA_SEL15_SEL31_SHIFT, XBARA_SEL15_SEL31_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL16 - Crossbar A Select Register 16
 ******************************************************************************/

/*!
 * @brief XBARA_SEL16 - Crossbar A Select Register 16 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL16 register
 */
/*@{*/
#define XBARA_RD_SEL16(base)     (XBARA_SEL16_REG(base))
#define XBARA_WR_SEL16(base, value) (XBARA_SEL16_REG(base) = (value))
#define XBARA_RMW_SEL16(base, mask, value) (XBARA_WR_SEL16(base, (XBARA_RD_SEL16(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL16(base, value) (BME_OR16(&XBARA_SEL16_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL16(base, value) (BME_AND16(&XBARA_SEL16_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL16(base, value) (BME_XOR16(&XBARA_SEL16_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL16 bitfields
 */

/*!
 * @name Register XBARA_SEL16, field SEL32[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT32 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL16_SEL32 field. */
#define XBARA_RD_SEL16_SEL32(base) ((XBARA_SEL16_REG(base) & XBARA_SEL16_SEL32_MASK) >> XBARA_SEL16_SEL32_SHIFT)
#define XBARA_BRD_SEL16_SEL32(base) (BME_UBFX16(&XBARA_SEL16_REG(base), XBARA_SEL16_SEL32_SHIFT, XBARA_SEL16_SEL32_WIDTH))

/*! @brief Set the SEL32 field to a new value. */
#define XBARA_WR_SEL16_SEL32(base, value) (XBARA_RMW_SEL16(base, XBARA_SEL16_SEL32_MASK, XBARA_SEL16_SEL32(value)))
#define XBARA_BWR_SEL16_SEL32(base, value) (BME_BFI16(&XBARA_SEL16_REG(base), ((uint16_t)(value) << XBARA_SEL16_SEL32_SHIFT), XBARA_SEL16_SEL32_SHIFT, XBARA_SEL16_SEL32_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL16, field SEL33[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT33 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL16_SEL33 field. */
#define XBARA_RD_SEL16_SEL33(base) ((XBARA_SEL16_REG(base) & XBARA_SEL16_SEL33_MASK) >> XBARA_SEL16_SEL33_SHIFT)
#define XBARA_BRD_SEL16_SEL33(base) (BME_UBFX16(&XBARA_SEL16_REG(base), XBARA_SEL16_SEL33_SHIFT, XBARA_SEL16_SEL33_WIDTH))

/*! @brief Set the SEL33 field to a new value. */
#define XBARA_WR_SEL16_SEL33(base, value) (XBARA_RMW_SEL16(base, XBARA_SEL16_SEL33_MASK, XBARA_SEL16_SEL33(value)))
#define XBARA_BWR_SEL16_SEL33(base, value) (BME_BFI16(&XBARA_SEL16_REG(base), ((uint16_t)(value) << XBARA_SEL16_SEL33_SHIFT), XBARA_SEL16_SEL33_SHIFT, XBARA_SEL16_SEL33_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL17 - Crossbar A Select Register 17
 ******************************************************************************/

/*!
 * @brief XBARA_SEL17 - Crossbar A Select Register 17 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL17 register
 */
/*@{*/
#define XBARA_RD_SEL17(base)     (XBARA_SEL17_REG(base))
#define XBARA_WR_SEL17(base, value) (XBARA_SEL17_REG(base) = (value))
#define XBARA_RMW_SEL17(base, mask, value) (XBARA_WR_SEL17(base, (XBARA_RD_SEL17(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL17(base, value) (BME_OR16(&XBARA_SEL17_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL17(base, value) (BME_AND16(&XBARA_SEL17_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL17(base, value) (BME_XOR16(&XBARA_SEL17_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL17 bitfields
 */

/*!
 * @name Register XBARA_SEL17, field SEL34[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT34 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL17_SEL34 field. */
#define XBARA_RD_SEL17_SEL34(base) ((XBARA_SEL17_REG(base) & XBARA_SEL17_SEL34_MASK) >> XBARA_SEL17_SEL34_SHIFT)
#define XBARA_BRD_SEL17_SEL34(base) (BME_UBFX16(&XBARA_SEL17_REG(base), XBARA_SEL17_SEL34_SHIFT, XBARA_SEL17_SEL34_WIDTH))

/*! @brief Set the SEL34 field to a new value. */
#define XBARA_WR_SEL17_SEL34(base, value) (XBARA_RMW_SEL17(base, XBARA_SEL17_SEL34_MASK, XBARA_SEL17_SEL34(value)))
#define XBARA_BWR_SEL17_SEL34(base, value) (BME_BFI16(&XBARA_SEL17_REG(base), ((uint16_t)(value) << XBARA_SEL17_SEL34_SHIFT), XBARA_SEL17_SEL34_SHIFT, XBARA_SEL17_SEL34_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL17, field SEL35[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT35 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL17_SEL35 field. */
#define XBARA_RD_SEL17_SEL35(base) ((XBARA_SEL17_REG(base) & XBARA_SEL17_SEL35_MASK) >> XBARA_SEL17_SEL35_SHIFT)
#define XBARA_BRD_SEL17_SEL35(base) (BME_UBFX16(&XBARA_SEL17_REG(base), XBARA_SEL17_SEL35_SHIFT, XBARA_SEL17_SEL35_WIDTH))

/*! @brief Set the SEL35 field to a new value. */
#define XBARA_WR_SEL17_SEL35(base, value) (XBARA_RMW_SEL17(base, XBARA_SEL17_SEL35_MASK, XBARA_SEL17_SEL35(value)))
#define XBARA_BWR_SEL17_SEL35(base, value) (BME_BFI16(&XBARA_SEL17_REG(base), ((uint16_t)(value) << XBARA_SEL17_SEL35_SHIFT), XBARA_SEL17_SEL35_SHIFT, XBARA_SEL17_SEL35_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL18 - Crossbar A Select Register 18
 ******************************************************************************/

/*!
 * @brief XBARA_SEL18 - Crossbar A Select Register 18 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL18 register
 */
/*@{*/
#define XBARA_RD_SEL18(base)     (XBARA_SEL18_REG(base))
#define XBARA_WR_SEL18(base, value) (XBARA_SEL18_REG(base) = (value))
#define XBARA_RMW_SEL18(base, mask, value) (XBARA_WR_SEL18(base, (XBARA_RD_SEL18(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL18(base, value) (BME_OR16(&XBARA_SEL18_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL18(base, value) (BME_AND16(&XBARA_SEL18_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL18(base, value) (BME_XOR16(&XBARA_SEL18_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL18 bitfields
 */

/*!
 * @name Register XBARA_SEL18, field SEL36[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT36 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL18_SEL36 field. */
#define XBARA_RD_SEL18_SEL36(base) ((XBARA_SEL18_REG(base) & XBARA_SEL18_SEL36_MASK) >> XBARA_SEL18_SEL36_SHIFT)
#define XBARA_BRD_SEL18_SEL36(base) (BME_UBFX16(&XBARA_SEL18_REG(base), XBARA_SEL18_SEL36_SHIFT, XBARA_SEL18_SEL36_WIDTH))

/*! @brief Set the SEL36 field to a new value. */
#define XBARA_WR_SEL18_SEL36(base, value) (XBARA_RMW_SEL18(base, XBARA_SEL18_SEL36_MASK, XBARA_SEL18_SEL36(value)))
#define XBARA_BWR_SEL18_SEL36(base, value) (BME_BFI16(&XBARA_SEL18_REG(base), ((uint16_t)(value) << XBARA_SEL18_SEL36_SHIFT), XBARA_SEL18_SEL36_SHIFT, XBARA_SEL18_SEL36_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL18, field SEL37[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT37 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL18_SEL37 field. */
#define XBARA_RD_SEL18_SEL37(base) ((XBARA_SEL18_REG(base) & XBARA_SEL18_SEL37_MASK) >> XBARA_SEL18_SEL37_SHIFT)
#define XBARA_BRD_SEL18_SEL37(base) (BME_UBFX16(&XBARA_SEL18_REG(base), XBARA_SEL18_SEL37_SHIFT, XBARA_SEL18_SEL37_WIDTH))

/*! @brief Set the SEL37 field to a new value. */
#define XBARA_WR_SEL18_SEL37(base, value) (XBARA_RMW_SEL18(base, XBARA_SEL18_SEL37_MASK, XBARA_SEL18_SEL37(value)))
#define XBARA_BWR_SEL18_SEL37(base, value) (BME_BFI16(&XBARA_SEL18_REG(base), ((uint16_t)(value) << XBARA_SEL18_SEL37_SHIFT), XBARA_SEL18_SEL37_SHIFT, XBARA_SEL18_SEL37_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL19 - Crossbar A Select Register 19
 ******************************************************************************/

/*!
 * @brief XBARA_SEL19 - Crossbar A Select Register 19 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL19 register
 */
/*@{*/
#define XBARA_RD_SEL19(base)     (XBARA_SEL19_REG(base))
#define XBARA_WR_SEL19(base, value) (XBARA_SEL19_REG(base) = (value))
#define XBARA_RMW_SEL19(base, mask, value) (XBARA_WR_SEL19(base, (XBARA_RD_SEL19(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL19(base, value) (BME_OR16(&XBARA_SEL19_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL19(base, value) (BME_AND16(&XBARA_SEL19_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL19(base, value) (BME_XOR16(&XBARA_SEL19_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL19 bitfields
 */

/*!
 * @name Register XBARA_SEL19, field SEL38[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT38 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL19_SEL38 field. */
#define XBARA_RD_SEL19_SEL38(base) ((XBARA_SEL19_REG(base) & XBARA_SEL19_SEL38_MASK) >> XBARA_SEL19_SEL38_SHIFT)
#define XBARA_BRD_SEL19_SEL38(base) (BME_UBFX16(&XBARA_SEL19_REG(base), XBARA_SEL19_SEL38_SHIFT, XBARA_SEL19_SEL38_WIDTH))

/*! @brief Set the SEL38 field to a new value. */
#define XBARA_WR_SEL19_SEL38(base, value) (XBARA_RMW_SEL19(base, XBARA_SEL19_SEL38_MASK, XBARA_SEL19_SEL38(value)))
#define XBARA_BWR_SEL19_SEL38(base, value) (BME_BFI16(&XBARA_SEL19_REG(base), ((uint16_t)(value) << XBARA_SEL19_SEL38_SHIFT), XBARA_SEL19_SEL38_SHIFT, XBARA_SEL19_SEL38_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL19, field SEL39[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT39 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL19_SEL39 field. */
#define XBARA_RD_SEL19_SEL39(base) ((XBARA_SEL19_REG(base) & XBARA_SEL19_SEL39_MASK) >> XBARA_SEL19_SEL39_SHIFT)
#define XBARA_BRD_SEL19_SEL39(base) (BME_UBFX16(&XBARA_SEL19_REG(base), XBARA_SEL19_SEL39_SHIFT, XBARA_SEL19_SEL39_WIDTH))

/*! @brief Set the SEL39 field to a new value. */
#define XBARA_WR_SEL19_SEL39(base, value) (XBARA_RMW_SEL19(base, XBARA_SEL19_SEL39_MASK, XBARA_SEL19_SEL39(value)))
#define XBARA_BWR_SEL19_SEL39(base, value) (BME_BFI16(&XBARA_SEL19_REG(base), ((uint16_t)(value) << XBARA_SEL19_SEL39_SHIFT), XBARA_SEL19_SEL39_SHIFT, XBARA_SEL19_SEL39_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL20 - Crossbar A Select Register 20
 ******************************************************************************/

/*!
 * @brief XBARA_SEL20 - Crossbar A Select Register 20 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL20 register
 */
/*@{*/
#define XBARA_RD_SEL20(base)     (XBARA_SEL20_REG(base))
#define XBARA_WR_SEL20(base, value) (XBARA_SEL20_REG(base) = (value))
#define XBARA_RMW_SEL20(base, mask, value) (XBARA_WR_SEL20(base, (XBARA_RD_SEL20(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL20(base, value) (BME_OR16(&XBARA_SEL20_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL20(base, value) (BME_AND16(&XBARA_SEL20_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL20(base, value) (BME_XOR16(&XBARA_SEL20_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL20 bitfields
 */

/*!
 * @name Register XBARA_SEL20, field SEL40[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT40 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL20_SEL40 field. */
#define XBARA_RD_SEL20_SEL40(base) ((XBARA_SEL20_REG(base) & XBARA_SEL20_SEL40_MASK) >> XBARA_SEL20_SEL40_SHIFT)
#define XBARA_BRD_SEL20_SEL40(base) (BME_UBFX16(&XBARA_SEL20_REG(base), XBARA_SEL20_SEL40_SHIFT, XBARA_SEL20_SEL40_WIDTH))

/*! @brief Set the SEL40 field to a new value. */
#define XBARA_WR_SEL20_SEL40(base, value) (XBARA_RMW_SEL20(base, XBARA_SEL20_SEL40_MASK, XBARA_SEL20_SEL40(value)))
#define XBARA_BWR_SEL20_SEL40(base, value) (BME_BFI16(&XBARA_SEL20_REG(base), ((uint16_t)(value) << XBARA_SEL20_SEL40_SHIFT), XBARA_SEL20_SEL40_SHIFT, XBARA_SEL20_SEL40_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL20, field SEL41[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT41 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL20_SEL41 field. */
#define XBARA_RD_SEL20_SEL41(base) ((XBARA_SEL20_REG(base) & XBARA_SEL20_SEL41_MASK) >> XBARA_SEL20_SEL41_SHIFT)
#define XBARA_BRD_SEL20_SEL41(base) (BME_UBFX16(&XBARA_SEL20_REG(base), XBARA_SEL20_SEL41_SHIFT, XBARA_SEL20_SEL41_WIDTH))

/*! @brief Set the SEL41 field to a new value. */
#define XBARA_WR_SEL20_SEL41(base, value) (XBARA_RMW_SEL20(base, XBARA_SEL20_SEL41_MASK, XBARA_SEL20_SEL41(value)))
#define XBARA_BWR_SEL20_SEL41(base, value) (BME_BFI16(&XBARA_SEL20_REG(base), ((uint16_t)(value) << XBARA_SEL20_SEL41_SHIFT), XBARA_SEL20_SEL41_SHIFT, XBARA_SEL20_SEL41_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL21 - Crossbar A Select Register 21
 ******************************************************************************/

/*!
 * @brief XBARA_SEL21 - Crossbar A Select Register 21 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL21 register
 */
/*@{*/
#define XBARA_RD_SEL21(base)     (XBARA_SEL21_REG(base))
#define XBARA_WR_SEL21(base, value) (XBARA_SEL21_REG(base) = (value))
#define XBARA_RMW_SEL21(base, mask, value) (XBARA_WR_SEL21(base, (XBARA_RD_SEL21(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL21(base, value) (BME_OR16(&XBARA_SEL21_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL21(base, value) (BME_AND16(&XBARA_SEL21_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL21(base, value) (BME_XOR16(&XBARA_SEL21_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL21 bitfields
 */

/*!
 * @name Register XBARA_SEL21, field SEL42[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT42 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL21_SEL42 field. */
#define XBARA_RD_SEL21_SEL42(base) ((XBARA_SEL21_REG(base) & XBARA_SEL21_SEL42_MASK) >> XBARA_SEL21_SEL42_SHIFT)
#define XBARA_BRD_SEL21_SEL42(base) (BME_UBFX16(&XBARA_SEL21_REG(base), XBARA_SEL21_SEL42_SHIFT, XBARA_SEL21_SEL42_WIDTH))

/*! @brief Set the SEL42 field to a new value. */
#define XBARA_WR_SEL21_SEL42(base, value) (XBARA_RMW_SEL21(base, XBARA_SEL21_SEL42_MASK, XBARA_SEL21_SEL42(value)))
#define XBARA_BWR_SEL21_SEL42(base, value) (BME_BFI16(&XBARA_SEL21_REG(base), ((uint16_t)(value) << XBARA_SEL21_SEL42_SHIFT), XBARA_SEL21_SEL42_SHIFT, XBARA_SEL21_SEL42_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL21, field SEL43[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT43 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL21_SEL43 field. */
#define XBARA_RD_SEL21_SEL43(base) ((XBARA_SEL21_REG(base) & XBARA_SEL21_SEL43_MASK) >> XBARA_SEL21_SEL43_SHIFT)
#define XBARA_BRD_SEL21_SEL43(base) (BME_UBFX16(&XBARA_SEL21_REG(base), XBARA_SEL21_SEL43_SHIFT, XBARA_SEL21_SEL43_WIDTH))

/*! @brief Set the SEL43 field to a new value. */
#define XBARA_WR_SEL21_SEL43(base, value) (XBARA_RMW_SEL21(base, XBARA_SEL21_SEL43_MASK, XBARA_SEL21_SEL43(value)))
#define XBARA_BWR_SEL21_SEL43(base, value) (BME_BFI16(&XBARA_SEL21_REG(base), ((uint16_t)(value) << XBARA_SEL21_SEL43_SHIFT), XBARA_SEL21_SEL43_SHIFT, XBARA_SEL21_SEL43_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL22 - Crossbar A Select Register 22
 ******************************************************************************/

/*!
 * @brief XBARA_SEL22 - Crossbar A Select Register 22 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL22 register
 */
/*@{*/
#define XBARA_RD_SEL22(base)     (XBARA_SEL22_REG(base))
#define XBARA_WR_SEL22(base, value) (XBARA_SEL22_REG(base) = (value))
#define XBARA_RMW_SEL22(base, mask, value) (XBARA_WR_SEL22(base, (XBARA_RD_SEL22(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL22(base, value) (BME_OR16(&XBARA_SEL22_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL22(base, value) (BME_AND16(&XBARA_SEL22_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL22(base, value) (BME_XOR16(&XBARA_SEL22_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL22 bitfields
 */

/*!
 * @name Register XBARA_SEL22, field SEL44[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT44 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL22_SEL44 field. */
#define XBARA_RD_SEL22_SEL44(base) ((XBARA_SEL22_REG(base) & XBARA_SEL22_SEL44_MASK) >> XBARA_SEL22_SEL44_SHIFT)
#define XBARA_BRD_SEL22_SEL44(base) (BME_UBFX16(&XBARA_SEL22_REG(base), XBARA_SEL22_SEL44_SHIFT, XBARA_SEL22_SEL44_WIDTH))

/*! @brief Set the SEL44 field to a new value. */
#define XBARA_WR_SEL22_SEL44(base, value) (XBARA_RMW_SEL22(base, XBARA_SEL22_SEL44_MASK, XBARA_SEL22_SEL44(value)))
#define XBARA_BWR_SEL22_SEL44(base, value) (BME_BFI16(&XBARA_SEL22_REG(base), ((uint16_t)(value) << XBARA_SEL22_SEL44_SHIFT), XBARA_SEL22_SEL44_SHIFT, XBARA_SEL22_SEL44_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL22, field SEL45[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT45 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL22_SEL45 field. */
#define XBARA_RD_SEL22_SEL45(base) ((XBARA_SEL22_REG(base) & XBARA_SEL22_SEL45_MASK) >> XBARA_SEL22_SEL45_SHIFT)
#define XBARA_BRD_SEL22_SEL45(base) (BME_UBFX16(&XBARA_SEL22_REG(base), XBARA_SEL22_SEL45_SHIFT, XBARA_SEL22_SEL45_WIDTH))

/*! @brief Set the SEL45 field to a new value. */
#define XBARA_WR_SEL22_SEL45(base, value) (XBARA_RMW_SEL22(base, XBARA_SEL22_SEL45_MASK, XBARA_SEL22_SEL45(value)))
#define XBARA_BWR_SEL22_SEL45(base, value) (BME_BFI16(&XBARA_SEL22_REG(base), ((uint16_t)(value) << XBARA_SEL22_SEL45_SHIFT), XBARA_SEL22_SEL45_SHIFT, XBARA_SEL22_SEL45_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL23 - Crossbar A Select Register 23
 ******************************************************************************/

/*!
 * @brief XBARA_SEL23 - Crossbar A Select Register 23 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL23 register
 */
/*@{*/
#define XBARA_RD_SEL23(base)     (XBARA_SEL23_REG(base))
#define XBARA_WR_SEL23(base, value) (XBARA_SEL23_REG(base) = (value))
#define XBARA_RMW_SEL23(base, mask, value) (XBARA_WR_SEL23(base, (XBARA_RD_SEL23(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL23(base, value) (BME_OR16(&XBARA_SEL23_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL23(base, value) (BME_AND16(&XBARA_SEL23_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL23(base, value) (BME_XOR16(&XBARA_SEL23_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL23 bitfields
 */

/*!
 * @name Register XBARA_SEL23, field SEL46[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT46 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL23_SEL46 field. */
#define XBARA_RD_SEL23_SEL46(base) ((XBARA_SEL23_REG(base) & XBARA_SEL23_SEL46_MASK) >> XBARA_SEL23_SEL46_SHIFT)
#define XBARA_BRD_SEL23_SEL46(base) (BME_UBFX16(&XBARA_SEL23_REG(base), XBARA_SEL23_SEL46_SHIFT, XBARA_SEL23_SEL46_WIDTH))

/*! @brief Set the SEL46 field to a new value. */
#define XBARA_WR_SEL23_SEL46(base, value) (XBARA_RMW_SEL23(base, XBARA_SEL23_SEL46_MASK, XBARA_SEL23_SEL46(value)))
#define XBARA_BWR_SEL23_SEL46(base, value) (BME_BFI16(&XBARA_SEL23_REG(base), ((uint16_t)(value) << XBARA_SEL23_SEL46_SHIFT), XBARA_SEL23_SEL46_SHIFT, XBARA_SEL23_SEL46_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL23, field SEL47[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT47 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL23_SEL47 field. */
#define XBARA_RD_SEL23_SEL47(base) ((XBARA_SEL23_REG(base) & XBARA_SEL23_SEL47_MASK) >> XBARA_SEL23_SEL47_SHIFT)
#define XBARA_BRD_SEL23_SEL47(base) (BME_UBFX16(&XBARA_SEL23_REG(base), XBARA_SEL23_SEL47_SHIFT, XBARA_SEL23_SEL47_WIDTH))

/*! @brief Set the SEL47 field to a new value. */
#define XBARA_WR_SEL23_SEL47(base, value) (XBARA_RMW_SEL23(base, XBARA_SEL23_SEL47_MASK, XBARA_SEL23_SEL47(value)))
#define XBARA_BWR_SEL23_SEL47(base, value) (BME_BFI16(&XBARA_SEL23_REG(base), ((uint16_t)(value) << XBARA_SEL23_SEL47_SHIFT), XBARA_SEL23_SEL47_SHIFT, XBARA_SEL23_SEL47_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL24 - Crossbar A Select Register 24
 ******************************************************************************/

/*!
 * @brief XBARA_SEL24 - Crossbar A Select Register 24 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL24 register
 */
/*@{*/
#define XBARA_RD_SEL24(base)     (XBARA_SEL24_REG(base))
#define XBARA_WR_SEL24(base, value) (XBARA_SEL24_REG(base) = (value))
#define XBARA_RMW_SEL24(base, mask, value) (XBARA_WR_SEL24(base, (XBARA_RD_SEL24(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL24(base, value) (BME_OR16(&XBARA_SEL24_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL24(base, value) (BME_AND16(&XBARA_SEL24_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL24(base, value) (BME_XOR16(&XBARA_SEL24_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL24 bitfields
 */

/*!
 * @name Register XBARA_SEL24, field SEL48[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT48 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL24_SEL48 field. */
#define XBARA_RD_SEL24_SEL48(base) ((XBARA_SEL24_REG(base) & XBARA_SEL24_SEL48_MASK) >> XBARA_SEL24_SEL48_SHIFT)
#define XBARA_BRD_SEL24_SEL48(base) (BME_UBFX16(&XBARA_SEL24_REG(base), XBARA_SEL24_SEL48_SHIFT, XBARA_SEL24_SEL48_WIDTH))

/*! @brief Set the SEL48 field to a new value. */
#define XBARA_WR_SEL24_SEL48(base, value) (XBARA_RMW_SEL24(base, XBARA_SEL24_SEL48_MASK, XBARA_SEL24_SEL48(value)))
#define XBARA_BWR_SEL24_SEL48(base, value) (BME_BFI16(&XBARA_SEL24_REG(base), ((uint16_t)(value) << XBARA_SEL24_SEL48_SHIFT), XBARA_SEL24_SEL48_SHIFT, XBARA_SEL24_SEL48_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL24, field SEL49[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT49 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL24_SEL49 field. */
#define XBARA_RD_SEL24_SEL49(base) ((XBARA_SEL24_REG(base) & XBARA_SEL24_SEL49_MASK) >> XBARA_SEL24_SEL49_SHIFT)
#define XBARA_BRD_SEL24_SEL49(base) (BME_UBFX16(&XBARA_SEL24_REG(base), XBARA_SEL24_SEL49_SHIFT, XBARA_SEL24_SEL49_WIDTH))

/*! @brief Set the SEL49 field to a new value. */
#define XBARA_WR_SEL24_SEL49(base, value) (XBARA_RMW_SEL24(base, XBARA_SEL24_SEL49_MASK, XBARA_SEL24_SEL49(value)))
#define XBARA_BWR_SEL24_SEL49(base, value) (BME_BFI16(&XBARA_SEL24_REG(base), ((uint16_t)(value) << XBARA_SEL24_SEL49_SHIFT), XBARA_SEL24_SEL49_SHIFT, XBARA_SEL24_SEL49_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL25 - Crossbar A Select Register 25
 ******************************************************************************/

/*!
 * @brief XBARA_SEL25 - Crossbar A Select Register 25 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL25 register
 */
/*@{*/
#define XBARA_RD_SEL25(base)     (XBARA_SEL25_REG(base))
#define XBARA_WR_SEL25(base, value) (XBARA_SEL25_REG(base) = (value))
#define XBARA_RMW_SEL25(base, mask, value) (XBARA_WR_SEL25(base, (XBARA_RD_SEL25(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL25(base, value) (BME_OR16(&XBARA_SEL25_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL25(base, value) (BME_AND16(&XBARA_SEL25_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL25(base, value) (BME_XOR16(&XBARA_SEL25_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL25 bitfields
 */

/*!
 * @name Register XBARA_SEL25, field SEL50[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT50 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL25_SEL50 field. */
#define XBARA_RD_SEL25_SEL50(base) ((XBARA_SEL25_REG(base) & XBARA_SEL25_SEL50_MASK) >> XBARA_SEL25_SEL50_SHIFT)
#define XBARA_BRD_SEL25_SEL50(base) (BME_UBFX16(&XBARA_SEL25_REG(base), XBARA_SEL25_SEL50_SHIFT, XBARA_SEL25_SEL50_WIDTH))

/*! @brief Set the SEL50 field to a new value. */
#define XBARA_WR_SEL25_SEL50(base, value) (XBARA_RMW_SEL25(base, XBARA_SEL25_SEL50_MASK, XBARA_SEL25_SEL50(value)))
#define XBARA_BWR_SEL25_SEL50(base, value) (BME_BFI16(&XBARA_SEL25_REG(base), ((uint16_t)(value) << XBARA_SEL25_SEL50_SHIFT), XBARA_SEL25_SEL50_SHIFT, XBARA_SEL25_SEL50_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL25, field SEL51[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT51 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL25_SEL51 field. */
#define XBARA_RD_SEL25_SEL51(base) ((XBARA_SEL25_REG(base) & XBARA_SEL25_SEL51_MASK) >> XBARA_SEL25_SEL51_SHIFT)
#define XBARA_BRD_SEL25_SEL51(base) (BME_UBFX16(&XBARA_SEL25_REG(base), XBARA_SEL25_SEL51_SHIFT, XBARA_SEL25_SEL51_WIDTH))

/*! @brief Set the SEL51 field to a new value. */
#define XBARA_WR_SEL25_SEL51(base, value) (XBARA_RMW_SEL25(base, XBARA_SEL25_SEL51_MASK, XBARA_SEL25_SEL51(value)))
#define XBARA_BWR_SEL25_SEL51(base, value) (BME_BFI16(&XBARA_SEL25_REG(base), ((uint16_t)(value) << XBARA_SEL25_SEL51_SHIFT), XBARA_SEL25_SEL51_SHIFT, XBARA_SEL25_SEL51_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL26 - Crossbar A Select Register 26
 ******************************************************************************/

/*!
 * @brief XBARA_SEL26 - Crossbar A Select Register 26 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL26 register
 */
/*@{*/
#define XBARA_RD_SEL26(base)     (XBARA_SEL26_REG(base))
#define XBARA_WR_SEL26(base, value) (XBARA_SEL26_REG(base) = (value))
#define XBARA_RMW_SEL26(base, mask, value) (XBARA_WR_SEL26(base, (XBARA_RD_SEL26(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL26(base, value) (BME_OR16(&XBARA_SEL26_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL26(base, value) (BME_AND16(&XBARA_SEL26_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL26(base, value) (BME_XOR16(&XBARA_SEL26_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL26 bitfields
 */

/*!
 * @name Register XBARA_SEL26, field SEL52[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT52 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL26_SEL52 field. */
#define XBARA_RD_SEL26_SEL52(base) ((XBARA_SEL26_REG(base) & XBARA_SEL26_SEL52_MASK) >> XBARA_SEL26_SEL52_SHIFT)
#define XBARA_BRD_SEL26_SEL52(base) (BME_UBFX16(&XBARA_SEL26_REG(base), XBARA_SEL26_SEL52_SHIFT, XBARA_SEL26_SEL52_WIDTH))

/*! @brief Set the SEL52 field to a new value. */
#define XBARA_WR_SEL26_SEL52(base, value) (XBARA_RMW_SEL26(base, XBARA_SEL26_SEL52_MASK, XBARA_SEL26_SEL52(value)))
#define XBARA_BWR_SEL26_SEL52(base, value) (BME_BFI16(&XBARA_SEL26_REG(base), ((uint16_t)(value) << XBARA_SEL26_SEL52_SHIFT), XBARA_SEL26_SEL52_SHIFT, XBARA_SEL26_SEL52_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL26, field SEL53[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT53 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL26_SEL53 field. */
#define XBARA_RD_SEL26_SEL53(base) ((XBARA_SEL26_REG(base) & XBARA_SEL26_SEL53_MASK) >> XBARA_SEL26_SEL53_SHIFT)
#define XBARA_BRD_SEL26_SEL53(base) (BME_UBFX16(&XBARA_SEL26_REG(base), XBARA_SEL26_SEL53_SHIFT, XBARA_SEL26_SEL53_WIDTH))

/*! @brief Set the SEL53 field to a new value. */
#define XBARA_WR_SEL26_SEL53(base, value) (XBARA_RMW_SEL26(base, XBARA_SEL26_SEL53_MASK, XBARA_SEL26_SEL53(value)))
#define XBARA_BWR_SEL26_SEL53(base, value) (BME_BFI16(&XBARA_SEL26_REG(base), ((uint16_t)(value) << XBARA_SEL26_SEL53_SHIFT), XBARA_SEL26_SEL53_SHIFT, XBARA_SEL26_SEL53_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL27 - Crossbar A Select Register 27
 ******************************************************************************/

/*!
 * @brief XBARA_SEL27 - Crossbar A Select Register 27 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL27 register
 */
/*@{*/
#define XBARA_RD_SEL27(base)     (XBARA_SEL27_REG(base))
#define XBARA_WR_SEL27(base, value) (XBARA_SEL27_REG(base) = (value))
#define XBARA_RMW_SEL27(base, mask, value) (XBARA_WR_SEL27(base, (XBARA_RD_SEL27(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL27(base, value) (BME_OR16(&XBARA_SEL27_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL27(base, value) (BME_AND16(&XBARA_SEL27_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL27(base, value) (BME_XOR16(&XBARA_SEL27_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL27 bitfields
 */

/*!
 * @name Register XBARA_SEL27, field SEL54[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT54 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL27_SEL54 field. */
#define XBARA_RD_SEL27_SEL54(base) ((XBARA_SEL27_REG(base) & XBARA_SEL27_SEL54_MASK) >> XBARA_SEL27_SEL54_SHIFT)
#define XBARA_BRD_SEL27_SEL54(base) (BME_UBFX16(&XBARA_SEL27_REG(base), XBARA_SEL27_SEL54_SHIFT, XBARA_SEL27_SEL54_WIDTH))

/*! @brief Set the SEL54 field to a new value. */
#define XBARA_WR_SEL27_SEL54(base, value) (XBARA_RMW_SEL27(base, XBARA_SEL27_SEL54_MASK, XBARA_SEL27_SEL54(value)))
#define XBARA_BWR_SEL27_SEL54(base, value) (BME_BFI16(&XBARA_SEL27_REG(base), ((uint16_t)(value) << XBARA_SEL27_SEL54_SHIFT), XBARA_SEL27_SEL54_SHIFT, XBARA_SEL27_SEL54_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL27, field SEL55[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT55 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL27_SEL55 field. */
#define XBARA_RD_SEL27_SEL55(base) ((XBARA_SEL27_REG(base) & XBARA_SEL27_SEL55_MASK) >> XBARA_SEL27_SEL55_SHIFT)
#define XBARA_BRD_SEL27_SEL55(base) (BME_UBFX16(&XBARA_SEL27_REG(base), XBARA_SEL27_SEL55_SHIFT, XBARA_SEL27_SEL55_WIDTH))

/*! @brief Set the SEL55 field to a new value. */
#define XBARA_WR_SEL27_SEL55(base, value) (XBARA_RMW_SEL27(base, XBARA_SEL27_SEL55_MASK, XBARA_SEL27_SEL55(value)))
#define XBARA_BWR_SEL27_SEL55(base, value) (BME_BFI16(&XBARA_SEL27_REG(base), ((uint16_t)(value) << XBARA_SEL27_SEL55_SHIFT), XBARA_SEL27_SEL55_SHIFT, XBARA_SEL27_SEL55_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL28 - Crossbar A Select Register 28
 ******************************************************************************/

/*!
 * @brief XBARA_SEL28 - Crossbar A Select Register 28 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL28 register
 */
/*@{*/
#define XBARA_RD_SEL28(base)     (XBARA_SEL28_REG(base))
#define XBARA_WR_SEL28(base, value) (XBARA_SEL28_REG(base) = (value))
#define XBARA_RMW_SEL28(base, mask, value) (XBARA_WR_SEL28(base, (XBARA_RD_SEL28(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL28(base, value) (BME_OR16(&XBARA_SEL28_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL28(base, value) (BME_AND16(&XBARA_SEL28_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL28(base, value) (BME_XOR16(&XBARA_SEL28_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL28 bitfields
 */

/*!
 * @name Register XBARA_SEL28, field SEL56[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT56 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL28_SEL56 field. */
#define XBARA_RD_SEL28_SEL56(base) ((XBARA_SEL28_REG(base) & XBARA_SEL28_SEL56_MASK) >> XBARA_SEL28_SEL56_SHIFT)
#define XBARA_BRD_SEL28_SEL56(base) (BME_UBFX16(&XBARA_SEL28_REG(base), XBARA_SEL28_SEL56_SHIFT, XBARA_SEL28_SEL56_WIDTH))

/*! @brief Set the SEL56 field to a new value. */
#define XBARA_WR_SEL28_SEL56(base, value) (XBARA_RMW_SEL28(base, XBARA_SEL28_SEL56_MASK, XBARA_SEL28_SEL56(value)))
#define XBARA_BWR_SEL28_SEL56(base, value) (BME_BFI16(&XBARA_SEL28_REG(base), ((uint16_t)(value) << XBARA_SEL28_SEL56_SHIFT), XBARA_SEL28_SEL56_SHIFT, XBARA_SEL28_SEL56_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_SEL28, field SEL57[13:8] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT57 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL28_SEL57 field. */
#define XBARA_RD_SEL28_SEL57(base) ((XBARA_SEL28_REG(base) & XBARA_SEL28_SEL57_MASK) >> XBARA_SEL28_SEL57_SHIFT)
#define XBARA_BRD_SEL28_SEL57(base) (BME_UBFX16(&XBARA_SEL28_REG(base), XBARA_SEL28_SEL57_SHIFT, XBARA_SEL28_SEL57_WIDTH))

/*! @brief Set the SEL57 field to a new value. */
#define XBARA_WR_SEL28_SEL57(base, value) (XBARA_RMW_SEL28(base, XBARA_SEL28_SEL57_MASK, XBARA_SEL28_SEL57(value)))
#define XBARA_BWR_SEL28_SEL57(base, value) (BME_BFI16(&XBARA_SEL28_REG(base), ((uint16_t)(value) << XBARA_SEL28_SEL57_SHIFT), XBARA_SEL28_SEL57_SHIFT, XBARA_SEL28_SEL57_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_SEL29 - Crossbar A Select Register 29
 ******************************************************************************/

/*!
 * @brief XBARA_SEL29 - Crossbar A Select Register 29 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARA_SEL29 register
 */
/*@{*/
#define XBARA_RD_SEL29(base)     (XBARA_SEL29_REG(base))
#define XBARA_WR_SEL29(base, value) (XBARA_SEL29_REG(base) = (value))
#define XBARA_RMW_SEL29(base, mask, value) (XBARA_WR_SEL29(base, (XBARA_RD_SEL29(base) & ~(mask)) | (value)))
#define XBARA_SET_SEL29(base, value) (BME_OR16(&XBARA_SEL29_REG(base), (uint16_t)(value)))
#define XBARA_CLR_SEL29(base, value) (BME_AND16(&XBARA_SEL29_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_SEL29(base, value) (BME_XOR16(&XBARA_SEL29_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_SEL29 bitfields
 */

/*!
 * @name Register XBARA_SEL29, field SEL58[5:0] (RW)
 *
 * Input (XBARA_INn) to be muxed to XBARA_OUT58 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARA_SEL29_SEL58 field. */
#define XBARA_RD_SEL29_SEL58(base) ((XBARA_SEL29_REG(base) & XBARA_SEL29_SEL58_MASK) >> XBARA_SEL29_SEL58_SHIFT)
#define XBARA_BRD_SEL29_SEL58(base) (BME_UBFX16(&XBARA_SEL29_REG(base), XBARA_SEL29_SEL58_SHIFT, XBARA_SEL29_SEL58_WIDTH))

/*! @brief Set the SEL58 field to a new value. */
#define XBARA_WR_SEL29_SEL58(base, value) (XBARA_RMW_SEL29(base, XBARA_SEL29_SEL58_MASK, XBARA_SEL29_SEL58(value)))
#define XBARA_BWR_SEL29_SEL58(base, value) (BME_BFI16(&XBARA_SEL29_REG(base), ((uint16_t)(value) << XBARA_SEL29_SEL58_SHIFT), XBARA_SEL29_SEL58_SHIFT, XBARA_SEL29_SEL58_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_CTRL0 - Crossbar A Control Register 0
 ******************************************************************************/

/*!
 * @brief XBARA_CTRL0 - Crossbar A Control Register 0 (RW)
 *
 * Reset value: 0x0000U
 *
 * Use this register to configure edge detection, interrupt, and DMA features
 * for the XBAR_OUT0 and XBAR_OUT1 outputs. The XBAR_CTRL registers are organized
 * similarly to the XBAR_SEL registers, with control fields for two XBAR_OUT
 * outputs in each register. In control register 0, the LSBs contain the control
 * fields for XBAR_OUT0, and the MSBs contain the control fields for XBAR_OUT1.
 */
/*!
 * @name Constants and macros for entire XBARA_CTRL0 register
 */
/*@{*/
#define XBARA_RD_CTRL0(base)     (XBARA_CTRL0_REG(base))
#define XBARA_WR_CTRL0(base, value) (XBARA_CTRL0_REG(base) = (value))
#define XBARA_RMW_CTRL0(base, mask, value) (XBARA_WR_CTRL0(base, (XBARA_RD_CTRL0(base) & ~(mask)) | (value)))
#define XBARA_SET_CTRL0(base, value) (BME_OR16(&XBARA_CTRL0_REG(base), (uint16_t)(value)))
#define XBARA_CLR_CTRL0(base, value) (BME_AND16(&XBARA_CTRL0_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_CTRL0(base, value) (BME_XOR16(&XBARA_CTRL0_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_CTRL0 bitfields
 */

/*!
 * @name Register XBARA_CTRL0, field DEN0[0] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT0 output. When
 * enabled, DMA_REQ0 presents the value STS0. When disabled, the DMA_REQ0 output
 * remains low. IEN0 and DEN0 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_DEN0 field. */
#define XBARA_RD_CTRL0_DEN0(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_DEN0_MASK) >> XBARA_CTRL0_DEN0_SHIFT)
#define XBARA_BRD_CTRL0_DEN0(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_DEN0_SHIFT, XBARA_CTRL0_DEN0_WIDTH))

/*! @brief Set the DEN0 field to a new value. */
#define XBARA_WR_CTRL0_DEN0(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_DEN0_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_DEN0(value)))
#define XBARA_BWR_CTRL0_DEN0(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_DEN0_SHIFT), XBARA_CTRL0_DEN0_SHIFT, XBARA_CTRL0_DEN0_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field IEN0[1] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT0
 * output. When the interrupt is enabled, the output INT_REQ0 reflects the value STS0.
 * When the interrupt is disabled, INT_REQ0 remains low. The interrupt request is
 * cleared by writing a 1 to STS0. IEN0 and DEN0 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_IEN0 field. */
#define XBARA_RD_CTRL0_IEN0(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_IEN0_MASK) >> XBARA_CTRL0_IEN0_SHIFT)
#define XBARA_BRD_CTRL0_IEN0(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_IEN0_SHIFT, XBARA_CTRL0_IEN0_WIDTH))

/*! @brief Set the IEN0 field to a new value. */
#define XBARA_WR_CTRL0_IEN0(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_IEN0_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_IEN0(value)))
#define XBARA_BWR_CTRL0_IEN0(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_IEN0_SHIFT), XBARA_CTRL0_IEN0_SHIFT, XBARA_CTRL0_IEN0_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field EDGE0[3:2] (RW)
 *
 * This field selects which edges on XBAR_OUT0 cause STS0 to assert.
 *
 * Values:
 * - 0b00 - STS0 never asserts
 * - 0b01 - STS0 asserts on rising edges of XBAR_OUT0
 * - 0b10 - STS0 asserts on falling edges of XBAR_OUT0
 * - 0b11 - STS0 asserts on rising and falling edges of XBAR_OUT0
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_EDGE0 field. */
#define XBARA_RD_CTRL0_EDGE0(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_EDGE0_MASK) >> XBARA_CTRL0_EDGE0_SHIFT)
#define XBARA_BRD_CTRL0_EDGE0(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_EDGE0_SHIFT, XBARA_CTRL0_EDGE0_WIDTH))

/*! @brief Set the EDGE0 field to a new value. */
#define XBARA_WR_CTRL0_EDGE0(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_EDGE0_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_EDGE0(value)))
#define XBARA_BWR_CTRL0_EDGE0(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_EDGE0_SHIFT), XBARA_CTRL0_EDGE0_SHIFT, XBARA_CTRL0_EDGE0_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field STS0[4] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT0. This field is
 * set to 1 when an edge consistent with the current setting of EDGE0 is detected
 * on XBAR_OUT0. This field is cleared by writing 1 to it or by a DMA_ACK0
 * reception when DEN0 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT0, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT0
 * - 0b1 - Active edge detected on XBAR_OUT0
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_STS0 field. */
#define XBARA_RD_CTRL0_STS0(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_STS0_MASK) >> XBARA_CTRL0_STS0_SHIFT)
#define XBARA_BRD_CTRL0_STS0(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_STS0_SHIFT, XBARA_CTRL0_STS0_WIDTH))

/*! @brief Set the STS0 field to a new value. */
#define XBARA_WR_CTRL0_STS0(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_STS0(value)))
#define XBARA_BWR_CTRL0_STS0(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_STS0_SHIFT), XBARA_CTRL0_STS0_SHIFT, XBARA_CTRL0_STS0_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field DEN1[8] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT1 output. When
 * enabled, DMA_REQ1 presents the value STS1. When disabled, the DMA_REQ1 output
 * remains low. IEN1 and DEN1 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_DEN1 field. */
#define XBARA_RD_CTRL0_DEN1(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_DEN1_MASK) >> XBARA_CTRL0_DEN1_SHIFT)
#define XBARA_BRD_CTRL0_DEN1(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_DEN1_SHIFT, XBARA_CTRL0_DEN1_WIDTH))

/*! @brief Set the DEN1 field to a new value. */
#define XBARA_WR_CTRL0_DEN1(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_DEN1_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_DEN1(value)))
#define XBARA_BWR_CTRL0_DEN1(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_DEN1_SHIFT), XBARA_CTRL0_DEN1_SHIFT, XBARA_CTRL0_DEN1_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field IEN1[9] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT1
 * output. When the interrupt is enabled, the output INT_REQ1 reflects the value STS1.
 * When the interrupt is disabled, INT_REQ1 remains low. The interrupt request is
 * cleared by writing a 1 to STS1. IEN1 and DEN1 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_IEN1 field. */
#define XBARA_RD_CTRL0_IEN1(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_IEN1_MASK) >> XBARA_CTRL0_IEN1_SHIFT)
#define XBARA_BRD_CTRL0_IEN1(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_IEN1_SHIFT, XBARA_CTRL0_IEN1_WIDTH))

/*! @brief Set the IEN1 field to a new value. */
#define XBARA_WR_CTRL0_IEN1(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_IEN1_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_IEN1(value)))
#define XBARA_BWR_CTRL0_IEN1(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_IEN1_SHIFT), XBARA_CTRL0_IEN1_SHIFT, XBARA_CTRL0_IEN1_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field EDGE1[11:10] (RW)
 *
 * This field selects which edges on XBAR_OUT1 cause STS1 to assert.
 *
 * Values:
 * - 0b00 - STS1 never asserts
 * - 0b01 - STS1 asserts on rising edges of XBAR_OUT1
 * - 0b10 - STS1 asserts on falling edges of XBAR_OUT1
 * - 0b11 - STS1 asserts on rising and falling edges of XBAR_OUT1
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_EDGE1 field. */
#define XBARA_RD_CTRL0_EDGE1(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_EDGE1_MASK) >> XBARA_CTRL0_EDGE1_SHIFT)
#define XBARA_BRD_CTRL0_EDGE1(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_EDGE1_SHIFT, XBARA_CTRL0_EDGE1_WIDTH))

/*! @brief Set the EDGE1 field to a new value. */
#define XBARA_WR_CTRL0_EDGE1(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_EDGE1_MASK | XBARA_CTRL0_STS0_MASK | XBARA_CTRL0_STS1_MASK), XBARA_CTRL0_EDGE1(value)))
#define XBARA_BWR_CTRL0_EDGE1(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_EDGE1_SHIFT), XBARA_CTRL0_EDGE1_SHIFT, XBARA_CTRL0_EDGE1_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL0, field STS1[12] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT1. This field is
 * set to 1 when an edge consistent with the current setting of EDGE1 is detected
 * on XBAR_OUT1. This field is cleared by writing 1 to it or by a DMA_ACK1
 * reception when DEN1 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT1, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT1
 * - 0b1 - Active edge detected on XBAR_OUT1
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL0_STS1 field. */
#define XBARA_RD_CTRL0_STS1(base) ((XBARA_CTRL0_REG(base) & XBARA_CTRL0_STS1_MASK) >> XBARA_CTRL0_STS1_SHIFT)
#define XBARA_BRD_CTRL0_STS1(base) (BME_UBFX16(&XBARA_CTRL0_REG(base), XBARA_CTRL0_STS1_SHIFT, XBARA_CTRL0_STS1_WIDTH))

/*! @brief Set the STS1 field to a new value. */
#define XBARA_WR_CTRL0_STS1(base, value) (XBARA_RMW_CTRL0(base, (XBARA_CTRL0_STS1_MASK | XBARA_CTRL0_STS0_MASK), XBARA_CTRL0_STS1(value)))
#define XBARA_BWR_CTRL0_STS1(base, value) (BME_BFI16(&XBARA_CTRL0_REG(base), ((uint16_t)(value) << XBARA_CTRL0_STS1_SHIFT), XBARA_CTRL0_STS1_SHIFT, XBARA_CTRL0_STS1_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARA_CTRL1 - Crossbar A Control Register 1
 ******************************************************************************/

/*!
 * @brief XBARA_CTRL1 - Crossbar A Control Register 1 (RW)
 *
 * Reset value: 0x0000U
 *
 * Use this register to configure edge detection, interrupt, and DMA features
 * for the XBAR_OUT2 and XBAR_OUT3 outputs. The XBAR_CTRL registers are organized
 * similarly to the XBAR_SEL registers, with control fields for two XBAR_OUT
 * outputs in each register. In control register 1, the LSBs contain the control
 * fields for XBAR_OUT2, and the MSBs contain the control fields for XBAR_OUT3.
 */
/*!
 * @name Constants and macros for entire XBARA_CTRL1 register
 */
/*@{*/
#define XBARA_RD_CTRL1(base)     (XBARA_CTRL1_REG(base))
#define XBARA_WR_CTRL1(base, value) (XBARA_CTRL1_REG(base) = (value))
#define XBARA_RMW_CTRL1(base, mask, value) (XBARA_WR_CTRL1(base, (XBARA_RD_CTRL1(base) & ~(mask)) | (value)))
#define XBARA_SET_CTRL1(base, value) (BME_OR16(&XBARA_CTRL1_REG(base), (uint16_t)(value)))
#define XBARA_CLR_CTRL1(base, value) (BME_AND16(&XBARA_CTRL1_REG(base), (uint16_t)(~(value))))
#define XBARA_TOG_CTRL1(base, value) (BME_XOR16(&XBARA_CTRL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARA_CTRL1 bitfields
 */

/*!
 * @name Register XBARA_CTRL1, field DEN2[0] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT2 output. When
 * enabled, DMA_REQ2 presents the value STS2. When disabled, the DMA_REQ2 output
 * remains low. IEN2 and DEN2 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_DEN2 field. */
#define XBARA_RD_CTRL1_DEN2(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_DEN2_MASK) >> XBARA_CTRL1_DEN2_SHIFT)
#define XBARA_BRD_CTRL1_DEN2(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_DEN2_SHIFT, XBARA_CTRL1_DEN2_WIDTH))

/*! @brief Set the DEN2 field to a new value. */
#define XBARA_WR_CTRL1_DEN2(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_DEN2_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_DEN2(value)))
#define XBARA_BWR_CTRL1_DEN2(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_DEN2_SHIFT), XBARA_CTRL1_DEN2_SHIFT, XBARA_CTRL1_DEN2_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field IEN2[1] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT2
 * output. When the interrupt is enabled, the output INT_REQ2 reflects the value STS2.
 * When the interrupt is disabled, INT_REQ2 remains low. The interrupt request is
 * cleared by writing a 1 to STS2. IEN2 and DEN2 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_IEN2 field. */
#define XBARA_RD_CTRL1_IEN2(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_IEN2_MASK) >> XBARA_CTRL1_IEN2_SHIFT)
#define XBARA_BRD_CTRL1_IEN2(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_IEN2_SHIFT, XBARA_CTRL1_IEN2_WIDTH))

/*! @brief Set the IEN2 field to a new value. */
#define XBARA_WR_CTRL1_IEN2(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_IEN2_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_IEN2(value)))
#define XBARA_BWR_CTRL1_IEN2(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_IEN2_SHIFT), XBARA_CTRL1_IEN2_SHIFT, XBARA_CTRL1_IEN2_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field EDGE2[3:2] (RW)
 *
 * This field selects which edges on XBAR_OUT2 cause STS2 to assert.
 *
 * Values:
 * - 0b00 - STS2 never asserts
 * - 0b01 - STS2 asserts on rising edges of XBAR_OUT2
 * - 0b10 - STS2 asserts on falling edges of XBAR_OUT2
 * - 0b11 - STS2 asserts on rising and falling edges of XBAR_OUT2
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_EDGE2 field. */
#define XBARA_RD_CTRL1_EDGE2(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_EDGE2_MASK) >> XBARA_CTRL1_EDGE2_SHIFT)
#define XBARA_BRD_CTRL1_EDGE2(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_EDGE2_SHIFT, XBARA_CTRL1_EDGE2_WIDTH))

/*! @brief Set the EDGE2 field to a new value. */
#define XBARA_WR_CTRL1_EDGE2(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_EDGE2_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_EDGE2(value)))
#define XBARA_BWR_CTRL1_EDGE2(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_EDGE2_SHIFT), XBARA_CTRL1_EDGE2_SHIFT, XBARA_CTRL1_EDGE2_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field STS2[4] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT2. This field is
 * set to 1 when an edge consistent with the current setting of EDGE2 is detected
 * on XBAR_OUT2. This field is cleared by writing 1 to it or by a DMA_ACK2
 * reception when DEN2 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT2, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT2
 * - 0b1 - Active edge detected on XBAR_OUT2
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_STS2 field. */
#define XBARA_RD_CTRL1_STS2(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_STS2_MASK) >> XBARA_CTRL1_STS2_SHIFT)
#define XBARA_BRD_CTRL1_STS2(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_STS2_SHIFT, XBARA_CTRL1_STS2_WIDTH))

/*! @brief Set the STS2 field to a new value. */
#define XBARA_WR_CTRL1_STS2(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_STS2(value)))
#define XBARA_BWR_CTRL1_STS2(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_STS2_SHIFT), XBARA_CTRL1_STS2_SHIFT, XBARA_CTRL1_STS2_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field DEN3[8] (RW)
 *
 * This bit enables the DMA function on the corresponding XBAR_OUT3 output. When
 * enabled, DMA_REQ3 presents the value STS3. When disabled, the DMA_REQ3 output
 * remains low. IEN3 and DEN3 should not both be set to 1.
 *
 * Values:
 * - 0b0 - DMA disabled
 * - 0b1 - DMA enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_DEN3 field. */
#define XBARA_RD_CTRL1_DEN3(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_DEN3_MASK) >> XBARA_CTRL1_DEN3_SHIFT)
#define XBARA_BRD_CTRL1_DEN3(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_DEN3_SHIFT, XBARA_CTRL1_DEN3_WIDTH))

/*! @brief Set the DEN3 field to a new value. */
#define XBARA_WR_CTRL1_DEN3(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_DEN3_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_DEN3(value)))
#define XBARA_BWR_CTRL1_DEN3(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_DEN3_SHIFT), XBARA_CTRL1_DEN3_SHIFT, XBARA_CTRL1_DEN3_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field IEN3[9] (RW)
 *
 * This bit enables the interrupt function on the corresponding XBAR_OUT3
 * output. When the interrupt is enabled, the output INT_REQ3 reflects the value STS3.
 * When the interrupt is disabled, INT_REQ3 remains low. The interrupt request is
 * cleared by writing a 1 to STS3. IEN3 and DEN3 should not both be set to 1.
 *
 * Values:
 * - 0b0 - Interrupt disabled
 * - 0b1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_IEN3 field. */
#define XBARA_RD_CTRL1_IEN3(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_IEN3_MASK) >> XBARA_CTRL1_IEN3_SHIFT)
#define XBARA_BRD_CTRL1_IEN3(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_IEN3_SHIFT, XBARA_CTRL1_IEN3_WIDTH))

/*! @brief Set the IEN3 field to a new value. */
#define XBARA_WR_CTRL1_IEN3(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_IEN3_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_IEN3(value)))
#define XBARA_BWR_CTRL1_IEN3(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_IEN3_SHIFT), XBARA_CTRL1_IEN3_SHIFT, XBARA_CTRL1_IEN3_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field EDGE3[11:10] (RW)
 *
 * This field selects which edges on XBAR_OUT3 cause STS3 to assert.
 *
 * Values:
 * - 0b00 - STS3 never asserts
 * - 0b01 - STS3 asserts on rising edges of XBAR_OUT3
 * - 0b10 - STS3 asserts on falling edges of XBAR_OUT3
 * - 0b11 - STS3 asserts on rising and falling edges of XBAR_OUT3
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_EDGE3 field. */
#define XBARA_RD_CTRL1_EDGE3(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_EDGE3_MASK) >> XBARA_CTRL1_EDGE3_SHIFT)
#define XBARA_BRD_CTRL1_EDGE3(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_EDGE3_SHIFT, XBARA_CTRL1_EDGE3_WIDTH))

/*! @brief Set the EDGE3 field to a new value. */
#define XBARA_WR_CTRL1_EDGE3(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_EDGE3_MASK | XBARA_CTRL1_STS2_MASK | XBARA_CTRL1_STS3_MASK), XBARA_CTRL1_EDGE3(value)))
#define XBARA_BWR_CTRL1_EDGE3(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_EDGE3_SHIFT), XBARA_CTRL1_EDGE3_SHIFT, XBARA_CTRL1_EDGE3_WIDTH))
/*@}*/

/*!
 * @name Register XBARA_CTRL1, field STS3[12] (W1C)
 *
 * This bit reflects the results of edge detection for XBAR_OUT3. This field is
 * set to 1 when an edge consistent with the current setting of EDGE3 is detected
 * on XBAR_OUT3. This field is cleared by writing 1 to it or by a DMA_ACK3
 * reception when DEN3 is set. Writing 0 to the field has no effect. When interrupt or
 * DMA functionality is enabled for XBAR_OUT3, this field is 1 when the
 * interrupt or DMA request is asserted and 0 when the interrupt or DMA request has been
 * cleared.
 *
 * Values:
 * - 0b0 - Active edge not yet detected on XBAR_OUT3
 * - 0b1 - Active edge detected on XBAR_OUT3
 */
/*@{*/
/*! @brief Read current value of the XBARA_CTRL1_STS3 field. */
#define XBARA_RD_CTRL1_STS3(base) ((XBARA_CTRL1_REG(base) & XBARA_CTRL1_STS3_MASK) >> XBARA_CTRL1_STS3_SHIFT)
#define XBARA_BRD_CTRL1_STS3(base) (BME_UBFX16(&XBARA_CTRL1_REG(base), XBARA_CTRL1_STS3_SHIFT, XBARA_CTRL1_STS3_WIDTH))

/*! @brief Set the STS3 field to a new value. */
#define XBARA_WR_CTRL1_STS3(base, value) (XBARA_RMW_CTRL1(base, (XBARA_CTRL1_STS3_MASK | XBARA_CTRL1_STS2_MASK), XBARA_CTRL1_STS3(value)))
#define XBARA_BWR_CTRL1_STS3(base, value) (BME_BFI16(&XBARA_CTRL1_REG(base), ((uint16_t)(value) << XBARA_CTRL1_STS3_SHIFT), XBARA_CTRL1_STS3_SHIFT, XBARA_CTRL1_STS3_WIDTH))
/*@}*/

/* Macros for entire XBARA_SELx register.  */
#define XBARA_SELx(base, outIndex)                (*(volatile uint16_t *)((uintptr_t)&XBARA_SEL0_REG(base) + ((outIndex) & (~1U))))

/* Macros for entire XBARA_CTRLx register. */
#define XBARA_CTRLx(base, outIndex)               (*(volatile uint16_t *)((uintptr_t)&XBARA_CTRL0_REG(base) + ((outIndex) & (~1U))))

/* Set the XBARA_SELx_SELx field to a new value. */
#define XBARA_WR_SELx_SELx(base, outIndex, input) (BME_BFI16(&XBARA_SELx((base), (outIndex)), ((uint16_t)(input) << (XBARA_SEL0_SEL1_SHIFT * ((outIndex) % 2U))), (XBARA_SEL0_SEL1_SHIFT * ((outIndex) % 2U)), XBARA_SEL0_SEL0_WIDTH))

/* Read current value of the XBARA_SELx_SELx field. */
#define XBARA_RD_SELx_SELx(base, outIndex)        (BME_UBFX16(&XBARA_SELx((base), (outIndex)), XBARA_SEL0_SEL1_SHIFT * ((outIndex) % 2U), XBARA_SEL0_SEL0_WIDTH))

/* Set the XBARA_CTRLx_IENx field to a new value. */
#define XBARA_WR_CTRLx_IENx(base, outIndex, enable) (BME_BFI16(&XBARA_CTRLx((base), (outIndex)), ((uint16_t)(enable) << (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + 1U)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_IEN0_SHIFT), XBARA_CTRL0_IEN0_WIDTH))

/* Set the XBARA_CTRLx_DENx field to a new value. */
#define XBARA_WR_CTRLx_DENx(base, outIndex, enable) (BME_BFI16(&XBARA_CTRLx((base), (outIndex)), ((uint16_t)(enable) << (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U))), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U)), XBARA_CTRL0_DEN0_WIDTH))

/* Read current value of the XBARA_CTRLx_IENx field. */
#define XBARA_RD_CTRLx_IENx(base, outIndex)       (BME_UBFX16(&XBARA_CTRLx((base), (outIndex)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_IEN0_SHIFT), XBARA_CTRL0_IEN0_WIDTH))

/* Read current value of the XBARA_CTRLx_DENx field. */
#define XBARA_RD_CTRLx_DENx(base, outIndex)       (BME_UBFX16(&XBARA_CTRLx((base), (outIndex)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U)), XBARA_CTRL0_DEN0_WIDTH))

/* Set the XBARA_CTRLx_EDGEx field to a new value. */
#define XBARA_WR_CTRLx_EDGEx(base, outIndex, edge) (BME_BFI16(&XBARA_CTRLx((base), (outIndex)), ((uint16_t)(edge) << (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_EDGE0_SHIFT)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_EDGE0_SHIFT), XBARA_CTRL0_EDGE0_WIDTH))

/* Read current value of the XBARA_CTRLx_EDGEx field. */
#define XBARA_RD_CTRLx_EDGEx(base, outIndex)      (BME_UBFX16(&XBARA_CTRLx((base), (outIndex)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_EDGE0_SHIFT), XBARA_CTRL0_EDGE0_WIDTH))

/* Read current value of the XBARA_CTRLx_STSx field. */
#define XBARA_RD_CTRLx_STSx(base, outIndex)       (BME_UBFX16(&XBARA_CTRLx((base), (outIndex)), (XBARA_CTRL0_DEN1_SHIFT * ((outIndex) % 2U) + XBARA_CTRL0_STS0_SHIFT), XBARA_CTRL0_STS0_WIDTH))

/* Clear the XBARA_CTRLx_STSx field value. */
#define XBARA_CLR_CTRLx_STSx(base, outIndex)      (BME_BFI16(&XBARA_CTRLx((base), (outIndex)), ((uint16_t)XBARA_CTRL0_STS0_MASK << (XBARA_CTRL0_IEN0_SHIFT * (outIndex) % 2)), ((XBARA_CTRL0_IEN0_SHIFT * ((outIndex) % 2)) + XBARA_CTRL0_STS0_SHIFT), XBARA_CTRL0_STS0_WIDTH))

/*
 * MKV58F24 XBARB
 *
 * Crossbar Switch
 *
 * Registers defined in this header file:
 * - XBARB_SEL0 - Crossbar B Select Register 0
 * - XBARB_SEL1 - Crossbar B Select Register 1
 * - XBARB_SEL2 - Crossbar B Select Register 2
 * - XBARB_SEL3 - Crossbar B Select Register 3
 * - XBARB_SEL4 - Crossbar B Select Register 4
 * - XBARB_SEL5 - Crossbar B Select Register 5
 * - XBARB_SEL6 - Crossbar B Select Register 6
 * - XBARB_SEL7 - Crossbar B Select Register 7
 */

#define XBARB_INSTANCE_COUNT (1U) /*!< Number of instances of the XBARB module. */
#define XBARB_IDX (0U) /*!< Instance number for XBARB. */

/*******************************************************************************
 * XBARB_SEL0 - Crossbar B Select Register 0
 ******************************************************************************/

/*!
 * @brief XBARB_SEL0 - Crossbar B Select Register 0 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL0 register
 */
/*@{*/
#define XBARB_RD_SEL0(base)      (XBARB_SEL0_REG(base))
#define XBARB_WR_SEL0(base, value) (XBARB_SEL0_REG(base) = (value))
#define XBARB_RMW_SEL0(base, mask, value) (XBARB_WR_SEL0(base, (XBARB_RD_SEL0(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL0(base, value) (BME_OR16(&XBARB_SEL0_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL0(base, value) (BME_AND16(&XBARB_SEL0_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL0(base, value) (BME_XOR16(&XBARB_SEL0_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL0 bitfields
 */

/*!
 * @name Register XBARB_SEL0, field SEL0[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT0 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL0_SEL0 field. */
#define XBARB_RD_SEL0_SEL0(base) ((XBARB_SEL0_REG(base) & XBARB_SEL0_SEL0_MASK) >> XBARB_SEL0_SEL0_SHIFT)
#define XBARB_BRD_SEL0_SEL0(base) (BME_UBFX16(&XBARB_SEL0_REG(base), XBARB_SEL0_SEL0_SHIFT, XBARB_SEL0_SEL0_WIDTH))

/*! @brief Set the SEL0 field to a new value. */
#define XBARB_WR_SEL0_SEL0(base, value) (XBARB_RMW_SEL0(base, XBARB_SEL0_SEL0_MASK, XBARB_SEL0_SEL0(value)))
#define XBARB_BWR_SEL0_SEL0(base, value) (BME_BFI16(&XBARB_SEL0_REG(base), ((uint16_t)(value) << XBARB_SEL0_SEL0_SHIFT), XBARB_SEL0_SEL0_SHIFT, XBARB_SEL0_SEL0_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL0, field SEL1[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT1 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL0_SEL1 field. */
#define XBARB_RD_SEL0_SEL1(base) ((XBARB_SEL0_REG(base) & XBARB_SEL0_SEL1_MASK) >> XBARB_SEL0_SEL1_SHIFT)
#define XBARB_BRD_SEL0_SEL1(base) (BME_UBFX16(&XBARB_SEL0_REG(base), XBARB_SEL0_SEL1_SHIFT, XBARB_SEL0_SEL1_WIDTH))

/*! @brief Set the SEL1 field to a new value. */
#define XBARB_WR_SEL0_SEL1(base, value) (XBARB_RMW_SEL0(base, XBARB_SEL0_SEL1_MASK, XBARB_SEL0_SEL1(value)))
#define XBARB_BWR_SEL0_SEL1(base, value) (BME_BFI16(&XBARB_SEL0_REG(base), ((uint16_t)(value) << XBARB_SEL0_SEL1_SHIFT), XBARB_SEL0_SEL1_SHIFT, XBARB_SEL0_SEL1_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL1 - Crossbar B Select Register 1
 ******************************************************************************/

/*!
 * @brief XBARB_SEL1 - Crossbar B Select Register 1 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL1 register
 */
/*@{*/
#define XBARB_RD_SEL1(base)      (XBARB_SEL1_REG(base))
#define XBARB_WR_SEL1(base, value) (XBARB_SEL1_REG(base) = (value))
#define XBARB_RMW_SEL1(base, mask, value) (XBARB_WR_SEL1(base, (XBARB_RD_SEL1(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL1(base, value) (BME_OR16(&XBARB_SEL1_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL1(base, value) (BME_AND16(&XBARB_SEL1_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL1(base, value) (BME_XOR16(&XBARB_SEL1_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL1 bitfields
 */

/*!
 * @name Register XBARB_SEL1, field SEL2[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT2 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL1_SEL2 field. */
#define XBARB_RD_SEL1_SEL2(base) ((XBARB_SEL1_REG(base) & XBARB_SEL1_SEL2_MASK) >> XBARB_SEL1_SEL2_SHIFT)
#define XBARB_BRD_SEL1_SEL2(base) (BME_UBFX16(&XBARB_SEL1_REG(base), XBARB_SEL1_SEL2_SHIFT, XBARB_SEL1_SEL2_WIDTH))

/*! @brief Set the SEL2 field to a new value. */
#define XBARB_WR_SEL1_SEL2(base, value) (XBARB_RMW_SEL1(base, XBARB_SEL1_SEL2_MASK, XBARB_SEL1_SEL2(value)))
#define XBARB_BWR_SEL1_SEL2(base, value) (BME_BFI16(&XBARB_SEL1_REG(base), ((uint16_t)(value) << XBARB_SEL1_SEL2_SHIFT), XBARB_SEL1_SEL2_SHIFT, XBARB_SEL1_SEL2_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL1, field SEL3[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT3 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL1_SEL3 field. */
#define XBARB_RD_SEL1_SEL3(base) ((XBARB_SEL1_REG(base) & XBARB_SEL1_SEL3_MASK) >> XBARB_SEL1_SEL3_SHIFT)
#define XBARB_BRD_SEL1_SEL3(base) (BME_UBFX16(&XBARB_SEL1_REG(base), XBARB_SEL1_SEL3_SHIFT, XBARB_SEL1_SEL3_WIDTH))

/*! @brief Set the SEL3 field to a new value. */
#define XBARB_WR_SEL1_SEL3(base, value) (XBARB_RMW_SEL1(base, XBARB_SEL1_SEL3_MASK, XBARB_SEL1_SEL3(value)))
#define XBARB_BWR_SEL1_SEL3(base, value) (BME_BFI16(&XBARB_SEL1_REG(base), ((uint16_t)(value) << XBARB_SEL1_SEL3_SHIFT), XBARB_SEL1_SEL3_SHIFT, XBARB_SEL1_SEL3_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL2 - Crossbar B Select Register 2
 ******************************************************************************/

/*!
 * @brief XBARB_SEL2 - Crossbar B Select Register 2 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL2 register
 */
/*@{*/
#define XBARB_RD_SEL2(base)      (XBARB_SEL2_REG(base))
#define XBARB_WR_SEL2(base, value) (XBARB_SEL2_REG(base) = (value))
#define XBARB_RMW_SEL2(base, mask, value) (XBARB_WR_SEL2(base, (XBARB_RD_SEL2(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL2(base, value) (BME_OR16(&XBARB_SEL2_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL2(base, value) (BME_AND16(&XBARB_SEL2_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL2(base, value) (BME_XOR16(&XBARB_SEL2_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL2 bitfields
 */

/*!
 * @name Register XBARB_SEL2, field SEL4[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT4 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL2_SEL4 field. */
#define XBARB_RD_SEL2_SEL4(base) ((XBARB_SEL2_REG(base) & XBARB_SEL2_SEL4_MASK) >> XBARB_SEL2_SEL4_SHIFT)
#define XBARB_BRD_SEL2_SEL4(base) (BME_UBFX16(&XBARB_SEL2_REG(base), XBARB_SEL2_SEL4_SHIFT, XBARB_SEL2_SEL4_WIDTH))

/*! @brief Set the SEL4 field to a new value. */
#define XBARB_WR_SEL2_SEL4(base, value) (XBARB_RMW_SEL2(base, XBARB_SEL2_SEL4_MASK, XBARB_SEL2_SEL4(value)))
#define XBARB_BWR_SEL2_SEL4(base, value) (BME_BFI16(&XBARB_SEL2_REG(base), ((uint16_t)(value) << XBARB_SEL2_SEL4_SHIFT), XBARB_SEL2_SEL4_SHIFT, XBARB_SEL2_SEL4_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL2, field SEL5[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT5 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL2_SEL5 field. */
#define XBARB_RD_SEL2_SEL5(base) ((XBARB_SEL2_REG(base) & XBARB_SEL2_SEL5_MASK) >> XBARB_SEL2_SEL5_SHIFT)
#define XBARB_BRD_SEL2_SEL5(base) (BME_UBFX16(&XBARB_SEL2_REG(base), XBARB_SEL2_SEL5_SHIFT, XBARB_SEL2_SEL5_WIDTH))

/*! @brief Set the SEL5 field to a new value. */
#define XBARB_WR_SEL2_SEL5(base, value) (XBARB_RMW_SEL2(base, XBARB_SEL2_SEL5_MASK, XBARB_SEL2_SEL5(value)))
#define XBARB_BWR_SEL2_SEL5(base, value) (BME_BFI16(&XBARB_SEL2_REG(base), ((uint16_t)(value) << XBARB_SEL2_SEL5_SHIFT), XBARB_SEL2_SEL5_SHIFT, XBARB_SEL2_SEL5_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL3 - Crossbar B Select Register 3
 ******************************************************************************/

/*!
 * @brief XBARB_SEL3 - Crossbar B Select Register 3 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL3 register
 */
/*@{*/
#define XBARB_RD_SEL3(base)      (XBARB_SEL3_REG(base))
#define XBARB_WR_SEL3(base, value) (XBARB_SEL3_REG(base) = (value))
#define XBARB_RMW_SEL3(base, mask, value) (XBARB_WR_SEL3(base, (XBARB_RD_SEL3(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL3(base, value) (BME_OR16(&XBARB_SEL3_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL3(base, value) (BME_AND16(&XBARB_SEL3_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL3(base, value) (BME_XOR16(&XBARB_SEL3_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL3 bitfields
 */

/*!
 * @name Register XBARB_SEL3, field SEL6[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT6 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL3_SEL6 field. */
#define XBARB_RD_SEL3_SEL6(base) ((XBARB_SEL3_REG(base) & XBARB_SEL3_SEL6_MASK) >> XBARB_SEL3_SEL6_SHIFT)
#define XBARB_BRD_SEL3_SEL6(base) (BME_UBFX16(&XBARB_SEL3_REG(base), XBARB_SEL3_SEL6_SHIFT, XBARB_SEL3_SEL6_WIDTH))

/*! @brief Set the SEL6 field to a new value. */
#define XBARB_WR_SEL3_SEL6(base, value) (XBARB_RMW_SEL3(base, XBARB_SEL3_SEL6_MASK, XBARB_SEL3_SEL6(value)))
#define XBARB_BWR_SEL3_SEL6(base, value) (BME_BFI16(&XBARB_SEL3_REG(base), ((uint16_t)(value) << XBARB_SEL3_SEL6_SHIFT), XBARB_SEL3_SEL6_SHIFT, XBARB_SEL3_SEL6_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL3, field SEL7[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT7 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL3_SEL7 field. */
#define XBARB_RD_SEL3_SEL7(base) ((XBARB_SEL3_REG(base) & XBARB_SEL3_SEL7_MASK) >> XBARB_SEL3_SEL7_SHIFT)
#define XBARB_BRD_SEL3_SEL7(base) (BME_UBFX16(&XBARB_SEL3_REG(base), XBARB_SEL3_SEL7_SHIFT, XBARB_SEL3_SEL7_WIDTH))

/*! @brief Set the SEL7 field to a new value. */
#define XBARB_WR_SEL3_SEL7(base, value) (XBARB_RMW_SEL3(base, XBARB_SEL3_SEL7_MASK, XBARB_SEL3_SEL7(value)))
#define XBARB_BWR_SEL3_SEL7(base, value) (BME_BFI16(&XBARB_SEL3_REG(base), ((uint16_t)(value) << XBARB_SEL3_SEL7_SHIFT), XBARB_SEL3_SEL7_SHIFT, XBARB_SEL3_SEL7_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL4 - Crossbar B Select Register 4
 ******************************************************************************/

/*!
 * @brief XBARB_SEL4 - Crossbar B Select Register 4 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL4 register
 */
/*@{*/
#define XBARB_RD_SEL4(base)      (XBARB_SEL4_REG(base))
#define XBARB_WR_SEL4(base, value) (XBARB_SEL4_REG(base) = (value))
#define XBARB_RMW_SEL4(base, mask, value) (XBARB_WR_SEL4(base, (XBARB_RD_SEL4(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL4(base, value) (BME_OR16(&XBARB_SEL4_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL4(base, value) (BME_AND16(&XBARB_SEL4_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL4(base, value) (BME_XOR16(&XBARB_SEL4_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL4 bitfields
 */

/*!
 * @name Register XBARB_SEL4, field SEL8[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT8 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL4_SEL8 field. */
#define XBARB_RD_SEL4_SEL8(base) ((XBARB_SEL4_REG(base) & XBARB_SEL4_SEL8_MASK) >> XBARB_SEL4_SEL8_SHIFT)
#define XBARB_BRD_SEL4_SEL8(base) (BME_UBFX16(&XBARB_SEL4_REG(base), XBARB_SEL4_SEL8_SHIFT, XBARB_SEL4_SEL8_WIDTH))

/*! @brief Set the SEL8 field to a new value. */
#define XBARB_WR_SEL4_SEL8(base, value) (XBARB_RMW_SEL4(base, XBARB_SEL4_SEL8_MASK, XBARB_SEL4_SEL8(value)))
#define XBARB_BWR_SEL4_SEL8(base, value) (BME_BFI16(&XBARB_SEL4_REG(base), ((uint16_t)(value) << XBARB_SEL4_SEL8_SHIFT), XBARB_SEL4_SEL8_SHIFT, XBARB_SEL4_SEL8_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL4, field SEL9[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT9 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL4_SEL9 field. */
#define XBARB_RD_SEL4_SEL9(base) ((XBARB_SEL4_REG(base) & XBARB_SEL4_SEL9_MASK) >> XBARB_SEL4_SEL9_SHIFT)
#define XBARB_BRD_SEL4_SEL9(base) (BME_UBFX16(&XBARB_SEL4_REG(base), XBARB_SEL4_SEL9_SHIFT, XBARB_SEL4_SEL9_WIDTH))

/*! @brief Set the SEL9 field to a new value. */
#define XBARB_WR_SEL4_SEL9(base, value) (XBARB_RMW_SEL4(base, XBARB_SEL4_SEL9_MASK, XBARB_SEL4_SEL9(value)))
#define XBARB_BWR_SEL4_SEL9(base, value) (BME_BFI16(&XBARB_SEL4_REG(base), ((uint16_t)(value) << XBARB_SEL4_SEL9_SHIFT), XBARB_SEL4_SEL9_SHIFT, XBARB_SEL4_SEL9_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL5 - Crossbar B Select Register 5
 ******************************************************************************/

/*!
 * @brief XBARB_SEL5 - Crossbar B Select Register 5 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL5 register
 */
/*@{*/
#define XBARB_RD_SEL5(base)      (XBARB_SEL5_REG(base))
#define XBARB_WR_SEL5(base, value) (XBARB_SEL5_REG(base) = (value))
#define XBARB_RMW_SEL5(base, mask, value) (XBARB_WR_SEL5(base, (XBARB_RD_SEL5(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL5(base, value) (BME_OR16(&XBARB_SEL5_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL5(base, value) (BME_AND16(&XBARB_SEL5_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL5(base, value) (BME_XOR16(&XBARB_SEL5_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL5 bitfields
 */

/*!
 * @name Register XBARB_SEL5, field SEL10[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT10 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL5_SEL10 field. */
#define XBARB_RD_SEL5_SEL10(base) ((XBARB_SEL5_REG(base) & XBARB_SEL5_SEL10_MASK) >> XBARB_SEL5_SEL10_SHIFT)
#define XBARB_BRD_SEL5_SEL10(base) (BME_UBFX16(&XBARB_SEL5_REG(base), XBARB_SEL5_SEL10_SHIFT, XBARB_SEL5_SEL10_WIDTH))

/*! @brief Set the SEL10 field to a new value. */
#define XBARB_WR_SEL5_SEL10(base, value) (XBARB_RMW_SEL5(base, XBARB_SEL5_SEL10_MASK, XBARB_SEL5_SEL10(value)))
#define XBARB_BWR_SEL5_SEL10(base, value) (BME_BFI16(&XBARB_SEL5_REG(base), ((uint16_t)(value) << XBARB_SEL5_SEL10_SHIFT), XBARB_SEL5_SEL10_SHIFT, XBARB_SEL5_SEL10_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL5, field SEL11[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT11 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL5_SEL11 field. */
#define XBARB_RD_SEL5_SEL11(base) ((XBARB_SEL5_REG(base) & XBARB_SEL5_SEL11_MASK) >> XBARB_SEL5_SEL11_SHIFT)
#define XBARB_BRD_SEL5_SEL11(base) (BME_UBFX16(&XBARB_SEL5_REG(base), XBARB_SEL5_SEL11_SHIFT, XBARB_SEL5_SEL11_WIDTH))

/*! @brief Set the SEL11 field to a new value. */
#define XBARB_WR_SEL5_SEL11(base, value) (XBARB_RMW_SEL5(base, XBARB_SEL5_SEL11_MASK, XBARB_SEL5_SEL11(value)))
#define XBARB_BWR_SEL5_SEL11(base, value) (BME_BFI16(&XBARB_SEL5_REG(base), ((uint16_t)(value) << XBARB_SEL5_SEL11_SHIFT), XBARB_SEL5_SEL11_SHIFT, XBARB_SEL5_SEL11_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL6 - Crossbar B Select Register 6
 ******************************************************************************/

/*!
 * @brief XBARB_SEL6 - Crossbar B Select Register 6 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL6 register
 */
/*@{*/
#define XBARB_RD_SEL6(base)      (XBARB_SEL6_REG(base))
#define XBARB_WR_SEL6(base, value) (XBARB_SEL6_REG(base) = (value))
#define XBARB_RMW_SEL6(base, mask, value) (XBARB_WR_SEL6(base, (XBARB_RD_SEL6(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL6(base, value) (BME_OR16(&XBARB_SEL6_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL6(base, value) (BME_AND16(&XBARB_SEL6_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL6(base, value) (BME_XOR16(&XBARB_SEL6_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL6 bitfields
 */

/*!
 * @name Register XBARB_SEL6, field SEL12[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT12 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL6_SEL12 field. */
#define XBARB_RD_SEL6_SEL12(base) ((XBARB_SEL6_REG(base) & XBARB_SEL6_SEL12_MASK) >> XBARB_SEL6_SEL12_SHIFT)
#define XBARB_BRD_SEL6_SEL12(base) (BME_UBFX16(&XBARB_SEL6_REG(base), XBARB_SEL6_SEL12_SHIFT, XBARB_SEL6_SEL12_WIDTH))

/*! @brief Set the SEL12 field to a new value. */
#define XBARB_WR_SEL6_SEL12(base, value) (XBARB_RMW_SEL6(base, XBARB_SEL6_SEL12_MASK, XBARB_SEL6_SEL12(value)))
#define XBARB_BWR_SEL6_SEL12(base, value) (BME_BFI16(&XBARB_SEL6_REG(base), ((uint16_t)(value) << XBARB_SEL6_SEL12_SHIFT), XBARB_SEL6_SEL12_SHIFT, XBARB_SEL6_SEL12_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL6, field SEL13[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT13 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL6_SEL13 field. */
#define XBARB_RD_SEL6_SEL13(base) ((XBARB_SEL6_REG(base) & XBARB_SEL6_SEL13_MASK) >> XBARB_SEL6_SEL13_SHIFT)
#define XBARB_BRD_SEL6_SEL13(base) (BME_UBFX16(&XBARB_SEL6_REG(base), XBARB_SEL6_SEL13_SHIFT, XBARB_SEL6_SEL13_WIDTH))

/*! @brief Set the SEL13 field to a new value. */
#define XBARB_WR_SEL6_SEL13(base, value) (XBARB_RMW_SEL6(base, XBARB_SEL6_SEL13_MASK, XBARB_SEL6_SEL13(value)))
#define XBARB_BWR_SEL6_SEL13(base, value) (BME_BFI16(&XBARB_SEL6_REG(base), ((uint16_t)(value) << XBARB_SEL6_SEL13_SHIFT), XBARB_SEL6_SEL13_SHIFT, XBARB_SEL6_SEL13_WIDTH))
/*@}*/

/*******************************************************************************
 * XBARB_SEL7 - Crossbar B Select Register 7
 ******************************************************************************/

/*!
 * @brief XBARB_SEL7 - Crossbar B Select Register 7 (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire XBARB_SEL7 register
 */
/*@{*/
#define XBARB_RD_SEL7(base)      (XBARB_SEL7_REG(base))
#define XBARB_WR_SEL7(base, value) (XBARB_SEL7_REG(base) = (value))
#define XBARB_RMW_SEL7(base, mask, value) (XBARB_WR_SEL7(base, (XBARB_RD_SEL7(base) & ~(mask)) | (value)))
#define XBARB_SET_SEL7(base, value) (BME_OR16(&XBARB_SEL7_REG(base), (uint16_t)(value)))
#define XBARB_CLR_SEL7(base, value) (BME_AND16(&XBARB_SEL7_REG(base), (uint16_t)(~(value))))
#define XBARB_TOG_SEL7(base, value) (BME_XOR16(&XBARB_SEL7_REG(base), (uint16_t)(value)))
/*@}*/

/*
 * Constants & macros for individual XBARB_SEL7 bitfields
 */

/*!
 * @name Register XBARB_SEL7, field SEL14[5:0] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT14 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL7_SEL14 field. */
#define XBARB_RD_SEL7_SEL14(base) ((XBARB_SEL7_REG(base) & XBARB_SEL7_SEL14_MASK) >> XBARB_SEL7_SEL14_SHIFT)
#define XBARB_BRD_SEL7_SEL14(base) (BME_UBFX16(&XBARB_SEL7_REG(base), XBARB_SEL7_SEL14_SHIFT, XBARB_SEL7_SEL14_WIDTH))

/*! @brief Set the SEL14 field to a new value. */
#define XBARB_WR_SEL7_SEL14(base, value) (XBARB_RMW_SEL7(base, XBARB_SEL7_SEL14_MASK, XBARB_SEL7_SEL14(value)))
#define XBARB_BWR_SEL7_SEL14(base, value) (BME_BFI16(&XBARB_SEL7_REG(base), ((uint16_t)(value) << XBARB_SEL7_SEL14_SHIFT), XBARB_SEL7_SEL14_SHIFT, XBARB_SEL7_SEL14_WIDTH))
/*@}*/

/*!
 * @name Register XBARB_SEL7, field SEL15[13:8] (RW)
 *
 * Input (XBARB_INn) to be muxed to XBARB_OUT15 (refer to Functional Description
 * section for input/output assignment)
 */
/*@{*/
/*! @brief Read current value of the XBARB_SEL7_SEL15 field. */
#define XBARB_RD_SEL7_SEL15(base) ((XBARB_SEL7_REG(base) & XBARB_SEL7_SEL15_MASK) >> XBARB_SEL7_SEL15_SHIFT)
#define XBARB_BRD_SEL7_SEL15(base) (BME_UBFX16(&XBARB_SEL7_REG(base), XBARB_SEL7_SEL15_SHIFT, XBARB_SEL7_SEL15_WIDTH))

/*! @brief Set the SEL15 field to a new value. */
#define XBARB_WR_SEL7_SEL15(base, value) (XBARB_RMW_SEL7(base, XBARB_SEL7_SEL15_MASK, XBARB_SEL7_SEL15(value)))
#define XBARB_BWR_SEL7_SEL15(base, value) (BME_BFI16(&XBARB_SEL7_REG(base), ((uint16_t)(value) << XBARB_SEL7_SEL15_SHIFT), XBARB_SEL7_SEL15_SHIFT, XBARB_SEL7_SEL15_WIDTH))
/*@}*/

/* Macros for entire XBARB_SELx register. */
#define XBARB_SELx(base, outIndex)         (*(volatile uint16_t *)((uintptr_t)&XBARB_SEL0_REG(base) + ((outIndex) & (~1U))))

/* Set the SELx field to a new value. */
#define XBARB_WR_SELx_SELx(base, outIndex, input) (BME_BFI16(&XBARB_SELx((base), (outIndex)), ((uint16_t)(input) << (XBARB_SEL0_SEL1_SHIFT * ((outIndex) % 2U))), (XBARB_SEL0_SEL1_SHIFT * ((outIndex) % 2U)), XBARB_SEL0_SEL0_WIDTH))

/* Read current value of the XBARB_SELx_SELx field. */
#define XBARB_RD_SELx_SELx(base, outIndex)        (BME_UBFX16(&XBARB_SELx((base), (outIndex)), XBARB_SEL0_SEL1_SHIFT * ((outIndex) % 2U), XBARB_SEL0_SEL0_WIDTH))

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#if defined(__IAR_SYSTEMS_ICC__)
  /* Restore checking of "Error[Pm008]: sections of code should not be 'commented out' (MISRA C 2004 rule 2.4)" */
  #pragma diag_default=pm008
#endif

#endif /* __MKV58F24_EXTENSION_H__ */
/* EOF */
